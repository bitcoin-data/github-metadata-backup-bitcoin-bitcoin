{
  "type": "issue",
  "issue": {
    "id": 3567649387,
    "node_id": "I_kwDOABII587UpgJr",
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33737",
    "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
    "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33737/labels%7B/name%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33737/comments",
    "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33737/events",
    "html_url": "https://github.com/bitcoin/bitcoin/issues/33737",
    "number": 33737,
    "state": "open",
    "state_reason": null,
    "title": "Limit \"Bulk Dust\" with a default filter or consensus..",
    "body": "I’m exploring a potential default filter or consensus-level rule (since a large number of people believe that default filters don't work) to discourage UTXO-bloat patterns without touching Script, witness data, or the block size limit.\n\nThe idea is to target “bulk dust” transactions — those that create large numbers of extremely small outputs — which are the main cause of long-term UTXO set growth.\n\nThese types of \"bulk dust\" transactions have been the No. 1 reason cited for wanting to expand the default OP_RETURN limit... and removing that limit obviously influenced BIP 444.  So it appears to me that there is overwhelming majority support for limiting these types of \"bulk dust\" transactions, as they do present a legitimate concern for node runners.\n\n**Concept**\n\nFlag a transaction as “bulk dust” if:\n- It has >=100 outputs each below a dynamically defined TinyTx threshold, and\n- Those tiny outputs make up >=60% of all outputs in the transaction.\n\nWhen flagged, it would be considered nonstandard (relay policy) or invalid (if soft-forked into consensus).\n\n**TinyTx threshold (dynamic halving schedule)**\n\nI originally considered a constant definition of what was a \"tiny\" Tx to be 1,000 sats... but some might still just use 1,001 sats, right?  Plus there very likely will be a time where there is  a valid use-case of >100 outputs under 1,000 sats.\n\nRather than fixing the “tiny” threshold to a constant like 1,000 sats, the rule defines it as a decreasing function of block height, starting high and gradually tightening over time.\n\n- Starts at 4096 sats when activated (target ~2028).\n- Halves every 210,000 blocks (~4 years).\n- Never falls below 1 sat (hard floor).\n\nYear ---- Block Height -- TinyTx Threshold\n2028 --- ~activation ---- 4096 sats\n2032 --- ~1,260,000 ---- 2048 sats\n2036 --- ~1,470,000 ---- 1024 sats\n2040 --- ~1,680,000 ---- 512 sats\n… -- every 210,000 blocks -- … until 1 sat floor\n\nThis gradual halving ensures the definition of \"tiny\" stays relevant as Bitcoin’s value rises.\nFor example, if 1 sat = $1 someday, having 100 outputs worth <1,000 sats each would no longer represent spam — but rather normal payments.\nBy then, the TinyTx limit would already have adjusted down automatically.\n\n**Patterns this would limit**\n\n- Fake pubkeys or scripts used to embed data via many UTXOs\n- Bitcoin STAMPS / UTXO-art spreading payloads across thousands of dust outputs\n- BRC-20 batch mints with 100s of \"tiny\" sat fan-outs\n- Some Ordinal or state inscription schemes that distribute data across many tiny outputs\n- Dust bombing (UTXO tracking or chain spam)\n- Mass micro-airdrops below the \"tiny\" sat range\n\nThese use cases rely on cheap, numerous outputs — making them several times more costly under this rule.\n\n**Non-goals / unaffected**\n\n- Normal user transactions, LN channel opens, and multisig spends\n- Batched exchange payouts (they typically have > 40% large-value outputs)\n- Single/few-output inscriptions using witness data (not affected)\n- Any legitimate pattern where most outputs are above the threshold\n\n**Why a ratio and a count?**\n\nRequiring both (tiny_count >= 100) and (tiny_ratio >= 60%) helps avoid false positives, such as legitimate custodial payouts or consolidation transactions with mixed values.\nIt specifically filters transactions that are mostly dust, rather than merely containing some.\n\n**Inquiry**\n\n- Are there credible, non-spam use cases that truly require >=100 sub-4k-sat outputs (or equivalent at later eras) and a >=60% tiny ratio?\n- Could this affect fee market behavior or any privacy tools in unintended ways?\n- Any concern with the 100 tiny_count limit or 60% tiny_ratio?\n- Any other unintended consequences?\n- Any objections in general??  What are they?\n\n**Intent**\n\nThis proposal doesn’t censor any monetary transaction or prevent inscriptions; it simply prices storage according to resource cost.\nIt keeps the chain “light and nimble” for everyday payments while allowing future flexibility — because the TinyTx definition decreases automatically in line with halvings and Bitcoin’s long-term value growth.\n\n**CODE SKETCHES**\n(with minimal syntax highlighting here:  https://pastebin.com/9qdQCH83)\n\n**RELAY POLICY FILTER sketch —**\n```\n// Place in src/policy/policy.cpp, and call from within IsStandardTx() before returning:\n//     if (IsBulkDust(tx, reason))\n//         return false;   // reject as nonstandard\n// ==========================================================================================================\n\nbool IsBulkDust(const CTransaction& tx, std::string& reason)\n{\n    static constexpr int     MAX_TINY_OUTPUTS        = 100;     // >=100 tiny outputs triggers ratio check\n    static constexpr double  TINY_RATIO_THRESHOLD    = 0.6;     // >=60% of all outputs tiny → reject\n    static constexpr CAmount BASE_TINY_THRESHOLD     = 4096;    // starting tiny threshold (sats)\n    static constexpr int64_t FIRST_TINY_HALVING_H    = 1260000; // first halving of tiny threshold\n    static constexpr int64_t HALVING_INTERVAL        = 210000;  // blocks per subsequent halving\n    static constexpr CAmount MIN_TINY_FLOOR          = 1;       // never below 1 sat\n\n    const int total = tx.vout.size();\n    if (total == 0) return false;\n\n    int currentHeight = chainActive.Tip() ? chainActive.Tip()->nHeight : 0;\n\n    // Era index for TinyTx threshold, anchored at FIRST_TINY_HALVING_H (not subsidy eras)\n    int era = 0;\n    if (currentHeight >= FIRST_TINY_HALVING_H) {\n        era = 1 + static_cast<int>((currentHeight - FIRST_TINY_HALVING_H) / HALVING_INTERVAL);\n    }\n\n    CAmount tinyThresh = BASE_TINY_THRESHOLD >> era;      // halve per era\n    if (tinyThresh < MIN_TINY_FLOOR) tinyThresh = MIN_TINY_FLOOR;\n\n    int tiny = 0;\n    for (const auto& out : tx.vout) {\n        if (out.nValue < tinyThresh) ++tiny;\n    }\n\n    if (tiny >= MAX_TINY_OUTPUTS && (static_cast<double>(tiny) / total) >= TINY_RATIO_THRESHOLD) {\n        reason = strprintf(\"too-many-tiny-outputs(%d of %d, %.2f%%, tiny<%d)\",\n                           tiny, total, 100.0 * tiny / total, tinyThresh);\n        return true; // flag as bulk dust (nonstandard)\n    }\n    return false;\n}\n```\n\n**CONSENSUS (soft-fork, hybrid activation) sketch —**\n```\n// Helpers in src/consensus/tx_check.cpp; activation/enforcement in src/validation.cpp\n// Also define deployment in: src/consensus/params.h, src/chainparams.cpp, src/versionbits.*\n// ==========================================================================================================\n\n// -----------------------------------------------------------------------\n// --- In src/consensus/tx_check.cpp (helper only; no params needed) ---\n// -----------------------------------------------------------------------\n\nstatic constexpr CAmount BASE_TINY_THRESHOLD     = 4096;\nstatic constexpr int64_t FIRST_TINY_HALVING_H    = 1260000;\nstatic constexpr int64_t HALVING_INTERVAL        = 210000;\nstatic constexpr int     MAX_TINY_OUTPUTS        = 100;\nstatic constexpr double  TINY_RATIO_THRESHOLD    = 0.6;\nstatic constexpr CAmount MIN_TINY_FLOOR          = 1;\n\nbool IsBulkDust(const CTransaction& tx, int currentHeight) // expose via tx_check.h if needed\n{\n    const int total = tx.vout.size();\n    if (total == 0) return false;\n\n    int era = 0;\n    if (currentHeight >= FIRST_TINY_HALVING_H) {\n        era = 1 + static_cast<int>((currentHeight - FIRST_TINY_HALVING_H) / HALVING_INTERVAL);\n    }\n\n    CAmount tinyThresh = BASE_TINY_THRESHOLD >> era;\n    if (tinyThresh < MIN_TINY_FLOOR) tinyThresh = MIN_TINY_FLOOR;\n\n    int tiny = 0;\n    for (const auto& out : tx.vout) {\n        if (out.nValue < tinyThresh) ++tiny;\n    }\n\n    if (tiny >= MAX_TINY_OUTPUTS && (static_cast<double>(tiny) / total) >= TINY_RATIO_THRESHOLD)\n        return true;\n\n    return false;\n}\n\n\n// -----------------------------------------------------------------------\n// --- In src/validation.cpp (enforcement with hybrid activation) ---\n// -----------------------------------------------------------------------\n\n#include <consensus/tx_check.h>\n#include <versionbits.h>\n\nconst Consensus::Params& params = chainparams.GetConsensus();\nint currentHeight = chainActive.Tip() ? chainActive.Tip()->nHeight : 0;\n\nconst bool bulk_dust_active =\n    DeploymentActiveAtTip(params, Consensus::DEPLOYMENT_BULK_DUST_LIMIT) ||\n    (currentHeight >= params.BulkDustActivationHeight);\n\nif (bulk_dust_active) {\n    if (IsBulkDust(tx, currentHeight)) {\n        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"too-many-tiny-outputs\");\n    }\n}\n\n\n// -----------------------------------------------------------------------\n// --- In src/consensus/params.h ---\n// -----------------------------------------------------------------------\n\nenum DeploymentPos {\n    // ...\n    DEPLOYMENT_BULK_DUST_LIMIT,\n    MAX_VERSION_BITS_DEPLOYMENTS\n};\n\nstruct Params {\n    // ...\n    int BulkDustActivationHeight; // height flag-day fallback\n};\n\n\n// -----------------------------------------------------------------------\n// --- In src/chainparams.cpp (per-network values; examples only) ---\n// -----------------------------------------------------------------------\n\nconsensus.vDeployments[Consensus::DEPLOYMENT_BULK_DUST_LIMIT].bit = 12;\nconsensus.vDeployments[Consensus::DEPLOYMENT_BULK_DUST_LIMIT].nStartTime = 1767225600;  // 2026-01-01 UTC\nconsensus.vDeployments[Consensus::DEPLOYMENT_BULK_DUST_LIMIT].nTimeout   = 1838160000;  // 2028-04-01 UTC\nconsensus.vDeployments[Consensus::DEPLOYMENT_BULK_DUST_LIMIT].min_activation_height = 969696;\n\nconsensus.BulkDustActivationHeight = 1021021; // flag-day fallback\n```",
    "user": {
      "login": "DoctorBuzz1",
      "id": 155297644,
      "node_id": "U_kgDOCUGnbA",
      "avatar_url": "https://avatars.githubusercontent.com/u/155297644?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DoctorBuzz1",
      "html_url": "https://github.com/DoctorBuzz1",
      "followers_url": "https://api.github.com/users/DoctorBuzz1/followers",
      "following_url": "https://api.github.com/users/DoctorBuzz1/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/DoctorBuzz1/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/DoctorBuzz1/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/DoctorBuzz1/subscriptions",
      "organizations_url": "https://api.github.com/users/DoctorBuzz1/orgs",
      "repos_url": "https://api.github.com/users/DoctorBuzz1/repos",
      "events_url": "https://api.github.com/users/DoctorBuzz1/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/DoctorBuzz1/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "labels": [],
    "assignees": [],
    "author_association": "NONE",
    "locked": false,
    "comments": 0,
    "created_at": "2025-10-29T20:00:40Z",
    "updated_at": "2025-10-29T20:00:40Z"
  },
  "events": []
}