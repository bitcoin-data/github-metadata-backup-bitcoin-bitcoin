{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158",
    "id": 1660385595,
    "node_id": "PR_kwDOABII585i93k7",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/29158",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/29158.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/29158.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
    "number": 29158,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "PoC: fuzz chainstate and block managers",
    "user": {
      "login": "darosior",
      "id": 22457751,
      "node_id": "MDQ6VXNlcjIyNDU3NzUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/darosior",
      "html_url": "https://github.com/darosior",
      "followers_url": "https://api.github.com/users/darosior/followers",
      "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
      "organizations_url": "https://api.github.com/users/darosior/orgs",
      "repos_url": "https://api.github.com/users/darosior/repos",
      "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/darosior/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "We don't have a fuzzing harness for our main consensus engine [0]. This PR introduces two new targets which respectively fuzz the `BlockManager`Â and `ChainstateManager` (process headers, blocks, reorgs and assert some invariants in doing so).\r\n\r\nThere is two main obstacles to achieving this: PoW and io. The blocks and chainstate databases can be stored in memory but blocks still need a valid proof of work and to be stored on disk. Niklas solved the first issue in #28043 by simply introducing a global which makes it possible to mock the PoW check (his commit is cherry-picked here). After considering other approaches, i also used globals to mock disk io.\r\n\r\nI'm interested with this PR in getting feedback on the concept and the approach, but also in suggestions of more invariants to be asserting in the `chainstate`Â fuzz target.\r\n\r\nRegarding other approaches i tried the most potentially promising was to leverage `ld`'s `--wrap` option to mock the syscalls without having to modify non-test code. But i didn't try too hard to make it work: better to have a demo of what can be achieved first with a more trivial way of mocking filesystem calls. If there is interest in these fuzz targets, i can give this approach another look.\r\n\r\nRegarding efficiency, the chainstate fuzz target is quite slow at the moment but i've at least 2x its performance by rebasing on #28960 and making `CheckBlockIndex` callable externally even if `!ShouldCheckBlockIndex()`. Suggestions for performance improvements welcome too.\r\n\r\n---\r\n\r\n[0] Well there is `utxo_total_supply` but it's very specialized toward exercising a specific past bug.",
    "labels": [
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2023-12-30T10:05:20Z",
    "updated_at": "2024-08-02T07:15:00Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "3582d4b41026123f379c79b84990d70ed7cc2297",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "darosior:2309_fuzz_chainstate",
      "ref": "2309_fuzz_chainstate",
      "sha": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 168868367,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjg4NjgzNjc=",
        "name": "bitcoin",
        "full_name": "darosior/bitcoin",
        "owner": {
          "login": "darosior",
          "id": 22457751,
          "node_id": "MDQ6VXNlcjIyNDU3NzUx",
          "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/darosior",
          "html_url": "https://github.com/darosior",
          "followers_url": "https://api.github.com/users/darosior/followers",
          "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
          "organizations_url": "https://api.github.com/users/darosior/orgs",
          "repos_url": "https://api.github.com/users/darosior/repos",
          "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/darosior/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/darosior/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/darosior/bitcoin",
        "archive_url": "https://api.github.com/repos/darosior/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/darosior/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/darosior/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/darosior/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/darosior/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/darosior/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/darosior/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/darosior/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/darosior/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/darosior/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/darosior/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/darosior/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/darosior/bitcoin/events",
        "forks_url": "https://api.github.com/repos/darosior/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/darosior/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/darosior/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/darosior/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/darosior/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/darosior/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/darosior/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/darosior/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/darosior/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/darosior/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/darosior/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/darosior/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/darosior/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/darosior/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/darosior/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/darosior/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:darosior/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/darosior/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/darosior/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/darosior/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/darosior/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/darosior/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/darosior/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/darosior/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/darosior/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/darosior/bitcoin/hooks",
        "svn_url": "https://github.com/darosior/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 245235,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-31T15:20:35Z",
        "created_at": "2019-02-02T19:20:27Z",
        "updated_at": "2023-11-07T12:50:46Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "9eb57d1ab6ea5ae642b6d6cc2e74c3046984230c",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35797,
        "stargazers_count": 77545,
        "watchers_count": 77545,
        "size": 264436,
        "default_branch": "master",
        "open_issues_count": 672,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-08-02T07:46:10Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-08-02T07:58:09Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
      }
    },
    "author_association": "MEMBER",
    "draft": true,
    "additions": 749,
    "deletions": 0,
    "changed_files": 4,
    "commits": 3,
    "review_comments": 19,
    "comments": 9
  },
  "events": [
    {
      "event": "commented",
      "id": 1872496827,
      "node_id": "IC_kwDOABII585vnAi7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1872496827",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-30T10:05:22Z",
      "updated_at": "2024-08-02T07:15:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29158).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875751255), [jamesob](https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1812003162) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1872496827",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "labeled",
      "id": 11359797222,
      "node_id": "LE_lADOABII5856080BzwAAAAKlGL_m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11359797222",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-30T10:53:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1800561385,
      "node_id": "PRR_kwDOABII585rUmLp",
      "url": null,
      "actor": null,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1800561385",
      "submitted_at": "2024-01-02T15:03:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "commented",
      "id": 1874196101,
      "node_id": "IC_kwDOABII585vtfaF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874196101",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T15:46:43Z",
      "updated_at": "2024-01-02T15:46:43Z",
      "author_association": "MEMBER",
      "body": "Cool, this is a great thing to investigate. I'll be giving the approach a look this week.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1874196101",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1874318288,
      "node_id": "IC_kwDOABII585vt9PQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874318288",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T17:22:14Z",
      "updated_at": "2024-01-02T17:22:14Z",
      "author_association": "MEMBER",
      "body": "Thanks for working on this!\r\n\r\nOne alternative that I have considered before (for chainstate fuzzing) is to abstract and further modularize `BlockManager`, which would allow us to have an `InMemoryBlockManager` for tests (especially useful for fuzzing but also nice in unit tests).\r\n\r\nThis would require a bunch of work:\r\n* Breaking up the friendship between `BlockManager`, `Chainstate` &  `ChainstateManager`\r\n* Abstracting `BlockManager`'s interface away from being file based\r\n* Hiding access to `BlockManager`'s internal fields\r\n* Probably more...\r\n\r\nThis approach would avoid filesystem syscalls entirely, as well as the large block file allocations.\r\n\r\n---\r\n\r\nThe coinbase maturity also seems relevant because you can't spend any coins in the test until you've mined 100 blocks. Mining 100 blocks every fuzz iteration ends up being pretty slow. Maybe we can use assumeutxo to avoid that? (or snapshot fuzzing)",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1874318288",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1875711592,
      "node_id": "IC_kwDOABII585vzRZo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1875711592",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-03T17:21:25Z",
      "updated_at": "2024-01-03T17:21:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Nice one! ",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875711592",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1875751255,
      "node_id": "IC_kwDOABII585vzbFX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1875751255",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-03T17:54:38Z",
      "updated_at": "2024-01-03T17:54:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875751255",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "reviewed",
      "id": 1812003162,
      "node_id": "PRR_kwDOABII585sAPla",
      "url": null,
      "actor": null,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK; midway through review and trying to resolve some of the CI issues.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1812003162",
      "submitted_at": "2024-01-10T16:20:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "commented",
      "id": 1885310514,
      "node_id": "IC_kwDOABII585wX44y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1885310514",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-10T17:38:48Z",
      "updated_at": "2024-01-10T17:38:48Z",
      "author_association": "MEMBER",
      "body": "Pushed three additional commits to my branch that may make a dent in the CI issues:\r\n- make `fs::path` hashable: https://github.com/jamesob/bitcoin/commit/8f5fdf8ad3d5102e4afaae415e004d4cf6c667cc\r\n- avoid use of `std::filesystem::path` where possible: https://github.com/jamesob/bitcoin/commit/4ef785749ff1c481b5681739653c5b153637e44e\r\n- update linter for mockable filesystem ops: https://github.com/jamesob/bitcoin/commit/face876d55711299c2679aad59b24ee04aa892f0",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1885310514",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "labeled",
      "id": 12087677368,
      "node_id": "LE_lADOABII5856080BzwAAAALQe1G4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12087677368",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-12T11:29:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13427065227,
      "node_id": "HRFPE_lADOABII5856080BzwAAAAMgUMGL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13427065227",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:00:53Z"
    },
    {
      "event": "unlabeled",
      "id": 13427073991,
      "node_id": "UNLE_lADOABII5856080BzwAAAAMgUOPH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13427073991",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:01:31Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2214720674,
      "node_id": "IC_kwDOABII586EAfSi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2214720674",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:04:07Z",
      "updated_at": "2024-07-08T17:04:07Z",
      "author_association": "MEMBER",
      "body": "Rebased this, taking advantage of https://github.com/bitcoin/bitcoin/pull/28960. I've also been investigating alternative approaches.\r\n\r\nI first tried to move from `fmemopen` toward the more flexible `memfd_create`. It avoided the need for some of the filesystem mocks (which were necessary before because you can't call `fileno` on a `FILE*` created with `fmemopen`). This allowed to drop one commit. Further, this removed the need from creating 128MiB in-memory blk files. This is in turn makes it potentially more reasonable to sometimes reindex in `CallOneOf`.\r\n\r\nWith that implemented i tried to \"cache\" an initial chainstate to re-use on each fuzzing round, to avoid having to connect the 110 blocks initial chain on every single iteration. Unsuccessfully.\r\n\r\nFinally, i wanted to compare the performances of mocking the filesystem to simply using a ramdisk. I realized if i were to use a ramdisk i could simply use the filesystem directly to \"cache\" an initial chainstate: create two datadirs, one for the initial chainstate, one for the fuzzing iteration. At initialization of the target create a fresh chainstate and connect the 110 blocks. Upon each iteration wipe the working datadir and copy over the initial datadir.\r\n\r\nSo i implemented that, which besides being more efficient also has the advantage of removing the modifications of non-test code and the platform-dependent syscalls. The target is still pretty slow, but at this point it's just because of the code it calls: we are doing a bunch of block/header connections and reorg upon every iteration, and each of those can take around a hundred milliseconds.\r\n\r\nI've pushed a WIP commit which implements what i described above for the `chainstate` target. Do people think this effort is worth pursuing in this form? If so i'll clean up this PR to remove the filesystem mocking commits and also use a ramdisk for the `blockstorage` target.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-2214720674",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "reviewed",
      "id": 2165630430,
      "node_id": "PRR_kwDOABII586BFOXe",
      "url": null,
      "actor": null,
      "commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-2165630430",
      "submitted_at": "2024-07-09T09:16:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13436986421,
      "node_id": "HRFPE_lADOABII5856080BzwAAAAMg6CQ1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13436986421",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:42:56Z"
    },
    {
      "event": "reviewed",
      "id": 2165669817,
      "node_id": "PRR_kwDOABII586BFX-5",
      "url": null,
      "actor": null,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-2165669817",
      "submitted_at": "2024-07-09T12:56:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM5NDY3M2FmMWE2ZWMyZTAzYjk0NDM2NWYzNzQ3ODUyZmIxNmRhZTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c94673af1a6ec2e03b944365f3747852fb16dae4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c94673af1a6ec2e03b944365f3747852fb16dae4",
      "tree": {
        "sha": "e13b4e74f42e649c8c0b5f0db6d261ebb8b98221",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e13b4e74f42e649c8c0b5f0db6d261ebb8b98221"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e13b4e74f42e649c8c0b5f0db6d261ebb8b98221\nparent 30cef53707fb62ab1c9e73c2b5bc8b006e0613d3\nauthor dergoegge <n.goeggi@gmail.com> 1688725335 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1722166275 +0200\n\nAllow mocking CheckProofOfWork\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmamLAMACgkQ4T/BRc0/\nQwQKngv+M0sPLUAir+wZk7T/wu49RHmVyyB57Lnfc4SJE02UDopamWGk3PkMOf6w\nwVvAgwGM+mDcSr7uYxGc/GR0oMnrKlHZpH+y2bE3LNU33kOet82kMB3wcvt9aj7U\nMcLJXJXutalUzSLEVOSkdSTUGblZZxop14rVq0t5XSORc68UfNGoYLQa7/fmKhYD\nZstSH0FKoODJLKjUSAVC3AyAuKpfaM0DDmq/88qwcsvz/PDckIYAl/pYO1iUZSXg\nrtFFVxPQrdxb5TFijy6iU0ai2pfoL0HsobTlkhZibYILBiUFJV3k8Wop6uchRiuI\nCSXTJUy1KGIe//fZZJP4M8dAl1BnKy1NgIHi1qv61OLMYgjRGqrRq2fCGaWO5aAV\nS122C1OjVoFY+cPQ9nLaqA/qeCC6MAP7HE8blgx5NURhZwx+Up4QjXH6TgzrptXh\nu/8fyKg6M/nkdBNq84oxIyxNa//uYCbPFl3fqk64FcgsjziBKM9JRHVE2PoNDfl6\nqWtBWKTX\n=dLm9\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/30cef53707fb62ab1c9e73c2b5bc8b006e0613d3",
          "sha": "30cef53707fb62ab1c9e73c2b5bc8b006e0613d3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/30cef53707fb62ab1c9e73c2b5bc8b006e0613d3"
        }
      ],
      "message": "Allow mocking CheckProofOfWork",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-28T11:31:15Z"
      },
      "author": {
        "name": "dergoegge",
        "email": "n.goeggi@gmail.com",
        "date": "2023-07-07T10:22:15Z"
      },
      "sha": "c94673af1a6ec2e03b944365f3747852fb16dae4"
    },
    {
      "event": "commented",
      "id": 2254650844,
      "node_id": "IC_kwDOABII586GYz3c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2254650844",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-28T21:15:30Z",
      "updated_at": "2024-07-28T21:15:41Z",
      "author_association": "MEMBER",
      "body": "Alright so i cleaned up this PR locally to only use a RAM disk. I'm now in a middle of a significant refactoring of the chainstate fuzz target which i hope to be able to push shortly. If you intended to read through this PoC, maybe wait for the next push.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-2254650844",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE3MjRkMWRiOGViM2UzMTIxZTFjOGU2NWEyMGY2M2I4MjEwYWRkZDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a724d1db8eb3e3121e1c8e65a20f63b8210addd3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a724d1db8eb3e3121e1c8e65a20f63b8210addd3",
      "tree": {
        "sha": "d7fe9636091d1225a54647f6c61aede1f808d291",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d7fe9636091d1225a54647f6c61aede1f808d291"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d7fe9636091d1225a54647f6c61aede1f808d291\nparent c94673af1a6ec2e03b944365f3747852fb16dae4\nauthor Antoine Poinsot <darosior@protonmail.com> 1699886435 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1722438367 +0200\n\nfuzz: add a target for the BlockManager\n\nExercise (most of) the public interface of the BlockManager and assert\nsome invariants. Notably, try to mimick block arrival whether its header\nwas announced first or not.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaqUuUACgkQ4T/BRc0/\nQwRI6QwA00HX81B5eQIzPmJ4hsUdEcb+8jS27CYXUimknntagaEUu01LTOuYZrNZ\nuFhxxclB9JinSJPvyk+WYtrRcQloDG6hi44jZ2UF/oYkLa87ZzbOg2PVV/vSxdAr\ngFSusPXBlyqR/bUqTuu3NFQ8/CKhHxsA3KKdI05QZDqssiV8Sd+j5YAbk0RWfgZc\ntw0jt2VHdXxVHWBsj0Xox0AJ0NVJ4ev2YYG65sGqGhDqougP2U36pc//37/CwcJu\nv2TsY3jY6Jkx6xv7mXXe+JdKPSo11JYlE9ljLbNA3dqYo8QhW1fQpaAqZ1bkMuBq\nLIn1yhVYdOrp8QR2AtgGpzKv13pcp7tZ499EeWwVCFyleUq5PUFUyPmP2Hbjmb71\npiWHCGKrNVqyqdhEuGOhLPKCmEysvsnGa7+E9/vpf6Gn2NAsMpZwPrRkyeKPBphQ\nTa5jh2zqbrdnkqK6ghH2DJdQBF7BbXkSQYXTB/mvO1BMaBCvmBhaW5sPMpbd+W+V\nkI2h1oke\n=jL7+\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c94673af1a6ec2e03b944365f3747852fb16dae4",
          "sha": "c94673af1a6ec2e03b944365f3747852fb16dae4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c94673af1a6ec2e03b944365f3747852fb16dae4"
        }
      ],
      "message": "fuzz: add a target for the BlockManager\n\nExercise (most of) the public interface of the BlockManager and assert\nsome invariants. Notably, try to mimick block arrival whether its header\nwas announced first or not.",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-31T15:06:07Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-11-13T14:40:35Z"
      },
      "sha": "a724d1db8eb3e3121e1c8e65a20f63b8210addd3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU5MmM5ZGRiMTc5M2QwMmFjZjc1MWU1YmEzNjJlYzFiYzE5ODhlZjY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "tree": {
        "sha": "06cf1943c39922eba8df0ec263a8f2555723909b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/06cf1943c39922eba8df0ec263a8f2555723909b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 06cf1943c39922eba8df0ec263a8f2555723909b\nparent a724d1db8eb3e3121e1c8e65a20f63b8210addd3\nauthor Antoine Poinsot <darosior@protonmail.com> 1694866386 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1722438374 +0200\n\nfuzz: add a target for the ChainstateManager\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaqUwAACgkQ4T/BRc0/\nQwRGzwv/bq4dstf/9uz/a9LnaPJzOANUM//A/Qn18/RPZN7Y2a4RmDeBghncwpja\ngJuabnyGUOvpbHIPYsETLi3hFef5WuLkwlFzbgcJw/e8wJeewkeXU1x+cyap6en3\nIbn6y/U7DSU6dXgoJX/z2oVFoGDnI6e5rwHrXgK1GnGCKavaIH8jJW7UFZgQOQ/r\nMVzgk2hnX0L6/YTcJmOF1khj//QiM+gjcEayc5WrjrKxHZ9WLxLKOs4gocY+Bj87\nmCxJTyiOQ1YALagfdfBQ38ncQgTdLFJZzrKzDLaWzbsz5TJP7olXhHWKV5Wz2zWr\noKocEAoHMc9P7dPUndSGSF3DgtP2FWBTsW7qQ1dKqyc8grTiEO+3wr6Is0d1yfka\nnPBYeUTP3MOZQvZUUpoO1EOPOjZEAw4IQ5R2IjBse8i1bwDQ1OSWeJGiOQrsnJvN\n8Ln/DyzNf5M05LrfL+CugE+ncA8rILUadqUUIYrPDwgMNTsbbhET0X9547ZxRZ0r\nRGhnboj5\n=vfPl\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a724d1db8eb3e3121e1c8e65a20f63b8210addd3",
          "sha": "a724d1db8eb3e3121e1c8e65a20f63b8210addd3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a724d1db8eb3e3121e1c8e65a20f63b8210addd3"
        }
      ],
      "message": "fuzz: add a target for the ChainstateManager",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-31T15:06:14Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-09-16T12:13:06Z"
      },
      "sha": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13711773595,
      "node_id": "HRFPE_lADOABII5856080BzwAAAAMxSQ-b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13711773595",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-31T15:20:37Z"
    },
    {
      "event": "commented",
      "id": 2260796754,
      "node_id": "IC_kwDOABII586GwQVS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2260796754",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-31T15:29:12Z",
      "updated_at": "2024-07-31T15:29:12Z",
      "author_association": "MEMBER",
      "body": "Cleaned up this PR to always use a ramdisk instead of trying to mock the filesystem. Also significantly reworked the chainstate target.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-2260796754",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "reviewed",
      "id": 2212035547,
      "node_id": "PRR_kwDOABII586D2Pvb",
      "url": null,
      "actor": null,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-2212035547",
      "submitted_at": "2024-08-01T08:43:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439533284",
      "pull_request_review_id": 1800561385,
      "id": 1439533284,
      "node_id": "PRRC_kwDOABII585VzYjk",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you checked if using `fmemopen` is better/faster than using a ram disk?",
      "created_at": "2024-01-02T15:03:27Z",
      "updated_at": "2024-01-02T15:03:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1439533284",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439533284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439796296",
      "pull_request_review_id": 1800974871,
      "id": 1439796296,
      "node_id": "PRRC_kwDOABII585V0YxI",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I haven't. Can we use a ramdisk at oss-fuzz?",
      "created_at": "2024-01-02T20:33:30Z",
      "updated_at": "2024-01-02T20:33:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1439796296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439796296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440301216",
      "pull_request_review_id": 1801749930,
      "id": 1440301216,
      "node_id": "PRRC_kwDOABII585V2UCg",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Afaict oss-fuzz already uses a ram disk for its environments: https://github.com/google/clusterfuzz/blob/c461a961d8fb2afe47fb4af5eee3d1434a324a40/docker/base/setup_clusterfuzz.sh#L38 (i.e. `/tmp` is mounted in ram).",
      "created_at": "2024-01-03T10:35:58Z",
      "updated_at": "2024-01-03T10:35:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1440301216",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440301216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1441013417",
      "pull_request_review_id": 1803140054,
      "id": 1441013417,
      "node_id": "PRRC_kwDOABII585V5B6p",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://joshua.hu/fuzzing-with-memfd-createfd-fmemopen-syscall-function\n\nThe author of this post found that a ram disk is slowerðŸš€\n\nI/O syscalls are avoided with fmempopen and everything simply happens in userland.",
      "created_at": "2024-01-03T22:12:06Z",
      "updated_at": "2024-01-03T22:12:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1441013417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1441013417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1442215861",
      "pull_request_review_id": 1804915877,
      "id": 1442215861,
      "node_id": "PRRC_kwDOABII585V9ne1",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting. I was aware of `open_memstream` but not `memfd_create`. It's slower but could actually be helpful to get rid of the `128 MiB` allocs and make it possible to reindex.",
      "created_at": "2024-01-04T20:21:16Z",
      "updated_at": "2024-01-04T20:21:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1442215861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1442215861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446610769",
      "pull_request_review_id": 1812003162,
      "id": 1446610769,
      "node_id": "PRRC_kwDOABII585WOYdR",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    CScheduler scheduler;\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+    scheduler.m_service_thread = std::thread(util::TraceThread, \"scheduler\", [&] { scheduler.serviceQueue(); });\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = datadir / \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = \"\",\n+        .adjusted_time_callback = NodeClock::now,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_notifications,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .block_tree_db_in_memory = true,\n+        .coins_db_in_memory = true,\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Activate the initial chain.\n+    BlockValidationState dummy_valstate;\n+    for (Chainstate* chainstate : chainman.GetAll()) {\n+        assert(chainstate->ActivateBestChain(dummy_valstate, nullptr));\n+    }\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};\n+                const int headers_count{is_random ? fuzzed_data_provider.ConsumeIntegralInRange(1, MAX_HEADERS_RESULTS) : 1};\n+                headers.reserve(headers_count);\n+\n+                if (is_random) {\n+                    for (int i = 0; i < headers_count; ++i) {\n+                        headers.push_back(CreateBlockHeader(fuzzed_data_provider, RandomPrevBlock(fuzzed_data_provider), /*set_merkle=*/true).first);\n+                    }\n+                } else {\n+                    // In 10% of the cases branch off a random header.\n+                    const bool extend_tip{fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 9) > 0};\n+                    // The unspent coins to be used to create transactions beside the coinbase in the block to be created.\n+                    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> empty_utxos;\n+                    auto& coins{extend_tip ? utxos : empty_utxos};\n+                    CBlockIndex* prev_block{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                        // Sometimes extend the best validated chain, sometimes the best header chain.\n+                        if (extend_tip) {\n+                            return fuzzed_data_provider.ConsumeBool() ? chainman.ActiveTip() : chainman.m_best_header;\n+                        }\n+                        return &PickValue(fuzzed_data_provider, chainman.m_blockman.m_block_index).second;\n+                    }()};\n+                    blocks_in_flight.push_back(CreateValidBlock(fuzzed_data_provider, chainparams.GetConsensus(), prev_block, coins));",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 551,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "When generating a valid block (here and below) do we want to do some kind of assertion that the block was actually considered valid? I could see the test code silently generating only invalid blocks and (afaik) there wouldn't be an indication of it here.",
      "created_at": "2024-01-09T21:04:10Z",
      "updated_at": "2024-01-10T16:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1446610769",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446610769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446611692",
      "pull_request_review_id": 1812003162,
      "id": 1446611692,
      "node_id": "PRRC_kwDOABII585WOYrs",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 460,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This type comes up often enough in this file that it might be worth an alias.",
      "created_at": "2024-01-09T21:05:16Z",
      "updated_at": "2024-01-10T16:44:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1446611692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446611692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 513,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447615580",
      "pull_request_review_id": 1812003162,
      "id": 1447615580,
      "node_id": "PRRC_kwDOABII585WSNxc",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/29158/commits/ea36af80beeeee0b9de793e52887ba3e164b803c\r\n\r\n`fmemopen` is Linux-specific; here's a fixup commit that `ifdef`s it out and fixes some of the CI errors if you want it: https://github.com/jamesob/bitcoin/commit/26b9c9d48e3ec16e69d550266c7f27f4db9cb9f8",
      "created_at": "2024-01-10T16:19:27Z",
      "updated_at": "2024-01-10T16:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1447615580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447615580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670101598",
      "pull_request_review_id": 2165630430,
      "id": 1670101598,
      "node_id": "PRRC_kwDOABII585ji7pe",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`fs::temp_directory_path()` points to the top level tmp dir and won't be unique every time. You'll want to do something similar to what the testing setups are doing: https://github.com/bitcoin/bitcoin/blob/1f9d30744d32d24ad3128721cf5bd65a3f1543e8/src/test/util/setup_common.cpp#L150-L152",
      "created_at": "2024-07-09T09:16:22Z",
      "updated_at": "2024-07-09T09:16:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670101598",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670101598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670126790",
      "pull_request_review_id": 2165669817,
      "id": 1670126790,
      "node_id": "PRRC_kwDOABII585jjBzG",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);\n+    }\n+} g_test_data;\n+\n+// Mapping from file path to in-memory file (descriptor). It's fine to use a path as key as we only\n+// ever use unique pathnames for block files.\n+std::unordered_map<fs::path, int, std::hash<std::filesystem::path>> g_fds;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it first.\n+        const auto fd{[&]{\n+            const auto it = g_fds.find(file_path);\n+            if (it != g_fds.end()) return it->second;\n+            const auto [it2, _]{g_fds.insert({file_path, memfd_create(file_path.c_str(), 0)})};\n+            return it2->second;\n+        }()};\n+        //std::cout << \"Opening \" << file_path << \" fd \" << fd << \" mode \" << mode << std::endl;\n+        return Assert(fdopen(dup(fd), mode));\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_fds.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_fds.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_fds.extract(old_p).key() = new_p;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    // FIXME: only used to setup logging. Set it up without instantiating a whole, unused, BasicTestingSetup.\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN/*, {\"-printtoconsole\", \"-debug\"}*/);\n+    g_setup = testing_setup.get();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // This creates the datadirs in the tmp dir.\n+    g_test_data.Init();\n+\n+    // Create the chainstate for the initial datadir. On every round we'll restart from this chainstate instead of\n+    // re-creating one from scratch.\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = Params(),\n+        .blocks_dir = g_test_data.init_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = Params(),\n+        .datadir = g_test_data.init_datadir,\n+        .check_block_index = false,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 1;\n+    cache_sizes.coins_db = 2;\n+    cache_sizes.coins = 3;\n+    node::ChainstateLoadOptions load_opts {\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Connect the initial chain to get 10 spendable UTxOs at the start of every fuzzing round.\n+    const auto g_initial_blockchain{CreateBlockChain(110, Params())};\n+    BlockValidationState valstate;\n+    auto& chainstate{chainman.ActiveChainstate()};\n+    assert(chainstate.ActivateBestChain(valstate, nullptr));\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    LOCK(cs_main);\n+    if (chainstate.CanFlushToDisk()) {\n+        chainstate.ForceFlushStateToDisk();\n+    }\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    //const auto first_time{SteadyClock::now()};\n+\n+    // On every round start from a freshly copied initial datadir.\n+    fs::remove_all(g_test_data.working_datadir);\n+    fs::copy(g_test_data.init_datadir, g_test_data.working_datadir, fs::copy_options::overwrite_existing | fs::copy_options::recursive);\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = g_test_data.working_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = g_test_data.working_datadir,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, and call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    //const auto time_before_loop{SteadyClock::now()};\n+\n+    BlockValidationState dummy_valstate;\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 570,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Trying to choose probabilities like this won't really work with modern fuzzing engines (because the inputs given to the harness are not uniformly random) and is probably equivalent to the following:\r\n\r\n```suggestion\r\n                const bool is_random{fuzzed_data_provider.ConsumeBool()};\r\n```",
      "created_at": "2024-07-09T09:30:16Z",
      "updated_at": "2024-07-09T12:56:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670126790",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670126790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 576,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670149765",
      "pull_request_review_id": 2165707627,
      "id": 1670149765,
      "node_id": "PRRC_kwDOABII585jjHaF",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": 1670101598,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-09T09:44:00Z",
      "updated_at": "2024-07-09T09:44:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670149765",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670149765"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670484095",
      "pull_request_review_id": 2165669817,
      "id": 1670484095,
      "node_id": "PRRC_kwDOABII585jkZB_",
      "diff_hunk": "@@ -0,0 +1,699 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <random.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+//! To generate a random tmp datadir per process (necessary to fuzz with multiple cores).\n+static FastRandomContext g_insecure_rand_ctx_temp_path;\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        const auto rand_str{g_insecure_rand_ctx_temp_path.rand256().ToString()};\n+        const auto tmp_dir{fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME / rand_str};\n+        init_datadir = tmp_dir / \"init\";\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = tmp_dir / \"working\";\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This should nuke the whole parent tmp dir that was created for the fuzz test, not just `init_datadir`. I'm seeing tons of left over directories otherwise.",
      "created_at": "2024-07-09T12:56:36Z",
      "updated_at": "2024-07-09T12:56:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670484095",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670484095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670749288",
      "pull_request_review_id": 2166688465,
      "id": 1670749288,
      "node_id": "PRRC_kwDOABII585jlZxo",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);\n+    }\n+} g_test_data;\n+\n+// Mapping from file path to in-memory file (descriptor). It's fine to use a path as key as we only\n+// ever use unique pathnames for block files.\n+std::unordered_map<fs::path, int, std::hash<std::filesystem::path>> g_fds;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it first.\n+        const auto fd{[&]{\n+            const auto it = g_fds.find(file_path);\n+            if (it != g_fds.end()) return it->second;\n+            const auto [it2, _]{g_fds.insert({file_path, memfd_create(file_path.c_str(), 0)})};\n+            return it2->second;\n+        }()};\n+        //std::cout << \"Opening \" << file_path << \" fd \" << fd << \" mode \" << mode << std::endl;\n+        return Assert(fdopen(dup(fd), mode));\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_fds.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_fds.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_fds.extract(old_p).key() = new_p;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    // FIXME: only used to setup logging. Set it up without instantiating a whole, unused, BasicTestingSetup.\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN/*, {\"-printtoconsole\", \"-debug\"}*/);\n+    g_setup = testing_setup.get();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // This creates the datadirs in the tmp dir.\n+    g_test_data.Init();\n+\n+    // Create the chainstate for the initial datadir. On every round we'll restart from this chainstate instead of\n+    // re-creating one from scratch.\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = Params(),\n+        .blocks_dir = g_test_data.init_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = Params(),\n+        .datadir = g_test_data.init_datadir,\n+        .check_block_index = false,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 1;\n+    cache_sizes.coins_db = 2;\n+    cache_sizes.coins = 3;\n+    node::ChainstateLoadOptions load_opts {\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Connect the initial chain to get 10 spendable UTxOs at the start of every fuzzing round.\n+    const auto g_initial_blockchain{CreateBlockChain(110, Params())};\n+    BlockValidationState valstate;\n+    auto& chainstate{chainman.ActiveChainstate()};\n+    assert(chainstate.ActivateBestChain(valstate, nullptr));\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    LOCK(cs_main);\n+    if (chainstate.CanFlushToDisk()) {\n+        chainstate.ForceFlushStateToDisk();\n+    }\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    //const auto first_time{SteadyClock::now()};\n+\n+    // On every round start from a freshly copied initial datadir.\n+    fs::remove_all(g_test_data.working_datadir);\n+    fs::copy(g_test_data.init_datadir, g_test_data.working_datadir, fs::copy_options::overwrite_existing | fs::copy_options::recursive);\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = g_test_data.working_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = g_test_data.working_datadir,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, and call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    //const auto time_before_loop{SteadyClock::now()};\n+\n+    BlockValidationState dummy_valstate;\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 570,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": 1670126790,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "When debating this with myself my weak argument in favour of it was that the target was very slow and this could help discover interesting paths faster. I also wanted your feedback on this, so thanks.",
      "created_at": "2024-07-09T15:35:25Z",
      "updated_at": "2024-07-09T15:35:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670749288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670749288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 576,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698712620",
      "pull_request_review_id": 2210502672,
      "id": 1698712620,
      "node_id": "PRRC_kwDOABII585lQEws",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    CScheduler scheduler;\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+    scheduler.m_service_thread = std::thread(util::TraceThread, \"scheduler\", [&] { scheduler.serviceQueue(); });\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = datadir / \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = \"\",\n+        .adjusted_time_callback = NodeClock::now,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_notifications,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .block_tree_db_in_memory = true,\n+        .coins_db_in_memory = true,\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Activate the initial chain.\n+    BlockValidationState dummy_valstate;\n+    for (Chainstate* chainstate : chainman.GetAll()) {\n+        assert(chainstate->ActivateBestChain(dummy_valstate, nullptr));\n+    }\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};\n+                const int headers_count{is_random ? fuzzed_data_provider.ConsumeIntegralInRange(1, MAX_HEADERS_RESULTS) : 1};\n+                headers.reserve(headers_count);\n+\n+                if (is_random) {\n+                    for (int i = 0; i < headers_count; ++i) {\n+                        headers.push_back(CreateBlockHeader(fuzzed_data_provider, RandomPrevBlock(fuzzed_data_provider), /*set_merkle=*/true).first);\n+                    }\n+                } else {\n+                    // In 10% of the cases branch off a random header.\n+                    const bool extend_tip{fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 9) > 0};\n+                    // The unspent coins to be used to create transactions beside the coinbase in the block to be created.\n+                    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> empty_utxos;\n+                    auto& coins{extend_tip ? utxos : empty_utxos};\n+                    CBlockIndex* prev_block{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                        // Sometimes extend the best validated chain, sometimes the best header chain.\n+                        if (extend_tip) {\n+                            return fuzzed_data_provider.ConsumeBool() ? chainman.ActiveTip() : chainman.m_best_header;\n+                        }\n+                        return &PickValue(fuzzed_data_provider, chainman.m_blockman.m_block_index).second;\n+                    }()};\n+                    blocks_in_flight.push_back(CreateValidBlock(fuzzed_data_provider, chainparams.GetConsensus(), prev_block, coins));",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 551,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1446610769,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-31T15:27:30Z",
      "updated_at": "2024-07-31T15:27:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1698712620",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698712620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698713340",
      "pull_request_review_id": 2210503768,
      "id": 1698713340,
      "node_id": "PRRC_kwDOABII585lQE78",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1447615580,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not mocking the fs anymore.",
      "created_at": "2024-07-31T15:27:56Z",
      "updated_at": "2024-07-31T15:27:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1698713340",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698713340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698713590",
      "pull_request_review_id": 2210504176,
      "id": 1698713590,
      "node_id": "PRRC_kwDOABII585lQE_2",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);\n+    }\n+} g_test_data;\n+\n+// Mapping from file path to in-memory file (descriptor). It's fine to use a path as key as we only\n+// ever use unique pathnames for block files.\n+std::unordered_map<fs::path, int, std::hash<std::filesystem::path>> g_fds;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it first.\n+        const auto fd{[&]{\n+            const auto it = g_fds.find(file_path);\n+            if (it != g_fds.end()) return it->second;\n+            const auto [it2, _]{g_fds.insert({file_path, memfd_create(file_path.c_str(), 0)})};\n+            return it2->second;\n+        }()};\n+        //std::cout << \"Opening \" << file_path << \" fd \" << fd << \" mode \" << mode << std::endl;\n+        return Assert(fdopen(dup(fd), mode));\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_fds.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_fds.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_fds.extract(old_p).key() = new_p;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    // FIXME: only used to setup logging. Set it up without instantiating a whole, unused, BasicTestingSetup.\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN/*, {\"-printtoconsole\", \"-debug\"}*/);\n+    g_setup = testing_setup.get();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // This creates the datadirs in the tmp dir.\n+    g_test_data.Init();\n+\n+    // Create the chainstate for the initial datadir. On every round we'll restart from this chainstate instead of\n+    // re-creating one from scratch.\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = Params(),\n+        .blocks_dir = g_test_data.init_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = Params(),\n+        .datadir = g_test_data.init_datadir,\n+        .check_block_index = false,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 1;\n+    cache_sizes.coins_db = 2;\n+    cache_sizes.coins = 3;\n+    node::ChainstateLoadOptions load_opts {\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Connect the initial chain to get 10 spendable UTxOs at the start of every fuzzing round.\n+    const auto g_initial_blockchain{CreateBlockChain(110, Params())};\n+    BlockValidationState valstate;\n+    auto& chainstate{chainman.ActiveChainstate()};\n+    assert(chainstate.ActivateBestChain(valstate, nullptr));\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    LOCK(cs_main);\n+    if (chainstate.CanFlushToDisk()) {\n+        chainstate.ForceFlushStateToDisk();\n+    }\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    //const auto first_time{SteadyClock::now()};\n+\n+    // On every round start from a freshly copied initial datadir.\n+    fs::remove_all(g_test_data.working_datadir);\n+    fs::copy(g_test_data.init_datadir, g_test_data.working_datadir, fs::copy_options::overwrite_existing | fs::copy_options::recursive);\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = g_test_data.working_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = g_test_data.working_datadir,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, and call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    //const auto time_before_loop{SteadyClock::now()};\n+\n+    BlockValidationState dummy_valstate;\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 570,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": 1670126790,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-31T15:28:07Z",
      "updated_at": "2024-07-31T15:28:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1698713590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698713590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 576,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698713853",
      "pull_request_review_id": 2210504508,
      "id": 1698713853,
      "node_id": "PRRC_kwDOABII585lQFD9",
      "diff_hunk": "@@ -0,0 +1,699 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <random.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+//! To generate a random tmp datadir per process (necessary to fuzz with multiple cores).\n+static FastRandomContext g_insecure_rand_ctx_temp_path;\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        const auto rand_str{g_insecure_rand_ctx_temp_path.rand256().ToString()};\n+        const auto tmp_dir{fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME / rand_str};\n+        init_datadir = tmp_dir / \"init\";\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = tmp_dir / \"working\";\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "in_reply_to_id": 1670484095,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-31T15:28:15Z",
      "updated_at": "2024-07-31T15:28:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1698713853",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698713853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699601977",
      "pull_request_review_id": 2211907628,
      "id": 1699601977,
      "node_id": "PRRC_kwDOABII585lTd45",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As discussed below i tried various ways of mocking the filesystem and ended up not mocking it at all: https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-2214720674.",
      "created_at": "2024-08-01T07:50:03Z",
      "updated_at": "2024-08-01T07:50:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1699601977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699601977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699687340",
      "pull_request_review_id": 2212035547,
      "id": 1699687340,
      "node_id": "PRRC_kwDOABII585lTyus",
      "diff_hunk": "@@ -0,0 +1,740 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <random.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/random.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/task_runner.h>\n+#include <util/thread.h>\n+\n+#include <ranges>\n+\n+namespace {\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+/**\n+ * Manage the state for a run of the fuzz target.\n+ *\n+ * This stores our utxos and keep them in sync with the state of the chain. This also allows to register some block\n+ * hashes to assert the validity of a given block.\n+ */\n+class StateManager : public CValidationInterface {\n+    //! Utxos created in a coinbase transaction which hasn't matured yet. Those are keyed by the height at\n+    //! which they can be spent in the next block.\n+    std::unordered_map<int, std::pair<COutPoint, CTxOut>> m_immature_utxos;\n+\n+    //! Utxos which can be spent in the next block.\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> m_spendable_utxos;\n+\n+    //! Utxos which were spent. Kept around to add them back in case of reorg.\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> m_spent_utxos;\n+\n+    //! Block hashes of blocks we assume are valid. Unbounded but we assume we won't add millions such entries.\n+    std::unordered_set<uint256, SaltedTxidHasher> m_assert_valid_blocks;\n+\n+public:\n+    /** Create a transaction spending a random amount of utxos from our wallet, if possible. */\n+    CTransactionRef CreateTransaction(FuzzedDataProvider& prov)\n+    {\n+        if (m_spendable_utxos.empty()) return {};\n+        CMutableTransaction tx;\n+\n+        // Pick the utxos to use as input of our transaction. Drop them from our set of available\n+        // utxos to avoid reusing them in another transaction before a block gets connected.\n+        // FIXME: can we be smarter than erasing a hundred times? For instance keeping track of reserved utxos?\n+        const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)m_spendable_utxos.size(), 100))};\n+        tx.vin.resize(input_count);\n+        CAmount in_value{0};\n+        auto it{m_spendable_utxos.begin()};\n+        for (int i{0}; i < input_count; ++i) {\n+            auto [outpoint, coin] = *it++;\n+            in_value += coin.nValue;\n+            tx.vin[i].prevout = outpoint;\n+            tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+            m_spendable_utxos.erase(outpoint);\n+            m_spent_utxos.emplace(outpoint, std::move(coin));\n+        }\n+\n+        const auto out_count{prov.ConsumeIntegralInRange(1, 100)};\n+        tx.vout.resize(out_count);\n+        for (int i{0}; i < out_count; ++i) {\n+            tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+            tx.vout[i].nValue = in_value / out_count;\n+        }\n+\n+        return MakeTransactionRef(std::move(tx));\n+    }\n+\n+    /** Record a block hash to assert the validity of the block once it'll have been checked. */\n+    void AssertBlockValidity(uint256 block_hash)\n+    {\n+        m_assert_valid_blocks.insert(std::move(block_hash));\n+    }\n+\n+protected:\n+    /** We subscribe to the block checked notification to let the fuzz target assert the validity of some blocks. */\n+    void BlockChecked(const CBlock& block, const BlockValidationState& state) override\n+    {\n+        if (!state.IsValid()) {\n+            // FIXME: since we never delete records is it possible that we re-create the same block but treat it as\n+            // invalid this time (min_pow_checked = false for instance) and it would fail this assert?\n+            assert(!m_assert_valid_blocks.contains(block.GetHash()));\n+        }\n+    }\n+\n+    /** We subscribe to the block connected notifications to update our \"wallet view\", ie the coins we can spend at the\n+     * next block. */\n+    void BlockConnected(ChainstateRole role, const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex) override\n+    {\n+        // First of all record the new coinbase output.\n+        COutPoint coinbase_op{block->vtx[0]->GetHash(), 0};\n+        CTxOut coinbase_coin{block->vtx[0]->vout[0]};\n+        m_immature_utxos.emplace(pindex->nHeight + COINBASE_MATURITY - 1, std::make_pair(coinbase_op, coinbase_coin));\n+\n+        // Then record outputs spent and created by all other transactions in the block. In the fuzz target\n+        // blocks only ever contain transactions which spend and create our own outputs.\n+        for (const auto& tx: block->vtx | std::views::drop(1)) {\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                COutPoint op{tx->GetHash(), (uint32_t)i};\n+                m_spendable_utxos.emplace(std::move(op), tx->vout[i]);\n+            }\n+\n+            for (const auto& vin: tx->vin) {\n+                m_spendable_utxos.erase(vin.prevout);\n+            }\n+        }\n+\n+        // Finally, record any newly matured utxo as spendable in the next block. Note we don't move\n+        // and erase the entry on purpose here, as we might need it again in case of reorg.\n+        const auto& matured_utxo{m_immature_utxos.find(pindex->nHeight)};\n+        if (matured_utxo != m_immature_utxos.end()) {\n+            m_spendable_utxos.emplace(matured_utxo->second.first, matured_utxo->second.second);\n+        }\n+    }\n+\n+    /** We subscribe to the block disconnected notifications to update our \"wallet view\", the coins we can spend at the\n+     * next block. */\n+    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override\n+    {\n+        // First of all drop the coinbase output for this block.\n+        m_immature_utxos.erase(pindex->nHeight + COINBASE_MATURITY - 1);\n+\n+        // Then if we previously marked a coinbase output as newly matured for a coin at this height,\n+        // mark it as immature again.\n+        const auto& re_immatured_utxo{m_immature_utxos.find(pindex->nHeight)};\n+        if (re_immatured_utxo != m_immature_utxos.end()) {\n+            m_spendable_utxos.erase(re_immatured_utxo->second.first);\n+        }\n+\n+        // Finally, drop any coin created in this block and re-insert formerly spent coins.\n+        for (const auto& tx: block->vtx) {\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                COutPoint op{tx->GetHash(), (uint32_t)i};\n+                m_spendable_utxos.erase(op);\n+            }\n+\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& vin: tx->vin) {\n+                auto spent_utxo{m_spent_utxos.find(vin.prevout)};\n+                if (spent_utxo != m_spent_utxos.end()) {\n+                    m_spendable_utxos.emplace(spent_utxo->first, spent_utxo->second);\n+                }\n+            }\n+        }\n+    }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+//! To generate a random tmp datadir per process (necessary to fuzz with multiple cores).\n+static FastRandomContext g_insecure_rand_ctx_temp_path;\n+\n+struct TestData {\n+    fs::path m_tmp_dir;\n+    fs::path m_datadir;\n+    fs::path m_init_datadir;\n+    const CChainParams m_chain_params{*CChainParams::RegTest({})};\n+    KernelNotifications m_notifs;\n+    util::SignalInterrupt m_interrupt;\n+\n+    void Init() {\n+        SeedRandomForTest(SeedRand::SEED);\n+        const auto rand_str{g_insecure_rand_ctx_temp_path.rand256().ToString()};\n+        m_tmp_dir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME / rand_str;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 203,
      "original_position": 203,
      "commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "original_commit_id": "e92c9ddb1793d02acf751e5ba362ec1bc1988ef6",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe just inline it, if it is only used once? Also, the build system overhead seems not worth it to place `PACKAGE_NAME` here? (See lint failure)\r\n\r\n\r\n```suggestion\r\n\r\n\r\n\r\nstruct TestData {\r\n    fs::path m_tmp_dir;\r\n    fs::path m_datadir;\r\n    fs::path m_init_datadir;\r\n    const CChainParams m_chain_params{*CChainParams::RegTest({})};\r\n    KernelNotifications m_notifs;\r\n    util::SignalInterrupt m_interrupt;\r\n\r\n    void Init() {\r\n        SeedRandomForTest(SeedRand::SEED);\r\n        const auto rand_str{FastRandomContext{}.rand256().ToString()}; //! To generate a random tmp datadir per process (necessary to fuzz with multiple cores).\r\n        m_tmp_dir = fs::temp_directory_path() / \"fuzz_chainstate\" / rand_str;\r\n```",
      "created_at": "2024-08-01T08:43:35Z",
      "updated_at": "2024-08-01T08:43:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1699687340",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699687340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": 189,
      "original_start_line": 189,
      "start_side": "RIGHT",
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    }
  ]
}