{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158",
    "id": 1660385595,
    "node_id": "PR_kwDOABII585i93k7",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/29158",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/29158.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/29158.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/040af0ea45e05ad45c372090dc50b4eeda93737f",
    "number": 29158,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "PoC: fuzz chainstate and block managers",
    "user": {
      "login": "darosior",
      "id": 22457751,
      "node_id": "MDQ6VXNlcjIyNDU3NzUx",
      "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/darosior",
      "html_url": "https://github.com/darosior",
      "followers_url": "https://api.github.com/users/darosior/followers",
      "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
      "organizations_url": "https://api.github.com/users/darosior/orgs",
      "repos_url": "https://api.github.com/users/darosior/repos",
      "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/darosior/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "We don't have a fuzzing harness for our main consensus engine [0]. This PR introduces two new targets which respectively fuzz the `BlockManager`Â and `ChainstateManager` (process headers, blocks, reorgs and assert some invariants in doing so).\r\n\r\nThere is two main obstacles to achieving this: PoW and io. The blocks and chainstate databases can be stored in memory but blocks still need a valid proof of work and to be stored on disk. Niklas solved the first issue in #28043 by simply introducing a global which makes it possible to mock the PoW check (his commit is cherry-picked here). After considering other approaches, i also used globals to mock disk io.\r\n\r\nI'm interested with this PR in getting feedback on the concept and the approach, but also in suggestions of more invariants to be asserting in the `chainstate`Â fuzz target.\r\n\r\nRegarding other approaches i tried the most potentially promising was to leverage `ld`'s `--wrap` option to mock the syscalls without having to modify non-test code. But i didn't try too hard to make it work: better to have a demo of what can be achieved first with a more trivial way of mocking filesystem calls. If there is interest in these fuzz targets, i can give this approach another look.\r\n\r\nRegarding efficiency, the chainstate fuzz target is quite slow at the moment but i've at least 2x its performance by rebasing on #28960 and making `CheckBlockIndex` callable externally even if `!ShouldCheckBlockIndex()`. Suggestions for performance improvements welcome too.\r\n\r\n---\r\n\r\n[0] Well there is `utxo_total_supply` but it's very specialized toward exercising a specific past bug.",
    "labels": [
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2023-12-30T10:05:20Z",
    "updated_at": "2024-07-09T15:35:25Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "51853aa1502c4ed57e207d72704d09ef31f57707",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "darosior:2309_fuzz_chainstate",
      "ref": "2309_fuzz_chainstate",
      "sha": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 168868367,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjg4NjgzNjc=",
        "name": "bitcoin",
        "full_name": "darosior/bitcoin",
        "owner": {
          "login": "darosior",
          "id": 22457751,
          "node_id": "MDQ6VXNlcjIyNDU3NzUx",
          "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/darosior",
          "html_url": "https://github.com/darosior",
          "followers_url": "https://api.github.com/users/darosior/followers",
          "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
          "organizations_url": "https://api.github.com/users/darosior/orgs",
          "repos_url": "https://api.github.com/users/darosior/repos",
          "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/darosior/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/darosior/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/darosior/bitcoin",
        "archive_url": "https://api.github.com/repos/darosior/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/darosior/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/darosior/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/darosior/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/darosior/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/darosior/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/darosior/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/darosior/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/darosior/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/darosior/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/darosior/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/darosior/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/darosior/bitcoin/events",
        "forks_url": "https://api.github.com/repos/darosior/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/darosior/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/darosior/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/darosior/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/darosior/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/darosior/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/darosior/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/darosior/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/darosior/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/darosior/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/darosior/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/darosior/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/darosior/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/darosior/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/darosior/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/darosior/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:darosior/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/darosior/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/darosior/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/darosior/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/darosior/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/darosior/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/darosior/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/darosior/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/darosior/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/darosior/bitcoin/hooks",
        "svn_url": "https://github.com/darosior/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 243922,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-09T09:42:55Z",
        "created_at": "2019-02-02T19:20:27Z",
        "updated_at": "2023-11-07T12:50:46Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "1f9d30744d32d24ad3128721cf5bd65a3f1543e8",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35619,
        "stargazers_count": 77141,
        "watchers_count": 77141,
        "size": 262669,
        "default_branch": "master",
        "open_issues_count": 684,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-07-09T15:44:12Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-07-09T14:47:25Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
      }
    },
    "author_association": "MEMBER",
    "draft": true,
    "additions": 812,
    "deletions": 9,
    "changed_files": 11,
    "commits": 8,
    "review_comments": 13,
    "comments": 7
  },
  "events": [
    {
      "event": "commented",
      "id": 1872496827,
      "node_id": "IC_kwDOABII585vnAi7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1872496827",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-30T10:05:22Z",
      "updated_at": "2024-07-09T05:28:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/29158).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875751255), [jamesob](https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1812003162) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30364](https://github.com/bitcoin/bitcoin/pull/30364) (logging: Replace LogError and LogWarning with LogAlert by ryanofsky)\n* [#29307](https://github.com/bitcoin/bitcoin/pull/29307) (util: explicitly close all AutoFiles that have been written by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1872496827",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "labeled",
      "id": 11359797222,
      "node_id": "LE_lADOABII5856080BzwAAAAKlGL_m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11359797222",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-30T10:53:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1800561385,
      "node_id": "PRR_kwDOABII585rUmLp",
      "url": null,
      "actor": null,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1800561385",
      "submitted_at": "2024-01-02T15:03:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "commented",
      "id": 1874196101,
      "node_id": "IC_kwDOABII585vtfaF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874196101",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T15:46:43Z",
      "updated_at": "2024-01-02T15:46:43Z",
      "author_association": "MEMBER",
      "body": "Cool, this is a great thing to investigate. I'll be giving the approach a look this week.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1874196101",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1874318288,
      "node_id": "IC_kwDOABII585vt9PQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874318288",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T17:22:14Z",
      "updated_at": "2024-01-02T17:22:14Z",
      "author_association": "MEMBER",
      "body": "Thanks for working on this!\r\n\r\nOne alternative that I have considered before (for chainstate fuzzing) is to abstract and further modularize `BlockManager`, which would allow us to have an `InMemoryBlockManager` for tests (especially useful for fuzzing but also nice in unit tests).\r\n\r\nThis would require a bunch of work:\r\n* Breaking up the friendship between `BlockManager`, `Chainstate` &  `ChainstateManager`\r\n* Abstracting `BlockManager`'s interface away from being file based\r\n* Hiding access to `BlockManager`'s internal fields\r\n* Probably more...\r\n\r\nThis approach would avoid filesystem syscalls entirely, as well as the large block file allocations.\r\n\r\n---\r\n\r\nThe coinbase maturity also seems relevant because you can't spend any coins in the test until you've mined 100 blocks. Mining 100 blocks every fuzz iteration ends up being pretty slow. Maybe we can use assumeutxo to avoid that? (or snapshot fuzzing)",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1874318288",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1875711592,
      "node_id": "IC_kwDOABII585vzRZo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1875711592",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-03T17:21:25Z",
      "updated_at": "2024-01-03T17:21:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Nice one! ",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875711592",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "commented",
      "id": 1875751255,
      "node_id": "IC_kwDOABII585vzbFX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1875751255",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-03T17:54:38Z",
      "updated_at": "2024-01-03T17:54:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1875751255",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "reviewed",
      "id": 1812003162,
      "node_id": "PRR_kwDOABII585sAPla",
      "url": null,
      "actor": null,
      "commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK; midway through review and trying to resolve some of the CI issues.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-1812003162",
      "submitted_at": "2024-01-10T16:20:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "commented",
      "id": 1885310514,
      "node_id": "IC_kwDOABII585wX44y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1885310514",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-10T17:38:48Z",
      "updated_at": "2024-01-10T17:38:48Z",
      "author_association": "MEMBER",
      "body": "Pushed three additional commits to my branch that may make a dent in the CI issues:\r\n- make `fs::path` hashable: https://github.com/jamesob/bitcoin/commit/8f5fdf8ad3d5102e4afaae415e004d4cf6c667cc\r\n- avoid use of `std::filesystem::path` where possible: https://github.com/jamesob/bitcoin/commit/4ef785749ff1c481b5681739653c5b153637e44e\r\n- update linter for mockable filesystem ops: https://github.com/jamesob/bitcoin/commit/face876d55711299c2679aad59b24ee04aa892f0",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-1885310514",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "labeled",
      "id": 12087677368,
      "node_id": "LE_lADOABII5856080BzwAAAALQe1G4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12087677368",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-12T11:29:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY2MDM4MTZjODFiMTY4MGU0MjMyOTBlYjkxM2U5MjZmY2IxYjQ5Yjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6603816c81b1680e423290eb913e926fcb1b49b9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6603816c81b1680e423290eb913e926fcb1b49b9",
      "tree": {
        "sha": "17aa3d29255165149f00b6ea9211e503c2651046",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/17aa3d29255165149f00b6ea9211e503c2651046"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 17aa3d29255165149f00b6ea9211e503c2651046\nparent bd5d1688b4311e21c0e0ff89a3ae02ef7d0543b8\nauthor dergoegge <n.goeggi@gmail.com> 1688725335 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720178686 +0200\n\nAllow mocking CheckProofOfWork\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH1/4ACgkQ4T/BRc0/\nQwQjzAv+IHjngc8NH7MpWgm1Vf+phy4Ho2IYmGzXZBwgRtZQboiBiGdqiJ2+B78j\nTrAgJf9Kv6ZvMhR21nn4SR6MS6S4KiUyuoRA93pGaEsJfUaPfqLjU9M+9lKccUxH\nO8Tktq8AOQ3wVTcB+BlZ6xekWHaX6l8QNSqIjcBCTl4b6QGMlEuLw0sjnMxmaddv\n7spXNlmETc58/URA76PTppv1SAMq2S6mlaJIGei6zFQB6+8fii5NH9CkCw5pdsOu\n9XEP/iYkt9zzCPElOOobQ20P+kNphrQZQbv0hUJLlSS6r6QwmBrP0ofusqZn7mh9\n770/0pybCWEQtiOa2wUxNVUVSPlq4V2uaALR7DBAzg1U+Domf5maHwElNBhmNlhR\n0Ehh7mukvx561MrNSx30yNFtvWoM82VcR3B6NE+DYvX5hb7xR4aMPD77ne9qHEOY\ntytK860eKgXDyIj1Q+yDOlXxoAsBj+lvqE1QLt+Rm7MpLY10QHSNGjDTTZRfV0sr\ncg8H+XQJ\n=i/E5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd5d1688b4311e21c0e0ff89a3ae02ef7d0543b8",
          "sha": "bd5d1688b4311e21c0e0ff89a3ae02ef7d0543b8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bd5d1688b4311e21c0e0ff89a3ae02ef7d0543b8"
        }
      ],
      "message": "Allow mocking CheckProofOfWork",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T11:24:46Z"
      },
      "author": {
        "name": "dergoegge",
        "email": "n.goeggi@gmail.com",
        "date": "2023-07-07T10:22:15Z"
      },
      "sha": "6603816c81b1680e423290eb913e926fcb1b49b9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFiMzc5Yjg0NTRhMDhlMmZjYjA0ZjE4ZmMzN2M5MzFhYmIxMTRmMDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab379b8454a08e2fcb04f18fc37c931abb114f05",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ab379b8454a08e2fcb04f18fc37c931abb114f05",
      "tree": {
        "sha": "2a18e3caa6820bfa0b7c064c653d14004c61d88a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2a18e3caa6820bfa0b7c064c653d14004c61d88a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2a18e3caa6820bfa0b7c064c653d14004c61d88a\nparent 6603816c81b1680e423290eb913e926fcb1b49b9\nauthor Antoine Poinsot <darosior@protonmail.com> 1703353324 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720178687 +0200\n\n[PoC] fs: make some filesystem utilities mockable\n\nThe ones used indirectly by the chainstate-related fuzz targets introduced in later commits.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH1/8ACgkQ4T/BRc0/\nQwRPagwAl3R1bMYoTubWnq25SPRmrnAoMn2NmuJEbdq0D4VGI6g06euRT2/hh75e\nhFtMOgoWIRZE7vYIixKGr0J49NrSBmEezDKaqwchx2AvqD0uPDzrrilhMoBw4n69\nzrq3HJ/DbAXt7TLqIcAYB38RF6aB7ZyddB9kczZNn/4s2nn5lrkLOghgsJMCx29S\neHrlF3Wm3TWLW5ACBlCo2z0VNWIRFTGLvQ/Eisma03XoM3uiBVuncaaC6/1Yiwsf\n+PVrJLvTyh+10fSowqD9W/5W4VMUZ/8Zg7yLTSVJlucBTK1ylvmIjv6iHn//o7Lj\nof1Nxh0HMyfbPWSDfcIEBy3JjIY93zb1vAXoGIQaDpKsY5c3VttIpnVvFxSn80DP\nRfYaYEY5wjLxLG67ZsudZ4aYvzxdac2WZM2yfFUnbocHkwCsyyw/sBoI0OFbpgv5\neRdAvsFxFcFEEnO5qIa/2nGheH+N+fJQ9RfPw/qLEaCJk283Yyi40t00xXyuTtRf\nx1jtMEH3\n=Ict4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6603816c81b1680e423290eb913e926fcb1b49b9",
          "sha": "6603816c81b1680e423290eb913e926fcb1b49b9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6603816c81b1680e423290eb913e926fcb1b49b9"
        }
      ],
      "message": "[PoC] fs: make some filesystem utilities mockable\n\nThe ones used indirectly by the chainstate-related fuzz targets introduced in later commits.",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T11:24:47Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-23T17:42:04Z"
      },
      "sha": "ab379b8454a08e2fcb04f18fc37c931abb114f05"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDIwZWMyZmJlMzcyOTZkYTViYTRiYzZkOTJlMGE1YzYzZWU0MzdhZmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb",
      "tree": {
        "sha": "4b0bb0a665536f69ff3531c8defb20f00f8da30b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b0bb0a665536f69ff3531c8defb20f00f8da30b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4b0bb0a665536f69ff3531c8defb20f00f8da30b\nparent ab379b8454a08e2fcb04f18fc37c931abb114f05\nauthor Antoine Poinsot <darosior@protonmail.com> 1703353762 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720178688 +0200\n\n[PoC] fs: make std re[name,move] mockable\n\nNot in fsbridge because it would be a much larger diff: would have to\noverwrite all fs::rename and fs::remove to fsbridge::re[name,move].\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH2AAACgkQ4T/BRc0/\nQwTMqQwA0SAhrGbJPpGVjRh1N2d2YP2hAIegcilulU4IFi9Ad0b1E4kW1Mext9D9\ndw55rZQgu2jfcbeDNqkSOjHooSoUWqqX7NWyxAZa1jPfDwlK8k6enm9rfqILQD7Q\nE0xx7zvbOmTxh5MO7JcwRQdKnENdwZVqz1TcoZ/a51gIZ5ddiKU/oSygFhRhkKXX\ny0g6JzmwnhrR3y1KRv494VlKf483+fxjBAyNMzkiGuj44vi9ZUv4KRJ2qFmLxCNU\nyrWiIWDdeJss++t+UQTZf9E59Rmaogx78te+S26+Gphmui0IC2ImOPyGBpy3rovX\nD0ZbB9D2ADjHHWitZ5S5qVsOqZBcQk0blGkhhfwfA2J2itf2NiO+/3VXg+XjuXIR\n32ZS7lJ/b9Df/Z3aE6WZygFYazR5GnByB7ePKPsewfwFqCc3g7n9GLPtlfHSzwzF\nBBdiTcRDM3TdVc5ES7O7tp6ExgQ3ex8310peo3UpvuhmOjWCuEOtI/cOBp3PL8DL\nQz82kxfF\n=XlK9\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ab379b8454a08e2fcb04f18fc37c931abb114f05",
          "sha": "ab379b8454a08e2fcb04f18fc37c931abb114f05",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ab379b8454a08e2fcb04f18fc37c931abb114f05"
        }
      ],
      "message": "[PoC] fs: make std re[name,move] mockable\n\nNot in fsbridge because it would be a much larger diff: would have to\noverwrite all fs::rename and fs::remove to fsbridge::re[name,move].",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T11:24:48Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-12-23T17:49:22Z"
      },
      "sha": "20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZiNWFjZGMyNzVjYjFmNzc3OGVhNmZiYWUxOTUyMzMwNWY4ZDBjOTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b5acdc275cb1f7778ea6fbae19523305f8d0c96",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6b5acdc275cb1f7778ea6fbae19523305f8d0c96",
      "tree": {
        "sha": "fcd0b8af190f6b0231882982f5d90b508ae1c663",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fcd0b8af190f6b0231882982f5d90b508ae1c663"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fcd0b8af190f6b0231882982f5d90b508ae1c663\nparent 20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb\nauthor Antoine Poinsot <darosior@protonmail.com> 1699886435 +0100\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720178689 +0200\n\nfuzz: add a target for the BlockManager\n\nExercise (most of) the public interface of the BlockManager and assert\nsome invariants. Notably, try to mimick block arrival whether its header\nwas announced first or not.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH2AEACgkQ4T/BRc0/\nQwQzegv+IO/UriOur4936iHRmvwXwMctiehIRZv3qgMugYEsnTxjrdLDj1+sEBCz\ndpvi/rRBEuD6CovFcfRqPbj02InxPECMGkVIl+ONRDTBtouvVsM0fYb3XbMgUNwH\nbxBwoDu8J5INjyxbIn09yEAwj4rGrqECxOtIOv3MEmw0V4pnnGkLOgM9exF8VEPu\nVRzpSDExsp06U6Ik+Cxm2fpJ7lYlgb6EBM9XUdMXuAaVcGR6o3atTYCdC/ZF+FGC\nN0rw2HzVic/Kya9CsbhrcOyAF/7Bz2fjuKMeR5cuZC4JHzXzr06NJbKUPoKsIkwC\n7XATv2rJW9fDo0W6UcyaMbnZ4neoCxzsc3rEJ8SJl3//6LyapfLo+T+7RU7kcJWz\nigRgmo6rxJJleSOoRqezbsltLsG6EH63K71V2Z5SfsjVwchXHETaR7HLNn40F1OF\ntI3xFp0ImjBcBKOKHIgA5YuP9Rjf/jZK+PPylaUV7vGqCSxIo2DzYneC8zlLgh1X\nWGE/7N/9\n=MJJw\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb",
          "sha": "20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/20ec2fbe37296da5ba4bc6d92e0a5c63ee437afb"
        }
      ],
      "message": "fuzz: add a target for the BlockManager\n\nExercise (most of) the public interface of the BlockManager and assert\nsome invariants. Notably, try to mimick block arrival whether its header\nwas announced first or not.",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T11:24:49Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-11-13T14:40:35Z"
      },
      "sha": "6b5acdc275cb1f7778ea6fbae19523305f8d0c96"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1OTNhNzg2ZTI5NDVmMjFjNjI4MDE5OWI2ZjEzMzEyNzlmNjg1NmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e593a786e2945f21c6280199b6f1331279f6856a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e593a786e2945f21c6280199b6f1331279f6856a",
      "tree": {
        "sha": "7e5e4c309aa55f3e06934133670a68946bbd8535",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e5e4c309aa55f3e06934133670a68946bbd8535"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7e5e4c309aa55f3e06934133670a68946bbd8535\nparent 6b5acdc275cb1f7778ea6fbae19523305f8d0c96\nauthor Antoine Poinsot <darosior@protonmail.com> 1694866386 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720180893 +0200\n\nfuzz: add a target for the ChainstateManager\n\nExercise header and block processing, asserting some invariants. Also\nthe reorg logic.\n\nThere is some low hanging fruits to optimize this targets. Namely\ncalling CheckBlockIndex() externally in a CallOneOf callback instead\nof internally after every operation, and making it possible to not use a\nthread for the notification interface (done by opened PR 28960).\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH4J0ACgkQ4T/BRc0/\nQwQBvgv/YMUfwfwt280VJvi8r5VEyfaO7eDnXVXHSa28VIxio+c8x6lyPyKWg2fz\ni6a/gf63n5ABJL7w2WBCKZg1fmWQSbT048m5OTPzMU9MZAY3oA+0DptznwTx1/9Z\nWU7852EAM4wMuNu+dDwlNr320W8nw2sx1pA6b5pZwtEWbMxnRRmrscnK3eTUt9Qk\nUHNt8y1CD30LyNJcDd/PCdXnVjmddLMNcm7tTlowX7TE52iYEKO5UzKUdmUdKRYW\nHKTzGx6CmUcSFPFbJ8WAOAGxARX0ruaL1gz4w7Lb0kAGGgUO95p5qKuVMDrZjToh\nSuZdhLmaTz5yRBSLPhkm8E1vgPxhWWPuWaSal//P7GOymxLWH7IpB7uh06xRo3l/\nc037VdklSLkDnm0pj6rX9efWeSTKokfqT7ZZzFn1gwGKzJGvGC0WHeThHsfxvGlZ\ntRwAHI775E5VTGmiSm2Rae8MYM4nxmsLtbOQAiz1jLl5Vl7zaGByvoM0R97NSyV+\nnfT6VR9I\n=3hbW\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b5acdc275cb1f7778ea6fbae19523305f8d0c96",
          "sha": "6b5acdc275cb1f7778ea6fbae19523305f8d0c96",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6b5acdc275cb1f7778ea6fbae19523305f8d0c96"
        }
      ],
      "message": "fuzz: add a target for the ChainstateManager\n\nExercise header and block processing, asserting some invariants. Also\nthe reorg logic.\n\nThere is some low hanging fruits to optimize this targets. Namely\ncalling CheckBlockIndex() externally in a CallOneOf callback instead\nof internally after every operation, and making it possible to not use a\nthread for the notification interface (done by opened PR 28960).",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T12:01:33Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2023-09-16T12:13:06Z"
      },
      "sha": "e593a786e2945f21c6280199b6f1331279f6856a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg3NTRiMjZmNGZjY2E5ZWJmZDE3ZGQ5NGUxODYyMmM2ZDVmODYyZTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8754b26f4fcca9ebfd17dd94e18622c6d5f862e9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8754b26f4fcca9ebfd17dd94e18622c6d5f862e9",
      "tree": {
        "sha": "889318bdd87548d2ffd532e8ac2f5aae07211306",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/889318bdd87548d2ffd532e8ac2f5aae07211306"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 889318bdd87548d2ffd532e8ac2f5aae07211306\nparent e593a786e2945f21c6280199b6f1331279f6856a\nauthor Antoine Poinsot <darosior@protonmail.com> 1720180867 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720180921 +0200\n\nfuzz: chainstate: use a dummy queue for validation signals\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH4LoACgkQ4T/BRc0/\nQwTGVAwAhH/75wTRUl6VqCMIyzSQDafmkoFOI+HjUN3qyn1czPt0fMdAyrPjC9Sc\nlX7tgDdhFWPyTRWRN0UJP9W2KMrRM69zc4d6xqQYQ6zFLR73FVh9JfNym+QssrGh\nNq+v2qW/QCiHAMt+YyyEAJPehRqHEetjdnGIaKg7yikW1YpXcpcmNIFnKtea3Xxv\nCmTVdVqSTKMFiPuVLi7wJGBoMx0z+IJBYqk9/Ywfl8PImUPSvtbUqLFkukRZ3DPy\nzWkJRoF1GX3lKHV8J1pXODAWpjnXETTdJzvT8HeHIpr7QPJ7SfFb8ZTeUF58brU1\ng5WnldgRKx1/aMx3mhomXzs/GVmSM5wXZJa56ADYn9RXiYwv25pCBEr/MyrhNXcu\nD6YzPK1vUyfLIBF2dbGtlnQKVe1/IKtdjCsbrpkj4/uadXUpdwaXWz5TB6V8mbaW\nv4FM08XuwtDTo8khPna6gSu9SPQ2EtS0Ei8Huw+pyY4HxzM/HPywWmbX1J3gruzb\n+1uMBYAG\n=bLlP\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e593a786e2945f21c6280199b6f1331279f6856a",
          "sha": "e593a786e2945f21c6280199b6f1331279f6856a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e593a786e2945f21c6280199b6f1331279f6856a"
        }
      ],
      "message": "fuzz: chainstate: use a dummy queue for validation signals",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T12:02:01Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T12:01:07Z"
      },
      "sha": "8754b26f4fcca9ebfd17dd94e18622c6d5f862e9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU4OGJiMWQzNWY0Y2YwM2NiNDdmZWFmZDFlZDY1NDk2MTdkOTQzN2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/588bb1d35f4cf03cb47feafd1ed6549617d9437c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/588bb1d35f4cf03cb47feafd1ed6549617d9437c",
      "tree": {
        "sha": "0f5f6c1494e1431ee99538c77104239c37282ae2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f5f6c1494e1431ee99538c77104239c37282ae2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0f5f6c1494e1431ee99538c77104239c37282ae2\nparent 8754b26f4fcca9ebfd17dd94e18622c6d5f862e9\nauthor Antoine Poinsot <darosior@protonmail.com> 1719737711 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720181997 +0200\n\nfuzz: chainstate: use memfd_create in place of open_memstream\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaH5R0ACgkQ4T/BRc0/\nQwT2AQv/Vx0arWhEUrIzoPIA56frnZFkJ161JEKv3E4fyO3JiElI8wuV1Y5bM6v0\nCbO1Yo1eiuysmIzWQx0yEXsm+okS4TSgP2TSW0+kdSJQHvzU6Sh/8WL3XjspWNfm\nndIw0fmUhPQJu9ng3y4skh9lacDl0VQB7Odzcvq/6vigp9p/aLpYqWhdOctdebSt\nk0IAYqqOTWiOJE062nWj4IfUGaPp8kWTxm9N9ZXuOHZNMlbjg+A66CSOECcFYt6T\nGrkK0d/pEmLe63YnCd+IrSMxZNQMR45Trv2awz61QFl9Ww2289FHFYJzAHqTvLHI\nu4T+fcrgJlX4EzA4SD4U9N2PDTBXjJs3yIwXluGntzVOSYyJj5wnwT7JHV/qOMoD\naoSM/Pj9epU6GWtD1eIqh8Gsk8q+64+Ej/VIjZlwF2jLJpeldYC6YBO3avVh224K\nwBLGZ0F0aXjschtDmNSRZPmCPErdBVTKcm4tKFb7KLqYezJggJczV07nOr6arHd/\nGch3S2Bi\n=+SzB\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8754b26f4fcca9ebfd17dd94e18622c6d5f862e9",
          "sha": "8754b26f4fcca9ebfd17dd94e18622c6d5f862e9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8754b26f4fcca9ebfd17dd94e18622c6d5f862e9"
        }
      ],
      "message": "fuzz: chainstate: use memfd_create in place of open_memstream",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-05T12:19:57Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-06-30T08:55:11Z"
      },
      "sha": "588bb1d35f4cf03cb47feafd1ed6549617d9437c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13427065227,
      "node_id": "HRFPE_lADOABII5856080BzwAAAAMgUMGL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13427065227",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:00:53Z"
    },
    {
      "event": "unlabeled",
      "id": 13427073991,
      "node_id": "UNLE_lADOABII5856080BzwAAAAMgUOPH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13427073991",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:01:31Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2214720674,
      "node_id": "IC_kwDOABII586EAfSi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2214720674",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T17:04:07Z",
      "updated_at": "2024-07-08T17:04:07Z",
      "author_association": "MEMBER",
      "body": "Rebased this, taking advantage of https://github.com/bitcoin/bitcoin/pull/28960. I've also been investigating alternative approaches.\r\n\r\nI first tried to move from `fmemopen` toward the more flexible `memfd_create`. It avoided the need for some of the filesystem mocks (which were necessary before because you can't call `fileno` on a `FILE*` created with `fmemopen`). This allowed to drop one commit. Further, this removed the need from creating 128MiB in-memory blk files. This is in turn makes it potentially more reasonable to sometimes reindex in `CallOneOf`.\r\n\r\nWith that implemented i tried to \"cache\" an initial chainstate to re-use on each fuzzing round, to avoid having to connect the 110 blocks initial chain on every single iteration. Unsuccessfully.\r\n\r\nFinally, i wanted to compare the performances of mocking the filesystem to simply using a ramdisk. I realized if i were to use a ramdisk i could simply use the filesystem directly to \"cache\" an initial chainstate: create two datadirs, one for the initial chainstate, one for the fuzzing iteration. At initialization of the target create a fresh chainstate and connect the 110 blocks. Upon each iteration wipe the working datadir and copy over the initial datadir.\r\n\r\nSo i implemented that, which besides being more efficient also has the advantage of removing the modifications of non-test code and the platform-dependent syscalls. The target is still pretty slow, but at this point it's just because of the code it calls: we are doing a bunch of block/header connections and reorg upon every iteration, and each of those can take around a hundred milliseconds.\r\n\r\nI've pushed a WIP commit which implements what i described above for the `chainstate` target. Do people think this effort is worth pursuing in this form? If so i'll clean up this PR to remove the filesystem mocking commits and also use a ramdisk for the `blockstorage` target.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#issuecomment-2214720674",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29158"
    },
    {
      "event": "reviewed",
      "id": 2165630430,
      "node_id": "PRR_kwDOABII586BFOXe",
      "url": null,
      "actor": null,
      "commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-2165630430",
      "submitted_at": "2024-07-09T09:16:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA0MGFmMGVhNDVlMDVhZDQ1YzM3MjA5MGRjNTBiNGVlZGE5MzczN2Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/040af0ea45e05ad45c372090dc50b4eeda93737f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/040af0ea45e05ad45c372090dc50b4eeda93737f",
      "tree": {
        "sha": "a2f911c1a9cf7b845480db80d0d36ba2c80427ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2f911c1a9cf7b845480db80d0d36ba2c80427ba"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a2f911c1a9cf7b845480db80d0d36ba2c80427ba\nparent 588bb1d35f4cf03cb47feafd1ed6549617d9437c\nauthor Antoine Poinsot <darosior@protonmail.com> 1720454853 +0200\ncommitter Antoine Poinsot <darosior@protonmail.com> 1720517601 +0200\n\nWIP: just use a ramdisk, actually\n\nIt lets us cache the initial chainstate by creating it first at init and copying it over on every iteration.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEWQtykmla/6W2csuy4T/BRc0/QwQFAmaNA+EACgkQ4T/BRc0/\nQwR1CQwAouk7gX515sjuNsHrT4kyO7M0OWBDYVQxQaPg28XmfHrxkgC0tfaHUVtu\n+IZXDtGtCPXaJ2vsybnWtjhbxL+i3TZwGGj0ZQpnkEfIO+cnR4TZ5fpbgFWYCj9N\nvz1hN1dMJ0jzokfcu8c1yVGNLFwvB0419I3PpEJu/zMaO9MTc1Emp24V/vAvepRE\nUk66ImHn1VHJolfRh1kOFHJR7bznAnU8H/4IoaSyEGZqE+XKpCQrRQYk+KDfhYFv\nLQB0EptWNDt1oGFGa/5V1UOlu821ItKVyKotXsdmaL34U0xk1SwitE0CJApZRMiY\nLXa/oYKQQ4Gyp4asr0D/wSInbypsBu4ZTSO7BaIh0EyouSr8GfJJ8OuJgvsQGh76\nH2h/ueVfjMUIW075DuKoQIervaShsJCV+yOsXycTBqo2ws9h0iuZ/k9yIxUEd7ga\nClttOhK3lrKUpzDG7aau3Nifp9lgS0t/RaxdQFT9KpYutqkclP/lZBTnsdgP9rAD\n2ChyzmgV\n=+Lnn\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/588bb1d35f4cf03cb47feafd1ed6549617d9437c",
          "sha": "588bb1d35f4cf03cb47feafd1ed6549617d9437c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/588bb1d35f4cf03cb47feafd1ed6549617d9437c"
        }
      ],
      "message": "WIP: just use a ramdisk, actually\n\nIt lets us cache the initial chainstate by creating it first at init and copying it over on every iteration.",
      "committer": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-09T09:33:21Z"
      },
      "author": {
        "name": "Antoine Poinsot",
        "email": "darosior@protonmail.com",
        "date": "2024-07-08T16:07:33Z"
      },
      "sha": "040af0ea45e05ad45c372090dc50b4eeda93737f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13436986421,
      "node_id": "HRFPE_lADOABII5856080BzwAAAAMg6CQ1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13436986421",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-09T09:42:56Z"
    },
    {
      "event": "reviewed",
      "id": 2165669817,
      "node_id": "PRR_kwDOABII586BFX-5",
      "url": null,
      "actor": null,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#pullrequestreview-2165669817",
      "submitted_at": "2024-07-09T12:56:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439533284",
      "pull_request_review_id": 1800561385,
      "id": 1439533284,
      "node_id": "PRRC_kwDOABII585VzYjk",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you checked if using `fmemopen` is better/faster than using a ram disk?",
      "created_at": "2024-01-02T15:03:27Z",
      "updated_at": "2024-01-02T15:03:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1439533284",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439533284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439796296",
      "pull_request_review_id": 1800974871,
      "id": 1439796296,
      "node_id": "PRRC_kwDOABII585V0YxI",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I haven't. Can we use a ramdisk at oss-fuzz?",
      "created_at": "2024-01-02T20:33:30Z",
      "updated_at": "2024-01-02T20:33:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1439796296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439796296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440301216",
      "pull_request_review_id": 1801749930,
      "id": 1440301216,
      "node_id": "PRRC_kwDOABII585V2UCg",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Afaict oss-fuzz already uses a ram disk for its environments: https://github.com/google/clusterfuzz/blob/c461a961d8fb2afe47fb4af5eee3d1434a324a40/docker/base/setup_clusterfuzz.sh#L38 (i.e. `/tmp` is mounted in ram).",
      "created_at": "2024-01-03T10:35:58Z",
      "updated_at": "2024-01-03T10:35:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1440301216",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1440301216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1441013417",
      "pull_request_review_id": 1803140054,
      "id": 1441013417,
      "node_id": "PRRC_kwDOABII585V5B6p",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://joshua.hu/fuzzing-with-memfd-createfd-fmemopen-syscall-function\n\nThe author of this post found that a ram disk is slowerðŸš€\n\nI/O syscalls are avoided with fmempopen and everything simply happens in userland.",
      "created_at": "2024-01-03T22:12:06Z",
      "updated_at": "2024-01-03T22:12:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1441013417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1441013417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1442215861",
      "pull_request_review_id": 1804915877,
      "id": 1442215861,
      "node_id": "PRRC_kwDOABII585V9ne1",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": 1439533284,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting. I was aware of `open_memstream` but not `memfd_create`. It's slower but could actually be helpful to get rid of the `128 MiB` allocs and make it possible to reindex.",
      "created_at": "2024-01-04T20:21:16Z",
      "updated_at": "2024-01-04T20:21:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1442215861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1442215861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446610769",
      "pull_request_review_id": 1812003162,
      "id": 1446610769,
      "node_id": "PRRC_kwDOABII585WOYdR",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    CScheduler scheduler;\n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+    scheduler.m_service_thread = std::thread(util::TraceThread, \"scheduler\", [&] { scheduler.serviceQueue(); });\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = datadir / \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = \"\",\n+        .adjusted_time_callback = NodeClock::now,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_notifications,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .block_tree_db_in_memory = true,\n+        .coins_db_in_memory = true,\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Activate the initial chain.\n+    BlockValidationState dummy_valstate;\n+    for (Chainstate* chainstate : chainman.GetAll()) {\n+        assert(chainstate->ActivateBestChain(dummy_valstate, nullptr));\n+    }\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};\n+                const int headers_count{is_random ? fuzzed_data_provider.ConsumeIntegralInRange(1, MAX_HEADERS_RESULTS) : 1};\n+                headers.reserve(headers_count);\n+\n+                if (is_random) {\n+                    for (int i = 0; i < headers_count; ++i) {\n+                        headers.push_back(CreateBlockHeader(fuzzed_data_provider, RandomPrevBlock(fuzzed_data_provider), /*set_merkle=*/true).first);\n+                    }\n+                } else {\n+                    // In 10% of the cases branch off a random header.\n+                    const bool extend_tip{fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 9) > 0};\n+                    // The unspent coins to be used to create transactions beside the coinbase in the block to be created.\n+                    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> empty_utxos;\n+                    auto& coins{extend_tip ? utxos : empty_utxos};\n+                    CBlockIndex* prev_block{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                        // Sometimes extend the best validated chain, sometimes the best header chain.\n+                        if (extend_tip) {\n+                            return fuzzed_data_provider.ConsumeBool() ? chainman.ActiveTip() : chainman.m_best_header;\n+                        }\n+                        return &PickValue(fuzzed_data_provider, chainman.m_blockman.m_block_index).second;\n+                    }()};\n+                    blocks_in_flight.push_back(CreateValidBlock(fuzzed_data_provider, chainparams.GetConsensus(), prev_block, coins));",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 597,
      "original_position": 551,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "When generating a valid block (here and below) do we want to do some kind of assertion that the block was actually considered valid? I could see the test code silently generating only invalid blocks and (afaik) there wouldn't be an indication of it here.",
      "created_at": "2024-01-09T21:04:10Z",
      "updated_at": "2024-01-10T16:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1446610769",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446610769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 597,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446611692",
      "pull_request_review_id": 1812003162,
      "id": 1446611692,
      "node_id": "PRRC_kwDOABII585WOYrs",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_files.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_files.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_files.extract(old_p).key() = new_p;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_file_commit = [&](FILE* f) {\n+        return fflush(f) == 0;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_dir_commit = [&](std::filesystem::path) {};\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_truncate_file = [&](FILE*, unsigned int) {\n+        return true;\n+    };\n+    // Needs to be mocked because it may call `fileno(3)`, which returns an error for `fmemopen(3)`ed streams.\n+    g_mock_allocate_file_range = [&](FILE*, unsigned int, unsigned int) {\n+        return true;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_notifications,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0, nullptr)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height, nullptr)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // Get 10 spendable UTxOs.\n+    g_initial_blockchain = CreateBlockChain(110, Params());\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    const fs::path datadir{\"\"};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 513,
      "original_position": 460,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This type comes up often enough in this file that it might be worth an alias.",
      "created_at": "2024-01-09T21:05:16Z",
      "updated_at": "2024-01-10T16:44:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1446611692",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1446611692"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 513,
      "original_line": 513,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447615580",
      "pull_request_review_id": 1812003162,
      "id": 1447615580,
      "node_id": "PRRC_kwDOABII585WSNxc",
      "diff_hunk": "@@ -0,0 +1,651 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/merkle.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    void warning(const bilingual_str& warning) override {}\n+    void flushError(const std::string& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const std::string& debug_message, const bilingual_str& user_message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+auto g_notifications{KernelNotifications()};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+// We use a mapping from file path to buffer as a boutique in-memory file system. Note it's\n+// fine because we only ever use unique pathnames for block files, but it may cause issues if\n+// this assumption doesn't hold anymore. (\"/a/b/blk0000.dat\" and \"/a/b/c/../blk0000.dat\" point\n+// to two different buffers.)\n+// The use of a global does not prevent determinism (since the buffer from one run simply gets\n+// overwritten in the next) but avoids a 128MB allocation per run. FIXME: is that really true?\n+std::unordered_map<fs::path, std::vector<unsigned char>, std::hash<std::filesystem::path>> g_files;\n+\n+//! The initial block chain used to test the chainstate.\n+std::vector<std::shared_ptr<CBlock>> g_initial_blockchain;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it unless it's a file we aren't interested in.\n+        const auto [data, size]{[&]{\n+            const auto it = g_files.find(file_path);\n+            if (it != g_files.end()) return std::make_pair(it->second.data(), it->second.size());\n+            const auto file_name{PathToString(file_path.filename())};\n+            // We shouldn't need to store anything else than the blk and rev files.\n+            if (file_name.find(\"blk\") == std::string::npos && file_name.find(\"rev\") == std::string::npos) {\n+                std::make_pair(nullptr, 0);\n+            }\n+            // NOTE: we do a single large alloc of the max possible file size, as there is no sane way to\n+            // create shorter files but re-allocate when needed.\n+            std::vector<unsigned char> buf(node::MAX_BLOCKFILE_SIZE);\n+            const auto [it2, _]{g_files.insert({file_path, std::move(buf)})};\n+            return std::make_pair(it2->second.data(), it2->second.size());\n+        }()};\n+        if (!data) return (FILE*)nullptr;\n+        return fmemopen(data, size, mode);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "ea36af80beeeee0b9de793e52887ba3e164b803c",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/29158/commits/ea36af80beeeee0b9de793e52887ba3e164b803c\r\n\r\n`fmemopen` is Linux-specific; here's a fixup commit that `ifdef`s it out and fixes some of the CI errors if you want it: https://github.com/jamesob/bitcoin/commit/26b9c9d48e3ec16e69d550266c7f27f4db9cb9f8",
      "created_at": "2024-01-10T16:19:27Z",
      "updated_at": "2024-01-10T16:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1447615580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1447615580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670101598",
      "pull_request_review_id": 2165630430,
      "id": 1670101598,
      "node_id": "PRRC_kwDOABII585ji7pe",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`fs::temp_directory_path()` points to the top level tmp dir and won't be unique every time. You'll want to do something similar to what the testing setups are doing: https://github.com/bitcoin/bitcoin/blob/1f9d30744d32d24ad3128721cf5bd65a3f1543e8/src/test/util/setup_common.cpp#L150-L152",
      "created_at": "2024-07-09T09:16:22Z",
      "updated_at": "2024-07-09T09:16:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670101598",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670101598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670126790",
      "pull_request_review_id": 2165669817,
      "id": 1670126790,
      "node_id": "PRRC_kwDOABII585jjBzG",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);\n+    }\n+} g_test_data;\n+\n+// Mapping from file path to in-memory file (descriptor). It's fine to use a path as key as we only\n+// ever use unique pathnames for block files.\n+std::unordered_map<fs::path, int, std::hash<std::filesystem::path>> g_fds;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it first.\n+        const auto fd{[&]{\n+            const auto it = g_fds.find(file_path);\n+            if (it != g_fds.end()) return it->second;\n+            const auto [it2, _]{g_fds.insert({file_path, memfd_create(file_path.c_str(), 0)})};\n+            return it2->second;\n+        }()};\n+        //std::cout << \"Opening \" << file_path << \" fd \" << fd << \" mode \" << mode << std::endl;\n+        return Assert(fdopen(dup(fd), mode));\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_fds.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_fds.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_fds.extract(old_p).key() = new_p;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    // FIXME: only used to setup logging. Set it up without instantiating a whole, unused, BasicTestingSetup.\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN/*, {\"-printtoconsole\", \"-debug\"}*/);\n+    g_setup = testing_setup.get();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // This creates the datadirs in the tmp dir.\n+    g_test_data.Init();\n+\n+    // Create the chainstate for the initial datadir. On every round we'll restart from this chainstate instead of\n+    // re-creating one from scratch.\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = Params(),\n+        .blocks_dir = g_test_data.init_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = Params(),\n+        .datadir = g_test_data.init_datadir,\n+        .check_block_index = false,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 1;\n+    cache_sizes.coins_db = 2;\n+    cache_sizes.coins = 3;\n+    node::ChainstateLoadOptions load_opts {\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Connect the initial chain to get 10 spendable UTxOs at the start of every fuzzing round.\n+    const auto g_initial_blockchain{CreateBlockChain(110, Params())};\n+    BlockValidationState valstate;\n+    auto& chainstate{chainman.ActiveChainstate()};\n+    assert(chainstate.ActivateBestChain(valstate, nullptr));\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    LOCK(cs_main);\n+    if (chainstate.CanFlushToDisk()) {\n+        chainstate.ForceFlushStateToDisk();\n+    }\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    //const auto first_time{SteadyClock::now()};\n+\n+    // On every round start from a freshly copied initial datadir.\n+    fs::remove_all(g_test_data.working_datadir);\n+    fs::copy(g_test_data.init_datadir, g_test_data.working_datadir, fs::copy_options::overwrite_existing | fs::copy_options::recursive);\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = g_test_data.working_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = g_test_data.working_datadir,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, and call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    //const auto time_before_loop{SteadyClock::now()};\n+\n+    BlockValidationState dummy_valstate;\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 576,
      "original_position": 570,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Trying to choose probabilities like this won't really work with modern fuzzing engines (because the inputs given to the harness are not uniformly random) and is probably equivalent to the following:\r\n\r\n```suggestion\r\n                const bool is_random{fuzzed_data_provider.ConsumeBool()};\r\n```",
      "created_at": "2024-07-09T09:30:16Z",
      "updated_at": "2024-07-09T12:56:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670126790",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670126790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 576,
      "original_line": 576,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670149765",
      "pull_request_review_id": 2165707627,
      "id": 1670149765,
      "node_id": "PRRC_kwDOABII585jjHaF",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": 1670101598,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-09T09:44:00Z",
      "updated_at": "2024-07-09T09:44:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670149765",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670149765"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670484095",
      "pull_request_review_id": 2165669817,
      "id": 1670484095,
      "node_id": "PRRC_kwDOABII585jkZB_",
      "diff_hunk": "@@ -0,0 +1,699 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <random.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+//! To generate a random tmp datadir per process (necessary to fuzz with multiple cores).\n+static FastRandomContext g_insecure_rand_ctx_temp_path;\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        const auto rand_str{g_insecure_rand_ctx_temp_path.rand256().ToString()};\n+        const auto tmp_dir{fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME / rand_str};\n+        init_datadir = tmp_dir / \"init\";\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = tmp_dir / \"working\";\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 88,
      "original_position": 88,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This should nuke the whole parent tmp dir that was created for the fuzz test, not just `init_datadir`. I'm seeing tons of left over directories otherwise.",
      "created_at": "2024-07-09T12:56:36Z",
      "updated_at": "2024-07-09T12:56:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670484095",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670484095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670749288",
      "pull_request_review_id": 2166688465,
      "id": 1670749288,
      "node_id": "PRRC_kwDOABII585jlZxo",
      "diff_hunk": "@@ -0,0 +1,693 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <config/bitcoin-config.h>\n+#include <consensus/merkle.h>\n+#include <kernel/notifications_interface.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <node/miner.h>\n+#include <pow.h>\n+#include <scheduler.h>\n+#include <undo.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/mining.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <txdb.h>\n+#include <util/fs_helpers.h>\n+#include <util/thread.h>\n+\n+#include <sys/mman.h>\n+\n+\n+namespace {\n+\n+const BasicTestingSetup* g_setup;\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+public:\n+    kernel::InterruptResult blockTip(SynchronizationState, CBlockIndex&) override { return {}; }\n+    void headerTip(SynchronizationState, int64_t height, int64_t timestamp, bool presync) override {}\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override {}\n+    virtual void warningSet(kernel::Warning id, const bilingual_str& message) override {}\n+    virtual void warningUnset(kernel::Warning id) override {}\n+    void flushError(const bilingual_str& debug_message) override\n+    {\n+        assert(false);\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        assert(false);\n+    }\n+};\n+\n+class DummyQueue : public util::TaskRunnerInterface\n+{\n+public:\n+    DummyQueue() {}\n+\n+    void insert(std::function<void()> func) override {}\n+\n+    void flush() override {}\n+\n+    size_t size() override { return 0; }\n+};\n+\n+//! See net_processing.\n+static const int MAX_HEADERS_RESULTS{2000};\n+\n+struct TestData {\n+    fs::path init_datadir;\n+    fs::path working_datadir;\n+    ValidationSignals main_signals{std::make_unique<DummyQueue>()};\n+    KernelNotifications notifs;\n+\n+    void Init() {\n+        init_datadir = fs::temp_directory_path() / \"fuzz_chainstate_init_\" PACKAGE_NAME;\n+        fs::remove_all(init_datadir);\n+        fs::create_directories(init_datadir / \"blocks\");\n+        working_datadir = fs::temp_directory_path() / \"fuzz_chainstate_\" PACKAGE_NAME;\n+    }\n+\n+    ~TestData() {\n+        fs::remove_all(init_datadir);\n+    }\n+} g_test_data;\n+\n+// Mapping from file path to in-memory file (descriptor). It's fine to use a path as key as we only\n+// ever use unique pathnames for block files.\n+std::unordered_map<fs::path, int, std::hash<std::filesystem::path>> g_fds;\n+\n+void mock_filesystem_calls()\n+{\n+    fs::g_mock_create_dirs = [](const fs::path&) { return true; };\n+    g_mock_check_disk_space = [](const fs::path&, uint64_t) { return true; };\n+    fsbridge::g_mock_fopen = [&](const fs::path& file_path, const char* mode) {\n+        // Get the file from the map. If it's not there insert it first.\n+        const auto fd{[&]{\n+            const auto it = g_fds.find(file_path);\n+            if (it != g_fds.end()) return it->second;\n+            const auto [it2, _]{g_fds.insert({file_path, memfd_create(file_path.c_str(), 0)})};\n+            return it2->second;\n+        }()};\n+        //std::cout << \"Opening \" << file_path << \" fd \" << fd << \" mode \" << mode << std::endl;\n+        return Assert(fdopen(dup(fd), mode));\n+    };\n+    fs::g_mock_remove = [&](const fs::path& file_path) {\n+        g_fds.erase(file_path);\n+        return true;\n+    };\n+    fs::g_mock_exists = [&](const fs::path& file_path) {\n+        return g_fds.count(file_path) > 0;\n+    };\n+    fs::g_mock_rename = [&](const std::filesystem::path& old_p, const std::filesystem::path& new_p) {\n+        g_fds.extract(old_p).key() = new_p;\n+    };\n+}\n+\n+/** Consume a random block hash and height to be used as previous block. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov)\n+{\n+    auto hash{ConsumeDeserializable<uint256>(prov).value_or(uint256{})};\n+    // FIXME: it takes an int but it needs to be positive because there is a conversion to uint inside blockstorage.cpp:\n+    // node/blockstorage.cpp:968:45: runtime error: implicit conversion from type 'int' of value -2147483648 (32-bit, signed) to type 'unsigned int'\n+    const auto height{prov.ConsumeIntegralInRange<int>(0, std::numeric_limits<int>::max() - 1)};\n+    return {std::move(hash), height};\n+}\n+\n+/** In 90% of the cases, get any random block from the index. Otherwise generate a random one. */\n+std::pair<uint256, int> RandomPrevBlock(FuzzedDataProvider& prov, node::BlockManager& blockman) NO_THREAD_SAFETY_ANALYSIS\n+{\n+    if (prov.ConsumeIntegralInRange<int>(0, 9) > 0) {\n+        const auto prev_block{&PickValue(prov, blockman.m_block_index).second};\n+        return {prev_block->GetBlockHash(), prev_block->nHeight};\n+    }\n+    return RandomPrevBlock(prov);\n+}\n+\n+/** Create a random block. */\n+std::pair<CBlockHeader, int> CreateBlockHeader(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block, bool set_merkle = false)\n+{\n+    CBlockHeader header;\n+    header.nVersion = prov.ConsumeIntegral<int32_t>();\n+    header.nTime = prov.ConsumeIntegral<uint32_t>();\n+    header.nBits = prov.ConsumeIntegral<uint32_t>();\n+    header.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    if (set_merkle) {\n+        if (auto h = ConsumeDeserializable<uint256>(prov)) {\n+            header.hashMerkleRoot = *h;\n+        }\n+    }\n+    header.hashPrevBlock = std::move(prev_block.first);\n+    return std::make_pair(std::move(header), prev_block.second);\n+}\n+\n+/** Create a coinbase transaction paying to an anyonecanspend for the given height. */\n+CTransactionRef CreateCoinbase(int height)\n+{\n+    CMutableTransaction tx;\n+    tx.vin.resize(1);\n+    tx.vin[0].prevout.SetNull();\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = P2WSH_OP_TRUE;\n+    tx.vout[0].nValue = 50 * COIN; // We assume we don't mine so many blocks at once..\n+    tx.vin[0].scriptSig = CScript() << (height + 1) << OP_0;\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a transaction spending a random amount of utxos from the provided set. Must not be empty. */\n+CTransactionRef CreateTransaction(FuzzedDataProvider& prov, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    assert(!utxos.empty());\n+    CMutableTransaction tx;\n+\n+    const auto input_count{prov.ConsumeIntegralInRange(1, std::min((int)utxos.size(), 1'000))};\n+    tx.vin.resize(input_count);\n+    CAmount in_value{0};\n+    auto it{utxos.begin()};\n+    for (int i{0}; i < input_count; ++i) {\n+        auto [outpoint, coin] = *it++;\n+        in_value += coin.nValue;\n+        tx.vin[i].prevout = outpoint;\n+        tx.vin[i].scriptWitness.stack = std::vector<std::vector<uint8_t>>{WITNESS_STACK_ELEM_OP_TRUE};\n+        utxos.erase(outpoint);\n+    }\n+\n+    const auto out_count{prov.ConsumeIntegralInRange(1, 1'000)};\n+    tx.vout.resize(out_count);\n+    for (int i{0}; i < out_count; ++i) {\n+        tx.vout[i].scriptPubKey = P2WSH_OP_TRUE;\n+        tx.vout[i].nValue = in_value / out_count;\n+    }\n+\n+    // Add the coins created in this transaction to the set, for them to be spent by the next\n+    // ones or in future blocks.\n+    const auto txid{tx.GetHash()};\n+    for (int i{0}; i < out_count; ++i) {\n+        COutPoint outpoint{txid, static_cast<unsigned>(i)};\n+        CTxOut txo{in_value / out_count, P2WSH_OP_TRUE};\n+        utxos.emplace(std::move(outpoint), std::move(txo));\n+    }\n+\n+    return MakeTransactionRef(std::move(tx));\n+}\n+\n+/** Create a random block and include random (and most likely invalid) transactions. */\n+std::pair<CBlock, int> CreateBlock(FuzzedDataProvider& prov, std::pair<uint256, int> prev_block)\n+{\n+    CBlock block;\n+    auto [block_header, height]{CreateBlockHeader(prov, std::move(prev_block))};\n+    *(static_cast<CBlockHeader*>(&block)) = std::move(block_header);\n+\n+    block.vtx.push_back(CreateCoinbase(height));\n+    while (prov.ConsumeBool()) {\n+        if (auto tx = ConsumeDeserializable<CMutableTransaction>(prov, TX_WITH_WITNESS)) {\n+            block.vtx.push_back(MakeTransactionRef(std::move(*tx)));\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return std::make_pair(std::move(block), height);\n+}\n+\n+/** Create a consensus-valid random block.\n+ * If a non-empty list of transactions is passed include them. Otherwise create some random valid transactions\n+ * from the given utxos. Spent utxos will be erased from the map and created ones will be included. */\n+CBlock CreateValidBlock(FuzzedDataProvider& prov, const Consensus::Params& params, CBlockIndex* prev_block,\n+                        std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos, std::vector<CTransactionRef> txs = {})\n+{\n+    assert(prev_block);\n+    CBlock block;\n+    block.nVersion = prov.ConsumeIntegral<int32_t>();\n+    block.nNonce = prov.ConsumeIntegral<uint32_t>();\n+    node::UpdateTime(&block, params, prev_block);\n+    block.nBits = GetNextWorkRequired(prev_block, &block, params);\n+    block.hashPrevBlock = prev_block->GetBlockHash();\n+\n+    // Always create the coinbase. Then if a list of transactions was passed, use that. Otherwise\n+    // try to create a bunch of new transactions.\n+    block.vtx.push_back(CreateCoinbase(prev_block->nHeight + 1));\n+    if (!txs.empty()) {\n+        block.vtx.reserve(txs.size());\n+        block.vtx.insert(block.vtx.end(), std::make_move_iterator(txs.begin()), std::make_move_iterator(txs.end()));\n+        txs.erase(txs.begin(), txs.end());\n+    } else {\n+        while (prov.ConsumeBool() && !utxos.empty()) {\n+            block.vtx.push_back(CreateTransaction(prov, utxos));\n+            if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n+                block.vtx.pop_back();\n+                break;\n+            }\n+        }\n+    }\n+    block.hashMerkleRoot = BlockMerkleRoot(block);\n+\n+    return block;\n+}\n+\n+/** Make it possible to sanity check roundtrips to disk. */\n+bool operator==(const CBlock& a, const CBlock& b)\n+{\n+    return a.nVersion == b.nVersion\n+        && a.nTime == b.nTime\n+        && a.nBits == b.nBits\n+        && a.nNonce == b.nNonce\n+        && a.hashPrevBlock == b.hashPrevBlock\n+        && a.hashMerkleRoot == b.hashMerkleRoot;\n+}\n+\n+/** Add spendable utxos to our cache from the coins database. */\n+void AppendUtxos(ChainstateManager& chainman, std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher>& utxos)\n+{\n+    LOCK(cs_main);\n+    chainman.ActiveChainstate().CoinsTip().Sync();\n+\n+    const auto& coins{chainman.ActiveChainstate().CoinsDB()};\n+    const auto cur_height{chainman.ActiveHeight()};\n+    for (auto cursor{coins.Cursor()}; cursor->Valid(); cursor->Next()) {\n+        COutPoint outpoint;\n+        Coin coin;\n+        assert(cursor->GetValue(coin));\n+        if (coin.IsSpent() || (coin.IsCoinBase() && cur_height - coin.nHeight < COINBASE_MATURITY)) continue;\n+        assert(cursor->GetKey(outpoint));\n+        utxos.emplace(std::move(outpoint), std::move(coin.out));\n+    }\n+}\n+\n+} // namespace\n+\n+void init_blockstorage()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN);\n+    g_setup = testing_setup.get();\n+\n+    mock_filesystem_calls();\n+\n+    // Mock the pow check to always pass since it is checked when loading blocks and we don't\n+    // want to be mining within the target.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+}\n+\n+FUZZ_TARGET(blockstorage, .init = init_blockstorage)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+\n+    // Create the BlockManager and its index. The BlockManager file storage is mocked (see\n+    // the g_mock_* functions above) and the index uses an in-memory LevelDb.\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    auto blockman{node::BlockManager{*g_setup->m_node.shutdown, std::move(blockman_opts)}};\n+    {\n+    LOCK(cs_main);\n+    blockman.m_block_tree_db = std::make_unique<kernel::BlockTreeDB>(DBParams{\n+        .path = \"\", // Memory-only.\n+        .cache_bytes = nMaxBlockDBCache << 20,\n+        .memory_only = true,\n+    });\n+    }\n+\n+    // Needed by AddToBlockIndex, reuse it to test both nullptr and not.\n+    CBlockIndex* dummy_best{nullptr};\n+    BlockValidationState dummy_valstate;\n+\n+    // Load the genesis block.\n+    {\n+    LOCK(cs_main);\n+    assert(blockman.m_block_index.count(chainparams.GetConsensus().hashGenesisBlock) == 0);\n+    const CBlock& block = chainparams.GenesisBlock();\n+    FlatFilePos blockPos{blockman.SaveBlockToDisk(block, 0)};\n+    assert(!blockPos.IsNull());\n+    assert(blockman.AddToBlockIndex(block, dummy_best));\n+    assert(!blockman.m_block_index.empty());\n+    }\n+\n+    // This is used to store blocks which were created when accepting their header, to potentially\n+    // later be stored to disk entirely.\n+    std::vector<std::pair<CBlock, int>> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        CallOneOf(fuzzed_data_provider,\n+            // Add a header to the block index. Sometimes save the header of a full block which could be saved to disk\n+            // later (see below). Otherwise save a random header for which we'll never store a block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                auto header{[&]() NO_THREAD_SAFETY_ANALYSIS {\n+                    LOCK(cs_main);\n+                    auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                    if (fuzzed_data_provider.ConsumeBool()) {\n+                        auto [block, height]{CreateBlock(fuzzed_data_provider, std::move(prev_block))};\n+                        auto header{*(static_cast<CBlockHeader*>(&block))};\n+                        blocks_in_flight.emplace_back(std::move(block), height);\n+                        return header;\n+                    } else {\n+                        return CreateBlockHeader(fuzzed_data_provider, std::move(prev_block), /*set_merkle=*/true).first;\n+                    }\n+                }()};\n+                assert(blockman.AddToBlockIndex(header, dummy_best));\n+                assert(blockman.LookupBlockIndex(header.GetHash()));\n+            },\n+            // Roundtrip the block index database. It should always succeed, since we mock the pow check.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                assert(blockman.WriteBlockIndexDB());\n+                assert(blockman.LoadBlockIndexDB({}));\n+                // TODO: somehow compare m_block_tree_db before and after?\n+            },\n+            //// Write some random undo data for a random block from the index.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                // Always at least one block is present but the genesis doesn't have a pprev.\n+                auto& block = PickValue(fuzzed_data_provider, blockman.m_block_index).second;\n+                if (block.pprev) {\n+                    if (auto undo_data = ConsumeDeserializable<CBlockUndo>(fuzzed_data_provider)) {\n+                        if (WITH_LOCK(::cs_main, return blockman.WriteUndoDataForBlock(*undo_data, dummy_valstate, block))) {\n+                            CBlockUndo undo_read;\n+                            assert(blockman.UndoReadFromDisk(undo_read, block));\n+                            // TODO: assert they're equal?\n+                        }\n+                    }\n+                }\n+            },\n+            // Create a new block and roundtrip it to disk. In 50% of the cases, pick a block for which we\n+            // stored its header already (if there is any), in the rest create a whole new block.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                auto [block, height]{[&] {\n+                    LOCK(cs_main);\n+                    if (!blocks_in_flight.empty() && fuzzed_data_provider.ConsumeBool()) {\n+                        auto ret{std::move(blocks_in_flight.back())};\n+                        blocks_in_flight.pop_back();\n+                        return ret;\n+                    } else {\n+                        auto prev_block{RandomPrevBlock(fuzzed_data_provider, blockman)};\n+                        return CreateBlock(fuzzed_data_provider, std::move(prev_block));\n+                    }\n+                }()};\n+                const auto pos{blockman.SaveBlockToDisk(block, height)};\n+                blockman.GetBlockPosFilename(pos);\n+                CBlock read_block;\n+                blockman.ReadBlockFromDisk(read_block, pos);\n+                assert(block == read_block);\n+            },\n+            // Kitchen sink.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+\n+                CCheckpointData dummy_data;\n+                blockman.GetLastCheckpoint(dummy_data);\n+\n+                // Coverage for CheckBlockDataAvailability. It requires the lower and upper blocks to be correctly\n+                // ordered. There is always at least one block in the index, the genesis.\n+                const auto sz{blockman.m_block_index.size()};\n+                auto lower_it{blockman.m_block_index.begin()};\n+                std::advance(lower_it, fuzzed_data_provider.ConsumeIntegralInRange<decltype(sz)>(0, sz - 1));\n+                auto upper_it{lower_it};\n+                while (fuzzed_data_provider.ConsumeBool()) {\n+                    auto it = std::next(upper_it);\n+                    if (it == blockman.m_block_index.end()) break;\n+                    upper_it = it;\n+                }\n+                const auto& lower_block{lower_it->second};\n+                const auto& upper_block{upper_it->second};\n+                blockman.CheckBlockDataAvailability(upper_block, lower_block);\n+\n+                // Get coverage for IsBlockPruned.\n+                blockman.IsBlockPruned(upper_block);\n+            }\n+        );\n+    };\n+\n+    // At no point do we set an AssumeUtxo snapshot.\n+    assert(!blockman.m_snapshot_height);\n+}\n+\n+void init_chainstate()\n+{\n+    // FIXME: only used to setup logging. Set it up without instantiating a whole, unused, BasicTestingSetup.\n+    static const auto testing_setup = MakeNoLogFileContext<>(ChainType::MAIN/*, {\"-printtoconsole\", \"-debug\"}*/);\n+    g_setup = testing_setup.get();\n+\n+    // Make the pow check always pass to be able to mine a chain from inside the target.\n+    // TODO: we could have two mocks, once which passes, the other which fails. This way we can\n+    // also fuzz the codepath for invalid pow.\n+    g_check_pow_mock = [](uint256 hash, unsigned int, const Consensus::Params&) {\n+        return true;\n+    };\n+\n+    // This creates the datadirs in the tmp dir.\n+    g_test_data.Init();\n+\n+    // Create the chainstate for the initial datadir. On every round we'll restart from this chainstate instead of\n+    // re-creating one from scratch.\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = Params(),\n+        .blocks_dir = g_test_data.init_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = Params(),\n+        .datadir = g_test_data.init_datadir,\n+        .check_block_index = false,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 1;\n+    cache_sizes.coins_db = 2;\n+    cache_sizes.coins = 3;\n+    node::ChainstateLoadOptions load_opts {\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    // Connect the initial chain to get 10 spendable UTxOs at the start of every fuzzing round.\n+    const auto g_initial_blockchain{CreateBlockChain(110, Params())};\n+    BlockValidationState valstate;\n+    auto& chainstate{chainman.ActiveChainstate()};\n+    assert(chainstate.ActivateBestChain(valstate, nullptr));\n+    for (const auto& block : g_initial_blockchain) {\n+        bool new_block{false};\n+        assert(chainman.ProcessNewBlock(block, true, true, &new_block));\n+        assert(new_block);\n+    }\n+\n+    LOCK(cs_main);\n+    if (chainstate.CanFlushToDisk()) {\n+        chainstate.ForceFlushStateToDisk();\n+    }\n+}\n+\n+FUZZ_TARGET(chainstate, .init = init_chainstate)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    const auto& chainparams{Params()};\n+    std::unordered_map<COutPoint, CTxOut, SaltedOutpointHasher> utxos;\n+\n+    //const auto first_time{SteadyClock::now()};\n+\n+    // On every round start from a freshly copied initial datadir.\n+    fs::remove_all(g_test_data.working_datadir);\n+    fs::copy(g_test_data.init_datadir, g_test_data.working_datadir, fs::copy_options::overwrite_existing | fs::copy_options::recursive);\n+\n+    // Create the chainstate..\n+    uint64_t prune_target{0};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        prune_target = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+    }\n+    node::BlockManager::Options blockman_opts{\n+        .chainparams = chainparams,\n+        .prune_target = prune_target,\n+        .blocks_dir = g_test_data.working_datadir / \"blocks\",\n+        .notifications = g_test_data.notifs,\n+    };\n+    const ChainstateManager::Options chainman_opts{\n+        .chainparams = chainparams,\n+        .datadir = g_test_data.working_datadir,\n+        // TODO: make it possible to call CheckBlockIndex() without having set it here, and call it in CallOneOf().\n+        .check_block_index = true,\n+        .checkpoints_enabled = false,\n+        .minimum_chain_work = UintToArith256(uint256{}),\n+        .assumed_valid_block = uint256{},\n+        .notifications = g_test_data.notifs,\n+        .signals = &g_test_data.main_signals,\n+    };\n+    ChainstateManager chainman{*g_setup->m_node.shutdown, chainman_opts, blockman_opts};\n+\n+    // ..And then load it.\n+    node::CacheSizes cache_sizes;\n+    cache_sizes.block_tree_db = 2 << 20;\n+    cache_sizes.coins_db = 2 << 22;\n+    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);\n+    node::ChainstateLoadOptions load_opts {\n+        .prune = prune_target > 0,\n+        .require_full_verification = false,\n+        .coins_error_cb = nullptr,\n+    };\n+    auto [status, _] = node::LoadChainstate(chainman, cache_sizes, load_opts);\n+    assert(status == node::ChainstateLoadStatus::SUCCESS);\n+\n+    //const auto time_before_loop{SteadyClock::now()};\n+\n+    BlockValidationState dummy_valstate;\n+    std::vector<CBlock> blocks_in_flight;\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10'000) {\n+        // Every so often, update our cache used to create non-coinbase txs.\n+        if (_count % 100 == 0) AppendUtxos(chainman, utxos);\n+\n+        CallOneOf(fuzzed_data_provider,\n+            // Process a list of headers. Most of the time make it process the header of a valid block\n+            // cached for future processing.\n+            [&]() NO_THREAD_SAFETY_ANALYSIS {\n+                LOCK(cs_main);\n+                std::vector<CBlockHeader> headers;\n+\n+                // In 1% of the cases, generate a random list of headers to be processed. Otherwise, create a single\n+                // valid block.\n+                // TODO: make it possible to generate a chain of more than one valid block.\n+                const bool is_random{fuzzed_data_provider.ConsumeIntegralInRange(0, 99) == 99};",
      "path": "src/test/fuzz/chainstate.cpp",
      "position": 576,
      "original_position": 570,
      "commit_id": "040af0ea45e05ad45c372090dc50b4eeda93737f",
      "original_commit_id": "1059ca3f336f01de2c6a84afac01ba15c300182a",
      "in_reply_to_id": 1670126790,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "When debating this with myself my weak argument in favour of it was that the target was very slow and this could help discover interesting paths faster. I also wanted your feedback on this, so thanks.",
      "created_at": "2024-07-09T15:35:25Z",
      "updated_at": "2024-07-09T15:35:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29158#discussion_r1670749288",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1670749288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29158"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 576,
      "original_line": 576,
      "side": "RIGHT"
    }
  ]
}