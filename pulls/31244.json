{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244",
    "id": 2168019750,
    "node_id": "PR_kwDOABII586BOVsm",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31244",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31244.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31244.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
    "number": 31244,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "descriptors: MuSig2",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Implements parsing of BIP 390 `musig()` descriptors.\r\n\r\nSplit from #29675",
    "labels": [
      {
        "id": 1482182044,
        "node_id": "MDU6TGFiZWwxNDgyMTgyMDQ0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Descriptors",
        "name": "Descriptors",
        "description": "",
        "color": "e9f76c",
        "default": false
      }
    ],
    "created_at": "2024-11-07T18:10:02Z",
    "updated_at": "2025-07-18T10:58:50Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "d3c8f281c7655834ab665edb7223aee34304f5e5",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "achow101:musig2-desc",
      "ref": "musig2-desc",
      "sha": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 45006379,
        "node_id": "MDEwOlJlcG9zaXRvcnk0NTAwNjM3OQ==",
        "name": "bitcoin",
        "full_name": "achow101/bitcoin",
        "owner": {
          "login": "achow101",
          "id": 3782274,
          "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/achow101",
          "html_url": "https://github.com/achow101",
          "followers_url": "https://api.github.com/users/achow101/followers",
          "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
          "organizations_url": "https://api.github.com/users/achow101/orgs",
          "repos_url": "https://api.github.com/users/achow101/repos",
          "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/achow101/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/achow101/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/achow101/bitcoin",
        "archive_url": "https://api.github.com/repos/achow101/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/achow101/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/achow101/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/achow101/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/achow101/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/achow101/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/achow101/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/achow101/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/achow101/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/achow101/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/achow101/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/achow101/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/achow101/bitcoin/events",
        "forks_url": "https://api.github.com/repos/achow101/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/achow101/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/achow101/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/achow101/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/achow101/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/achow101/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/achow101/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/achow101/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/achow101/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/achow101/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/achow101/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/achow101/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/achow101/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/achow101/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/achow101/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/achow101/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:achow101/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/achow101/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/achow101/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/achow101/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/achow101/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/achow101/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/achow101/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/achow101/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/achow101/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/achow101/bitcoin/hooks",
        "svn_url": "https://github.com/achow101/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 10,
        "stargazers_count": 41,
        "watchers_count": 41,
        "size": 304326,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-16T22:18:36Z",
        "created_at": "2015-10-27T00:20:28Z",
        "updated_at": "2025-07-13T19:52:21Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "ad654a4807cd584be9ffcd8640f628ab40cb5170",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37531,
        "stargazers_count": 84619,
        "watchers_count": 84619,
        "size": 289148,
        "default_branch": "master",
        "open_issues_count": 757,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-16T12:49:29Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-07-18T09:15:42Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 752,
    "deletions": 51,
    "changed_files": 14,
    "commits": 12,
    "review_comments": 165,
    "comments": 17
  },
  "events": [
    {
      "event": "commented",
      "id": 2462913654,
      "node_id": "IC_kwDOABII586SzRR2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2462913654",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-07T18:10:05Z",
      "updated_at": "2025-07-16T17:33:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31244.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [w0xlt](https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2955519593), [rkrux](https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2957389841), [theStack](https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2958410039) |\n| Concept ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2846300829) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#32966](https://github.com/bitcoin/bitcoin/pull/32966) (Silent Payments: Receiving by Eunovo)\n* [#32745](https://github.com/bitcoin/bitcoin/pull/32745) (scripted-diff: Update DeriveType enum values to mention ranged derivations by rkrux)\n* [#32724](https://github.com/bitcoin/bitcoin/pull/32724) (Musig2 tests by w0xlt)\n* [#32489](https://github.com/bitcoin/bitcoin/pull/32489) (wallet: Add `exportwatchonlywallet` RPC to export a watchonly version of a wallet by achow101)\n* [#32471](https://github.com/bitcoin/bitcoin/pull/32471) (wallet/rpc: fix listdescriptors RPC fails to return descriptors with private key information when wallet contains descriptors missing any key by Eunovo)\n* [#32332](https://github.com/bitcoin/bitcoin/pull/32332) (refactor: Update `XOnlyPubKey::GetKeyIDs()` to return a pair of pubkeys by w0xlt)\n* [#30243](https://github.com/bitcoin/bitcoin/pull/30243) (descriptors: taproot partial descriptors by Eunovo)\n* [#29675](https://github.com/bitcoin/bitcoin/pull/29675) (wallet: Be able to receive and spend inputs involving MuSig2 aggregate keys by achow101)\n* [#28201](https://github.com/bitcoin/bitcoin/pull/28201) (Silent Payments: sending by josibake)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2462913654",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "labeled",
      "id": 15188785099,
      "node_id": "LE_lADOABII586ddsd2zwAAAAOJUnfL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15188785099",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-07T18:10:09Z",
      "label": {
        "name": "Descriptors",
        "color": "e9f76c"
      }
    },
    {
      "event": "commented",
      "id": 2500865562,
      "node_id": "IC_kwDOABII586VEC4a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2500865562",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-26T13:54:14Z",
      "updated_at": "2024-11-26T13:55:27Z",
      "author_association": "MEMBER",
      "body": "Can you add an example to `doc/descriptors.md`?\r\n\r\nDid you mean [BIP390](https://github.com/bitcoin/bips/blob/master/bip-0390.mediawiki) in the description?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2500865562",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "commented",
      "id": 2527475671,
      "node_id": "IC_kwDOABII586WpjfX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2527475671",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T10:06:44Z",
      "updated_at": "2024-12-09T10:06:44Z",
      "author_association": "MEMBER",
      "body": "```\r\n$ echo \"cGsobXVzaWcoZGR9dXVlLzAwLylrKA==\" | base64 --decode > mocked_descriptor_parse_1.crash\r\n$ FUZZ=mocked_descriptor_parse fuzz mocked_descriptor_parse_1.crash\r\nscript/descriptor.cpp:1838 ParsePubkey: Assertion `Func(\"musig\", expr)' failed.\r\n\r\n$ echo \"dHIobXVzaWcoICAgICB0dXVzKG9sZGVwayhnZylnZ2dnZmdnKTwseigoKCgoKCgoKCgoKCgoKCgoKCgoKHN0KQ==\" | base64 --decode > mocked_descriptor_parse_2.crash\r\n$ FUZZ=mocked_descriptor_parse fuzz mocked_descriptor_parse_2.crash\r\nscript/descriptor.cpp:1833 ParsePubkey: Assertion `split.size() <= 2' failed.\r\n```",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2527475671",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15591503410,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAOhU3Yy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15591503410",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7be277c4b8948fb5105b26e8aa12d0add43b14d4",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/7be277c4b8948fb5105b26e8aa12d0add43b14d4",
      "created_at": "2024-12-09T22:34:28Z"
    },
    {
      "event": "commented",
      "id": 2529679956,
      "node_id": "IC_kwDOABII586Wx9pU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2529679956",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T22:34:39Z",
      "updated_at": "2024-12-09T22:34:39Z",
      "author_association": "MEMBER",
      "body": "Fixed the fuzz crashes and added those descriptors to the unit tests.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2529679956",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "commented",
      "id": 2531046640,
      "node_id": "IC_kwDOABII586W3LTw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2531046640",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-10T09:51:04Z",
      "updated_at": "2024-12-10T09:51:04Z",
      "author_association": "MEMBER",
      "body": "```\r\n$ echo \"dHIobXVzaWcoJTIyLzMzMmgpSigoKChhZGRyKEJjdXUp\" | base64 --decode > mocked_descriptor_parse_3.crash\r\n$ FUZZ=mocked_descriptor_parse fuzz mocked_descriptor_parse_3.crash\r\nscript/descriptor.cpp:632 GetPubKey: Assertion `pubkey.has_value()' failed.\r\n```",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2531046640",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "commented",
      "id": 2531119817,
      "node_id": "IC_kwDOABII586W3dLJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2531119817",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-10T10:19:12Z",
      "updated_at": "2024-12-10T10:19:12Z",
      "author_association": "MEMBER",
      "body": "```\r\n$ echo \"dHIobXVzaWcoKS8wMDAwMTEp\" | base64 --decode > descriptor_parse_1.crash\r\n$ FUZZ=descriptor_parse fuzz descriptor_parse_1.crash\r\n[libsecp256k1] illegal argument: pubkeys != NULL\r\n```",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2531119817",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15604446841,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAOiGPZ5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15604446841",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9a0397e08b7f1b451a311d32a45970d27fd9fff9",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/9a0397e08b7f1b451a311d32a45970d27fd9fff9",
      "created_at": "2024-12-10T17:16:15Z"
    },
    {
      "event": "commented",
      "id": 2532329132,
      "node_id": "IC_kwDOABII586W8Eas",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2532329132",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-10T17:16:22Z",
      "updated_at": "2024-12-10T17:16:22Z",
      "author_association": "MEMBER",
      "body": "Fixed those crashes too.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2532329132",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "commented",
      "id": 2532707235,
      "node_id": "IC_kwDOABII586W9guj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2532707235",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-10T19:41:25Z",
      "updated_at": "2024-12-10T19:41:25Z",
      "author_association": "MEMBER",
      "body": "```\r\n$ echo \"dHIobXVzaWcoJWU5LzwwOzAwMDAwMzU7MDYwOzM7MDY+KS82Nik=\" | base64 --decode > mocked_descriptor_parse_4.crash\r\n$ FUZZ=mocked_descriptor_parse fuzz mocked_descriptor_parse_4.crash\r\nfuzz: script/descriptor.cpp:1942: std::vector<std::unique_ptr<PubkeyProvider>> (anonymous namespace)::ParsePubkey(uint32_t &, const Span<const char> &, ParseScriptContext, FlatSigningProvider &, std::string &): Assertion `pub.size() == 1' failed.\r\n```",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2532707235",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15786092305,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAOs7KcR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15786092305",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "65824b5d32e286dc7474b89759753558958e2f2f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/65824b5d32e286dc7474b89759753558958e2f2f",
      "created_at": "2024-12-30T17:45:57Z"
    },
    {
      "event": "commented",
      "id": 2565857130,
      "node_id": "IC_kwDOABII586Y799q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2565857130",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-30T19:46:48Z",
      "updated_at": "2024-12-30T19:46:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/34992034826</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2565857130",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "labeled",
      "id": 15786679140,
      "node_id": "LE_lADOABII586ddsd2zwAAAAOs9Ztk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15786679140",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-30T19:46:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15803626328,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAOt-DNY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15803626328",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "02f50cc2ea685324f50ca99835b548c067589ef2",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/02f50cc2ea685324f50ca99835b548c067589ef2",
      "created_at": "2025-01-03T01:20:52Z"
    },
    {
      "event": "unlabeled",
      "id": 15803820786,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAOt-yry",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15803820786",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-03T02:22:59Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15830479775,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAOvkfOf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15830479775",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7c65e9663a0932ce11da584619d500f080fc02aa",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/7c65e9663a0932ce11da584619d500f080fc02aa",
      "created_at": "2025-01-06T20:13:49Z"
    },
    {
      "event": "labeled",
      "id": 16013447937,
      "node_id": "LE_lADOABII586ddsd2zwAAAAO6edMB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16013447937",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-21T12:17:46Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16021037735,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAO67aKn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16021037735",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "efe85f891e625634e489e47ae2f84b851caa1785",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/efe85f891e625634e489e47ae2f84b851caa1785",
      "created_at": "2025-01-21T22:37:41Z"
    },
    {
      "event": "unlabeled",
      "id": 16021266985,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAO68SIp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16021266985",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-21T23:08:13Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 16899806372,
      "node_id": "LE_lADOABII586ddsd2zwAAAAPvTpSk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16899806372",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T10:16:54Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17214144236,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQCCv7s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17214144236",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "09d109d39b22256b4978e2c9300538f4bb0267b9",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/09d109d39b22256b4978e2c9300538f4bb0267b9",
      "created_at": "2025-04-10T21:43:55Z"
    },
    {
      "event": "labeled",
      "id": 17214382693,
      "node_id": "LE_lADOABII586ddsd2zwAAAAQCDqJl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17214382693",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-10T22:07:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2795270555,
      "node_id": "IC_kwDOABII586mnHGb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2795270555",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-10T22:07:37Z",
      "updated_at": "2025-04-10T22:07:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/40357481289</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2795270555",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17214764455,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQCFHWn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17214764455",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2e5756cc48ac1299c769e5e4428837a31eeaf630",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/2e5756cc48ac1299c769e5e4428837a31eeaf630",
      "created_at": "2025-04-10T22:35:36Z"
    },
    {
      "event": "unlabeled",
      "id": 17214951572,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAQCF1CU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17214951572",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-10T22:53:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17255472845,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQEgZ7N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17255472845",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "de468fc93a6748b8fa7d4271c5e4937ac29dd582",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/de468fc93a6748b8fa7d4271c5e4937ac29dd582",
      "created_at": "2025-04-14T20:33:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17255475124,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQEgae0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17255475124",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b5fd6067537ee1498bd3cd4fc04b24ab55c03c87",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/b5fd6067537ee1498bd3cd4fc04b24ab55c03c87",
      "created_at": "2025-04-14T20:33:52Z"
    },
    {
      "event": "unlabeled",
      "id": 17257149321,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAQEmzOJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17257149321",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-14T22:51:20Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 17342608495,
      "node_id": "LE_lADOABII586ddsd2zwAAAAQJszRv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17342608495",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-21T19:34:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17343811633,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQJxZAx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17343811633",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e7c67ec86dcb24f78b642f8dc1917a7e3cf2e780",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/e7c67ec86dcb24f78b642f8dc1917a7e3cf2e780",
      "created_at": "2025-04-21T21:36:29Z"
    },
    {
      "event": "ready_for_review",
      "id": 17343819027,
      "node_id": "RFRE_lADOABII586ddsd2zwAAAAQJxa0T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17343819027",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-21T21:37:26Z"
    },
    {
      "event": "commented",
      "id": 2819555645,
      "node_id": "IC_kwDOABII586oDwE9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2819555645",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-21T21:37:38Z",
      "updated_at": "2025-04-21T21:37:38Z",
      "author_association": "MEMBER",
      "body": "All dependencies have been merged, ready for review.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2819555645",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "unlabeled",
      "id": 17343963102,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAQJx9_e",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17343963102",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-21T21:53:47Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2796051128,
      "node_id": "PRR_kwDOABII586mqFq4",
      "url": null,
      "actor": null,
      "commit_id": "e7c67ec86dcb24f78b642f8dc1917a7e3cf2e780",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nSeems like the commit message for 2e6dcdbc8055660a2e20ba81b62b7d26ae0ccb05 (\"Add MuSig2 Keyagg Cache class and functions\") is out-of-sync, as there is no such class added and also the mentioned `MuSig2KeyAggCacheImpl` doesn't exist.\r\n\r\nFor the newly introduced parameters of the `Const` and `Split` functions (commits fe02d7cb237c00de6abe1776b3101342ffddf757 and 4a1eeee27a64c4be7293740f8fff839879b88d86), it would be nice to have unit test coverage, but this can be also done in a follow-up.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2796051128",
      "submitted_at": "2025-04-26T14:39:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2808489885,
      "node_id": "PRR_kwDOABII586nZied",
      "url": null,
      "actor": null,
      "commit_id": "e7c67ec86dcb24f78b642f8dc1917a7e3cf2e780",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2808489885",
      "submitted_at": "2025-04-30T21:26:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17563773885,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQW4eu9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17563773885",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "37f3557a7e26a9873d83ee309fdff53c9aa0114c",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/37f3557a7e26a9873d83ee309fdff53c9aa0114c",
      "created_at": "2025-05-07T21:33:16Z"
    },
    {
      "event": "commented",
      "id": 2860444988,
      "node_id": "IC_kwDOABII586qfu08",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2860444988",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T21:34:01Z",
      "updated_at": "2025-05-07T21:34:01Z",
      "author_association": "MEMBER",
      "body": "> Seems like the commit message for [2e6dcdb](https://github.com/bitcoin/bitcoin/commit/2e6dcdbc8055660a2e20ba81b62b7d26ae0ccb05) (\"Add MuSig2 Keyagg Cache class and functions\") is out-of-sync, as there is no such class added and also the mentioned `MuSig2KeyAggCacheImpl` doesn't exist.\r\n\r\nUpdated the commit message.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2860444988",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "reviewed",
      "id": 2843677281,
      "node_id": "PRR_kwDOABII586pfxJh",
      "url": null,
      "actor": null,
      "commit_id": "37f3557a7e26a9873d83ee309fdff53c9aa0114c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2843677281",
      "submitted_at": "2025-05-15T18:40:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2846300829,
      "node_id": "PRR_kwDOABII586ppxqd",
      "url": null,
      "actor": null,
      "commit_id": "37f3557a7e26a9873d83ee309fdff53c9aa0114c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nReviewed up to 6b634754d2783ffe16570ad37dbcf9251a7efc24, mostly happy.\r\n\r\nI didn't thoroughly check that all test vectors from BIP390 are in the test, but did check a few.\r\n\r\n> Can you add an example to `doc/descriptors.md`?\r\n\r\nThis still seems useful (and this document should probably link back to the bip numbers, but that's orthogonal).\r\n\r\nManual testing hint for other reviewers: you can use the `deriveaddresses` RPC with some of the test vectors. Just use `00000000` as the checksum, it will tell you the right one, and then call it gain to see an address. Pass that address into `validateaddress` and compare the `scriptPubKey` to the one in the bip. ",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2846300829",
      "submitted_at": "2025-05-16T13:58:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17693367571,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQem10T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17693367571",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4ec378418b3dcb5c912fbbcabdb6e7242a0378d1",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/4ec378418b3dcb5c912fbbcabdb6e7242a0378d1",
      "created_at": "2025-05-16T19:08:22Z"
    },
    {
      "event": "reviewed",
      "id": 2851595777,
      "node_id": "PRR_kwDOABII586p9-YB",
      "url": null,
      "actor": null,
      "commit_id": "4ec378418b3dcb5c912fbbcabdb6e7242a0378d1",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2851595777",
      "submitted_at": "2025-05-19T18:05:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17739650964,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQhXZeU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17739650964",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "08d8a59597db34bcddcc1ec5fda98b0b14803170",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/08d8a59597db34bcddcc1ec5fda98b0b14803170",
      "created_at": "2025-05-20T18:23:36Z"
    },
    {
      "event": "reviewed",
      "id": 2857019010,
      "node_id": "PRR_kwDOABII586qSqaC",
      "url": null,
      "actor": null,
      "commit_id": "08d8a59597db34bcddcc1ec5fda98b0b14803170",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2857019010",
      "submitted_at": "2025-05-21T09:37:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVmZTRjNjY0NjJlNjE0OWMyZWQzY2UyNDIyNGE3YTdiMzI4YTJjZmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa",
      "tree": {
        "sha": "8f04c87ccd4c97fc9a4ae59475bf51f82f6172db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f04c87ccd4c97fc9a4ae59475bf51f82f6172db"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87ec923d3a7af7b30613174b41c6fb11671df466",
          "sha": "87ec923d3a7af7b30613174b41c6fb11671df466",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/87ec923d3a7af7b30613174b41c6fb11671df466"
        }
      ],
      "message": "XOnlyPubKey: Add GetCPubKeys\n\nWe need to retrieve the even and odd compressed pubkeys for xonly\npubkeys, so add a function to do that. Also reuse it in GetKeyIDs.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-21T17:44:26Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-29T22:32:02Z"
      },
      "sha": "5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17758565914,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQifjYa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17758565914",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "78dc6f4bfe8ebaca93bba3b4b235e68714e86d93",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/78dc6f4bfe8ebaca93bba3b4b235e68714e86d93",
      "created_at": "2025-05-21T17:55:29Z"
    },
    {
      "event": "labeled",
      "id": 17762158176,
      "node_id": "LE_lADOABII586ddsd2zwAAAAQitQZg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17762158176",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-21T23:02:27Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2860429843,
      "node_id": "PRR_kwDOABII586qfrIT",
      "url": null,
      "actor": null,
      "commit_id": "78dc6f4bfe8ebaca93bba3b4b235e68714e86d93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Some more questions about the `MuSigPubkeyProvider` introduced in 35db4f2dcfc3435e10935581ffa447ffe219cc1e.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2860429843",
      "submitted_at": "2025-05-22T10:08:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "unlabeled",
      "id": 17784386944,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAQkCDWA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17784386944",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-23T06:49:53Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2864248620,
      "node_id": "PRR_kwDOABII586quPcs",
      "url": null,
      "actor": null,
      "commit_id": "78dc6f4bfe8ebaca93bba3b4b235e68714e86d93",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2864248620",
      "submitted_at": "2025-05-23T13:21:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17794605878,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQkpCM2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17794605878",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1d1aec1a2bd40132f1f72432dd5c0f82f8b880d3",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/1d1aec1a2bd40132f1f72432dd5c0f82f8b880d3",
      "created_at": "2025-05-23T18:25:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17795235768,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQkrb-4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17795235768",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "db69e69bb3182a63582bfe52ba011126e2c1efe9",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/db69e69bb3182a63582bfe52ba011126e2c1efe9",
      "created_at": "2025-05-23T19:19:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17818272860,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQmDURc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17818272860",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e1475cbd0d477cd8e04348e839dbc3dff1374a44",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/e1475cbd0d477cd8e04348e839dbc3dff1374a44",
      "created_at": "2025-05-26T18:28:46Z"
    },
    {
      "event": "reviewed",
      "id": 2870961667,
      "node_id": "PRR_kwDOABII586rH2YD",
      "url": null,
      "actor": null,
      "commit_id": "e1475cbd0d477cd8e04348e839dbc3dff1374a44",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2870961667",
      "submitted_at": "2025-05-27T12:54:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2871820534,
      "node_id": "PRR_kwDOABII586rLID2",
      "url": null,
      "actor": null,
      "commit_id": "e1475cbd0d477cd8e04348e839dbc3dff1374a44",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed thoroughly up to ff7476ec32f4dbee07bf04169e741e2aea5a9ab7, looks good to me (with one refactoring suggestion below). Still need to go again through the parsing code as there is a lot going on with all the conditions on what is allowed and what not w.r.t. derivations.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2871820534",
      "submitted_at": "2025-05-27T17:26:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17835746212,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQnF-Ok",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17835746212",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c30c29746184d970ff4c5fec4f44ec2347985ff4",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/c30c29746184d970ff4c5fec4f44ec2347985ff4",
      "created_at": "2025-05-27T18:13:27Z"
    },
    {
      "event": "reviewed",
      "id": 2885837240,
      "node_id": "PRR_kwDOABII586sAmG4",
      "url": null,
      "actor": null,
      "commit_id": "c30c29746184d970ff4c5fec4f44ec2347985ff4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "According to BIP 390 [_\"Repeated participant public keys are not allowed.\"_](https://github.com/bitcoin/bips/blob/72af87fc72999e3f0a26a06e6e0a7f3134236337/bip-0390.mediawiki?plain=1#L36), but it seems there is currently no check preventing that? Example test case that passes but shouldn't (IIUC): https://github.com/theStack/bitcoin/commit/f260c7ec06e8bbb7148877a9a9b7e96707c41fa1",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2885837240",
      "submitted_at": "2025-06-01T17:00:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17942314842,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQtcf9a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17942314842",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "afcd397bc791d047508adb9d151d21384d7b49e3",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/afcd397bc791d047508adb9d151d21384d7b49e3",
      "created_at": "2025-06-02T20:13:02Z"
    },
    {
      "event": "commented",
      "id": 2932328786,
      "node_id": "IC_kwDOABII586ux8lS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2932328786",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-02T20:13:15Z",
      "updated_at": "2025-06-02T20:13:15Z",
      "author_association": "MEMBER",
      "body": "> According to BIP 390 [_\"Repeated participant public keys are not allowed.\"_](https://github.com/bitcoin/bips/blob/72af87fc72999e3f0a26a06e6e0a7f3134236337/bip-0390.mediawiki?plain=1#L36), but it seems there is currently no check preventing that? Example test case that passes but shouldn't (IIUC): [theStack@f260c7e](https://github.com/theStack/bitcoin/commit/f260c7ec06e8bbb7148877a9a9b7e96707c41fa1)\r\n\r\nGood catch. Fixed and added a test.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2932328786",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "reviewed",
      "id": 2892172589,
      "node_id": "PRR_kwDOABII586sYw0t",
      "url": null,
      "actor": null,
      "commit_id": "afcd397bc791d047508adb9d151d21384d7b49e3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2892172589",
      "submitted_at": "2025-06-03T13:27:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17968043059,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQu-pQz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17968043059",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "981b2abd79e3a7a4701c9d8794057b5523acb177",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/981b2abd79e3a7a4701c9d8794057b5523acb177",
      "created_at": "2025-06-03T21:14:20Z"
    },
    {
      "event": "reviewed",
      "id": 2896780371,
      "node_id": "PRR_kwDOABII586sqVxT",
      "url": null,
      "actor": null,
      "commit_id": "981b2abd79e3a7a4701c9d8794057b5523acb177",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Partial code review 981b2abd79e3a7a4701c9d8794057b5523acb177\r\nI just started and am still reviewing.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2896780371",
      "submitted_at": "2025-06-04T14:30:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17989722041,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQwRV-5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17989722041",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/96af090b97e4a42e729202004b94f76d19faeac2",
      "created_at": "2025-06-04T21:31:32Z"
    },
    {
      "event": "reviewed",
      "id": 2900761388,
      "node_id": "PRR_kwDOABII586s5hss",
      "url": null,
      "actor": null,
      "commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2900761388",
      "submitted_at": "2025-06-05T18:53:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18008147534,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQxXoZO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18008147534",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "created_at": "2025-06-05T19:13:03Z"
    },
    {
      "event": "reviewed",
      "id": 2915252677,
      "node_id": "PRR_kwDOABII586twznF",
      "url": null,
      "actor": null,
      "commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2915252677",
      "submitted_at": "2025-06-10T23:26:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2915269775,
      "node_id": "PRR_kwDOABII586tw3yP",
      "url": null,
      "actor": null,
      "commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Perhaps the description of the commits `script/parsing: Allow Const to not skip the found constant ` (https://github.com/bitcoin/bitcoin/pull/31244/commits/4b135f80d03c92fb522d1dcfd7d697aa0a4af626) and  `util/string: Allow Split to include the separator` (https://github.com/bitcoin/bitcoin/pull/31244/commits/b89a937225ed217556b38e000ee5d1bf0b5952aa) could explain why these changes are necessary for the musig2 descriptor.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2915269775",
      "submitted_at": "2025-06-10T23:43:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2915284020,
      "node_id": "PRR_kwDOABII586tw7Q0",
      "url": null,
      "actor": null,
      "commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2915284020",
      "submitted_at": "2025-06-10T23:58:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2915292347,
      "node_id": "PRR_kwDOABII586tw9S7",
      "url": null,
      "actor": null,
      "commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2915292347",
      "submitted_at": "2025-06-11T00:06:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18099507753,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ20JIp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18099507753",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e2b9129d9fad33a828043976b566441281b4f98c",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/e2b9129d9fad33a828043976b566441281b4f98c",
      "created_at": "2025-06-11T18:05:28Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg4MTEzMTI1NzE2YzUwY2U0ZGViODY0MDQxODQwZDUzYTU2NzU1NGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88113125716c50ce4deb864041840d53a567554c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/88113125716c50ce4deb864041840d53a567554c",
      "tree": {
        "sha": "b2b3b421fd116f20ce5d4ec536eaaa64704d7346",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2b3b421fd116f20ce5d4ec536eaaa64704d7346"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa",
          "sha": "5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa"
        }
      ],
      "message": "script/parsing: Allow Const to not skip the found constant\n\nWhen parsing a descriptor, it is useful to be able to check whether a\nstring begins with a substring without consuming that substring as\nanother function such as Func() will be used later which requires that\nsubstring to be present at the beginning.\n\nSpecifically, for MuSig2, this modified Const will be used to determine\nwhether a an expression begins with \"musig(\" before a subsequent\nFunc(\"musig\", ...) is used.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-11T18:07:35Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-15T22:08:47Z"
      },
      "sha": "88113125716c50ce4deb864041840d53a567554c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEyYmMxZDBiMWU5NjgxYzMzOGM5ZDBkZjBiYmFjMWQ0YTMxNjIzMjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12bc1d0b1e9681c338c9d0df0bbac1d4a3162322",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/12bc1d0b1e9681c338c9d0df0bbac1d4a3162322",
      "tree": {
        "sha": "0f25f57ce1a795faca583905fa3780a08707463e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f25f57ce1a795faca583905fa3780a08707463e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/88113125716c50ce4deb864041840d53a567554c",
          "sha": "88113125716c50ce4deb864041840d53a567554c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/88113125716c50ce4deb864041840d53a567554c"
        }
      ],
      "message": "util/string: Allow Split to include the separator\n\nWhen splitting a string, sometimes the separator needs to be included.\nSplit will now optionally include the separator at the end of the left\nside of the splits, i.e. it appears at the end of the splits, except\nfor the last one.\n\nSpecifically, for musig() descriptors, Split is used to separate a\nmusig() from any derivation path that follows it by splitting on the\nclosing parentheses. Since that parentheses is needed for Func() and\nExpr(), Split() needs to preserve the end parentheses instead of\ndiscarding it.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-11T18:09:42Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-04-14T20:31:31Z"
      },
      "sha": "12bc1d0b1e9681c338c9d0df0bbac1d4a3162322"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE4OTRmOTc1MDMyMDEzZWY4NTVjNDM4NjU0ZmJiNzQ1NTEyZTc5ODI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1894f975032013ef855c438654fbb745512e7982",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1894f975032013ef855c438654fbb745512e7982",
      "tree": {
        "sha": "550e0cfe93387d81014b94a933494e0c4c269733",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/550e0cfe93387d81014b94a933494e0c4c269733"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12bc1d0b1e9681c338c9d0df0bbac1d4a3162322",
          "sha": "12bc1d0b1e9681c338c9d0df0bbac1d4a3162322",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/12bc1d0b1e9681c338c9d0df0bbac1d4a3162322"
        }
      ],
      "message": "descriptors: Add PubkeyProvider::IsBIP32()",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-11T18:11:48Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-15T22:09:22Z"
      },
      "sha": "1894f975032013ef855c438654fbb745512e7982"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZhYzBlZTBiZmM5MTBhODI2NzhhM2Y4ZWMxM2M0Nzk2N2ZkN2RlZjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac0ee0bfc910a82678a3f8ec13c47967fd7def2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fac0ee0bfc910a82678a3f8ec13c47967fd7def2",
      "tree": {
        "sha": "b614ae0ef0e3f310ce29fd81b7149b24b9989f60",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b614ae0ef0e3f310ce29fd81b7149b24b9989f60"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1894f975032013ef855c438654fbb745512e7982",
          "sha": "1894f975032013ef855c438654fbb745512e7982",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1894f975032013ef855c438654fbb745512e7982"
        }
      ],
      "message": "build: Enable secp256k1 musig module",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-11T18:11:48Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-11-05T20:09:55Z"
      },
      "sha": "fac0ee0bfc910a82678a3f8ec13c47967fd7def2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhlY2VhOTFiZjI5NmI4ZmFlOGI4NGMzZGJmNjhkNTcwMzgyMWNiNzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ecea91bf296b8fae8b84c3dbf68d5703821cb79",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8ecea91bf296b8fae8b84c3dbf68d5703821cb79",
      "tree": {
        "sha": "083776dfcc05217fd129637f0f46d39a3b60321c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/083776dfcc05217fd129637f0f46d39a3b60321c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fac0ee0bfc910a82678a3f8ec13c47967fd7def2",
          "sha": "fac0ee0bfc910a82678a3f8ec13c47967fd7def2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fac0ee0bfc910a82678a3f8ec13c47967fd7def2"
        }
      ],
      "message": "sign: Add GetMuSig2ParticipantPubkeys to SigningProvider",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-11T18:11:48Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-22T21:43:26Z"
      },
      "sha": "8ecea91bf296b8fae8b84c3dbf68d5703821cb79"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQwMGQ5NTQzN2RkMTEzYTIzY2NkNTU2YzI1YTc3YmIwNGJjZTIzZjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d00d95437dd113a23ccd556c25a77bb04bce23f7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d00d95437dd113a23ccd556c25a77bb04bce23f7",
      "tree": {
        "sha": "a5211973975bc0b9ad189308019fac405da81d44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a5211973975bc0b9ad189308019fac405da81d44"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ecea91bf296b8fae8b84c3dbf68d5703821cb79",
          "sha": "8ecea91bf296b8fae8b84c3dbf68d5703821cb79",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8ecea91bf296b8fae8b84c3dbf68d5703821cb79"
        }
      ],
      "message": "Add MuSig2 Keyagg Cache helper functions\n\nsecp256k1 provides us secp256k1_musig_keyagg_cache objects which we are\nused as part of session info and to get the aggregate pubkey. These\nhelper functions help us convert to/from the secp256k1 C objects into\nthe Bitcoin Core C++ objects.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-11T18:11:48Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-22T20:18:28Z"
      },
      "sha": "d00d95437dd113a23ccd556c25a77bb04bce23f7"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18099610228,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ20iJ0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18099610228",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "created_at": "2025-06-11T18:11:57Z"
    },
    {
      "event": "commented",
      "id": 2963744013,
      "node_id": "IC_kwDOABII586wpyUN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2963744013",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-11T18:12:01Z",
      "updated_at": "2025-06-11T18:12:01Z",
      "author_association": "MEMBER",
      "body": "> Perhaps the description of the commits `script/parsing: Allow Const to not skip the found constant ` ([4b135f8](https://github.com/bitcoin/bitcoin/commit/4b135f80d03c92fb522d1dcfd7d697aa0a4af626)) and `util/string: Allow Split to include the separator` ([b89a937](https://github.com/bitcoin/bitcoin/commit/b89a937225ed217556b38e000ee5d1bf0b5952aa)) could explain why these changes are necessary for the musig2 descriptor.\r\n\r\nDone",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2963744013",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "reviewed",
      "id": 2918358960,
      "node_id": "PRR_kwDOABII586t8p-w",
      "url": null,
      "actor": null,
      "commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2918358960",
      "submitted_at": "2025-06-11T18:56:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2918555987,
      "node_id": "PRR_kwDOABII586t9aFT",
      "url": null,
      "actor": null,
      "commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2918555987",
      "submitted_at": "2025-06-11T20:18:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2918783679,
      "node_id": "PRR_kwDOABII586t-Rq_",
      "url": null,
      "actor": null,
      "commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/31244/commits/f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2918783679",
      "submitted_at": "2025-06-11T21:22:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18102080750,
      "node_id": "RRE_lADOABII586ddsd2zwAAAAQ299Tu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18102080750",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-11T21:22:07Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18102080870,
      "node_id": "RRE_lADOABII586ddsd2zwAAAAQ299Vm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18102080870",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-11T21:22:08Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2918917395,
      "node_id": "PRR_kwDOABII586t-yUT",
      "url": null,
      "actor": null,
      "commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code-review ACK f1b0fded41223c9b5b92696a0cfa553a10f3d9bf\r\n(modulo the outstanding question on how to cope with duplicate participant pubkeys, as https://github.com/bitcoin/bips/pull/1867 isn't merged yet; very likely the repeated key expression detection in 1e738242a8c642805b7cdbab51a21ee5a298bbab can be removed)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2918917395",
      "submitted_at": "2025-06-11T23:59:55Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "referenced",
      "id": 18131824943,
      "node_id": "REFE_lADOABII586ddsd2zwAAAAQ4vbEv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18131824943",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2a064f0a7a48d20d01d49ee7ded8f8479668dc5a",
      "commit_url": "https://api.github.com/repos/rkrux/bitcoin/commits/2a064f0a7a48d20d01d49ee7ded8f8479668dc5a",
      "created_at": "2025-06-13T10:54:32Z"
    },
    {
      "event": "referenced",
      "id": 18131841418,
      "node_id": "REFE_lADOABII586ddsd2zwAAAAQ4vfGK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18131841418",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a11bcca960c7decc28008fc56ed70c35a20d5937",
      "commit_url": "https://api.github.com/repos/rkrux/bitcoin/commits/a11bcca960c7decc28008fc56ed70c35a20d5937",
      "created_at": "2025-06-13T10:55:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18181249718,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ7r9q2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18181249718",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "73225c5f768cec75cff7d0ff9f0b442c8a55e27a",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/73225c5f768cec75cff7d0ff9f0b442c8a55e27a",
      "created_at": "2025-06-17T02:11:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18181269846,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ7sClW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18181269846",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1e205ca66c97295eca21f61dc309e8403814e802",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/1e205ca66c97295eca21f61dc309e8403814e802",
      "created_at": "2025-06-17T02:14:16Z"
    },
    {
      "event": "commented",
      "id": 2978705017,
      "node_id": "IC_kwDOABII586xi255",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2978705017",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T02:15:05Z",
      "updated_at": "2025-06-17T02:15:05Z",
      "author_association": "MEMBER",
      "body": "#29675 revealed a bug in `ToNormalizedString` which is fixed in the latest push.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2978705017",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "reviewed",
      "id": 2937108521,
      "node_id": "PRR_kwDOABII586vELgp",
      "url": null,
      "actor": null,
      "commit_id": "1e205ca66c97295eca21f61dc309e8403814e802",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/31244/commits/1e205ca66c97295eca21f61dc309e8403814e802",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2937108521",
      "submitted_at": "2025-06-17T21:13:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18198505981,
      "node_id": "RRE_lADOABII586ddsd2zwAAAAQ8tyn9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18198505981",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T21:13:57Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2939559036,
      "node_id": "PRR_kwDOABII586vNhx8",
      "url": null,
      "actor": null,
      "commit_id": "1e205ca66c97295eca21f61dc309e8403814e802",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 1e205ca66c97295eca21f61dc309e8403814e802",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2939559036",
      "submitted_at": "2025-06-18T14:50:32Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18218711061,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ963gV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18218711061",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f3c97b81a214724c14d8c8a7db1207f19584db83",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/f3c97b81a214724c14d8c8a7db1207f19584db83",
      "created_at": "2025-06-18T21:47:36Z"
    },
    {
      "event": "commented",
      "id": 2985786922,
      "node_id": "IC_kwDOABII586x934q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2985786922",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T21:47:46Z",
      "updated_at": "2025-06-18T21:47:46Z",
      "author_association": "MEMBER",
      "body": "The BIP change was merged, so dropped the duplicate check",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2985786922",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "reviewed",
      "id": 2940800030,
      "node_id": "PRR_kwDOABII586vSQwe",
      "url": null,
      "actor": null,
      "commit_id": "f3c97b81a214724c14d8c8a7db1207f19584db83",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "reACK https://github.com/bitcoin/bitcoin/pull/31244/commits/f3c97b81a214724c14d8c8a7db1207f19584db83",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2940800030",
      "submitted_at": "2025-06-18T21:58:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18218820533,
      "node_id": "RRE_lADOABII586ddsd2zwAAAAQ97SO1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18218820533",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-18T21:58:38Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 18220109288,
      "node_id": "LE_lADOABII586ddsd2zwAAAAQ-AM3o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18220109288",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-19T00:15:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2986098472,
      "node_id": "IC_kwDOABII586x_D8o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2986098472",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-19T00:15:38Z",
      "updated_at": "2025-06-19T00:15:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `tidy`: https://github.com/bitcoin/bitcoin/runs/44377129467</sub>\n<sub>LLM reason (âœ¨ experimental): The CI failure is caused by errors reported by clang-tidy, specifically an unused variable warning treated as an error in descriptor_tests.cpp.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#issuecomment-2986098472",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31244"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18220114280,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ-AOFo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18220114280",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "35a17e5a2e1394cc3f4f5a4f304f58528cb44151",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/35a17e5a2e1394cc3f4f5a4f304f58528cb44151",
      "created_at": "2025-06-19T00:16:16Z"
    },
    {
      "event": "unlabeled",
      "id": 18221055578,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAAQ-Dz5a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18221055578",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-19T02:07:41Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2946388525,
      "node_id": "PRR_kwDOABII586vnlIt",
      "url": null,
      "actor": null,
      "commit_id": "35a17e5a2e1394cc3f4f5a4f304f58528cb44151",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 35a17e5a2e1394cc3f4f5a4f304f58528cb44151 :musical_note: :two: \r\n\r\nVerified that since my previous ACK, the duplicate KEY expression check has been removed (as per BIP390 change https://github.com/bitcoin/bips/pull/1867), test cases were updated accordingly, and the [alternative \"disallow hardened derivation\" suggestion](https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2154811811) was tackled. Just left two code comment nits below, feel free to ignore.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2946388525",
      "submitted_at": "2025-06-20T14:31:34Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18248940608,
      "node_id": "RRE_lADOABII586ddsd2zwAAAAQ_uLxA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18248940608",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-20T14:31:40Z",
      "requested_reviewer": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18252733014,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ_8ppW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18252733014",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a096ff0188be43f5e7555c9d6181e96e7cd84021",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/a096ff0188be43f5e7555c9d6181e96e7cd84021",
      "created_at": "2025-06-20T19:33:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18252736935,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAAQ_8qmn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18252736935",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "created_at": "2025-06-20T19:34:09Z"
    },
    {
      "event": "labeled",
      "id": 18252739014,
      "node_id": "LE_lADOABII586ddsd2zwAAAAQ_8rHG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18252739014",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-20T19:34:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 18253828886,
      "node_id": "UNLE_lADOABII586ddsd2zwAAAARAA1MW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18253828886",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-20T21:29:02Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2947376462,
      "node_id": "PRR_kwDOABII586vrWVO",
      "url": null,
      "actor": null,
      "commit_id": "cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/31244/commits/cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2947376462",
      "submitted_at": "2025-06-20T22:31:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18254278025,
      "node_id": "RRE_lADOABII586ddsd2zwAAAARACi2J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18254278025",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-20T22:31:09Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2947741646,
      "node_id": "PRR_kwDOABII586vsvfO",
      "url": null,
      "actor": null,
      "commit_id": "cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2947741646",
      "submitted_at": "2025-06-21T11:33:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2949984903,
      "node_id": "PRR_kwDOABII586v1TKH",
      "url": null,
      "actor": null,
      "commit_id": "cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code review effe4fcc59bb2f84139bbaee064bfcb72da0baba\r\n\r\nI have completed reviewing the `descriptor: Parse musig() key expressions` commit by going through it in detail and have suggested few naming suggestions if they make sense. \r\n\r\nI'm taking a final look at the `descriptor: Add MuSigPubkeyProvider` commit and the open discussions. Thank you for addressing the comments previously.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2949984903",
      "submitted_at": "2025-06-23T15:51:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2953212032,
      "node_id": "PRR_kwDOABII586wBnCA",
      "url": null,
      "actor": null,
      "commit_id": "cf6e4170fa0529c4c238b7f185fc708e94dec34f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I have finished reviewing the `descriptor: Add MuSigPubkeyProvider` commit - 4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2953212032",
      "submitted_at": "2025-06-24T14:03:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRhZjBkY2EwOTZjYTQ5N2E2YjRlNTMxNGM5ZWRlYTY4M2VmZTYyMGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4af0dca096ca497a6b4e5314c9edea683efe620e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4af0dca096ca497a6b4e5314c9edea683efe620e",
      "tree": {
        "sha": "80e23db2232602ecfeb115d139b4811a2f84c75b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/80e23db2232602ecfeb115d139b4811a2f84c75b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d00d95437dd113a23ccd556c25a77bb04bce23f7",
          "sha": "d00d95437dd113a23ccd556c25a77bb04bce23f7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d00d95437dd113a23ccd556c25a77bb04bce23f7"
        }
      ],
      "message": "descriptor: Add MuSigPubkeyProvider",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-24T20:35:29Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-15T22:10:08Z"
      },
      "sha": "4af0dca096ca497a6b4e5314c9edea683efe620e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk0NzNlOTYwNmNlNzIxMGE4OTEyZmI2ZTgxZTk2YWUzNWZkZmI2YWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9473e9606ce7210a8912fb6e81e96ae35fdfb6ad",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9473e9606ce7210a8912fb6e81e96ae35fdfb6ad",
      "tree": {
        "sha": "4c27325af4b5f4e445f1bcf47ba50ed4d664aa87",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c27325af4b5f4e445f1bcf47ba50ed4d664aa87"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4af0dca096ca497a6b4e5314c9edea683efe620e",
          "sha": "4af0dca096ca497a6b4e5314c9edea683efe620e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4af0dca096ca497a6b4e5314c9edea683efe620e"
        }
      ],
      "message": "descriptors: Move DeriveType parsing into its own function",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-24T20:39:54Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-24T18:43:29Z"
      },
      "sha": "9473e9606ce7210a8912fb6e81e96ae35fdfb6ad"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE1MzkyNGJlZTMyMWY5ZDAxZDA1M2NmNTYyZWUzZDk0OTNlMDA1Mjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a53924bee321f9d01d053cf562ee3d9493e00529",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a53924bee321f9d01d053cf562ee3d9493e00529",
      "tree": {
        "sha": "82a1ee09faa002de4c672b3cd22cd6c90d90706b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/82a1ee09faa002de4c672b3cd22cd6c90d90706b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9473e9606ce7210a8912fb6e81e96ae35fdfb6ad",
          "sha": "9473e9606ce7210a8912fb6e81e96ae35fdfb6ad",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9473e9606ce7210a8912fb6e81e96ae35fdfb6ad"
        }
      ],
      "message": "descriptor: Parse musig() key expressions",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-24T20:40:12Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-15T22:10:25Z"
      },
      "sha": "a53924bee321f9d01d053cf562ee3d9493e00529"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ1NzYwNzlhYjQ3MGRiNGY1MDBkMGYyZGY1ZGRjNzdhYjY1ZTc0Y2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d576079ab470db4f500d0f2df5ddc77ab65e74cc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d576079ab470db4f500d0f2df5ddc77ab65e74cc",
      "tree": {
        "sha": "38169c1173146fcd2eda58463ffac4c0da4ba82c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/38169c1173146fcd2eda58463ffac4c0da4ba82c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a53924bee321f9d01d053cf562ee3d9493e00529",
          "sha": "a53924bee321f9d01d053cf562ee3d9493e00529",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a53924bee321f9d01d053cf562ee3d9493e00529"
        }
      ],
      "message": "tests: Test musig() parsing",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-24T20:43:32Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2024-01-15T22:48:19Z"
      },
      "sha": "d576079ab470db4f500d0f2df5ddc77ab65e74cc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVmZTc5MTVjODY1YThlN2MwYTk1ZWMzNzZkMGYxZmY3MzdmNWQxYzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "tree": {
        "sha": "f72b6ab5d73f34a5785f05f977c9b77c2e73fada",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f72b6ab5d73f34a5785f05f977c9b77c2e73fada"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d576079ab470db4f500d0f2df5ddc77ab65e74cc",
          "sha": "d576079ab470db4f500d0f2df5ddc77ab65e74cc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d576079ab470db4f500d0f2df5ddc77ab65e74cc"
        }
      ],
      "message": "doc: Add musig() example",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-06-24T20:43:32Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-16T19:08:09Z"
      },
      "sha": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18302293597,
      "node_id": "HRFPE_lADOABII586ddsd2zwAAAARC5tZd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18302293597",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "created_at": "2025-06-24T20:43:41Z"
    },
    {
      "event": "reviewed",
      "id": 2955519593,
      "node_id": "PRR_kwDOABII586wKaZp",
      "url": null,
      "actor": null,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "reACK https://github.com/bitcoin/bitcoin/pull/31244/commits/5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2955519593",
      "submitted_at": "2025-06-24T22:08:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18303411766,
      "node_id": "RRE_lADOABII586ddsd2zwAAAARC9-Y2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18303411766",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-24T22:08:44Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2957389841,
      "node_id": "PRR_kwDOABII586wRjAR",
      "url": null,
      "actor": null,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2\r\n\r\nTYVM for patiently addressing all the comments in this big PR!\r\n\r\nIn the `tests: Test musig() parsing` commit, I have looked at all the unit test vectors but I have only glanced through the changes in the `DoCheck` function in the `descriptor_tests` for now.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2957389841",
      "submitted_at": "2025-06-25T12:00:50Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 2958410039,
      "node_id": "PRR_kwDOABII586wVcE3",
      "url": null,
      "actor": null,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2 ðŸŽ¹ \r\n\r\n(as per `$ git range-diff cf6e417...5fe7915`, changes were mostly tackling rkrux' suggestions, which I agree are all improvements ðŸ‘ )\r\nmicro-nit: not worth it now to further invalidate acks, but fwiw, I'm still not a huge fan of cluttering the `ParseKeyPath{,num}` functions with extra booleans to restrict/detect properties that can be trivially detected after and think the previously suggested approach (`IsKeyPathsHardened` helper) was fine.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-2958410039",
      "submitted_at": "2025-06-25T14:23:46Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "reviewed",
      "id": 3016814938,
      "node_id": "PRR_kwDOABII586z0PFa",
      "url": null,
      "actor": null,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed from 4af0dca096ca497a6b4e5314c9edea683efe620e to a53924bee321f9d01d053cf562ee3d9493e00529.\r\n\r\nIn a53924bee321f9d01d053cf562ee3d9493e00529 _descriptor: Parse musig() key expressions_: it might be slightly easier to follow if you extract `& has_hardened`, the `ParsePubkey` signature change and `FromString` changes into their own commit(s).",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#pullrequestreview-3016814938",
      "submitted_at": "2025-07-14T16:32:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
    },
    {
      "event": "review_requested",
      "id": 18621615956,
      "node_id": "RRE_lADOABII586ddsd2zwAAAARV709U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18621615956",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T16:32:32Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061332697",
      "pull_request_review_id": 2796051128,
      "id": 2061332697,
      "node_id": "PRRC_kwDOABII58563XDZ",
      "diff_hunk": "@@ -82,13 +87,21 @@ bool FlatSigningProvider::GetTaprootBuilder(const XOnlyPubKey& output_key, Tapro\n     return LookupHelper(tr_trees, output_key, builder);\n }\n \n+std::vector<CPubKey> FlatSigningProvider::GetAggregateParticipantPubkeys(const CPubKey& pubkey) const\n+{\n+    const auto& it = aggregate_pubkeys.find(pubkey);\n+    if (it == aggregate_pubkeys.end()) return {};\n+    return it->second;",
      "path": "src/script/signingprovider.cpp",
      "position": null,
      "original_position": 20,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "7da3e7bdd050d864a7b46fabb285aefa29ce61fc",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could use `LookupHelper` here (for slightly better readability imho)\r\n```suggestion\r\n    std::vector<CPubKey> participant_pubkeys;\r\n    LookupHelper(aggregate_pubkeys, pubkey, participant_pubkeys);\r\n    return participant_pubkeys;\r\n```",
      "created_at": "2025-04-26T14:20:43Z",
      "updated_at": "2025-04-26T14:39:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2061332697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061332697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061338625",
      "pull_request_review_id": 2796051128,
      "id": 2061338625,
      "node_id": "PRRC_kwDOABII58563YgB",
      "diff_hunk": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <vector>",
      "path": "src/musig.h",
      "position": 11,
      "original_position": 10,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "2e6dcdbc8055660a2e20ba81b62b7d26ae0ccb05",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: should also include ` <optional>`, since it's used for the return types below\r\n```suggestion\r\n#include <optional>\r\n#include <vector>\r\n```",
      "created_at": "2025-04-26T14:27:24Z",
      "updated_at": "2025-04-26T14:39:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2061338625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061338625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 11,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061339360",
      "pull_request_review_id": 2796051128,
      "id": 2061339360,
      "node_id": "PRRC_kwDOABII58563Yrg",
      "diff_hunk": "@@ -580,6 +581,219 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        for (const auto& pubkey : m_participants) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        return false;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "b70531cac94aa125116093c28c65f4c203dca772",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could turn this into a one-liner by using `std::any_of`",
      "created_at": "2025-04-26T14:29:41Z",
      "updated_at": "2025-04-26T14:39:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2061339360",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061339360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 600,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 603,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061339636",
      "pull_request_review_id": 2796051128,
      "id": 2061339636,
      "node_id": "PRRC_kwDOABII58563Yv0",
      "diff_hunk": "@@ -580,6 +581,219 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        for (const auto& pubkey : m_participants) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for all participants\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());\n+        }\n+        return std::make_unique<MuSigPubkeyProvider>(m_expr_index, std::move(providers), m_path, m_derive);\n+    }\n+    bool IsBIP32() const override\n+    {\n+        // musig() can only be a BIP 32 key if all participants are bip32 too\n+        bool all_bip32 = true;\n+        for (const auto& pk : m_participants) {\n+            all_bip32 &= pk->IsBIP32();\n+        }\n+        return all_bip32;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 221,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "b70531cac94aa125116093c28c65f4c203dca772",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could turn this into a one-liner by using `std::all_of`",
      "created_at": "2025-04-26T14:30:30Z",
      "updated_at": "2025-04-26T14:39:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2061339636",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2061339636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 789,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526779",
      "pull_request_review_id": 2823263223,
      "id": 2078526779,
      "node_id": "PRRC_kwDOABII58574807",
      "diff_hunk": "@@ -82,13 +87,21 @@ bool FlatSigningProvider::GetTaprootBuilder(const XOnlyPubKey& output_key, Tapro\n     return LookupHelper(tr_trees, output_key, builder);\n }\n \n+std::vector<CPubKey> FlatSigningProvider::GetAggregateParticipantPubkeys(const CPubKey& pubkey) const\n+{\n+    const auto& it = aggregate_pubkeys.find(pubkey);\n+    if (it == aggregate_pubkeys.end()) return {};\n+    return it->second;",
      "path": "src/script/signingprovider.cpp",
      "position": null,
      "original_position": 20,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "7da3e7bdd050d864a7b46fabb285aefa29ce61fc",
      "in_reply_to_id": 2061332697,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-07T21:33:32Z",
      "updated_at": "2025-05-07T21:33:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2078526779",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526779"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 92,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526898",
      "pull_request_review_id": 2823263381,
      "id": 2078526898,
      "node_id": "PRRC_kwDOABII5857482y",
      "diff_hunk": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <vector>",
      "path": "src/musig.h",
      "position": 11,
      "original_position": 10,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "2e6dcdbc8055660a2e20ba81b62b7d26ae0ccb05",
      "in_reply_to_id": 2061338625,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-07T21:33:40Z",
      "updated_at": "2025-05-07T21:33:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2078526898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 11,
      "original_line": 11,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526958",
      "pull_request_review_id": 2823263492,
      "id": 2078526958,
      "node_id": "PRRC_kwDOABII5857483u",
      "diff_hunk": "@@ -580,6 +581,219 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        for (const auto& pubkey : m_participants) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        return false;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "b70531cac94aa125116093c28c65f4c203dca772",
      "in_reply_to_id": 2061339360,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-07T21:33:44Z",
      "updated_at": "2025-05-07T21:33:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2078526958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 600,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 603,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526998",
      "pull_request_review_id": 2823263567,
      "id": 2078526998,
      "node_id": "PRRC_kwDOABII5857484W",
      "diff_hunk": "@@ -580,6 +581,219 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        for (const auto& pubkey : m_participants) {\n+            if (pubkey->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for all participants\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());\n+        }\n+        return std::make_unique<MuSigPubkeyProvider>(m_expr_index, std::move(providers), m_path, m_derive);\n+    }\n+    bool IsBIP32() const override\n+    {\n+        // musig() can only be a BIP 32 key if all participants are bip32 too\n+        bool all_bip32 = true;\n+        for (const auto& pk : m_participants) {\n+            all_bip32 &= pk->IsBIP32();\n+        }\n+        return all_bip32;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 221,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "b70531cac94aa125116093c28c65f4c203dca772",
      "in_reply_to_id": 2061339636,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-07T21:33:47Z",
      "updated_at": "2025-05-07T21:33:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2078526998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2078526998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 789,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 793,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091162026",
      "pull_request_review_id": 2843677281,
      "id": 2091162026,
      "node_id": "PRRC_kwDOABII5858pJmq",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could add a comment where this constant is coming from (https://github.com/bitcoin/bips/blob/master/bip-0328.mediawiki#cite_note-1)",
      "created_at": "2025-05-15T13:21:16Z",
      "updated_at": "2025-05-15T18:40:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2091162026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091162026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 643,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091770520",
      "pull_request_review_id": 2843677281,
      "id": 2091770520,
      "node_id": "PRRC_kwDOABII5858reKY",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache);\n+std::optional<CPubKey> GetCPubKeyFromMuSig2KeyAggCache(secp256k1_musig_keyagg_cache& cache);",
      "path": "src/musig.h",
      "position": null,
      "original_position": 16,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "895f0c5ca9a12df843f2f7faff37c948046654ea",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "note for other reviewers that might wonder: these two functions and the involved `secp256k1_musig_keyagg_cache` instance are not publicly used within this PR yet, but they will be in #29675 (or any other future PRs that get split up from that one)",
      "created_at": "2025-05-15T18:40:36Z",
      "updated_at": "2025-05-15T18:40:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2091770520",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2091770520"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 15,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092839369",
      "pull_request_review_id": 2846300829,
      "id": 2092839369,
      "node_id": "PRRC_kwDOABII5858vjHJ",
      "diff_hunk": "@@ -286,6 +286,7 @@ class XOnlyPubKey\n      * This is needed for key lookups since keys are indexed by CKeyID.\n      */\n     std::vector<CKeyID> GetKeyIDs() const;\n+    std::vector<CPubKey> GetCPubKeys() const;",
      "path": "src/pubkey.h",
      "position": 10,
      "original_position": 4,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "225b3adbf53e4dfde32a1f798cde30cc41998e3c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 225b3adbf53e4dfde32a1f798cde30cc41998e3c \"XOnlyPubKey: Add GetCPubKeys\": maybe document:\r\n\r\n```cpp\r\n// Return both a version prefixed with 0x02, and one with 0x03.\r\n```\r\n\r\nThe comment inside `GetKeyIDs` could also be moved to the header.",
      "created_at": "2025-05-16T11:05:08Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092839369",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092839369"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092871907",
      "pull_request_review_id": 2846300829,
      "id": 2092871907,
      "node_id": "PRRC_kwDOABII5858vrDj",
      "diff_hunk": "@@ -13,10 +13,10 @@ namespace script {\n \n /** Parse a constant.\n  *\n- * If sp's initial part matches str, sp is updated to skip that part, and true is returned.\n+ * If sp's initial part matches str, sp is optionally updated to skip that part, and true is returned.",
      "path": "src/script/parsing.h",
      "position": 5,
      "original_position": 5,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "fe02d7cb237c00de6abe1776b3101342ffddf757",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In fe02d7cb237c00de6abe1776b3101342ffddf757 \"script/parsing: Allow Const to not skip the found constant\": what does \"sp\" stand for anyway?",
      "created_at": "2025-05-16T11:30:03Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092871907",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092871907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 16,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092880889",
      "pull_request_review_id": 2846300829,
      "id": 2092880889,
      "node_id": "PRRC_kwDOABII5858vtP5",
      "diff_hunk": "@@ -100,18 +100,27 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n  *\n  * If sep does not occur in sp, a singleton with the entirety of sp is returned.\n  *\n+ * @param[in] include_sep Whether to include the separator at the end of the left side of the splits.",
      "path": "src/util/string.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4a1eeee27a64c4be7293740f8fff839879b88d86",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 4a1eeee27a64c4be7293740f8fff839879b88d86 \"util/string: Allow Split to include the separator\": the commit message would be more clear if you use the same wording as in this comment, i.e. \"include the separator at the end of the left side of the splits\".",
      "created_at": "2025-05-16T11:37:01Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092880889",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092880889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 103,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092887857",
      "pull_request_review_id": 2846300829,
      "id": 2092887857,
      "node_id": "PRRC_kwDOABII5858vu8x",
      "diff_hunk": "@@ -100,18 +100,27 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n  *\n  * If sep does not occur in sp, a singleton with the entirety of sp is returned.\n  *\n+ * @param[in] include_sep Whether to include the separator at the end of the left side of the splits.\n+ *\n  * Note that this function does not care about braces, so splitting\n  * \"foo(bar(1),2),3) on ',' will return {\"foo(bar(1)\", \"2)\", \"3)\"}.\n+ *\n+ * If include_sep == true, splitting \"foo(bar(1),2),3) on ','\n+ * will return {\"foo(bar(1),\", \"2),\", \"3)\"}.",
      "path": "src/util/string.h",
      "position": null,
      "original_position": 10,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4a1eeee27a64c4be7293740f8fff839879b88d86",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Also in https://github.com/bitcoin/bitcoin/commit/4a1eeee27a64c4be7293740f8fff839879b88d86, this would be a bit easier to read:\r\n\r\n```\r\n* will return the following strings:\r\n* - foo(bar(1),\r\n* - 2),\r\n* - 3)\r\n```",
      "created_at": "2025-05-16T11:42:18Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092887857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092887857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092892121",
      "pull_request_review_id": 2846300829,
      "id": 2092892121,
      "node_id": "PRRC_kwDOABII5858vv_Z",
      "diff_hunk": "@@ -221,6 +221,9 @@ struct PubkeyProvider\n \n     /** Make a deep copy of this PubkeyProvider */\n     virtual std::unique_ptr<PubkeyProvider> Clone() const = 0;\n+\n+    /** Whether this PubkeyProvider can be a BIP 32 extended key that can be derived from */",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "26c25fed919d2520f561a891236220d54880b079",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 26c25fed919d2520f561a891236220d54880b079 \"descriptors: Add PubkeyProvider::IsBIP32()\": \"can be\" a BIP 32 extended key or \"is\"? In the former case, an additional comment would be useful. ",
      "created_at": "2025-05-16T11:45:35Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092892121",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092892121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092904357",
      "pull_request_review_id": 2846300829,
      "id": 2092904357,
      "node_id": "PRRC_kwDOABII5858vy-l",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache);\n+std::optional<CPubKey> GetCPubKeyFromMuSig2KeyAggCache(secp256k1_musig_keyagg_cache& cache);\n+std::optional<CPubKey> MuSig2AggregatePubkeys(const std::vector<CPubKey>& pubkeys);",
      "path": "src/musig.h",
      "position": 24,
      "original_position": 17,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "895f0c5ca9a12df843f2f7faff37c948046654ea",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 895f0c5ca9a12df843f2f7faff37c948046654ea \"Add MuSig2 Keyagg Cache helper functions\": why is this plural? IIUC there's one aggregate _key_ that's derived from the participant _keys_. If so, then maybe call this `MuSig2DeriveAggregatePubkey()`",
      "created_at": "2025-05-16T11:54:31Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092904357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092904357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092998484",
      "pull_request_review_id": 2846300829,
      "id": 2092998484,
      "node_id": "PRRC_kwDOABII5858wJ9U",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache);",
      "path": "src/musig.h",
      "position": 20,
      "original_position": 15,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "895f0c5ca9a12df843f2f7faff37c948046654ea",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 895f0c5ca9a12df843f2f7faff37c948046654ea \"Add MuSig2 Keyagg Cache helper functions\": although we don't have to copy-paste all libsecp documentation,  I think it's worth mentioning that this doesn't sort pubkeys and the order matters.",
      "created_at": "2025-05-16T12:57:12Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2092998484",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2092998484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 20,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093043309",
      "pull_request_review_id": 2846300829,
      "id": 2093043309,
      "node_id": "PRRC_kwDOABII5858wU5t",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for all participants\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+    std::optional<CPubKey> GetRootPubKey() const override",
      "path": "src/script/descriptor.cpp",
      "position": 229,
      "original_position": 194,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 6b634754d2783ffe16570ad37dbcf9251a7efc24 \"descriptor: Add MuSigPubkeyProvider\": could add a short comment to explain why this doesn't exist",
      "created_at": "2025-05-16T13:22:44Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093043309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093043309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 767,
      "original_line": 767,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093043962",
      "pull_request_review_id": 2846300829,
      "id": 2093043962,
      "node_id": "PRRC_kwDOABII5858wVD6",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for all participants",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 6b634754d2783ffe16570ad37dbcf9251a7efc24 \"descriptor: Add MuSigPubkeyProvider\": do you mean \"all or nothing\" or \"any that we have\"?",
      "created_at": "2025-05-16T13:23:07Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093043962",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093043962"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 759,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093048884",
      "pull_request_review_id": 2846300829,
      "id": 2093048884,
      "node_id": "PRRC_kwDOABII5858wWQ0",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 158,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/6b634754d2783ffe16570ad37dbcf9251a7efc24 \"descriptor: why apostrophe? ðŸ˜¢",
      "created_at": "2025-05-16T13:25:36Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093048884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093048884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 730,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093082286",
      "pull_request_review_id": 2846300829,
      "id": 2093082286,
      "node_id": "PRRC_kwDOABII5858weau",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2091162026,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This constant should probably live in `musig.h`.",
      "created_at": "2025-05-16T13:43:50Z",
      "updated_at": "2025-05-16T13:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093082286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093082286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 643,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093504031",
      "pull_request_review_id": 2847351532,
      "id": 2093504031,
      "node_id": "PRRC_kwDOABII5858yFYf",
      "diff_hunk": "@@ -13,10 +13,10 @@ namespace script {\n \n /** Parse a constant.\n  *\n- * If sp's initial part matches str, sp is updated to skip that part, and true is returned.\n+ * If sp's initial part matches str, sp is optionally updated to skip that part, and true is returned.",
      "path": "src/script/parsing.h",
      "position": 5,
      "original_position": 5,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "fe02d7cb237c00de6abe1776b3101342ffddf757",
      "in_reply_to_id": 2092871907,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "**sp**an?",
      "created_at": "2025-05-16T18:23:31Z",
      "updated_at": "2025-05-16T18:23:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093504031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093504031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 16,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093515670",
      "pull_request_review_id": 2847370495,
      "id": 2093515670,
      "node_id": "PRRC_kwDOABII5858yIOW",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache);\n+std::optional<CPubKey> GetCPubKeyFromMuSig2KeyAggCache(secp256k1_musig_keyagg_cache& cache);\n+std::optional<CPubKey> MuSig2AggregatePubkeys(const std::vector<CPubKey>& pubkeys);",
      "path": "src/musig.h",
      "position": 24,
      "original_position": 17,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "895f0c5ca9a12df843f2f7faff37c948046654ea",
      "in_reply_to_id": 2092904357,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"Aggregate\" is used as an imperative verb here, so it is \"(you,) aggregate (these) pubkeys\"",
      "created_at": "2025-05-16T18:34:13Z",
      "updated_at": "2025-05-16T18:34:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093515670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093515670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093530014",
      "pull_request_review_id": 2847393088,
      "id": 2093530014,
      "node_id": "PRRC_kwDOABII5858yLue",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 158,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2093048884,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It doesn't actually matter, the parameter does nothing as you can't do hardened derivation from the musig aggregate key.",
      "created_at": "2025-05-16T18:46:57Z",
      "updated_at": "2025-05-16T18:46:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093530014",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093530014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 730,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554238",
      "pull_request_review_id": 2847431331,
      "id": 2093554238,
      "node_id": "PRRC_kwDOABII5858yRo-",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 71,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2091162026,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, added to musig.h",
      "created_at": "2025-05-16T19:08:31Z",
      "updated_at": "2025-05-16T19:08:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093554238",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 643,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554514",
      "pull_request_review_id": 2847431738,
      "id": 2093554514,
      "node_id": "PRRC_kwDOABII5858yRtS",
      "diff_hunk": "@@ -286,6 +286,7 @@ class XOnlyPubKey\n      * This is needed for key lookups since keys are indexed by CKeyID.\n      */\n     std::vector<CKeyID> GetKeyIDs() const;\n+    std::vector<CPubKey> GetCPubKeys() const;",
      "path": "src/pubkey.h",
      "position": 10,
      "original_position": 4,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "225b3adbf53e4dfde32a1f798cde30cc41998e3c",
      "in_reply_to_id": 2092839369,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Updated the comments.",
      "created_at": "2025-05-16T19:08:46Z",
      "updated_at": "2025-05-16T19:08:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093554514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 292,
      "original_line": 292,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554645",
      "pull_request_review_id": 2847431931,
      "id": 2093554645,
      "node_id": "PRRC_kwDOABII5858yRvV",
      "diff_hunk": "@@ -100,18 +100,27 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n  *\n  * If sep does not occur in sp, a singleton with the entirety of sp is returned.\n  *\n+ * @param[in] include_sep Whether to include the separator at the end of the left side of the splits.",
      "path": "src/util/string.h",
      "position": 4,
      "original_position": 4,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4a1eeee27a64c4be7293740f8fff839879b88d86",
      "in_reply_to_id": 2092880889,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-16T19:08:53Z",
      "updated_at": "2025-05-16T19:08:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093554645",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 103,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554764",
      "pull_request_review_id": 2847432111,
      "id": 2093554764,
      "node_id": "PRRC_kwDOABII5858yRxM",
      "diff_hunk": "@@ -100,18 +100,27 @@ void ReplaceAll(std::string& in_out, const std::string& search, const std::strin\n  *\n  * If sep does not occur in sp, a singleton with the entirety of sp is returned.\n  *\n+ * @param[in] include_sep Whether to include the separator at the end of the left side of the splits.\n+ *\n  * Note that this function does not care about braces, so splitting\n  * \"foo(bar(1),2),3) on ',' will return {\"foo(bar(1)\", \"2)\", \"3)\"}.\n+ *\n+ * If include_sep == true, splitting \"foo(bar(1),2),3) on ','\n+ * will return {\"foo(bar(1),\", \"2),\", \"3)\"}.",
      "path": "src/util/string.h",
      "position": null,
      "original_position": 10,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4a1eeee27a64c4be7293740f8fff839879b88d86",
      "in_reply_to_id": 2092887857,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-16T19:08:59Z",
      "updated_at": "2025-05-16T19:08:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093554764",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554764"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554945",
      "pull_request_review_id": 2847432400,
      "id": 2093554945,
      "node_id": "PRRC_kwDOABII5858yR0B",
      "diff_hunk": "@@ -221,6 +221,9 @@ struct PubkeyProvider\n \n     /** Make a deep copy of this PubkeyProvider */\n     virtual std::unique_ptr<PubkeyProvider> Clone() const = 0;\n+\n+    /** Whether this PubkeyProvider can be a BIP 32 extended key that can be derived from */",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "26c25fed919d2520f561a891236220d54880b079",
      "in_reply_to_id": 2092892121,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"is\"",
      "created_at": "2025-05-16T19:09:09Z",
      "updated_at": "2025-05-16T19:09:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093554945",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093554945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093555270",
      "pull_request_review_id": 2847432936,
      "id": 2093555270,
      "node_id": "PRRC_kwDOABII5858yR5G",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache);",
      "path": "src/musig.h",
      "position": 20,
      "original_position": 15,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "895f0c5ca9a12df843f2f7faff37c948046654ea",
      "in_reply_to_id": 2092998484,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added comments.",
      "created_at": "2025-05-16T19:09:27Z",
      "updated_at": "2025-05-16T19:09:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093555270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093555270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 20,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093555374",
      "pull_request_review_id": 2847433106,
      "id": 2093555374,
      "node_id": "PRRC_kwDOABII5858yR6u",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for all participants\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+    std::optional<CPubKey> GetRootPubKey() const override",
      "path": "src/script/descriptor.cpp",
      "position": 229,
      "original_position": 194,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2093043309,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-16T19:09:34Z",
      "updated_at": "2025-05-16T19:09:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093555374",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093555374"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 767,
      "original_line": 767,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093555457",
      "pull_request_review_id": 2847433279,
      "id": 2093555457,
      "node_id": "PRRC_kwDOABII5858yR8B",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for all participants",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 187,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2093043962,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "any that we have.",
      "created_at": "2025-05-16T19:09:41Z",
      "updated_at": "2025-05-16T19:09:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2093555457",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2093555457"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 759,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095000787",
      "pull_request_review_id": 2849650680,
      "id": 2095000787,
      "node_id": "PRRC_kwDOABII58583yzT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache);\n+std::optional<CPubKey> GetCPubKeyFromMuSig2KeyAggCache(secp256k1_musig_keyagg_cache& cache);\n+std::optional<CPubKey> MuSig2AggregatePubkeys(const std::vector<CPubKey>& pubkeys);",
      "path": "src/musig.h",
      "position": 24,
      "original_position": 17,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "895f0c5ca9a12df843f2f7faff37c948046654ea",
      "in_reply_to_id": 2092904357,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, it's a verb, then it makes sense.",
      "created_at": "2025-05-19T07:14:21Z",
      "updated_at": "2025-05-19T07:14:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2095000787",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095000787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095003386",
      "pull_request_review_id": 2849655253,
      "id": 2095003386,
      "node_id": "PRRC_kwDOABII58583zb6",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 158,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2093048884,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In that case it's less confusing if you don't pass this argument (as the default is false).",
      "created_at": "2025-05-19T07:16:10Z",
      "updated_at": "2025-05-19T07:16:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2095003386",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095003386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 730,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095044674",
      "pull_request_review_id": 2849720692,
      "id": 2095044674,
      "node_id": "PRRC_kwDOABII585839hC",
      "diff_hunk": "@@ -580,6 +581,212 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode.FromHex(\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\");\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        Assert(pubout.IsValid());\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path, /*apostrophe=*/true);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 158,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "6b634754d2783ffe16570ad37dbcf9251a7efc24",
      "in_reply_to_id": 2093048884,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Update: I see you already did that in 048c95ea55.",
      "created_at": "2025-05-19T07:36:04Z",
      "updated_at": "2025-05-19T07:36:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2095044674",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2095044674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 730,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096234268",
      "pull_request_review_id": 2851595777,
      "id": 2096234268,
      "node_id": "PRRC_kwDOABII58588f8c",
      "diff_hunk": "@@ -580,6 +581,219 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "048c95ea557cf81a8e55c5ffe9994cc9d8f3e039",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 048c95ea557cf81a8e55c5ffe9994cc9d8f3e039: could `Assert` this condition instead, as otherwise the logic suggests that it's possible that neither of the if-branches are executed (it's not, IIUC; the only reason to not have a cached aggregate pubkey at this point is if we have ranged participants, so this condition is always true)\r\n```suggestion\r\n        } else {\r\n            Assert(IsRangedParticipants());\r\n```",
      "created_at": "2025-05-19T17:52:25Z",
      "updated_at": "2025-05-19T18:05:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2096234268",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096234268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 669,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096247242",
      "pull_request_review_id": 2851595777,
      "id": 2096247242,
      "node_id": "PRRC_kwDOABII58588jHK",
      "diff_hunk": "@@ -12,6 +12,10 @@\n \n struct secp256k1_musig_keyagg_cache;\n \n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+constexpr uint256 MUSIG_CHAINCODE{\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\"};",
      "path": "src/musig.h",
      "position": null,
      "original_position": 6,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "048c95ea557cf81a8e55c5ffe9994cc9d8f3e039",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 048c95ea557cf81a8e55c5ffe9994cc9d8f3e039: not too fond of \"reverse-hexstrings of byte-strings\"  creeping in, could do instead\r\n```suggestion\r\nusing namespace util::hex_literals;\r\nconstexpr std::array<uint8_t, 32> MUSIG_CHAINCODE{\"868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965\"_hex_u8};\r\n```\r\nand assign the constant to the uint256 instance via `... = uint256(MUSIG_CHAINCODE)`.\r\n(but shouldn't be a blocker, can be improved in a follow-up as well, if others are even as annoyed by that as me ðŸ˜… )",
      "created_at": "2025-05-19T18:02:18Z",
      "updated_at": "2025-05-19T18:05:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2096247242",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096247242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096297063",
      "pull_request_review_id": 2851697041,
      "id": 2096297063,
      "node_id": "PRRC_kwDOABII58588vRn",
      "diff_hunk": "@@ -12,6 +12,10 @@\n \n struct secp256k1_musig_keyagg_cache;\n \n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+constexpr uint256 MUSIG_CHAINCODE{\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\"};",
      "path": "src/musig.h",
      "position": null,
      "original_position": 6,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "048c95ea557cf81a8e55c5ffe9994cc9d8f3e039",
      "in_reply_to_id": 2096247242,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed it's nice if we can avoid this, because although reviewing the reversal was easy, finding it later with search is tedious.",
      "created_at": "2025-05-19T18:41:39Z",
      "updated_at": "2025-05-19T18:41:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2096297063",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2096297063"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098613575",
      "pull_request_review_id": 2855191524,
      "id": 2098613575,
      "node_id": "PRRC_kwDOABII5859Fk1H",
      "diff_hunk": "@@ -580,6 +581,219 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            Assert(m_aggregate_pubkey.has_value());\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else if (IsRangedParticipants()) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "048c95ea557cf81a8e55c5ffe9994cc9d8f3e039",
      "in_reply_to_id": 2096234268,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, with `Assume`. It's occurred to me that `Assert` in descriptor code is probably not the way to go, so I've changed the couple other `Assert` to `Assume`.",
      "created_at": "2025-05-20T18:24:14Z",
      "updated_at": "2025-05-20T18:24:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2098613575",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098613575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 669,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098614758",
      "pull_request_review_id": 2855193710,
      "id": 2098614758,
      "node_id": "PRRC_kwDOABII5859FlHm",
      "diff_hunk": "@@ -12,6 +12,10 @@\n \n struct secp256k1_musig_keyagg_cache;\n \n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+constexpr uint256 MUSIG_CHAINCODE{\"6589e367712c6200e367717145cb322d76576bc3248959c474f9a602ca878086\"};",
      "path": "src/musig.h",
      "position": null,
      "original_position": 6,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "048c95ea557cf81a8e55c5ffe9994cc9d8f3e039",
      "in_reply_to_id": 2096247242,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It looks like `_hex_u8` can be used directly in uin256's constructor with normal byte order, so used that.",
      "created_at": "2025-05-20T18:24:46Z",
      "updated_at": "2025-05-20T18:24:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2098614758",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098614758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 16,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2099836377",
      "pull_request_review_id": 2857019010,
      "id": 2099836377,
      "node_id": "PRRC_kwDOABII5859KPXZ",
      "diff_hunk": "@@ -0,0 +1,27 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+using namespace util::hex_literals;\n+constexpr uint256 MUSIG_CHAINCODE{\"868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965\"_hex_u8};\n+\n+//! Create a secp56k1_musig_keyagg_cache from the pubkeys in their current order. This is necessary for most MuSig2 operations",
      "path": "src/musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "08d8a59597db34bcddcc1ec5fda98b0b14803170",
      "in_reply_to_id": null,
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "secp56k1 -> secp256k1 [typo in library name]",
      "created_at": "2025-05-21T09:37:19Z",
      "updated_at": "2025-05-21T09:37:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2099836377",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2099836377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100870613",
      "pull_request_review_id": 2858668264,
      "id": 2100870613,
      "node_id": "PRRC_kwDOABII5859OL3V",
      "diff_hunk": "@@ -0,0 +1,27 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_MUSIG_H\n+#define BITCOIN_MUSIG_H\n+\n+#include <pubkey.h>\n+\n+#include <optional>\n+#include <vector>\n+\n+struct secp256k1_musig_keyagg_cache;\n+\n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+using namespace util::hex_literals;\n+constexpr uint256 MUSIG_CHAINCODE{\"868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965\"_hex_u8};\n+\n+//! Create a secp56k1_musig_keyagg_cache from the pubkeys in their current order. This is necessary for most MuSig2 operations",
      "path": "src/musig.h",
      "position": null,
      "original_position": 20,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "08d8a59597db34bcddcc1ec5fda98b0b14803170",
      "in_reply_to_id": 2099836377,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-21T17:55:32Z",
      "updated_at": "2025-05-21T17:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2100870613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100870613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102052043",
      "pull_request_review_id": 2860429843,
      "id": 2102052043,
      "node_id": "PRRC_kwDOABII5859SsTL",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for any participants that we have\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+\n+    // Get RootPubKey and GetRootExtPubKey are used to return the single pubkey underlying the pubkey provider\n+    // to be presented to the user in gethdkeys. As this is a multisig construction, there is no single underlying\n+    // pubkey hence nothing should be returned.\n+    // While the aggregate pubkey could be returned as the root (ext)pubkey, it is not a pubkey that anyone should\n+    // be using by itself in a descriptor as it is unspendable without knowing its participants.\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());",
      "path": "src/script/descriptor.cpp",
      "position": 243,
      "original_position": 215,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 35db4f2dcfc3435e10935581ffa447ffe219cc1e \"descriptor: Add MuSigPubkeyProvider\": no tests break if I delete this loop. What's the typical use case for `Clone()`? Maybe `Check()` in `descriptor_tests.cpp` should do this for all valid descriptors?",
      "created_at": "2025-05-22T09:13:11Z",
      "updated_at": "2025-05-22T10:08:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2102052043",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102052043"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 781,
      "original_line": 781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102121605",
      "pull_request_review_id": 2860429843,
      "id": 2102121605,
      "node_id": "PRRC_kwDOABII5859S9SF",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);",
      "path": "src/script/descriptor.cpp",
      "position": 176,
      "original_position": 148,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 35db4f2dcfc3435e10935581ffa447ffe219cc1e \"descriptor: Add MuSigPubkeyProvider\": could avoid old school `for i`, make it slightly shorter and have the intention be more clear:\r\n\r\n```diff\r\n--- a/src/script/descriptor.cpp\r\n+++ b/src/script/descriptor.cpp\r\n@@ -691,9 +691,9 @@ public:\r\n     std::string ToString(StringType type=StringType::PUBLIC) const override\r\n     {\r\n         std::string out = \"musig(\";\r\n-        for (size_t i = 0; i < m_participants.size(); ++i) {\r\n-            const auto& pubkey = m_participants.at(i);\r\n-            if (i) out += \",\";\r\n+        size_t pos{0};\r\n+        for (const auto& pubkey : m_participants) {\r\n+            if (pos++) out += \",\";\r\n             std::string tmp;\r\n```\r\n\r\nThough it's a not a huge improvement.",
      "created_at": "2025-05-22T09:45:05Z",
      "updated_at": "2025-05-22T10:08:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2102121605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102121605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 714,
      "original_line": 714,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102178194",
      "pull_request_review_id": 2860429843,
      "id": 2102178194,
      "node_id": "PRRC_kwDOABII5859TLGS",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it",
      "path": "src/script/descriptor.cpp",
      "position": 86,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 35db4f2dcfc3435e10935581ffa447ffe219cc1e \"descriptor: Add MuSigPubkeyProvider\": just to check my own understanding, by ranged participants you mean the case of `musig(alice/*, bob)`, i.e. derivation before aggregation?\r\n\r\nI assume that if the participants are ranged, then you can't also have a range after derivation, e.g. `musig(alice/*, bob)/*` isn't allowed. Where do we check this?",
      "created_at": "2025-05-22T10:08:30Z",
      "updated_at": "2025-05-22T10:08:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2102178194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2102178194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 624,
      "original_line": 624,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103137795",
      "pull_request_review_id": 2862155531,
      "id": 2103137795,
      "node_id": "PRRC_kwDOABII5859W1YD",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for any participants that we have\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+\n+    // Get RootPubKey and GetRootExtPubKey are used to return the single pubkey underlying the pubkey provider\n+    // to be presented to the user in gethdkeys. As this is a multisig construction, there is no single underlying\n+    // pubkey hence nothing should be returned.\n+    // While the aggregate pubkey could be returned as the root (ext)pubkey, it is not a pubkey that anyone should\n+    // be using by itself in a descriptor as it is unspendable without knowing its participants.\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());",
      "path": "src/script/descriptor.cpp",
      "position": 243,
      "original_position": 215,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102052043,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It is used for multipath descriptors, tests of which are added 2 commits later. We do not (and cannot) directly test the actual `DescriptorImpl` and `PubkeyProvider` classes; all of the unit tests start with a descriptor string that has to be parsed. The parsing is implemented in the next commit (because the `PubkeyProvider` it uses needs to exist before parsing can construct the object), and tests for everything in the following commit.",
      "created_at": "2025-05-22T18:09:58Z",
      "updated_at": "2025-05-22T18:13:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2103137795",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103137795"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 781,
      "original_line": 781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103139861",
      "pull_request_review_id": 2862159152,
      "id": 2103139861,
      "node_id": "PRRC_kwDOABII5859W14V",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);",
      "path": "src/script/descriptor.cpp",
      "position": 176,
      "original_position": 148,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102121605,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I find that harder to read. `for i` is used here because we need the position.",
      "created_at": "2025-05-22T18:11:03Z",
      "updated_at": "2025-05-22T18:11:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2103139861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103139861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 714,
      "original_line": 714,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103140839",
      "pull_request_review_id": 2862161280,
      "id": 2103140839,
      "node_id": "PRRC_kwDOABII5859W2Hn",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it",
      "path": "src/script/descriptor.cpp",
      "position": 86,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102178194,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In the next commit which implements parsing. Enforcement of the descriptor constraints is usually at the parsing level as it is not possible create these classes outside of the descriptor module.",
      "created_at": "2025-05-22T18:11:26Z",
      "updated_at": "2025-05-22T18:14:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2103140839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103140839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 624,
      "original_line": 624,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104017923",
      "pull_request_review_id": 2863524960,
      "id": 2104017923,
      "node_id": "PRRC_kwDOABII5859aMQD",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for any participants that we have\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+\n+    // Get RootPubKey and GetRootExtPubKey are used to return the single pubkey underlying the pubkey provider\n+    // to be presented to the user in gethdkeys. As this is a multisig construction, there is no single underlying\n+    // pubkey hence nothing should be returned.\n+    // While the aggregate pubkey could be returned as the root (ext)pubkey, it is not a pubkey that anyone should\n+    // be using by itself in a descriptor as it is unspendable without knowing its participants.\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());",
      "path": "src/script/descriptor.cpp",
      "position": 243,
      "original_position": 215,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102052043,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just to clarify my initial comment: I can remove this loop _in the final version of this PR_ without breaking any test.",
      "created_at": "2025-05-23T07:45:09Z",
      "updated_at": "2025-05-23T07:45:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2104017923",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104017923"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 781,
      "original_line": 781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104022638",
      "pull_request_review_id": 2863532394,
      "id": 2104022638,
      "node_id": "PRRC_kwDOABII5859aNZu",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it",
      "path": "src/script/descriptor.cpp",
      "position": 86,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102178194,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Being able to generate a (derived) descriptor without parsing is still on my wish list: https://github.com/bitcoin/bitcoin/issues/24003\r\n\r\nBut even in that case it could generate, convert to string and then re-parse as a sanity check.",
      "created_at": "2025-05-23T07:48:13Z",
      "updated_at": "2025-05-23T07:48:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2104022638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104022638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 624,
      "original_line": 624,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104489088",
      "pull_request_review_id": 2864248620,
      "id": 2104489088,
      "node_id": "PRRC_kwDOABII5859b_SA",
      "diff_hunk": "@@ -12,6 +12,11 @@\n \n struct secp256k1_musig_keyagg_cache;\n \n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+using namespace util::hex_literals;\n+constexpr uint256 MUSIG_CHAINCODE{\"868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965\"_hex_u8};",
      "path": "src/musig.h",
      "position": null,
      "original_position": 7,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 35db4f2dcfc3435e10935581ffa447ffe219cc1e: the byteswap comment is obsolete now\r\n```suggestion\r\n//! MuSig2 chaincode as defined by BIP 328\r\nusing namespace util::hex_literals;\r\nconstexpr uint256 MUSIG_CHAINCODE{\"868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965\"_hex_u8};\r\n```",
      "created_at": "2025-05-23T12:29:53Z",
      "updated_at": "2025-05-23T13:21:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2104489088",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104489088"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 15,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104493385",
      "pull_request_review_id": 2864248620,
      "id": 2104493385,
      "node_id": "PRRC_kwDOABII5859cAVJ",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 35db4f2dcfc3435e10935581ffa447ffe219cc1e: nit, could use the helper here:\r\n```suggestion\r\n            if (IsRangedDerivation() || !m_path.empty()) {\r\n```",
      "created_at": "2025-05-23T12:32:31Z",
      "updated_at": "2025-05-23T13:21:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2104493385",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104493385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104518220",
      "pull_request_review_id": 2864248620,
      "id": 2104518220,
      "node_id": "PRRC_kwDOABII5859cGZM",
      "diff_hunk": "@@ -1653,7 +1658,7 @@ std::optional<uint32_t> ParseKeyPathNum(std::span<const char> elem, bool& apostr\n  * @param[in] allow_multipath Allows the parsed path to use the multipath specifier\n  * @returns false if parsing failed\n  **/\n-[[nodiscard]] bool ParseKeyPath(const std::vector<std::span<const char>>& split, std::vector<KeyPath>& out, bool& apostrophe, std::string& error, bool allow_multipath)\n+[[nodiscard]] bool ParseKeyPath(const std::vector<std::span<const char>>& split, std::vector<KeyPath>& out, bool& apostrophe, std::string& error, bool allow_multipath, bool allow_hardened = true)",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 26,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "739f13986a49d8d7d5568ebcdd88665ea8423d42",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 739f13986a49d8d7d5568ebcdd88665ea8423d42: could add a doxygen comment for the newly introduced parameter",
      "created_at": "2025-05-23T12:47:43Z",
      "updated_at": "2025-05-23T13:21:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2104518220",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104518220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1660,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104576393",
      "pull_request_review_id": 2864248620,
      "id": 2104576393,
      "node_id": "PRRC_kwDOABII5859cUmJ",
      "diff_hunk": "@@ -1802,9 +1807,153 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)",
      "path": "src/script/descriptor.cpp",
      "position": 362,
      "original_position": 54,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "739f13986a49d8d7d5568ebcdd88665ea8423d42",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is the `key_exp_index` parameter changed to pass by reference? Without that the unit tests fail, so it seems necessary, but I'm confused why this was not needed earlier already for similar constructs (e.g. for `multi()` expressions where the value is also incremented in the key expression parsing loop). Probably I'm missing some basic descriptors parsing knowledge.",
      "created_at": "2025-05-23T13:20:02Z",
      "updated_at": "2025-05-23T13:21:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2104576393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104576393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1815,
      "original_line": 1815,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211527",
      "pull_request_review_id": 2865366499,
      "id": 2105211527,
      "node_id": "PRRC_kwDOABII5859evqH",
      "diff_hunk": "@@ -1802,9 +1807,153 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)",
      "path": "src/script/descriptor.cpp",
      "position": 362,
      "original_position": 54,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "739f13986a49d8d7d5568ebcdd88665ea8423d42",
      "in_reply_to_id": 2104576393,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`musig()` expressions are a key expression, which itself contains multiple key expressions. It needs to be able to increment `key_exp_index` such that the caller will also know what the `key_exp_index` has been incremented to. The easiest way to do this was a reference.",
      "created_at": "2025-05-23T18:27:08Z",
      "updated_at": "2025-05-23T18:27:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2105211527",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1815,
      "original_line": 1815,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211725",
      "pull_request_review_id": 2865366773,
      "id": 2105211725,
      "node_id": "PRRC_kwDOABII5859evtN",
      "diff_hunk": "@@ -12,6 +12,11 @@\n \n struct secp256k1_musig_keyagg_cache;\n \n+//! MuSig2 chaincode as defined by BIP 328\n+//! uint256 will byteswap the hex\n+using namespace util::hex_literals;\n+constexpr uint256 MUSIG_CHAINCODE{\"868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965\"_hex_u8};",
      "path": "src/musig.h",
      "position": null,
      "original_position": 7,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2104489088,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-23T18:27:18Z",
      "updated_at": "2025-05-23T18:27:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2105211725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 15,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211791",
      "pull_request_review_id": 2865366895,
      "id": 2105211791,
      "node_id": "PRRC_kwDOABII5859evuP",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2104493385,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-23T18:27:23Z",
      "updated_at": "2025-05-23T18:27:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2105211791",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211849",
      "pull_request_review_id": 2865366978,
      "id": 2105211849,
      "node_id": "PRRC_kwDOABII5859evvJ",
      "diff_hunk": "@@ -1653,7 +1658,7 @@ std::optional<uint32_t> ParseKeyPathNum(std::span<const char> elem, bool& apostr\n  * @param[in] allow_multipath Allows the parsed path to use the multipath specifier\n  * @returns false if parsing failed\n  **/\n-[[nodiscard]] bool ParseKeyPath(const std::vector<std::span<const char>>& split, std::vector<KeyPath>& out, bool& apostrophe, std::string& error, bool allow_multipath)\n+[[nodiscard]] bool ParseKeyPath(const std::vector<std::span<const char>>& split, std::vector<KeyPath>& out, bool& apostrophe, std::string& error, bool allow_multipath, bool allow_hardened = true)",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 26,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "739f13986a49d8d7d5568ebcdd88665ea8423d42",
      "in_reply_to_id": 2104518220,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-05-23T18:27:27Z",
      "updated_at": "2025-05-23T18:27:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2105211849",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105211849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1660,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105280293",
      "pull_request_review_id": 2865482451,
      "id": 2105280293,
      "node_id": "PRRC_kwDOABII5859fAcl",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (m_derive != DeriveType::NO || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for any participants that we have\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+\n+    // Get RootPubKey and GetRootExtPubKey are used to return the single pubkey underlying the pubkey provider\n+    // to be presented to the user in gethdkeys. As this is a multisig construction, there is no single underlying\n+    // pubkey hence nothing should be returned.\n+    // While the aggregate pubkey could be returned as the root (ext)pubkey, it is not a pubkey that anyone should\n+    // be using by itself in a descriptor as it is unspendable without knowing its participants.\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());",
      "path": "src/script/descriptor.cpp",
      "position": 243,
      "original_position": 215,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102052043,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah. I've added a test which exercises this code.",
      "created_at": "2025-05-23T19:19:36Z",
      "updated_at": "2025-05-23T19:19:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2105280293",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2105280293"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 781,
      "original_line": 781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2107645746",
      "pull_request_review_id": 2868881729,
      "id": 2107645746,
      "node_id": "PRRC_kwDOABII5859oB8y",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it",
      "path": "src/script/descriptor.cpp",
      "position": 86,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102178194,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I assume that if the participants are ranged, then you can't also have a range after derivation, e.g. musig(alice/\\*, bob)/\\* isn't allowed. Where do we check this?\r\n\r\n> In the next commit which implements parsing. Enforcement of the descriptor constraints is usually at the parsing level as it is not possible create these classes outside of the descriptor module.\r\n\r\nAs an additional belt-and-suspenders and documentation, would a corresponding assertion (or `Assume`) in the MuSig2PubkeyProvider ctor make sense? E.g. something like\r\n```diff\r\ndiff --git a/src/script/descriptor.cpp b/src/script/descriptor.cpp\r\nindex 04ba832ffc..92dcf73755 100644\r\n--- a/src/script/descriptor.cpp\r\n+++ b/src/script/descriptor.cpp\r\n@@ -611,7 +611,10 @@ public:\r\n         m_participants(std::move(providers)),\r\n         m_path(std::move(path)),\r\n         m_derive(derive)\r\n-    {}\r\n+    {\r\n+        /* if participants are already ranged, further derivation after pubkey aggregation isn't allowed */\r\n+        Assert(!(IsRangedParticipants() && IsRangedDerivation()));\r\n+    }\r\n \r\n     std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\r\n     {\r\n```",
      "created_at": "2025-05-26T16:45:10Z",
      "updated_at": "2025-05-26T16:45:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2107645746",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2107645746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 624,
      "original_line": 624,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2107649960",
      "pull_request_review_id": 2868887368,
      "id": 2107649960,
      "node_id": "PRRC_kwDOABII5859oC-o",
      "diff_hunk": "@@ -1802,9 +1807,153 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)",
      "path": "src/script/descriptor.cpp",
      "position": 362,
      "original_position": 54,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "739f13986a49d8d7d5568ebcdd88665ea8423d42",
      "in_reply_to_id": 2104576393,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That makes sense. I only realize now that I was talking about code paths in two different functions (`ParsePubkey` vs `ParseScript`; for the latter the `key_exp_index` argument was already passed by reference).",
      "created_at": "2025-05-26T16:50:18Z",
      "updated_at": "2025-05-26T16:50:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2107649960",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2107649960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1815,
      "original_line": 1815,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2107728700",
      "pull_request_review_id": 2868994393,
      "id": 2107728700,
      "node_id": "PRRC_kwDOABII5859oWM8",
      "diff_hunk": "@@ -580,6 +581,220 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {}\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it",
      "path": "src/script/descriptor.cpp",
      "position": 86,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "35db4f2dcfc3435e10935581ffa447ffe219cc1e",
      "in_reply_to_id": 2102178194,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added an `Assume`.",
      "created_at": "2025-05-26T18:28:54Z",
      "updated_at": "2025-05-26T18:28:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2107728700",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2107728700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 624,
      "original_line": 624,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109115291",
      "pull_request_review_id": 2870961667,
      "id": 2109115291,
      "node_id": "PRRC_kwDOABII5859toub",
      "diff_hunk": "@@ -574,6 +581,224 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participatns and ranged derivation\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "e1475cbd0d477cd8e04348e839dbc3dff1374a44",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\r\n    participatns -> participants [correct misspelling in error message]\r\n",
      "created_at": "2025-05-27T12:54:54Z",
      "updated_at": "2025-05-27T12:54:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2109115291",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109115291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 616,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109683327",
      "pull_request_review_id": 2871820534,
      "id": 2109683327,
      "node_id": "PRRC_kwDOABII5859vzZ_",
      "diff_hunk": "@@ -580,6 +581,224 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participatns and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 138,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "ff7476ec32f4dbee07bf04169e741e2aea5a9ab7",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit ff7476ec32f4dbee07bf04169e741e2aea5a9ab7: can't this be simplified to\r\n```suggestion\r\n            out += pubkey->ToString(type);\r\n```\r\n? It's a bit confusing that there are two `StringType` enum classes within different classes, (`PubkeyProvider::StringType` and `DescriptorImpl::StringType`), but the code here seems to deal only with the former. I guess whether the diff makes sense or not depends on if it's possible in the future that the default arguments for pubkey providers `ToString(...)` method is ever changed from `StringType::PUBLIC` to something else. The unit tests still seem to pass at least.",
      "created_at": "2025-05-27T16:44:37Z",
      "updated_at": "2025-05-27T17:26:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2109683327",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109683327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 701,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109851713",
      "pull_request_review_id": 2872078210,
      "id": 2109851713,
      "node_id": "PRRC_kwDOABII5859wchB",
      "diff_hunk": "@@ -574,6 +581,224 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participatns and ranged derivation\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "e1475cbd0d477cd8e04348e839dbc3dff1374a44",
      "in_reply_to_id": 2109115291,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed",
      "created_at": "2025-05-27T18:13:35Z",
      "updated_at": "2025-05-27T18:13:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2109851713",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109851713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 616,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109851898",
      "pull_request_review_id": 2872078461,
      "id": 2109851898,
      "node_id": "PRRC_kwDOABII5859wcj6",
      "diff_hunk": "@@ -580,6 +581,224 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participatns and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(IsRangedParticipants())) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || IsRangedParticipants(); }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            switch (type) {\n+                case StringType::PUBLIC:\n+                    tmp = pubkey->ToString();\n+                    break;\n+                case StringType::COMPAT:\n+                    tmp = pubkey->ToString(PubkeyProvider::StringType::COMPAT);\n+                    break;\n+            }\n+            out += tmp;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 138,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "ff7476ec32f4dbee07bf04169e741e2aea5a9ab7",
      "in_reply_to_id": 2109683327,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, done.",
      "created_at": "2025-05-27T18:13:42Z",
      "updated_at": "2025-05-27T18:13:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2109851898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2109851898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 701,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123695013",
      "pull_request_review_id": 2892172589,
      "id": 2123695013,
      "node_id": "PRRC_kwDOABII585-lQOl",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "16a88829e92c2676cae6b6e0acb75d2d26795a6d",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 16a88829e92c2676cae6b6e0acb75d2d26795a6d:\r\n```suggestion\r\n    //! Derivation path\r\n    const KeyPath m_path;\r\n```\r\nas using non-ranged derivation is also possible (e.g. `musig(...)/1`, we also have a [test for that](https://github.com/achow101/bitcoin/blob/afcd397bc791d047508adb9d151d21384d7b49e3/src/test/descriptor_tests.cpp#L1118)); the BIP 390 specification can be interpreted in a way that only ranged derivation is possible though (https://github.com/bitcoin/bips/blob/master/bip-0390.mediawiki#user-content-Specification), maybe something that could be improved there?",
      "created_at": "2025-06-03T12:42:37Z",
      "updated_at": "2025-06-03T13:27:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2123695013",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123695013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 590,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 591,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123760984",
      "pull_request_review_id": 2892172589,
      "id": 2123760984,
      "node_id": "PRRC_kwDOABII585-lgVY",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 9e3a1d05bf066df31a6e124638046e70669eb470: nit: the `Expr` call seems to be a no-op here, considering that we already extracted the function expression with the parens-splitting above\r\n```suggestion\r\n        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\r\n        if (!Func(\"musig\", expr)) {\r\n```\r\n\r\n",
      "created_at": "2025-06-03T13:07:49Z",
      "updated_at": "2025-06-03T13:27:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2123760984",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123760984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1828,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1837,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123779414",
      "pull_request_review_id": 2892172589,
      "id": 2123779414,
      "node_id": "PRRC_kwDOABII585-lk1W",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): Ranged musig() requires all participants to be xpubs\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 129,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 9e3a1d05bf066df31a6e124638046e70669eb470: should this be \r\n```suggestion\r\n            if (!all_bip32) {\r\n                error = \"musig(): musig() derivation requires all participants to be xpubs\";\r\n```\r\ninstead? Ranged would mean ending with `/*` IIUC, which is not necessarily the case.\r\n",
      "created_at": "2025-06-03T13:15:37Z",
      "updated_at": "2025-06-03T13:27:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2123779414",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123779414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1878,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1879,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123808039",
      "pull_request_review_id": 2892172589,
      "id": 2123808039,
      "node_id": "PRRC_kwDOABII585-lr0n",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 9e3a1d05bf066df31a6e124638046e70669eb470: nit: A more thorough check would be to detect duplicates of actual resulting pubkeys, rather than only the expression strings (i.e. for a keypair `(priv,pub)`, the expression `musig(priv,pub)` would now still be valid).",
      "created_at": "2025-06-03T13:25:30Z",
      "updated_at": "2025-06-03T13:27:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2123808039",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2123808039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124891874",
      "pull_request_review_id": 2894064140,
      "id": 2124891874,
      "node_id": "PRRC_kwDOABII585-p0bi",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Checking for duplicates is actually a bit more complicated, and I'm thinking now that it would probably be easier to allow duplicates.\r\n\r\nThere are some scenarios where I think it's ambiguous whether they should be allowed. For example, would `musig(xpub/1,xpub/*)` be allowed? The same pubkey would appear twice for exactly one index.",
      "created_at": "2025-06-03T20:43:35Z",
      "updated_at": "2025-06-03T20:43:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2124891874",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124891874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124941224",
      "pull_request_review_id": 2894138969,
      "id": 2124941224,
      "node_id": "PRRC_kwDOABII585-qAeo",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path if this is ranged\n+    const KeyPath m_path;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "16a88829e92c2676cae6b6e0acb75d2d26795a6d",
      "in_reply_to_id": 2123695013,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-03T21:14:37Z",
      "updated_at": "2025-06-03T21:14:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2124941224",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124941224"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 590,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 591,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124941299",
      "pull_request_review_id": 2894139100,
      "id": 2124941299,
      "node_id": "PRRC_kwDOABII585-qAfz",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123760984,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-03T21:14:41Z",
      "updated_at": "2025-06-03T21:14:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2124941299",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124941299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1828,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1837,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124941401",
      "pull_request_review_id": 2894139259,
      "id": 2124941401,
      "node_id": "PRRC_kwDOABII585-qAhZ",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): Ranged musig() requires all participants to be xpubs\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 129,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123779414,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-03T21:14:46Z",
      "updated_at": "2025-06-03T21:14:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2124941401",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2124941401"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1878,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1879,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2125949575",
      "pull_request_review_id": 2895704122,
      "id": 2125949575,
      "node_id": "PRRC_kwDOABII585-t2qH",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You could also be more strict and disallow any duplicate non-hardened path. Or even duplicate origin fingerprint.\r\n\r\nThe bigger problem may be that whatever we choose might be slightly different than what implementations do. So we should probably change the descriptor standard to pick an extreme on either side: allow duplicate keys or more thorowly prevent them.",
      "created_at": "2025-06-04T07:59:56Z",
      "updated_at": "2025-06-04T07:59:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2125949575",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2125949575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126630415",
      "pull_request_review_id": 2896780371,
      "id": 2126630415,
      "node_id": "PRRC_kwDOABII585-wc4P",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n- \"musig() is only allowed in tr()\"\r\n+ \"musig() is allowed in only tr() and rawtr()\"\r\n```",
      "created_at": "2025-06-04T13:38:09Z",
      "updated_at": "2025-06-04T14:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126630415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126630415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1817,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126634254",
      "pull_request_review_id": 2896780371,
      "id": 2126634254,
      "node_id": "PRRC_kwDOABII585-wd0O",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): musig() derivation requires all participants to be xpubs\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 127,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n- musig(): musig() derivation requires all participants to be xpubs\r\n+ musig(): derivation requires all participants to be xpubs or xprvs\r\n```",
      "created_at": "2025-06-04T13:39:58Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126634254",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126634254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1877,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126642131",
      "pull_request_review_id": 2896780371,
      "id": 2126642131,
      "node_id": "PRRC_kwDOABII585-wfvT",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Bitwise operations on bools, sorry to be the one raising this multiple times. :)",
      "created_at": "2025-06-04T13:43:17Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126642131",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126642131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1859,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126663894",
      "pull_request_review_id": 2896780371,
      "id": 2126663894,
      "node_id": "PRRC_kwDOABII585-wlDW",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> There are some scenarios where I think it's ambiguous whether they should be allowed.\r\n\r\n\"Repeated participant public keys are not allowed. The aggregate public key is produced by using the KeyAgg algorithm on all KEYs specified in the expression after performing all specified derivation.\"\r\n\r\nThe current language^ in [BIP 390](https://github.com/bitcoin/bips/blob/master/bip-0390.mediawiki) gives me an impression that the public key derived from the KEY expression should not be repeated that subsequently leads me to believe that the current check, which operates on string key expressions, is brittle.\r\n\r\n> So we should probably change the descriptor standard to pick an extreme on either side\r\n\r\nAgree, picking a side will lead to certainty.",
      "created_at": "2025-06-04T13:52:35Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126663894",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126663894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126684020",
      "pull_request_review_id": 2896780371,
      "id": 2126684020,
      "node_id": "PRRC_kwDOABII585-wp90",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): musig() derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+                if (any_ranged) {\n+                    error = \"musig(): Cannot have ranged participant keys if musig() is also ranged\";\n+                    return {};\n+                }\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true, /*allow_hardened=*/false)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";",
      "path": "src/script/descriptor.cpp",
      "position": 481,
      "original_position": 179,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Currently, [BIP 390](https://github.com/bitcoin/bips/blob/master/bip-0390.mediawiki) doesn't have a mention of multipath participant keys. As per [BIP 389](https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki):\r\n\r\n> Descriptors that contain multiple Key Expressions that each have a /<NUM;NUM;...;NUM> must have tuples of exactly the same length so that they are derived in lockstep in the same way that /* paths in multiple Key expressions are handled.\r\n\r\nBy using this lockstep approach, I believe technically multipath derivations for musig can be done. Is it not allowed because it doesn't seem as needed? ",
      "created_at": "2025-06-04T14:00:54Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126684020",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126684020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1934,
      "original_line": 1934,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126695356",
      "pull_request_review_id": 2896780371,
      "id": 2126695356,
      "node_id": "PRRC_kwDOABII585-wsu8",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`IsRangedParticipants` is called multiple times in this class, can evaluate it once in the constructor itself and store the result in a const because I don't suppose a `MuSigPubkeyProvider` is updated with more `m_participants` after creation.",
      "created_at": "2025-06-04T14:06:01Z",
      "updated_at": "2025-06-04T14:33:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126695356",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126695356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 598,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 601,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126700491",
      "pull_request_review_id": 2896780371,
      "id": 2126700491,
      "node_id": "PRRC_kwDOABII585-wt_L",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive",
      "path": "src/script/descriptor.cpp",
      "position": 67,
      "original_position": 36,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can add `Assume` and throw if the derivation type is hardened, it's not allowed because IIUC, `m_derive` refers to the derivation type of this musig provider only.",
      "created_at": "2025-06-04T14:08:10Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126700491",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126700491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 605,
      "original_line": 605,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126702224",
      "pull_request_review_id": 2896780371,
      "id": 2126702224,
      "node_id": "PRRC_kwDOABII585-wuaQ",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 96,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n- Either way, we can passthrough to it's GetPubKey\r\n+ Either way, we can passthrough to its GetPubKey\r\n```",
      "created_at": "2025-06-04T14:08:55Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126702224",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126702224"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 668,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126734205",
      "pull_request_review_id": 2896780371,
      "id": 2126734205,
      "node_id": "PRRC_kwDOABII585-w2N9",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 82,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: The calculation of aggregate public key & its provider can be done in the constructor itself unless it's anticipated that for some reason dummy MuSigPubkeyProviders will be used later.",
      "created_at": "2025-06-04T14:20:54Z",
      "updated_at": "2025-06-04T14:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126734205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126734205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 623,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 655,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126952270",
      "pull_request_review_id": 2897310198,
      "id": 2126952270,
      "node_id": "PRRC_kwDOABII585-xrdO",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> allow duplicate keys or more thorowly prevent them.\r\n\r\nYes, I've suggest to the [mailing list](https://groups.google.com/g/bitcoindev/c/SSpyvbD9CMg) that we should allow the duplicate keys. Still checking with cryptographers that that will be okay, particularly since PSBT doesn't allow duplicate participants to use different pubnonces and partial sigs.",
      "created_at": "2025-06-04T15:59:25Z",
      "updated_at": "2025-06-04T15:59:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126952270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126952270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127435207",
      "pull_request_review_id": 2898097424,
      "id": 2127435207,
      "node_id": "PRRC_kwDOABII585-zhXH",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): musig() derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+                if (any_ranged) {\n+                    error = \"musig(): Cannot have ranged participant keys if musig() is also ranged\";\n+                    return {};\n+                }\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true, /*allow_hardened=*/false)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";",
      "path": "src/script/descriptor.cpp",
      "position": 481,
      "original_position": 179,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": 2126684020,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since multipath is similar to ranged expansion, I've applied the same restrictions that are on ranged to multipath as well. I suppose this should be mentioned in the BIP.",
      "created_at": "2025-06-04T21:02:45Z",
      "updated_at": "2025-06-04T21:02:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127435207",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127435207"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1934,
      "original_line": 1934,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127464652",
      "pull_request_review_id": 2898145044,
      "id": 2127464652,
      "node_id": "PRRC_kwDOABII585-zojM",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 82,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": 2126734205,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's deferred to `GetPubKey` as the participants may involve hardened derivation which requires private keys that the constructor doesn't have access to.",
      "created_at": "2025-06-04T21:22:48Z",
      "updated_at": "2025-06-04T21:22:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127464652",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127464652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 623,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 655,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475291",
      "pull_request_review_id": 2898161838,
      "id": 2127475291,
      "node_id": "PRRC_kwDOABII585-zrJb",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": 2126630415,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-04T21:31:43Z",
      "updated_at": "2025-06-04T21:31:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127475291",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1817,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475367",
      "pull_request_review_id": 2898161937,
      "id": 2127475367,
      "node_id": "PRRC_kwDOABII585-zrKn",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): musig() derivation requires all participants to be xpubs\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 127,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": 2126634254,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-04T21:31:47Z",
      "updated_at": "2025-06-04T21:31:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127475367",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1877,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475461",
      "pull_request_review_id": 2898162330,
      "id": 2127475461,
      "node_id": "PRRC_kwDOABII585-zrMF",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": 2126642131,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-04T21:31:51Z",
      "updated_at": "2025-06-04T21:31:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127475461",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475461"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1859,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475603",
      "pull_request_review_id": 2898162701,
      "id": 2127475603,
      "node_id": "PRRC_kwDOABII585-zrOT",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": 2126695356,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-04T21:31:57Z",
      "updated_at": "2025-06-04T21:31:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127475603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 598,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 601,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475727",
      "pull_request_review_id": 2898163054,
      "id": 2127475727,
      "node_id": "PRRC_kwDOABII585-zrQP",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive",
      "path": "src/script/descriptor.cpp",
      "position": 67,
      "original_position": 36,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": 2126700491,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-04T21:32:02Z",
      "updated_at": "2025-06-04T21:32:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127475727",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475727"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 605,
      "original_line": 605,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475822",
      "pull_request_review_id": 2898163216,
      "id": 2127475822,
      "node_id": "PRRC_kwDOABII585-zrRu",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to it's GetPubKey",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 96,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": 2126702224,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-04T21:32:06Z",
      "updated_at": "2025-06-04T21:32:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2127475822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2127475822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 668,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128825473",
      "pull_request_review_id": 2900283699,
      "id": 2128825473,
      "node_id": "PRRC_kwDOABII585-40yB",
      "diff_hunk": "@@ -1797,9 +1803,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged |= pk.at(0)->IsRange();\n+            all_bip32 &= pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): musig() derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+                if (any_ranged) {\n+                    error = \"musig(): Cannot have ranged participant keys if musig() is also ranged\";\n+                    return {};\n+                }\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true, /*allow_hardened=*/false)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";",
      "path": "src/script/descriptor.cpp",
      "position": 481,
      "original_position": 179,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8a2dc4662c816dcf7c845f55f69dbcd5c7267a66",
      "in_reply_to_id": 2126684020,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I raised a PR for it here: https://github.com/bitcoin/bips/pull/1866",
      "created_at": "2025-06-05T13:12:17Z",
      "updated_at": "2025-06-05T13:12:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2128825473",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128825473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1934,
      "original_line": 1934,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128930669",
      "pull_request_review_id": 2900467330,
      "id": 2128930669,
      "node_id": "PRRC_kwDOABII585-5Odt",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In [BIP 327](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki), the paragraph starting from [here](https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#:~:text=The%20same%20individual%20public%20key%20is%20allowed%20to%20occur%20more%20than%20once%20in%20the%20input%20of%20KeyAgg%20and%20KeySort) ~makes~ allows the case for having duplicate keys in the protocol. It's also recommended to omit such checks.\r\n\r\n>  In fact, applications are recommended to omit checks for duplicate individual public keys in order to simplify error handling.\r\n\r\nThe next paragraph, however, mentions a case where applications may choose to abort when duplicates are found. Since the base Musig2 BIP itself has a recommendation towards allowing duplicates, I don't mind the parsing of descriptors allowing them as well though I don't see a case where having duplicate keys would be valuable.\r\n\r\n> since PSBT doesn't allow duplicate participants to use different pubnonces and partial sigs.\r\n\r\nGood point, these 2 structs in PSBT would need to be updated: https://github.com/bitcoin/bitcoin/blob/ae024137bda9fe189f4e7ccf26dbaffd44cbbeb6/src/psbt.h#L272-L275 \r\nOne way I see is to also store the index of the participant key in the expression to differentiate between the duplicates.",
      "created_at": "2025-06-05T13:58:29Z",
      "updated_at": "2025-06-05T14:04:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2128930669",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128930669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128980010",
      "pull_request_review_id": 2900553375,
      "id": 2128980010,
      "node_id": "PRRC_kwDOABII585-5agq",
      "diff_hunk": "@@ -580,6 +581,215 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+    bool IsRangedParticipants() const\n+    {\n+        return std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); });\n+    }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive)\n+    {\n+        if (!Assume(!(IsRangedParticipants() && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !IsRangedParticipants()) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 82,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "66f5405f5fad08231b06115a06c52c7267a2ca4e",
      "in_reply_to_id": 2126734205,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```cpp\r\nprov->GetPubKey(0, arg,\r\n```\r\n\r\nAh I see now the SigningProvider being passed here. I notice that `const SigningProvider& arg` is quite prevalent in this file, but I don't prefer calling the signing provider here just `arg` - it's easy to miss. Fine to stick with it in this PR, can be updated separately for all occurrences in one go if it makes sense to others as well.",
      "created_at": "2025-06-05T14:19:55Z",
      "updated_at": "2025-06-05T14:19:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2128980010",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2128980010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 623,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 655,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129101313",
      "pull_request_review_id": 2900761388,
      "id": 2129101313,
      "node_id": "PRRC_kwDOABII585-54IB",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 132,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC, I think we should explicitly pass a dummy signing provider here instead of `arg` because there can't be a hardened derivation at this level. Also, better to not pass the signing provider if we know for certain that it will not be used.",
      "created_at": "2025-06-05T15:15:59Z",
      "updated_at": "2025-06-05T18:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129101313",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129101313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 670,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129128674",
      "pull_request_review_id": 2900761388,
      "id": 2129128674,
      "node_id": "PRRC_kwDOABII585-5-zi",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Slightly confused in this `else` block: for the case of ranged participants and non ranged musig derivation that has a `m_path` such as `/0/1/2`, it doesn't seem to do the derivation after getting the aggregate pubkey because I don't see `m_path` being used here like it is used in `m_aggregate_provider` above.\r\n\r\nI don't see an explicit mention of this in BIP 390 as well, is this not a valid case to consider?",
      "created_at": "2025-06-05T15:28:44Z",
      "updated_at": "2025-06-05T18:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129128674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129128674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 675,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129133487",
      "pull_request_review_id": 2900761388,
      "id": 2129133487,
      "node_id": "PRRC_kwDOABII585-5_-v",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 79,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n- Cannot have hardened hardened derivation\r\n+ Cannot have hardened derivation\r\n```",
      "created_at": "2025-06-05T15:31:17Z",
      "updated_at": "2025-06-05T18:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129133487",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129133487"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129134556",
      "pull_request_review_id": 2900761388,
      "id": 2129134556,
      "node_id": "PRRC_kwDOABII585-6APc",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {",
      "path": "src/script/descriptor.cpp",
      "position": 78,
      "original_position": 78,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Interesting, I now understand why it's written in a double negation way.",
      "created_at": "2025-06-05T15:31:50Z",
      "updated_at": "2025-06-05T18:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129134556",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129134556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 613,
      "original_start_line": 613,
      "start_side": "RIGHT",
      "line": 616,
      "original_line": 616,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129163516",
      "pull_request_review_id": 2900761388,
      "id": 2129163516,
      "node_id": "PRRC_kwDOABII585-6HT8",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Derive participants and compute new aggregate key",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 138,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Aren't the participant pubkeys already derived in the loop on line 659? Here it seems to only aggregate the derived keys.",
      "created_at": "2025-06-05T15:46:57Z",
      "updated_at": "2025-06-05T18:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129163516",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129163516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 676,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129819178",
      "pull_request_review_id": 2900761388,
      "id": 2129819178,
      "node_id": "PRRC_kwDOABII585-8nYq",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());",
      "path": "src/script/descriptor.cpp",
      "position": 126,
      "original_position": 126,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm sensing that this block of derivation of participants' keys should reside later in the `else` block starting on line 674. Reason being that in case of non ranged participants that leads to the presence of `m_aggregate_provider`, we don't really need to derive the participants' keys again and `pos` is effectively unused.\r\n\r\nAfter moving this block down there, either we can derive the keys in the `if` block below with 0 `pos`, or preferably cache the participants' derived keys along with `m_aggregate_provider` so that we don't do this derivation again.\r\n\r\nThough the current implementation gets rid of code duplication by having this block before the below if/else blocks, but it derives again the keys in case of non ranged participants and also passes the unneeded `pos` argument, which makes the reader reason through it unnecessarily imho. ",
      "created_at": "2025-06-05T18:46:18Z",
      "updated_at": "2025-06-05T18:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129819178",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129819178"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 657,
      "original_start_line": 657,
      "start_side": "RIGHT",
      "line": 664,
      "original_line": 664,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129857969",
      "pull_request_review_id": 2901739605,
      "id": 2129857969,
      "node_id": "PRRC_kwDOABII585-8w2x",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Good point, these 2 structs in PSBT would need to be updated: \r\n\r\nI believe there won't need to be any changes to PSBT. If a participant pubkey is duplicated, it is still valid to for each time the pubkey appears, to use the same pubnonce and the same partial sig for that nonce for each instance the pubkey appears. The only complication with this is if the duplicate pubkeys are different signers and produce different nonces and partial sigs as they may overwrite each other resulting a PSBT with a partial sig that does not match the pubn However, I'm pretty sure (and I did check with a cryptographer) that there cannot be any key leakage.",
      "created_at": "2025-06-05T18:54:37Z",
      "updated_at": "2025-06-05T18:54:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129857969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129857969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129889627",
      "pull_request_review_id": 2901776782,
      "id": 2129889627,
      "node_id": "PRRC_kwDOABII585-84lb",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Derive participants and compute new aggregate key\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129128674,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's disallowed. If there is derivation done on the aggregate at all, there cannot be ranged participants. This is not explicitly stated as disallowed in the BIP, but it is not stated as being allowed. It should be implied as the only form of `musig()` with aggregate derivation that the BIP describes explicitly disallows ranged participants.",
      "created_at": "2025-06-05T19:02:39Z",
      "updated_at": "2025-06-05T19:05:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129889627",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129889627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 675,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 684,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129925030",
      "pull_request_review_id": 2901823262,
      "id": 2129925030,
      "node_id": "PRRC_kwDOABII585-9BOm",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());",
      "path": "src/script/descriptor.cpp",
      "position": 126,
      "original_position": 126,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129819178,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Even with aggregate derivation, `out` needs to be filled with participant pukey info. This loop is present in order to do that for both aggregate derivation and participant derivation.",
      "created_at": "2025-06-05T19:11:06Z",
      "updated_at": "2025-06-05T19:11:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129925030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129925030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 657,
      "original_start_line": 657,
      "start_side": "RIGHT",
      "line": 664,
      "original_line": 664,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129933928",
      "pull_request_review_id": 2901833831,
      "id": 2129933928,
      "node_id": "PRRC_kwDOABII585-9DZo",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 132,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129101313,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-05T19:13:04Z",
      "updated_at": "2025-06-05T19:13:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129933928",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129933928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 670,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129934262",
      "pull_request_review_id": 2901834205,
      "id": 2129934262,
      "node_id": "PRRC_kwDOABII585-9De2",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 79,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129133487,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-05T19:13:10Z",
      "updated_at": "2025-06-05T19:13:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129934262",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129934262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129935247",
      "pull_request_review_id": 2901835270,
      "id": 2129935247,
      "node_id": "PRRC_kwDOABII585-9DuP",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Derive participants and compute new aggregate key",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 138,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129163516,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed the comment.",
      "created_at": "2025-06-05T19:13:22Z",
      "updated_at": "2025-06-05T19:13:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129935247",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2129935247"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 676,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2138916560",
      "pull_request_review_id": 2915252677,
      "id": 2138916560,
      "node_id": "PRRC_kwDOABII585_fUbQ",
      "diff_hunk": "@@ -13,10 +13,10 @@ namespace script {\n \n /** Parse a constant.\n  *\n- * If sp's initial part matches str, sp is updated to skip that part, and true is returned.\n+ * If sp's initial part matches str, sp is optionally updated to skip that part, and true is returned.\n  * Otherwise sp is unmodified and false is returned.\n  */\n-bool Const(const std::string& str, std::span<const char>& sp);\n+bool Const(const std::string& str, std::span<const char>& sp, bool skip = true);",
      "path": "src/script/parsing.h",
      "position": 9,
      "original_position": 9,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4b135f80d03c92fb522d1dcfd7d697aa0a4af626",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe a test in `src/test/util_tests.cpp` in `BOOST_AUTO_TEST_CASE(test_script_parsing)` would be good for consistency's sake.",
      "created_at": "2025-06-10T23:26:12Z",
      "updated_at": "2025-06-10T23:26:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2138916560",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2138916560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 19,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2138939609",
      "pull_request_review_id": 2915284020,
      "id": 2138939609,
      "node_id": "PRRC_kwDOABII585_faDZ",
      "diff_hunk": "@@ -161,6 +161,7 @@ class SigningProvider\n     virtual bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const { return false; }\n     virtual bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const { return false; }\n     virtual bool GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const { return false; }\n+    virtual std::vector<CPubKey> GetAggregateParticipantPubkeys(const CPubKey& pubkey) const { return {}; }",
      "path": "src/script/signingprovider.h",
      "position": null,
      "original_position": 4,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Without proper context, it may not be clear that this aggregation specifically refers to a MuSig2 aggregation.\r\nPerhaps a name change could make the purpose and use of the function clearer.\r\n```suggestion\r\n    virtual std::vector<CPubKey> GetMuSig2AggregateParticipantPubkeys(const CPubKey& pubkey) const { return {}; }\r\n```",
      "created_at": "2025-06-10T23:58:21Z",
      "updated_at": "2025-06-10T23:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2138939609",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2138939609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2138945119",
      "pull_request_review_id": 2915292347,
      "id": 2138945119,
      "node_id": "PRRC_kwDOABII585_fbZf",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <musig.h>\n+\n+#include <secp256k1_musig.h>\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache)\n+{\n+    // Parse the pubkeys\n+    std::vector<secp256k1_pubkey> secp_pubkeys;\n+    std::vector<const secp256k1_pubkey*> pubkey_ptrs;\n+    for (const CPubKey& pubkey : pubkeys) {\n+        if (!secp256k1_ec_pubkey_parse(secp256k1_context_static, &secp_pubkeys.emplace_back(), pubkey.data(), pubkey.size())) {\n+            return false;\n+        }\n+    }\n+    pubkey_ptrs.reserve(secp_pubkeys.size());\n+    for (const secp256k1_pubkey& p : secp_pubkeys) {\n+        pubkey_ptrs.push_back(&p);\n+    }\n+\n+    // Aggregate the pubkey\n+    if (!secp256k1_musig_pubkey_agg(secp256k1_context_static, nullptr, &keyagg_cache, pubkey_ptrs.data(), pubkey_ptrs.size())) {",
      "path": "src/musig.cpp",
      "position": 25,
      "original_position": 25,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "18aa7752304d84b02a539a34fe26961214e44aa2",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I wonder if this function should have an output parameter for `agg_pk` (the MuSig-aggregated x-only public key) for future use, instead of considering it null.\r\nBut yes, for now, there is no use.",
      "created_at": "2025-06-11T00:06:08Z",
      "updated_at": "2025-06-11T00:06:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2138945119",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2138945119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 25,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140771903",
      "pull_request_review_id": 2918195602,
      "id": 2140771903,
      "node_id": "PRRC_kwDOABII585_mZY_",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <musig.h>\n+\n+#include <secp256k1_musig.h>\n+\n+bool GetMuSig2KeyAggCache(const std::vector<CPubKey>& pubkeys, secp256k1_musig_keyagg_cache& keyagg_cache)\n+{\n+    // Parse the pubkeys\n+    std::vector<secp256k1_pubkey> secp_pubkeys;\n+    std::vector<const secp256k1_pubkey*> pubkey_ptrs;\n+    for (const CPubKey& pubkey : pubkeys) {\n+        if (!secp256k1_ec_pubkey_parse(secp256k1_context_static, &secp_pubkeys.emplace_back(), pubkey.data(), pubkey.size())) {\n+            return false;\n+        }\n+    }\n+    pubkey_ptrs.reserve(secp_pubkeys.size());\n+    for (const secp256k1_pubkey& p : secp_pubkeys) {\n+        pubkey_ptrs.push_back(&p);\n+    }\n+\n+    // Aggregate the pubkey\n+    if (!secp256k1_musig_pubkey_agg(secp256k1_context_static, nullptr, &keyagg_cache, pubkey_ptrs.data(), pubkey_ptrs.size())) {",
      "path": "src/musig.cpp",
      "position": 25,
      "original_position": 25,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "18aa7752304d84b02a539a34fe26961214e44aa2",
      "in_reply_to_id": 2138945119,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That can be added if it is needed.\r\n\r\nAll of the MuSig2 operations rely on the keyagg cache, which is only produced by aggregating. That's why this function has that as an output parameter.",
      "created_at": "2025-06-11T17:58:26Z",
      "updated_at": "2025-06-11T17:58:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140771903",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140771903"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 25,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140783834",
      "pull_request_review_id": 2918215393,
      "id": 2140783834,
      "node_id": "PRRC_kwDOABII585_mcTa",
      "diff_hunk": "@@ -13,10 +13,10 @@ namespace script {\n \n /** Parse a constant.\n  *\n- * If sp's initial part matches str, sp is updated to skip that part, and true is returned.\n+ * If sp's initial part matches str, sp is optionally updated to skip that part, and true is returned.\n  * Otherwise sp is unmodified and false is returned.\n  */\n-bool Const(const std::string& str, std::span<const char>& sp);\n+bool Const(const std::string& str, std::span<const char>& sp, bool skip = true);",
      "path": "src/script/parsing.h",
      "position": 9,
      "original_position": 9,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4b135f80d03c92fb522d1dcfd7d697aa0a4af626",
      "in_reply_to_id": 2138916560,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-11T18:05:30Z",
      "updated_at": "2025-06-11T18:05:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140783834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140783834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 19,
      "original_line": 19,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140784395",
      "pull_request_review_id": 2918216497,
      "id": 2140784395,
      "node_id": "PRRC_kwDOABII585_mccL",
      "diff_hunk": "@@ -161,6 +161,7 @@ class SigningProvider\n     virtual bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const { return false; }\n     virtual bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const { return false; }\n     virtual bool GetTaprootBuilder(const XOnlyPubKey& output_key, TaprootBuilder& builder) const { return false; }\n+    virtual std::vector<CPubKey> GetAggregateParticipantPubkeys(const CPubKey& pubkey) const { return {}; }",
      "path": "src/script/signingprovider.h",
      "position": null,
      "original_position": 4,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "af27ffbce34e3b6cf07eab82aa240b5482cc6f87",
      "in_reply_to_id": 2138939609,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed to `GetMuSig2ParticipantPubkeys`",
      "created_at": "2025-06-11T18:05:45Z",
      "updated_at": "2025-06-11T18:05:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140784395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140784395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140861981",
      "pull_request_review_id": 2918348806,
      "id": 2140861981,
      "node_id": "PRRC_kwDOABII585_mvYd",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {",
      "path": "src/script/descriptor.cpp",
      "position": 78,
      "original_position": 78,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129134556,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This way, the derivation type is equal to `DeriveType::HARDENED`, the test/debug run will be terminated and a diagnostic message will be printed to the standard error stream.\r\nIn production, a runtime error will be generated.",
      "created_at": "2025-06-11T18:52:50Z",
      "updated_at": "2025-06-11T18:55:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140861981",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140861981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 613,
      "original_start_line": 613,
      "start_side": "RIGHT",
      "line": 616,
      "original_line": 616,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140868201",
      "pull_request_review_id": 2918358960,
      "id": 2140868201,
      "node_id": "PRRC_kwDOABII585_mw5p",
      "diff_hunk": "@@ -574,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());",
      "path": "src/script/descriptor.cpp",
      "position": 97,
      "original_position": 97,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is `std::sort(pubkeys.begin(), pubkeys.end())` equivalent to `secp256k1_ec_pubkey_sort` ?",
      "created_at": "2025-06-11T18:56:43Z",
      "updated_at": "2025-06-11T18:56:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140868201",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140868201"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 635,
      "original_line": 635,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140940882",
      "pull_request_review_id": 2918476214,
      "id": 2140940882,
      "node_id": "PRRC_kwDOABII585_nCpS",
      "diff_hunk": "@@ -574,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());",
      "path": "src/script/descriptor.cpp",
      "position": 97,
      "original_position": 97,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "f1b0fded41223c9b5b92696a0cfa553a10f3d9bf",
      "in_reply_to_id": 2140868201,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes. They both essentially do memcmp on the serialized pubkey",
      "created_at": "2025-06-11T19:46:08Z",
      "updated_at": "2025-06-11T19:46:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140940882",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140940882"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 635,
      "original_line": 635,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140985437",
      "pull_request_review_id": 2918555987,
      "id": 2140985437,
      "node_id": "PRRC_kwDOABII585_nNhd",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);",
      "path": "src/script/descriptor.cpp",
      "position": 108,
      "original_position": 74,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "adeeacb49f11eec3dd31327cc33b094b7a5601d6",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: if you don't want to hardcode vchFingerprint size: `std::fill(std::begin(extpub.vchFingerprint), std::end(extpub.vchFingerprint), 0);`",
      "created_at": "2025-06-11T20:17:57Z",
      "updated_at": "2025-06-11T20:18:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2140985437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2140985437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 646,
      "original_line": 646,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2141222533",
      "pull_request_review_id": 2918917395,
      "id": 2141222533,
      "node_id": "PRRC_kwDOABII585_oHaF",
      "diff_hunk": "@@ -213,6 +215,7 @@ struct FlatSigningProvider final : public SigningProvider\n     std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>> origins;\n     std::map<CKeyID, CKey> keys;\n     std::map<XOnlyPubKey, TaprootBuilder> tr_trees; /** Map from output key to Taproot tree (which can then make the TaprootSpendData */\n+    std::map<CPubKey, std::vector<CPubKey>> aggregate_pubkeys; /** MuSig2 aggregate pubkeys */",
      "path": "src/script/signingprovider.h",
      "position": 20,
      "original_position": 20,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "8ecea91bf296b8fae8b84c3dbf68d5703821cb79",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit 8ecea91bf296b8fae8b84c3dbf68d5703821cb79: comment nit\r\n```suggestion\r\n    std::map<CPubKey, std::vector<CPubKey>> aggregate_pubkeys; /** Map from MuSig2 aggregate pubkey to participant pubkeys */\r\n```",
      "created_at": "2025-06-11T22:40:53Z",
      "updated_at": "2025-06-11T23:59:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2141222533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2141222533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 218,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2141253735",
      "pull_request_review_id": 2918917395,
      "id": 2141253735,
      "node_id": "PRRC_kwDOABII585_oPBn",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Compute aggregate key from derived participants\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || m_ranged_participants; }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            out += pubkey->ToString(type);\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for any participants that we have\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+\n+    // Get RootPubKey and GetRootExtPubKey are used to return the single pubkey underlying the pubkey provider\n+    // to be presented to the user in gethdkeys. As this is a multisig construction, there is no single underlying\n+    // pubkey hence nothing should be returned.\n+    // While the aggregate pubkey could be returned as the root (ext)pubkey, it is not a pubkey that anyone should\n+    // be using by itself in a descriptor as it is unspendable without knowing its participants.\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());\n+        }\n+        return std::make_unique<MuSigPubkeyProvider>(m_expr_index, std::move(providers), m_path, m_derive);\n+    }\n+    bool IsBIP32() const override\n+    {\n+        // musig() can only be a BIP 32 key if all participants are bip32 too\n+        return std::all_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsBIP32(); });\n+    }",
      "path": "src/script/descriptor.cpp",
      "position": 251,
      "original_position": 221,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "adeeacb49f11eec3dd31327cc33b094b7a5601d6",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in commit adeeacb49f11eec3dd31327cc33b094b7a5601d6: just a small note, since I didn't notice it in previous review rounds: it seems this method contains dead code in practice for this class, as currently `.IsBIP32()` is only called for parsing participant pubkeys in `musig(...)` expressions, and nesting those is not allowed. Not sure what to do with this information though, I guess it's fine to keep as-is even if it stays very likely unused.",
      "created_at": "2025-06-11T23:18:42Z",
      "updated_at": "2025-06-11T23:59:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2141253735",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2141253735"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 785,
      "original_start_line": 789,
      "start_side": "RIGHT",
      "line": 789,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2143414491",
      "pull_request_review_id": 2922274606,
      "id": 2143414491,
      "node_id": "PRRC_kwDOABII585_wejb",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Compute aggregate key from derived participants\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || m_ranged_participants; }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            out += pubkey->ToString(type);\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        if (!any_privkeys) out.clear();\n+        return any_privkeys;\n+    }\n+    bool ToNormalizedString(const SigningProvider& arg, std::string& out, const DescriptorCache* cache = nullptr) const override\n+    {\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (!pubkey->ToNormalizedString(arg, tmp)) {\n+                return false;\n+            }\n+            out += tmp;\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return true;\n+    }\n+\n+    void GetPrivKey(int pos, const SigningProvider& arg, FlatSigningProvider& out) const override\n+    {\n+        // Get the private keys for any participants that we have\n+        // If there is participant derivation, it will be done.\n+        // If there is not, then the participant privkeys will be included directly\n+        for (const auto& prov : m_participants) {\n+            prov->GetPrivKey(pos, arg, out);\n+        }\n+    }\n+\n+    // Get RootPubKey and GetRootExtPubKey are used to return the single pubkey underlying the pubkey provider\n+    // to be presented to the user in gethdkeys. As this is a multisig construction, there is no single underlying\n+    // pubkey hence nothing should be returned.\n+    // While the aggregate pubkey could be returned as the root (ext)pubkey, it is not a pubkey that anyone should\n+    // be using by itself in a descriptor as it is unspendable without knowing its participants.\n+    std::optional<CPubKey> GetRootPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+    std::optional<CExtPubKey> GetRootExtPubKey() const override\n+    {\n+        return std::nullopt;\n+    }\n+\n+    std::unique_ptr<PubkeyProvider> Clone() const override\n+    {\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        providers.reserve(m_participants.size());\n+        for (const std::unique_ptr<PubkeyProvider>& p : m_participants) {\n+            providers.emplace_back(p->Clone());\n+        }\n+        return std::make_unique<MuSigPubkeyProvider>(m_expr_index, std::move(providers), m_path, m_derive);\n+    }\n+    bool IsBIP32() const override\n+    {\n+        // musig() can only be a BIP 32 key if all participants are bip32 too\n+        return std::all_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsBIP32(); });\n+    }",
      "path": "src/script/descriptor.cpp",
      "position": 251,
      "original_position": 221,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "adeeacb49f11eec3dd31327cc33b094b7a5601d6",
      "in_reply_to_id": 2141253735,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I prefer to leave it for correctness.",
      "created_at": "2025-06-12T18:51:46Z",
      "updated_at": "2025-06-12T18:51:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2143414491",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2143414491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 785,
      "original_start_line": 789,
      "start_side": "RIGHT",
      "line": 789,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154811811",
      "pull_request_review_id": 2939559036,
      "id": 2154811811,
      "node_id": "PRRC_kwDOABII586Ab9Gj",
      "diff_hunk": "@@ -1800,9 +1806,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+                if (any_ranged) {\n+                    error = \"musig(): Cannot have ranged participant keys if musig() is also ranged\";\n+                    return {};\n+                }\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true, /*allow_hardened=*/false)) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 143,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "c2e931653d34c97dbe9900117e0e2315a6803fd3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I think a slightly cleaner approach to implement the \"disallow hardened derivation\" rule would be to not clutter the keypath parsing interface with another parameter, but check the resulting `paths` object here instead (with e.g. a new `IsKeyPathHardened` helper).",
      "created_at": "2025-06-18T14:47:26Z",
      "updated_at": "2025-06-18T14:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2154811811",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2154811811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1896,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155561658",
      "pull_request_review_id": 2940781515,
      "id": 2155561658,
      "node_id": "PRRC_kwDOABII586Ae0K6",
      "diff_hunk": "@@ -1800,9 +1806,157 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+                if (any_ranged) {\n+                    error = \"musig(): Cannot have ranged participant keys if musig() is also ranged\";\n+                    return {};\n+                }\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true, /*allow_hardened=*/false)) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 143,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "c2e931653d34c97dbe9900117e0e2315a6803fd3",
      "in_reply_to_id": 2154811811,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-06-18T21:47:51Z",
      "updated_at": "2025-06-18T21:47:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2155561658",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2155561658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1896,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159122370",
      "pull_request_review_id": 2946388525,
      "id": 2159122370,
      "node_id": "PRRC_kwDOABII586AsZfC",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_providers_len > 1) {\n+            if (!clone_providers(max_providers_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_providers_len; ++i) {\n+                // Final MuSigPubkeyProvider use participant pubkey providers at each multipath position, and the first (and only) path",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "677639d6ddf2eb35bf7e6fa629660993f94d3f73",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n                // Final MuSigPubkeyProvider uses participant pubkey providers at each multipath position, and the first (and only) path\r\n```",
      "created_at": "2025-06-20T14:30:30Z",
      "updated_at": "2025-06-20T14:31:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2159122370",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159122370"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1945,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159123299",
      "pull_request_review_id": 2946388525,
      "id": 2159123299,
      "node_id": "PRRC_kwDOABII586AsZtj",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_providers_len > 1) {\n+            if (!clone_providers(max_providers_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_providers_len; ++i) {\n+                // Final MuSigPubkeyProvider use participant pubkey providers at each multipath position, and the first (and only) path\n+                emplace_final_provider(i, 0);\n+            }\n+        } else if (paths.size() > 1) {\n+            // All key provider vectors should be length 1. Clone them until they have the same length as paths\n+            if (!clone_providers(paths.size())) {\n+                error = \"musig(): Multipath derivation path with multipath participants is disallowed\"; // This error is unreachable due to earlier check\n+                return {};\n+            }\n+            for (size_t i = 0; i < paths.size(); ++i) {\n+                // Final MuSigPubkeyProvider uses cloned participant pubkey providers, and the multipath derivation paths\n+                emplace_final_provider(i, i);\n+            }\n+        } else {\n+            // No multipath derivation MuSigPubkeyProvider uses the first (and only) participant pubkey providers, and the first (and only) path",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 169,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "677639d6ddf2eb35bf7e6fa629660993f94d3f73",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n            // No multipath derivation, MuSigPubkeyProvider uses the first (and only) participant pubkey providers, and the first (and only) path\r\n```",
      "created_at": "2025-06-20T14:31:01Z",
      "updated_at": "2025-06-20T14:31:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2159123299",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159123299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1959,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159563966",
      "pull_request_review_id": 2947121838,
      "id": 2159563966,
      "node_id": "PRRC_kwDOABII586AuFS-",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_providers_len > 1) {\n+            if (!clone_providers(max_providers_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_providers_len; ++i) {\n+                // Final MuSigPubkeyProvider use participant pubkey providers at each multipath position, and the first (and only) path",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "677639d6ddf2eb35bf7e6fa629660993f94d3f73",
      "in_reply_to_id": 2159122370,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-20T19:33:42Z",
      "updated_at": "2025-06-20T19:33:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2159563966",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159563966"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1945,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159564064",
      "pull_request_review_id": 2947121948,
      "id": 2159564064,
      "node_id": "PRRC_kwDOABII586AuFUg",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_providers_len > 1) {\n+            if (!clone_providers(max_providers_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_providers_len; ++i) {\n+                // Final MuSigPubkeyProvider use participant pubkey providers at each multipath position, and the first (and only) path\n+                emplace_final_provider(i, 0);\n+            }\n+        } else if (paths.size() > 1) {\n+            // All key provider vectors should be length 1. Clone them until they have the same length as paths\n+            if (!clone_providers(paths.size())) {\n+                error = \"musig(): Multipath derivation path with multipath participants is disallowed\"; // This error is unreachable due to earlier check\n+                return {};\n+            }\n+            for (size_t i = 0; i < paths.size(); ++i) {\n+                // Final MuSigPubkeyProvider uses cloned participant pubkey providers, and the multipath derivation paths\n+                emplace_final_provider(i, i);\n+            }\n+        } else {\n+            // No multipath derivation MuSigPubkeyProvider uses the first (and only) participant pubkey providers, and the first (and only) path",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 169,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "677639d6ddf2eb35bf7e6fa629660993f94d3f73",
      "in_reply_to_id": 2159123299,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-20T19:33:46Z",
      "updated_at": "2025-06-20T19:33:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2159564064",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2159564064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1959,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161553622",
      "pull_request_review_id": 2949984903,
      "id": 2161553622,
      "node_id": "PRRC_kwDOABII586A1rDW",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 91,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2126634254\r\n\r\nI think this was done earlier but for some reason I don't see `xprvs` mentioned now. ",
      "created_at": "2025-06-23T12:53:27Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161553622",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161553622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1881,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161579120",
      "pull_request_review_id": 2949984903,
      "id": 2161579120,
      "node_id": "PRRC_kwDOABII586A1xRw",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {",
      "path": "src/script/descriptor.cpp",
      "position": 370,
      "original_position": 35,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This might be an opinionated suggestion, feel free to ignore if you're not convinced:\r\n\r\nOne of the reasons I find `ParseScript` function difficult to read is because of its length and all the script types `if` blocks present in one function. Though I don't suppose this `ParsePubkey` function will ever have that many types but if we are branching off right away at the start, then extracting out the MuSig parsing in a `ParseMusigPubKey` function (or similar) might be easier on the eyes - that way the reader doesn't have to keep this `if` condition is a mental context while reading the Musig specific flow.",
      "created_at": "2025-06-23T13:02:40Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161579120",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161579120"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1823,
      "original_line": 1823,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161592316",
      "pull_request_review_id": 2949984903,
      "id": 2161592316,
      "node_id": "PRRC_kwDOABII586A10f8",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: because this function early returns if any key path is hardened -\r\n\r\n```diff\r\n- IsKeyPathsHardened\r\n+ IsAnyKeyPathHardened\r\n```",
      "created_at": "2025-06-23T13:07:03Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161592316",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161592316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1803,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161598644",
      "pull_request_review_id": 2949984903,
      "id": 2161598644,
      "node_id": "PRRC_kwDOABII586A12C0",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Preference to use a common utility function `IsHardenedIndicator` here that can also check for `H` internally as suggested in the other PR: https://github.com/bitcoin/bitcoin/pull/32788#pullrequestreview-2949824136",
      "created_at": "2025-06-23T13:08:47Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161598644",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161598644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161613727",
      "pull_request_review_id": 2949984903,
      "id": 2161613727,
      "node_id": "PRRC_kwDOABII586A15uf",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": 80,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "At the cost of shilling PR #32745, this check in the `if` condition doesn't seem to cover all the ways the corresponding error can be thrown because the `m_path` can possibly still have a hardened derivation (even though the parsing caller code has a check for it).",
      "created_at": "2025-06-23T13:15:54Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161613727",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161613727"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 616,
      "original_start_line": 616,
      "start_side": "RIGHT",
      "line": 618,
      "original_line": 618,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161662081",
      "pull_request_review_id": 2949984903,
      "id": 2161662081,
      "node_id": "PRRC_kwDOABII586A2FiB",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";",
      "path": "src/script/descriptor.cpp",
      "position": 430,
      "original_position": 95,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> musig(): Cannot have ranged participant keys if musig() also has derivation\r\n\r\n+1, this is a much clearer error message that gets rid of the doubt I had in https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2129128674.",
      "created_at": "2025-06-23T13:37:32Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161662081",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161662081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1883,
      "original_line": 1883,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161706514",
      "pull_request_review_id": 2949984903,
      "id": 2161706514,
      "node_id": "PRRC_kwDOABII586A2QYS",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Based on my understanding of the loop and the corresponding error thrown on line 1872, the `first` here refers to `no_key_parsed` bool that's initialised to `true` at the beginning and toggled to `false` when one is (possibly) parsed.\r\nI think explicit variable naming like suggested above would help to read the code. An alternative (my preference) would be to use an `any_key_parsed` bool with inverse boolean values instead.\r\n\r\n\r\n```cpp\r\n        bool any_key_parsed = false;\r\n        size_t max_providers_len = 0;\r\n        while (expr.size()) {\r\n            if (any_key_parsed && !Const(\",\", expr)) {\r\n                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\r\n                return {};\r\n            }\r\n            any_key_parsed = true;\r\n```\r\n\r\n```cpp\r\n        if (!any_key_parsed) {\r\n            error = \"musig(): Must contain key expressions\";\r\n            return {};\r\n        }\r\n```",
      "created_at": "2025-06-23T13:57:56Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161706514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161706514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1848,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1855,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161781976",
      "pull_request_review_id": 2949984903,
      "id": 2161781976,
      "node_id": "PRRC_kwDOABII586A2izY",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 114,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The `ParseKeyPath` function updates the `apostrophe` boolean (`dummy` here) if an apostrophe'd hardened derivation is found. If this function also updated a `hardened` boolean that it already checks for, then the following `IsKeyPathsHardened` function, which iterates the paths again, would not have been required.\r\n\r\nThis can be done in a follow up if you don't want to introduce this kind of refactoring of the common `ParseKeyPath` function in this PR, which is already big enough.",
      "created_at": "2025-06-23T14:31:52Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161781976",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161781976"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1896,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1901,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161867671",
      "pull_request_review_id": 2949984903,
      "id": 2161867671,
      "node_id": "PRRC_kwDOABII586A23uX",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_providers_len > 1) {\n+            if (!clone_providers(max_providers_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_providers_len; ++i) {\n+                // Final MuSigPubkeyProvider uses participant pubkey providers at each multipath position, and the first (and only) path\n+                emplace_final_provider(i, 0);\n+            }\n+        } else if (paths.size() > 1) {\n+            // All key provider vectors should be length 1. Clone them until they have the same length as paths\n+            if (!clone_providers(paths.size())) {\n+                error = \"musig(): Multipath derivation path with multipath participants is disallowed\"; // This error is unreachable due to earlier check\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> // All key provider vectors should be length 1.\r\n\r\n> // This error is unreachable due to earlier check\r\n\r\nInstead of having uncovered code because it's unreachable, can't we replace the error setting with an assert instead?\r\n\r\n```diff\r\n- if (!clone_providers(paths.size())) {\r\n-                error = \"musig(): Multipath derivation path with multipath participants is disallowed\"; // This error is unreachable due to earlier check\r\n-                return {};\r\n-            }\r\n+ assert(max_providers_len == 1);\r\n+ clone_providers(paths.size());\r\n```\r\n\r\nor \r\n\r\n```diff\r\n+ assert(clone_providers(paths.size()));\r\n```",
      "created_at": "2025-06-23T15:11:18Z",
      "updated_at": "2025-06-23T15:55:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161867671",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161867671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1950,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1950,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161903696",
      "pull_request_review_id": 2949984903,
      "id": 2161903696,
      "node_id": "PRRC_kwDOABII586A3AhQ",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It took me some time to understand how the 4 conditions starting from here are handled individually. I feel some verbose and contextualised naming could be helpful for the reader as most of them are concerned with multipaths.\r\n\r\n```\r\nmax_providers_len -> providers_max_multipaths\r\npaths -> derivation_multipaths\r\n```\r\n\r\nThis or something similar would be helpful imho.",
      "created_at": "2025-06-23T15:28:28Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161903696",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161903696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1936,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161916993",
      "pull_request_review_id": 2949984903,
      "id": 2161916993,
      "node_id": "PRRC_kwDOABII586A3DxB",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\nproviders -> pubkeys_providers\r\nvec -> pubkey_providers_mulltipath\r\n```\r\n\r\nBecause `std::vector<std::vector<std::unique_ptr<PubkeyProvider>>>` is a vector of vectors representing multiple pubkeys in the Musig expression each of which could have multipaths if `vec.size() > 1`.\r\nApplicable inside `emplace_final_provider` function as well.\r\n\r\nI feel the `clone_providers` function is quite cool because IIUC it handles both the cases of expanding/cloning when either the pubkey provider multipath size is passed, or the musig derivation multipath size is passed.",
      "created_at": "2025-06-23T15:34:30Z",
      "updated_at": "2025-06-23T15:51:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161916993",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2161916993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1911,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1912,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2163599033",
      "pull_request_review_id": 2953212032,
      "id": 2163599033,
      "node_id": "PRRC_kwDOABII586A9ea5",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Compute aggregate key from derived participants\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || m_ranged_participants; }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            out += pubkey->ToString(type);\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": 184,
      "original_position": 154,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nice defaulting to using the public key incase private key is not present. This is a more forward facing solution that aligns with the resolution of the existing issue #32078. ",
      "created_at": "2025-06-24T10:44:35Z",
      "updated_at": "2025-06-24T14:03:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2163599033",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2163599033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 720,
      "original_start_line": 724,
      "start_side": "RIGHT",
      "line": 722,
      "original_line": 722,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2163760571",
      "pull_request_review_id": 2953212032,
      "id": 2163760571,
      "node_id": "PRRC_kwDOABII586A-F27",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: can add an `Assume` here for `m_path` being empty keeping in mind this error.\r\n\r\n> \"musig(): Cannot have ranged participant keys if musig() also has derivation\"",
      "created_at": "2025-06-24T11:57:44Z",
      "updated_at": "2025-06-24T14:03:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2163760571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2163760571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2163953475",
      "pull_request_review_id": 2953212032,
      "id": 2163953475,
      "node_id": "PRRC_kwDOABII586A-09D",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());",
      "path": "src/script/descriptor.cpp",
      "position": 126,
      "original_position": 126,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129819178,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see, `out` does need to be filled. In that case, there is an option to cache the `dummy` signing provider on line 629 when the aggregate pubkey & provider are being created (and cached) in case of non ranged participants. This could later be `FlatSigningProvider::Merge`'d with the `out` signing provider on line 672 so that `out` has information for both the participants and the aggregate.\r\n\r\nThe reason I find moving this snippet inside the `else` block here appealing is that then we don't need to derive the non ranged participant pubkeys every time `GetPubKey` is called and I do like seeing 0 being passed as `pos` in case of non ranged participants (ConstPubkeyProvider or DeriveType::NO BIP32PubkeyProvider) like done on line 629.\r\n\r\n`pubkeys` would also need to be cached in this case. Ok if you are not looking to do major changes in the PR at this stage.",
      "created_at": "2025-06-24T13:04:16Z",
      "updated_at": "2025-06-24T14:28:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2163953475",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2163953475"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 657,
      "original_start_line": 657,
      "start_side": "RIGHT",
      "line": 664,
      "original_line": 664,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164092082",
      "pull_request_review_id": 2953212032,
      "id": 2164092082,
      "node_id": "PRRC_kwDOABII586A_Wyy",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Compute aggregate key from derived participants\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 115,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n-            KeyOriginInfo info;\r\n-            CKeyID keyid = aggregate_pubkey->GetID();\r\n-            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\r\n-            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\r\n-            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\r\n+            auto temp_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, aggregate_pubkey.value(), /*xonly=*/false);\r\n+            FlatSigningProvider dummy;\r\n+            temp_aggregate_provider->GetPubKey(/*pos=*/0, dummy, out, read_cache, write_cache);\r\n```\r\nThis passes the unit tests in my system.\r\n\r\n> musig(KEY, KEY, ..., KEY)\r\n\r\nI could notice that we effectively need a const aggregate provider in case of ranged participants.\r\n\r\n`FlatSigningProvider dummy;` - this would be common in both the if/else blocks and can be extracted out.",
      "created_at": "2025-06-24T13:57:42Z",
      "updated_at": "2025-06-24T14:05:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164092082",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164092082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 683,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164783505",
      "pull_request_review_id": 2955124574,
      "id": 2164783505,
      "node_id": "PRRC_kwDOABII586BB_mR",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": 80,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": 2161613727,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, that is a known and expected limitation. The purpose is to have cheap checks here as everything should already be checked by the parser. There is no way for these specific `PubkeyProvider`s to be created outside of this file anyways.",
      "created_at": "2025-06-24T19:54:50Z",
      "updated_at": "2025-06-24T19:54:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164783505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164783505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 616,
      "original_start_line": 616,
      "start_side": "RIGHT",
      "line": 618,
      "original_line": 618,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164821963",
      "pull_request_review_id": 2955195112,
      "id": 2164821963,
      "node_id": "PRRC_kwDOABII586BCI_L",
      "diff_hunk": "@@ -574,6 +581,216 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());",
      "path": "src/script/descriptor.cpp",
      "position": 126,
      "original_position": 126,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "96af090b97e4a42e729202004b94f76d19faeac2",
      "in_reply_to_id": 2129819178,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Non-ranged participants generally won't be rederived every time because of the `read_cache`.",
      "created_at": "2025-06-24T20:16:53Z",
      "updated_at": "2025-06-24T20:16:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164821963",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164821963"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 657,
      "original_start_line": 657,
      "start_side": "RIGHT",
      "line": 664,
      "original_line": 664,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164866941",
      "pull_request_review_id": 2955270721,
      "id": 2164866941,
      "node_id": "PRRC_kwDOABII586BCT99",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 91,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161553622,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed",
      "created_at": "2025-06-24T20:43:46Z",
      "updated_at": "2025-06-24T20:43:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164866941",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164866941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1881,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164868678",
      "pull_request_review_id": 2955274336,
      "id": 2164868678,
      "node_id": "PRRC_kwDOABII586BCUZG",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {",
      "path": "src/script/descriptor.cpp",
      "position": 370,
      "original_position": 35,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161579120,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since this `if` uses `ParsePubkey` recursively, I prefer to have it be in `ParsePubkey` than adding a circular dependency between `ParsePubkey` and a `ParseMusig`.",
      "created_at": "2025-06-24T20:44:56Z",
      "updated_at": "2025-06-24T20:44:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164868678",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164868678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1823,
      "original_line": 1823,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164868920",
      "pull_request_review_id": 2955274719,
      "id": 2164868920,
      "node_id": "PRRC_kwDOABII586BCUc4",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161592316,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ended up dropping this funciton",
      "created_at": "2025-06-24T20:45:07Z",
      "updated_at": "2025-06-24T20:45:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164868920",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164868920"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1803,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164869706",
      "pull_request_review_id": 2955276395,
      "id": 2164869706,
      "node_id": "PRRC_kwDOABII586BCUpK",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161598644,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ended up extracting this entire derive type parsing into a separate function.",
      "created_at": "2025-06-24T20:45:38Z",
      "updated_at": "2025-06-24T20:45:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164869706",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164869706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164870116",
      "pull_request_review_id": 2955277115,
      "id": 2164870116,
      "node_id": "PRRC_kwDOABII586BCUvk",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161706514,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Renamed",
      "created_at": "2025-06-24T20:45:57Z",
      "updated_at": "2025-06-24T20:45:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164870116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164870116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1848,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1855,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164870481",
      "pull_request_review_id": 2955277987,
      "id": 2164870481,
      "node_id": "PRRC_kwDOABII586BCU1R",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 114,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161781976,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a `has_hardened` output parameter.",
      "created_at": "2025-06-24T20:46:13Z",
      "updated_at": "2025-06-24T20:46:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164870481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164870481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1896,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1901,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164871481",
      "pull_request_review_id": 2955280063,
      "id": 2164871481,
      "node_id": "PRRC_kwDOABII586BCVE5",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_providers_len > 1) {\n+            if (!clone_providers(max_providers_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_providers_len; ++i) {\n+                // Final MuSigPubkeyProvider uses participant pubkey providers at each multipath position, and the first (and only) path\n+                emplace_final_provider(i, 0);\n+            }\n+        } else if (paths.size() > 1) {\n+            // All key provider vectors should be length 1. Clone them until they have the same length as paths\n+            if (!clone_providers(paths.size())) {\n+                error = \"musig(): Multipath derivation path with multipath participants is disallowed\"; // This error is unreachable due to earlier check\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161867671,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've changed it to an `Assume`. I don't really like having `assert`s in modules like descriptors.",
      "created_at": "2025-06-24T20:46:51Z",
      "updated_at": "2025-06-24T20:46:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164871481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164871481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1950,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1950,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164871650",
      "pull_request_review_id": 2955280333,
      "id": 2164871650,
      "node_id": "PRRC_kwDOABII586BCVHi",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {\n+                if (vec.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        vec.emplace_back(vec.at(0)->Clone());\n+                    }\n+                } else if (vec.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &paths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = paths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_providers_len > 1 && paths.size() > 1) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161903696,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, mostly",
      "created_at": "2025-06-24T20:46:59Z",
      "updated_at": "2025-06-24T20:46:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164871650",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164871650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1936,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164871808",
      "pull_request_review_id": 2955280591,
      "id": 2164871808,
      "node_id": "PRRC_kwDOABII586BCVKA",
      "diff_hunk": "@@ -1799,10 +1800,168 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n     return ret;\n }\n \n+static bool IsKeyPathsHardened(const std::vector<KeyPath>& paths)\n+{\n+    for (const KeyPath& path : paths) {\n+        for (const uint32_t step : path) {\n+            if (step >> 31) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_providers_len = std::max(max_providers_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (first) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> paths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            auto deriv_split = Split(split.at(1), '/');\n+            if (std::ranges::equal(deriv_split.back(), std::span{\"*\"}.first(1))) {\n+                deriv_split.pop_back();\n+                deriv_type = DeriveType::UNHARDENED;\n+            } else if (std::ranges::equal(deriv_split.back(), std::span{\"*'\"}.first(2)) || std::ranges::equal(deriv_split.back(), std::span{\"*h\"}.first(2))) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            if (!ParseKeyPath(deriv_split, paths, dummy, error, /*allow_multipath=*/true)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (IsKeyPathsHardened(paths)) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            paths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& vec : providers) {",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "effe4fcc59bb2f84139bbaee064bfcb72da0baba",
      "in_reply_to_id": 2161916993,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, mostly",
      "created_at": "2025-06-24T20:47:06Z",
      "updated_at": "2025-06-24T20:47:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164871808",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164871808"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1911,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1912,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164872003",
      "pull_request_review_id": 2955281040,
      "id": 2164872003,
      "node_id": "PRRC_kwDOABII586BCVND",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": 2163760571,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-24T20:47:16Z",
      "updated_at": "2025-06-24T20:47:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164872003",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164872003"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 677,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164872311",
      "pull_request_review_id": 2955281517,
      "id": 2164872311,
      "node_id": "PRRC_kwDOABII586BCVR3",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Compute aggregate key from derived participants\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 115,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": 2164092082,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-24T20:47:28Z",
      "updated_at": "2025-06-24T20:47:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2164872311",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2164872311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 683,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166251339",
      "pull_request_review_id": 2957389841,
      "id": 2166251339,
      "node_id": "PRRC_kwDOABII586BHl9L",
      "diff_hunk": "@@ -1802,9 +1811,154 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(sp, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool any_key_parsed = true;\n+        size_t max_multipath_len = 0;\n+        while (expr.size()) {\n+            if (!any_key_parsed && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            any_key_parsed = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_multipath_len = std::max(max_multipath_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (any_key_parsed) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": 419,
      "original_position": 131,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "a53924bee321f9d01d053cf562ee3d9493e00529",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for using a more elaborate name, using `first` variable name here was not resonating with me. \r\nThis previous suggestion (https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2161706514) also suggested to inverse the boolean values, otherwise this block now reads \"if any key is parsed, then set error\", which is not right.\r\nI can fix this in follow-up though.",
      "created_at": "2025-06-25T09:23:39Z",
      "updated_at": "2025-06-25T12:00:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2166251339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166251339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 1869,
      "original_start_line": 1869,
      "start_side": "RIGHT",
      "line": 1872,
      "original_line": 1872,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166272447",
      "pull_request_review_id": 2957389841,
      "id": 2166272447,
      "node_id": "PRRC_kwDOABII586BHrG_",
      "diff_hunk": "@@ -1802,9 +1811,154 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(sp, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool any_key_parsed = true;\n+        size_t max_multipath_len = 0;\n+        while (expr.size()) {\n+            if (!any_key_parsed && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            any_key_parsed = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+\n+            any_ranged = any_ranged || pk.at(0)->IsRange();\n+            all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\n+\n+            max_multipath_len = std::max(max_multipath_len, pk.size());\n+\n+            providers.emplace_back(std::move(pk));\n+            key_exp_index++;\n+        }\n+        if (any_key_parsed) {\n+            error = \"musig(): Must contain key expressions\";\n+            return {};\n+        }\n+\n+        // Parse any derivation\n+        DeriveType deriv_type = DeriveType::NO;\n+        std::vector<KeyPath> derivation_multipaths;\n+        if (split.size() == 2 && Const(\"/\", split.at(1), /*skip=*/false)) {\n+            if (!all_bip32) {\n+                error = \"musig(): derivation requires all participants to be xpubs or xprvs\";\n+                return {};\n+            }\n+            if (any_ranged) {\n+                error = \"musig(): Cannot have ranged participant keys if musig() also has derivation\";\n+                return {};\n+            }\n+            bool dummy = false;\n+            auto deriv_split = Split(split.at(1), '/');\n+            deriv_type = ParseDeriveType(deriv_split, dummy);\n+            if (deriv_type == DeriveType::HARDENED) {\n+                error = \"musig(): Cannot have hardened child derivation\";\n+                return {};\n+            }\n+            bool has_hardened = false;\n+            if (!ParseKeyPath(deriv_split, derivation_multipaths, dummy, error, /*allow_multipath=*/true, has_hardened)) {\n+                error = \"musig(): \" + error;\n+                return {};\n+            }\n+            if (has_hardened) {\n+                error = \"musig(): cannot have hardened derivation steps\";\n+                return {};\n+            }\n+        } else {\n+            derivation_multipaths.emplace_back();\n+        }\n+\n+        // Makes sure that all providers vectors in providers are the given length, or exactly length 1\n+        // Length 1 vectors have the single provider cloned until it matches the given length.\n+        const auto& clone_providers = [&providers](size_t length) -> bool {\n+            for (auto& multipath_providers : providers) {\n+                if (multipath_providers.size() == 1) {\n+                    for (size_t i = 1; i < length; ++i) {\n+                        multipath_providers.emplace_back(multipath_providers.at(0)->Clone());\n+                    }\n+                } else if (multipath_providers.size() != length) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+\n+        // Emplace the final MuSigPubkeyProvider into ret with the pubkey providers from the specified provider vectors index\n+        // and the path from the specified path index\n+        const auto& emplace_final_provider = [&ret, &key_exp_index, &deriv_type, &derivation_multipaths, &providers](size_t vec_idx, size_t path_idx) -> void {\n+            KeyPath& path = derivation_multipaths.at(path_idx);\n+            std::vector<std::unique_ptr<PubkeyProvider>> pubs;\n+            pubs.reserve(providers.size());\n+            for (auto& vec : providers) {\n+                pubs.emplace_back(std::move(vec.at(vec_idx)));\n+            }\n+            ret.emplace_back(std::make_unique<MuSigPubkeyProvider>(key_exp_index, std::move(pubs), path, deriv_type));\n+        };\n+\n+        if (max_multipath_len > 1 && derivation_multipaths.size() > 1) {\n+            error = \"musig(): Cannot have multipath participant keys if musig() is also multipath\";\n+            return {};\n+        } else if (max_multipath_len > 1) {\n+            if (!clone_providers(max_multipath_len)) {\n+                error = strprintf(\"musig(): Multipath derivation paths have mismatched lengths\");\n+                return {};\n+            }\n+            for (size_t i = 0; i < max_multipath_len; ++i) {\n+                // Final MuSigPubkeyProvider uses participant pubkey providers at each multipath position, and the first (and only) path\n+                emplace_final_provider(i, 0);\n+            }\n+        } else if (derivation_multipaths.size() > 1) {\n+            // All key provider vectors should be length 1. Clone them until they have the same length as paths\n+            if (!Assume(clone_providers(derivation_multipaths.size()))) {\n+                error = \"musig(): Multipath derivation path with multipath participants is disallowed\"; // This error is unreachable due to earlier check\n+                return {};",
      "path": "src/script/descriptor.cpp",
      "position": 496,
      "original_position": 208,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "a53924bee321f9d01d053cf562ee3d9493e00529",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fine to use `Assume` but we still end up with an uncovered code block because it is unreachable.",
      "created_at": "2025-06-25T09:33:13Z",
      "updated_at": "2025-06-25T12:00:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2166272447",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166272447"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 1948,
      "original_start_line": 1948,
      "start_side": "RIGHT",
      "line": 1949,
      "original_line": 1949,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166303215",
      "pull_request_review_id": 2957389841,
      "id": 2166303215,
      "node_id": "PRRC_kwDOABII586BHynv",
      "diff_hunk": "@@ -1647,14 +1649,15 @@ std::optional<uint32_t> ParseKeyPathNum(std::span<const char> elem, bool& apostr\n  * @param[in] allow_multipath Allows the parsed path to use the multipath specifier\n  * @returns false if parsing failed",
      "path": "src/script/descriptor.cpp",
      "position": 279,
      "original_position": 22,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "a53924bee321f9d01d053cf562ee3d9493e00529",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```diff\r\n+ * @param[out] has_hardened updated if hardened derivation is found\r\n```",
      "created_at": "2025-06-25T09:47:41Z",
      "updated_at": "2025-06-25T12:00:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2166303215",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166303215"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 1649,
      "original_start_line": 1649,
      "start_side": "RIGHT",
      "line": 1650,
      "original_line": 1650,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166544023",
      "pull_request_review_id": 2957389841,
      "id": 2166544023,
      "node_id": "PRRC_kwDOABII586BItaX",
      "diff_hunk": "@@ -197,20 +197,26 @@ constexpr XOnlyPubKey XOnlyPubKey::NUMS_H{\n     []() consteval { return XOnlyPubKey{\"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\"_hex_u8}; }(),\n };\n \n-std::vector<CKeyID> XOnlyPubKey::GetKeyIDs() const\n+std::vector<CPubKey> XOnlyPubKey::GetCPubKeys() const",
      "path": "src/pubkey.cpp",
      "position": 5,
      "original_position": 5,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "5fe4c66462e6149c2ed3ce24224a7a7b328a2cfa",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Review note: Besides the internal use within `GetKeyIDs`, I see this function is actually used in the Musig signing PR.",
      "created_at": "2025-06-25T12:00:10Z",
      "updated_at": "2025-06-25T12:00:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2166544023",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166544023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166549418",
      "pull_request_review_id": 2957882208,
      "id": 2166549418,
      "node_id": "PRRC_kwDOABII586BIuuq",
      "diff_hunk": "@@ -1797,9 +1803,159 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(span, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> sp_musig(split.at(0).begin(), split.at(0).end());\n+\n+        auto expr = Expr(sp_musig);\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool first = true;\n+        size_t max_providers_len = 0;\n+        std::set<std::string_view> key_exprs;\n+        while (expr.size()) {\n+            if (!first && !Const(\",\", expr)) {\n+                error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\n+                return {};\n+            }\n+            first = false;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\n+            if (pk.empty()) {\n+                error = strprintf(\"musig(): %s\", error);\n+                return {};\n+            }\n+            const auto& [_, inserted] = key_exprs.emplace(arg.begin(), arg.end());\n+            if (!inserted) {\n+                error = strprintf(\"musig(): Cannot have repeated participant key expressions\");\n+                return {};\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": null,
      "original_position": 109,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "9e3a1d05bf066df31a6e124638046e70669eb470",
      "in_reply_to_id": 2123808039,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see that I had misunderstood your previous comment, this^ looks fine to me.\r\n\r\n> The Sign algorithm must not be executed twice with the same secnonce. Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of Sign.\r\n\r\nThis^ is the only precaution I read in BIP 327 related to reusing, and I don't think anything in the above comment goes against this precaution. Specially since using the same partial sig doesn't translate to signing again.\r\n\r\nI have not yet thought through the consequences when PSBTs are shared between signers during the signing process, I believe that picture would be clearer to me in the next PR of Musig signing.",
      "created_at": "2025-06-25T12:03:06Z",
      "updated_at": "2025-06-25T12:03:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2166549418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2166549418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": 1855,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1860,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205223219",
      "pull_request_review_id": 3016814938,
      "id": 2205223219,
      "node_id": "PRRC_kwDOABII586DcQkz",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }",
      "path": "src/script/descriptor.cpp",
      "position": 80,
      "original_position": 46,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": 2161613727,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "And if there accidentally was / becomes a way, hopefully a fuzzer catches it with the `Assume` above.\r\n\r\n(in 4af0dca096ca497a6b4e5314c9edea683efe620e _descriptor: Add MuSigPubkeyProvider_)",
      "created_at": "2025-07-14T15:30:01Z",
      "updated_at": "2025-07-14T16:32:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2205223219",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205223219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 616,
      "original_start_line": 616,
      "start_side": "RIGHT",
      "line": 618,
      "original_line": 618,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205263157",
      "pull_request_review_id": 3016814938,
      "id": 2205263157,
      "node_id": "PRRC_kwDOABII586DcaU1",
      "diff_hunk": "@@ -580,6 +581,218 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** PubkeyProvider for a musig() expression */\n+class MuSigPubkeyProvider final : public PubkeyProvider\n+{\n+private:\n+    //! PubkeyProvider for the participants\n+    const std::vector<std::unique_ptr<PubkeyProvider>> m_participants;\n+    //! Derivation path\n+    const KeyPath m_path;\n+    //! PubkeyProvider for the aggregate pubkey if it can be cached (i.e. participants are not ranged)\n+    mutable std::unique_ptr<PubkeyProvider> m_aggregate_provider;\n+    mutable std::optional<CPubKey> m_aggregate_pubkey;\n+    const DeriveType m_derive;\n+    const bool m_ranged_participants;\n+\n+    bool IsRangedDerivation() const { return m_derive != DeriveType::NO; }\n+\n+public:\n+    MuSigPubkeyProvider(\n+        uint32_t exp_index,\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers,\n+        KeyPath path,\n+        DeriveType derive\n+    )\n+        : PubkeyProvider(exp_index),\n+        m_participants(std::move(providers)),\n+        m_path(std::move(path)),\n+        m_derive(derive),\n+        m_ranged_participants(std::any_of(m_participants.begin(), m_participants.end(), [](const auto& pubkey) { return pubkey->IsRange(); }))\n+    {\n+        if (!Assume(!(m_ranged_participants && IsRangedDerivation()))) {\n+            throw std::runtime_error(\"musig(): Cannot have both ranged participants and ranged derivation\");\n+        }\n+        if (!Assume(m_derive != DeriveType::HARDENED)) {\n+            throw std::runtime_error(\"musig(): Cannot have hardened derivation\");\n+        }\n+    }\n+\n+    std::optional<CPubKey> GetPubKey(int pos, const SigningProvider& arg, FlatSigningProvider& out, const DescriptorCache* read_cache = nullptr, DescriptorCache* write_cache = nullptr) const override\n+    {\n+        // If the participants are not ranged, we can compute and cache the aggregate pubkey by creating a PubkeyProvider for it\n+        if (!m_aggregate_provider && !m_ranged_participants) {\n+            // Retrieve the pubkeys from the providers\n+            std::vector<CPubKey> pubkeys;\n+            for (const auto& prov : m_participants) {\n+                FlatSigningProvider dummy;\n+                std::optional<CPubKey> pubkey = prov->GetPubKey(0, arg, dummy, read_cache, write_cache);\n+                if (!pubkey.has_value()) {\n+                    return std::nullopt;\n+                }\n+                pubkeys.push_back(pubkey.value());\n+            }\n+            std::sort(pubkeys.begin(), pubkeys.end());\n+\n+            // Aggregate the pubkey\n+            m_aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!Assume(m_aggregate_pubkey.has_value())) return std::nullopt;\n+\n+            // Make our pubkey provider\n+            if (IsRangedDerivation() || !m_path.empty()) {\n+                // Make the synthetic xpub and construct the BIP32PubkeyProvider\n+                CExtPubKey extpub;\n+                extpub.nDepth = 0;\n+                std::memset(extpub.vchFingerprint, 0, 4);\n+                extpub.nChild = 0;\n+                extpub.chaincode = MUSIG_CHAINCODE;\n+                extpub.pubkey = m_aggregate_pubkey.value();\n+\n+                m_aggregate_provider = std::make_unique<BIP32PubkeyProvider>(m_expr_index, extpub, m_path, m_derive, /*apostrophe=*/false);\n+            } else {\n+                m_aggregate_provider = std::make_unique<ConstPubkeyProvider>(m_expr_index, m_aggregate_pubkey.value(), /*xonly=*/false);\n+            }\n+        }\n+\n+        // Retrieve all participant pubkeys\n+        std::vector<CPubKey> pubkeys;\n+        for (const auto& prov : m_participants) {\n+            std::optional<CPubKey> pub = prov->GetPubKey(pos, arg, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubkeys.emplace_back(*pub);\n+        }\n+        std::sort(pubkeys.begin(), pubkeys.end());\n+\n+        CPubKey pubout;\n+        if (m_aggregate_provider) {\n+            // When we have a cached aggregate key, we are either returning it or deriving from it\n+            // Either way, we can passthrough to its GetPubKey\n+            // Use a dummy signing provider as private keys do not exist for the aggregate pubkey\n+            FlatSigningProvider dummy;\n+            std::optional<CPubKey> pub = m_aggregate_provider->GetPubKey(pos, dummy, out, read_cache, write_cache);\n+            if (!pub) return std::nullopt;\n+            pubout = *pub;\n+            out.aggregate_pubkeys.emplace(m_aggregate_pubkey.value(), pubkeys);\n+        } else {\n+            if (!Assume(m_ranged_participants)) return std::nullopt;\n+            // Compute aggregate key from derived participants\n+            std::optional<CPubKey> aggregate_pubkey = MuSig2AggregatePubkeys(pubkeys);\n+            if (!aggregate_pubkey) return std::nullopt;\n+            pubout = *aggregate_pubkey;\n+\n+            KeyOriginInfo info;\n+            CKeyID keyid = aggregate_pubkey->GetID();\n+            std::copy(keyid.begin(), keyid.begin() + sizeof(info.fingerprint), info.fingerprint);\n+            out.origins.emplace(keyid, std::make_pair(*aggregate_pubkey, info));\n+            out.pubkeys.emplace(aggregate_pubkey->GetID(), *aggregate_pubkey);\n+            out.aggregate_pubkeys.emplace(pubout, pubkeys);\n+        }\n+\n+        if (!Assume(pubout.IsValid())) return std::nullopt;\n+        return pubout;\n+    }\n+    bool IsRange() const override { return IsRangedDerivation() || m_ranged_participants; }\n+    // musig() expressions can only be used in tr() contexts which have 32 byte xonly pubkeys\n+    size_t GetSize() const override { return 32; }\n+\n+    std::string ToString(StringType type=StringType::PUBLIC) const override\n+    {\n+        std::string out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            out += pubkey->ToString(type);\n+        }\n+        out += \")\";\n+        out += FormatHDKeypath(m_path);\n+        if (IsRangedDerivation()) {\n+            out += \"/*\";\n+        }\n+        return out;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        bool any_privkeys = false;\n+        out = \"musig(\";\n+        for (size_t i = 0; i < m_participants.size(); ++i) {\n+            const auto& pubkey = m_participants.at(i);\n+            if (i) out += \",\";\n+            std::string tmp;\n+            if (pubkey->ToPrivateString(arg, tmp)) {\n+                any_privkeys = true;\n+                out += tmp;\n+            } else {\n+                out += pubkey->ToString();\n+            }",
      "path": "src/script/descriptor.cpp",
      "position": 184,
      "original_position": 154,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "4039be3f9b78c1ddb75c04f4a8002d36c4b05f79",
      "in_reply_to_id": 2163599033,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree this behavior makes sense. TIL about #32471.\r\n\r\n(in 4af0dca096ca497a6b4e5314c9edea683efe620e _descriptor: Add MuSigPubkeyProvider_)",
      "created_at": "2025-07-14T15:50:01Z",
      "updated_at": "2025-07-14T16:32:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2205263157",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205263157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 720,
      "original_start_line": 724,
      "start_side": "RIGHT",
      "line": 722,
      "original_line": 722,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205299119",
      "pull_request_review_id": 3016814938,
      "id": 2205299119,
      "node_id": "PRRC_kwDOABII586DcjGv",
      "diff_hunk": "@@ -1647,14 +1649,15 @@ std::optional<uint32_t> ParseKeyPathNum(std::span<const char> elem, bool& apostr\n  * @param[in] allow_multipath Allows the parsed path to use the multipath specifier\n  * @returns false if parsing failed",
      "path": "src/script/descriptor.cpp",
      "position": 279,
      "original_position": 22,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "a53924bee321f9d01d053cf562ee3d9493e00529",
      "in_reply_to_id": 2166303215,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In a53924bee321f9d01d053cf562ee3d9493e00529 _descriptor: Parse musig() key expressions_: well, it only ratchets `hardened` from `false` to `true`, never the other way around. This should be documented, since it's not obvious.",
      "created_at": "2025-07-14T16:08:49Z",
      "updated_at": "2025-07-14T16:32:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2205299119",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205299119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": 1649,
      "original_start_line": 1649,
      "start_side": "RIGHT",
      "line": 1650,
      "original_line": 1650,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205328232",
      "pull_request_review_id": 3016814938,
      "id": 2205328232,
      "node_id": "PRRC_kwDOABII586DcqNo",
      "diff_hunk": "@@ -1802,9 +1811,154 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(sp, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool any_key_parsed = true;",
      "path": "src/script/descriptor.cpp",
      "position": 393,
      "original_position": 105,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "a53924bee321f9d01d053cf562ee3d9493e00529",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In a53924bee321f9d01d053cf562ee3d9493e00529 _descriptor: Parse musig() key expressions_: I'm confused by how this variable starts as `true`.\r\n\r\n```diff\r\n--- a/src/script/descriptor.cpp\r\n+++ b/src/script/descriptor.cpp\r\n@@ -1843,20 +1843,20 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index\r\n         bool any_ranged = false;\r\n         bool all_bip32 = true;\r\n         std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\r\n-        bool any_key_parsed = true;\r\n+        bool any_key_parsed = false;\r\n         size_t max_multipath_len = 0;\r\n         while (expr.size()) {\r\n-            if (!any_key_parsed && !Const(\",\", expr)) {\r\n+            if (any_key_parsed && !Const(\",\", expr)) {\r\n                 error = strprintf(\"musig(): expected ',', got '%c'\", expr[0]);\r\n                 return {};\r\n             }\r\n-            any_key_parsed = false;\r\n             auto arg = Expr(expr);\r\n             auto pk = ParsePubkey(key_exp_index, arg, ParseScriptContext::MUSIG, out, error);\r\n             if (pk.empty()) {\r\n                 error = strprintf(\"musig(): %s\", error);\r\n                 return {};\r\n             }\r\n+            any_key_parsed = true;\r\n\r\n             any_ranged = any_ranged || pk.at(0)->IsRange();\r\n             all_bip32 = all_bip32 &&  pk.at(0)->IsBIP32();\r\n@@ -1866,7 +1866,7 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index\r\n             providers.emplace_back(std::move(pk));\r\n             key_exp_index++;\r\n         }\r\n-        if (any_key_parsed) {\r\n+        if (!any_key_parsed) {\r\n             error = \"musig(): Must contain key expressions\";\r\n             return {};\r\n         }\r\n```",
      "created_at": "2025-07-14T16:24:27Z",
      "updated_at": "2025-07-14T16:32:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2205328232",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205328232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1846,
      "original_line": 1846,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205459748",
      "pull_request_review_id": 3017201290,
      "id": 2205459748,
      "node_id": "PRRC_kwDOABII586DdKUk",
      "diff_hunk": "@@ -1802,9 +1811,154 @@ std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkeyInner(uint32_t key_exp_i\n }\n \n /** Parse a public key including origin information (if enabled). */\n-std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n+// NOLINTNEXTLINE(misc-no-recursion)\n+std::vector<std::unique_ptr<PubkeyProvider>> ParsePubkey(uint32_t& key_exp_index, const std::span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n     std::vector<std::unique_ptr<PubkeyProvider>> ret;\n+\n+    using namespace script;\n+\n+    // musig cannot be nested inside of an origin\n+    std::span<const char> span = sp;\n+    if (Const(\"musig(\", span, /*skip=*/false)) {\n+        if (ctx != ParseScriptContext::P2TR) {\n+            error = \"musig() is only allowed in tr() and rawtr()\";\n+            return {};\n+        }\n+\n+        // Split the span on the end parentheses. The end parentheses must\n+        // be included in the resulting span so that Expr is happy.\n+        auto split = Split(sp, ')', /*include_sep=*/true);\n+        if (split.size() > 2) {\n+            error = \"Too many ')' in musig() expression\";\n+            return {};\n+        }\n+        std::span<const char> expr(split.at(0).begin(), split.at(0).end());\n+        if (!Func(\"musig\", expr)) {\n+            error = \"Invalid musig() expression\";\n+            return {};\n+        }\n+\n+        // Parse the participant pubkeys\n+        bool any_ranged = false;\n+        bool all_bip32 = true;\n+        std::vector<std::vector<std::unique_ptr<PubkeyProvider>>> providers;\n+        bool any_key_parsed = true;",
      "path": "src/script/descriptor.cpp",
      "position": 393,
      "original_position": 105,
      "commit_id": "5fe7915c865a8e7c0a95ec376d0f1ff737f5d1c2",
      "original_commit_id": "a53924bee321f9d01d053cf562ee3d9493e00529",
      "in_reply_to_id": 2205328232,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree, see https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2166251339",
      "created_at": "2025-07-14T17:34:14Z",
      "updated_at": "2025-07-14T17:34:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31244#discussion_r2205459748",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2205459748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31244"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1846,
      "original_line": 1846,
      "side": "RIGHT"
    }
  ]
}