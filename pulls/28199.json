{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199",
    "id": 1459601417,
    "node_id": "PR_kwDOABII585W_8AJ",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28199",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28199.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28199.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/9eac5a0529f869075f0331e40d322c34fc8fc2af",
    "number": 28199,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "test: tx orphan handling",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I was doing some mutation testing (through reckless refactoring) locally and found some specific behaviors in orphan handling that weren't picked up by tests. Adding some of these test cases now can maybe help with reviewing refactors like #28031.\r\n\r\n- Parent requests aren't sent immediately. A delay is added and the requests are filtered by AlreadyHaveTx before they are sent, which means you can't use fake orphans to probe precise arrival timing of a tx.\r\n- Parent requests include all that are not AlreadyHaveTx. This means old confirmed parents may be requested.\r\n- The node does not give up on orphans if the peer responds to a parent request with notfound. This means that if a parent is an old confirmed transaction (in which notfound is expected), the orphan should still be resolved.\r\n- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based on txid.\r\n- Rejected parents can cause an orphan to be rejected too, by both wtxid and txid.\r\n- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent has the same hash as an in-flight request, it shouldn't be requested.\r\n- Multiple orphans with overlapping parents should not cause duplicated parent requests.",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2023-08-02T11:14:20Z",
    "updated_at": "2024-08-21T13:13:01Z",
    "closed_at": "2023-08-22T21:03:56Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-08-22T21:03:56Z",
    "merge_commit_sha": "5aa67eb3655a0023f0cf115176fc8d5bac53cdcd",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "glozow:2023-08-test-orphan-handling",
      "ref": "2023-08-test-orphan-handling",
      "sha": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 244262754,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNDQyNjI3NTQ=",
        "name": "bitcoin",
        "full_name": "glozow/bitcoin",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/glozow/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bitcoin",
        "archive_url": "https://api.github.com/repos/glozow/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/glozow/bitcoin/events",
        "forks_url": "https://api.github.com/repos/glozow/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/glozow/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/glozow/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/glozow/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/glozow/bitcoin/hooks",
        "svn_url": "https://github.com/glozow/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 4,
        "stargazers_count": 12,
        "watchers_count": 12,
        "size": 256727,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-08-21T11:54:38Z",
        "created_at": "2020-03-02T02:31:56Z",
        "updated_at": "2024-08-20T15:53:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "6c508ac3ff118902a9bc5a209913de5d72e771dd",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36057,
        "stargazers_count": 77968,
        "watchers_count": 77968,
        "size": 265584,
        "default_branch": "master",
        "open_issues_count": 665,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-08-21T12:57:39Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-08-21T13:53:28Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 441,
    "deletions": 0,
    "changed_files": 4,
    "commits": 2,
    "review_comments": 54,
    "comments": 9
  },
  "events": [
    {
      "event": "labeled",
      "id": 9986839950,
      "node_id": "LE_lADOABII585tQPuGzwAAAAJTQxWO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9986839950",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:14:20Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 1662019735,
      "node_id": "IC_kwDOABII585jEGiX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662019735",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:14:23Z",
      "updated_at": "2023-08-22T16:34:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [dergoegge](https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1577100942), [achow101](https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1578574354), [fjahr](https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1584785042), [instagibbs](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1688552454) |\n| Concept ACK | [jamesob](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993), [brunoerg](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529), [jonatack](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614), [Empact](https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1664679951), [ajtowns](https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1572916458) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#20892](https://github.com/bitcoin/bitcoin/pull/20892) (tests: Run both descriptor and legacy tests within a single test invocation by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662019735",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "renamed",
      "id": 9986992853,
      "node_id": "RTE_lADOABII585tQPuGzwAAAAJTRWrV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9986992853",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:31:40Z",
      "rename": {
        "from": "functional test: tx orphan handling",
        "to": "test: tx orphan handling"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9987090350,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJTRueu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9987090350",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:42:28Z"
    },
    {
      "event": "labeled",
      "id": 9987092148,
      "node_id": "LE_lADOABII585tQPuGzwAAAAJTRu60",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9987092148",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:42:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1662073675,
      "node_id": "IC_kwDOABII585jETtL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662073675",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T11:54:40Z",
      "updated_at": "2023-08-02T11:54:40Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nGood to have these tests prior to refactoring",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662073675",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "commented",
      "id": 1662122993,
      "node_id": "IC_kwDOABII585jEfvx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662122993",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T12:29:21Z",
      "updated_at": "2023-08-02T12:29:21Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, looks like some great additional coverage.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662122993",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "commented",
      "id": 1662147529,
      "node_id": "IC_kwDOABII585jElvJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662147529",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T12:46:32Z",
      "updated_at": "2023-08-02T12:46:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK ",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662147529",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "unlabeled",
      "id": 9988041812,
      "node_id": "UNLE_lADOABII585tQPuGzwAAAAJTVWxU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9988041812",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T13:17:00Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1662205614,
      "node_id": "IC_kwDOABII585jEz6u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1662205614",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-02T13:22:36Z",
      "updated_at": "2023-08-02T13:22:36Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1662205614",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "reviewed",
      "id": 1559366940,
      "node_id": "PRR_kwDOABII585c8g0c",
      "url": null,
      "actor": null,
      "commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "moar coverage good",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1559366940",
      "submitted_at": "2023-08-02T18:24:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9997175982,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJT4Myu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9997175982",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T10:13:34Z"
    },
    {
      "event": "reviewed",
      "id": 1561117972,
      "node_id": "PRR_kwDOABII585dDMUU",
      "url": null,
      "actor": null,
      "commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1561117972",
      "submitted_at": "2023-08-03T13:58:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "commented",
      "id": 1664679951,
      "node_id": "IC_kwDOABII585jOQAP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1664679951",
      "actor": {
        "login": "Empact",
        "id": 5470,
        "node_id": "MDQ6VXNlcjU0NzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Empact",
        "html_url": "https://github.com/Empact",
        "followers_url": "https://api.github.com/users/Empact/followers",
        "following_url": "https://api.github.com/users/Empact/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Empact/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Empact/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
        "organizations_url": "https://api.github.com/users/Empact/orgs",
        "repos_url": "https://api.github.com/users/Empact/repos",
        "events_url": "https://api.github.com/users/Empact/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Empact/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T21:40:17Z",
      "updated_at": "2023-08-03T21:40:17Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "Empact",
        "id": 5470,
        "node_id": "MDQ6VXNlcjU0NzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Empact",
        "html_url": "https://github.com/Empact",
        "followers_url": "https://api.github.com/users/Empact/followers",
        "following_url": "https://api.github.com/users/Empact/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Empact/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Empact/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
        "organizations_url": "https://api.github.com/users/Empact/orgs",
        "repos_url": "https://api.github.com/users/Empact/repos",
        "events_url": "https://api.github.com/users/Empact/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Empact/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1664679951",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "commented",
      "id": 1669753053,
      "node_id": "IC_kwDOABII585jhmjd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1669753053",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:39:17Z",
      "updated_at": "2023-08-08T14:39:17Z",
      "author_association": "MEMBER",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/28199/commits/abe8536192c9f2cd6ba9d0e083f23dec4d20841f\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283271742 would be nice to be slightly cleaned up for future readers",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1669753053",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "commented",
      "id": 1669788993,
      "node_id": "IC_kwDOABII585jhvVB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1669788993",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:46Z",
      "updated_at": "2023-08-08T14:59:46Z",
      "author_association": "MEMBER",
      "body": "thanks for the concept acks @dergoegge @jamesob @brunoerg @Empact @jonatack, would appreciate a review of test too :pray:",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1669788993",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "mentioned",
      "id": 10036717026,
      "node_id": "MEE_lADOABII585tQPuGzwAAAAJWPCXi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717026",
      "actor": {
        "login": "Empact",
        "id": 5470,
        "node_id": "MDQ6VXNlcjU0NzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Empact",
        "html_url": "https://github.com/Empact",
        "followers_url": "https://api.github.com/users/Empact/followers",
        "following_url": "https://api.github.com/users/Empact/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Empact/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Empact/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
        "organizations_url": "https://api.github.com/users/Empact/orgs",
        "repos_url": "https://api.github.com/users/Empact/repos",
        "events_url": "https://api.github.com/users/Empact/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Empact/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:47Z"
    },
    {
      "event": "subscribed",
      "id": 10036717055,
      "node_id": "SE_lADOABII585tQPuGzwAAAAJWPCX_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717055",
      "actor": {
        "login": "Empact",
        "id": 5470,
        "node_id": "MDQ6VXNlcjU0NzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5470?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Empact",
        "html_url": "https://github.com/Empact",
        "followers_url": "https://api.github.com/users/Empact/followers",
        "following_url": "https://api.github.com/users/Empact/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Empact/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Empact/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Empact/subscriptions",
        "organizations_url": "https://api.github.com/users/Empact/orgs",
        "repos_url": "https://api.github.com/users/Empact/repos",
        "events_url": "https://api.github.com/users/Empact/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Empact/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:47Z"
    },
    {
      "event": "mentioned",
      "id": 10036717099,
      "node_id": "MEE_lADOABII585tQPuGzwAAAAJWPCYr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717099",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:47Z"
    },
    {
      "event": "subscribed",
      "id": 10036717125,
      "node_id": "SE_lADOABII585tQPuGzwAAAAJWPCZF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717125",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:47Z"
    },
    {
      "event": "mentioned",
      "id": 10036717176,
      "node_id": "MEE_lADOABII585tQPuGzwAAAAJWPCZ4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717176",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:47Z"
    },
    {
      "event": "subscribed",
      "id": 10036717193,
      "node_id": "SE_lADOABII585tQPuGzwAAAAJWPCaJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717193",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:48Z"
    },
    {
      "event": "mentioned",
      "id": 10036717230,
      "node_id": "MEE_lADOABII585tQPuGzwAAAAJWPCau",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717230",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:48Z"
    },
    {
      "event": "subscribed",
      "id": 10036717255,
      "node_id": "SE_lADOABII585tQPuGzwAAAAJWPCbH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717255",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:48Z"
    },
    {
      "event": "mentioned",
      "id": 10036717281,
      "node_id": "MEE_lADOABII585tQPuGzwAAAAJWPCbh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717281",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:48Z"
    },
    {
      "event": "subscribed",
      "id": 10036717301,
      "node_id": "SE_lADOABII585tQPuGzwAAAAJWPCb1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10036717301",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:59:48Z"
    },
    {
      "event": "reviewed",
      "id": 1571484607,
      "node_id": "PRR_kwDOABII585dqvO_",
      "url": null,
      "actor": null,
      "commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review ACK abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1571484607",
      "submitted_at": "2023-08-10T09:45:18Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "reviewed",
      "id": 1572916458,
      "node_id": "PRR_kwDOABII585dwMzq",
      "url": null,
      "actor": null,
      "commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK\r\n\r\nI think we should probably prefer to test behaviours that are intentional/desirable, rather than behaviours that just happen to be how it got implemented. It's not immediately clear to me which class the things being tested here fall into.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1572916458",
      "submitted_at": "2023-08-11T01:53:02Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "unsubscribed",
      "id": 10067579739,
      "node_id": "UE_lADOABII585tQPuGzwAAAAJYExNb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10067579739",
      "actor": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-11T09:15:13Z"
    },
    {
      "event": "comment_deleted",
      "id": 10067818938,
      "node_id": "CDE_lADOABII585tQPuGzwAAAAJYFrm6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10067818938",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-11T09:43:36Z"
    },
    {
      "event": "reviewed",
      "id": 1573365456,
      "node_id": "PRR_kwDOABII585dx6bQ",
      "url": null,
      "actor": null,
      "commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> I think we should probably prefer to test behaviours that are intentional/desirable, rather than behaviours that just happen to be how it got implemented.\r\n\r\nYeah the purpose of writing these tests was largely documentation and not changing behavior unintentionally.\r\n\r\nI think most of the things here are intentional, though can think of at least one thing that seems to be \"that's just how it got implemented.\" I was trying to figure out whether we would want to use a `notfound` for a parent tx to mean we should give up on processing the orphan that depends on it. Currently we don't do anything since we don't track the fact that the request is related to an orphan. But since we just request based on `!AlreadyHaveTx` we might reject due to a long-confirmed parent. I suppose it would be different if validation told net_processing which inputs were missing and request those. Though that doesn't seem worth implementing if we can just do ancestor package relay.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1573365456",
      "submitted_at": "2023-08-11T09:56:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10070935565,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJYRkgN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10070935565",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-11T15:14:08Z"
    },
    {
      "event": "reviewed",
      "id": 1573953791,
      "node_id": "PRR_kwDOABII585d0KD_",
      "url": null,
      "actor": null,
      "commit_id": "afbc2b17e5e830b273675ee04d337bad304127fb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1573953791",
      "submitted_at": "2023-08-11T15:34:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10083519904,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJZBk2g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10083519904",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-14T08:12:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10086890815,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJZOb0_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10086890815",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-14T13:45:07Z"
    },
    {
      "event": "reviewed",
      "id": 1577015320,
      "node_id": "PRR_kwDOABII585d_1gY",
      "url": null,
      "actor": null,
      "commit_id": "878f066565c2b48fb174e89c069a0be1b91f44e0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1577015320",
      "submitted_at": "2023-08-14T14:47:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDYxZTc3YmI5MDFiY2EwMzhiNDYwNjRkYzQ1MzFlMTJjMmFiNTA2NzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61e77bb901bca038b46064dc4531e12c2ab50673",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/61e77bb901bca038b46064dc4531e12c2ab50673",
      "tree": {
        "sha": "aa0966e10c7a3232492c0da36154812ef0582efe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa0966e10c7a3232492c0da36154812ef0582efe"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e92013e178727429fdf81ef180efffdad9f0ff5a",
          "sha": "e92013e178727429fdf81ef180efffdad9f0ff5a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e92013e178727429fdf81ef180efffdad9f0ff5a"
        }
      ],
      "message": "[test framework] make it easier to fast-forward setmocktime\n\nHave each TestNode keep track of the last timestamp it called\nsetmocktime with, and add a bumpmocktime() function to bump by a\nnumber of seconds. Makes it easy to fast forward n seconds without\nkeeping track of what the last timestamp was.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-08-14T14:53:33Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-08-11T14:51:39Z"
      },
      "sha": "61e77bb901bca038b46064dc4531e12c2ab50673"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDllYWM1YTA1MjlmODY5MDc1ZjAzMzFlNDBkMzIyYzM0ZmM4ZmMyYWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "tree": {
        "sha": "d703bb84d64c91147cc4141d197d1748878761c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d703bb84d64c91147cc4141d197d1748878761c7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61e77bb901bca038b46064dc4531e12c2ab50673",
          "sha": "61e77bb901bca038b46064dc4531e12c2ab50673",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/61e77bb901bca038b46064dc4531e12c2ab50673"
        }
      ],
      "message": "[functional test] transaction orphan handling",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-08-14T14:54:31Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-04-19T14:40:18Z"
      },
      "sha": "9eac5a0529f869075f0331e40d322c34fc8fc2af"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10087822836,
      "node_id": "HRFPE_lADOABII585tQPuGzwAAAAJZR_X0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10087822836",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-14T14:55:10Z"
    },
    {
      "event": "reviewed",
      "id": 1577100942,
      "node_id": "PRR_kwDOABII585eAKaO",
      "url": null,
      "actor": null,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK 9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1577100942",
      "submitted_at": "2023-08-14T15:27:34Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "review_requested",
      "id": 10088219792,
      "node_id": "RRE_lADOABII585tQPuGzwAAAAJZTgSQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10088219792",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-14T15:27:39Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 10088727270,
      "node_id": "RRE_lADOABII585tQPuGzwAAAAJZVcLm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10088727270",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-14T16:13:30Z",
      "requested_reviewer": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1578574354,
      "node_id": "PRR_kwDOABII585eFyIS",
      "url": null,
      "actor": null,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK 9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1578574354",
      "submitted_at": "2023-08-15T13:38:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "reviewed",
      "id": 1584785042,
      "node_id": "PRR_kwDOABII585edeaS",
      "url": null,
      "actor": null,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code review ACK 9eac5a0529f869075f0331e40d322c34fc8fc2af\r\n\r\n...modulo removing the dead code. Otherwise mostly nit-ish comments, I can also open a follow-up myself if someone feels like merging this as is.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#pullrequestreview-1584785042",
      "submitted_at": "2023-08-18T16:50:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
    },
    {
      "event": "commented",
      "id": 1688552454,
      "node_id": "IC_kwDOABII585kpUQG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1688552454",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T16:34:19Z",
      "updated_at": "2023-08-22T16:34:19Z",
      "author_association": "MEMBER",
      "body": "reACK https://github.com/bitcoin/bitcoin/pull/28199/commits/9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#issuecomment-1688552454",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28199"
    },
    {
      "event": "review_request_removed",
      "id": 10160802156,
      "node_id": "RRRE_lADOABII585tQPuGzwAAAAJdoYls",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10160802156",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T16:34:23Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "merged",
      "id": 10163154942,
      "node_id": "ME_lADOABII585tQPuGzwAAAAJdxW_-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10163154942",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5aa67eb3655a0023f0cf115176fc8d5bac53cdcd",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5aa67eb3655a0023f0cf115176fc8d5bac53cdcd",
      "created_at": "2023-08-22T21:03:56Z"
    },
    {
      "event": "closed",
      "id": 10163154970,
      "node_id": "CE_lADOABII585tQPuGzwAAAAJdxXAa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10163154970",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T21:03:56Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 10163406290,
      "node_id": "HRDE_lADOABII585tQPuGzwAAAAJdyUXS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10163406290",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-22T21:41:38Z"
    },
    {
      "event": "referenced",
      "id": 10320464590,
      "node_id": "REFE_lADOABII585tQPuGzwAAAAJnJcrO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/10320464590",
      "actor": {
        "login": "Frank-GER",
        "id": 87550788,
        "node_id": "MDQ6VXNlcjg3NTUwNzg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/87550788?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Frank-GER",
        "html_url": "https://github.com/Frank-GER",
        "followers_url": "https://api.github.com/users/Frank-GER/followers",
        "following_url": "https://api.github.com/users/Frank-GER/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Frank-GER/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Frank-GER/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Frank-GER/subscriptions",
        "organizations_url": "https://api.github.com/users/Frank-GER/orgs",
        "repos_url": "https://api.github.com/users/Frank-GER/repos",
        "events_url": "https://api.github.com/users/Frank-GER/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Frank-GER/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "52cce72c8f6ffb6b03ec8d94507d9150a69dfa83",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/52cce72c8f6ffb6b03ec8d94507d9150a69dfa83",
      "created_at": "2023-09-08T17:08:30Z"
    },
    {
      "event": "referenced",
      "id": 13575258258,
      "node_id": "REFE_lADOABII585tQPuGzwAAAAMpJgCS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13575258258",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "969e03c50dad8a57d22e8e0c239ac7b59f4939dc",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/969e03c50dad8a57d22e8e0c239ac7b59f4939dc",
      "created_at": "2024-07-19T14:11:24Z"
    },
    {
      "event": "locked",
      "id": 13960300840,
      "node_id": "LOE_lADOABII585tQPuGzwAAAANAGUko",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13960300840",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-21T13:13:01Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242",
      "pull_request_review_id": 1559366940,
      "id": 1282131242,
      "node_id": "PRRC_kwDOABII585Ma8Uq",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 6,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "comment block seems extraneous if there's logging for each test",
      "created_at": "2023-08-02T16:14:00Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282131242",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282131242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201",
      "pull_request_review_id": 1559366940,
      "id": 1282208201,
      "node_id": "PRRC_kwDOABII585MbPHJ",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 57,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Stick the constant inside `cleanup` and move the comment for `cleanup`, since it explains what the whole thing is doing.",
      "created_at": "2023-08-02T17:17:38Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282208201",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282208201"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657",
      "pull_request_review_id": 1559366940,
      "id": 1282234657,
      "node_id": "PRRC_kwDOABII585MbVkh",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 258,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        # The parent should be requested since the unstripped wtxid would differ. Delayed because it's by txid and this is not a preferred relay peer.\r\n```",
      "created_at": "2023-08-02T17:44:18Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282234657",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282234657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358",
      "pull_request_review_id": 1559366940,
      "id": 1282243358,
      "node_id": "PRRC_kwDOABII585MbXse",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 256,
      "original_position": 280,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can't we just reconsider it again?",
      "created_at": "2023-08-02T17:53:41Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282243358",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282243358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 256,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680",
      "pull_request_review_id": 1559366940,
      "id": 1282251680,
      "node_id": "PRRC_kwDOABII585MbZug",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 269,
      "original_position": 293,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "took me a second, just assert it's not in mempool for those quickly reading ",
      "created_at": "2023-08-02T18:02:11Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282251680",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282251680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 269,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631",
      "pull_request_review_id": 1559366940,
      "id": 1282257631,
      "node_id": "PRRC_kwDOABII585MbbLf",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 109,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        \"\"\"Check that the node does not immediately respond to this message with any of\r\n```",
      "created_at": "2023-08-02T18:06:00Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282257631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282257631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402",
      "pull_request_review_id": 1559366940,
      "id": 1282258402,
      "node_id": "PRRC_kwDOABII585MbbXi",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 180,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "can we assert that peer_spy hasn't received the INV, just to be sure?",
      "created_at": "2023-08-02T18:06:57Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282258402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282258402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677",
      "pull_request_review_id": 1559366940,
      "id": 1282259677,
      "node_id": "PRRC_kwDOABII585Mbbrd",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 191,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't get this case. Why wouldn't you request a \"fake\" parent if you don't know it's fake already?",
      "created_at": "2023-08-02T18:08:27Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282259677",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282259677"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573",
      "pull_request_review_id": 1559366940,
      "id": 1282261573,
      "node_id": "PRRC_kwDOABII585MbcJF",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 326,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "does this wallet never use 0-conf change? would be nice to assert to make it clear the lack of utxo connection",
      "created_at": "2023-08-02T18:09:53Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282261573",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282261573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679",
      "pull_request_review_id": 1559366940,
      "id": 1282268679,
      "node_id": "PRRC_kwDOABII585Mbd4H",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 331,
      "original_position": 351,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"The node should not request a parent if it has an in-flight txrequest\" ? Seems like parents are being reqiested. Maybe a typo or I can't tell what scenario it's covering.",
      "created_at": "2023-08-02T18:17:38Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282268679",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282268679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277",
      "pull_request_review_id": 1559366940,
      "id": 1282274277,
      "node_id": "PRRC_kwDOABII585MbfPl",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 391,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "bit of a repeat with test_orphan_rejected_parents_exceptions ?",
      "created_at": "2023-08-02T18:23:51Z",
      "updated_at": "2023-08-02T18:24:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282274277",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282274277"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 376,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282831868",
      "pull_request_review_id": 1560507719,
      "id": 1282831868,
      "node_id": "PRRC_kwDOABII585MdnX8",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 6,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282131242,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "removed comment block",
      "created_at": "2023-08-03T08:23:55Z",
      "updated_at": "2023-08-03T10:13:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282831868",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282831868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282832651",
      "pull_request_review_id": 1560507719,
      "id": 1282832651,
      "node_id": "PRRC_kwDOABII585MdnkL",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 57,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282208201,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done",
      "created_at": "2023-08-03T08:24:31Z",
      "updated_at": "2023-08-03T10:13:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282832651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282832651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 57,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282834565",
      "pull_request_review_id": 1560507719,
      "id": 1282834565,
      "node_id": "PRRC_kwDOABII585MdoCF",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 109,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282257631,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, and renamed to `assert_no_immediate_response`",
      "created_at": "2023-08-03T08:26:00Z",
      "updated_at": "2023-08-03T10:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282834565",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282834565"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282837698",
      "pull_request_review_id": 1560507719,
      "id": 1282837698,
      "node_id": "PRRC_kwDOABII585MdozC",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 180,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282258402,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2023-08-03T08:28:28Z",
      "updated_at": "2023-08-03T10:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282837698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282837698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 180,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282850596",
      "pull_request_review_id": 1560507719,
      "id": 1282850596,
      "node_id": "PRRC_kwDOABII585Mdr8k",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 191,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282259677,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Edited the comments.\r\n\r\nWithout delays and filtering right before sending, I figured you could query whether `tx_real` has arrived in the node's mempool yet by sending a fake orphan that spends from it (if the node requests `tx_real` they don't have it yet, if they don't request it then it's already in mempool/seen). Hence \"reveal.\" But you can only know whether `tx_real` arrived in the last ~2-4 seconds.",
      "created_at": "2023-08-03T08:39:22Z",
      "updated_at": "2023-08-03T10:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282850596",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282850596"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282853373",
      "pull_request_review_id": 1560507719,
      "id": 1282853373,
      "node_id": "PRRC_kwDOABII585Mdsn9",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 269,
      "original_position": 293,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282251680,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2023-08-03T08:41:00Z",
      "updated_at": "2023-08-03T10:13:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282853373",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282853373"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 269,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282857628",
      "pull_request_review_id": 1560507719,
      "id": 1282857628,
      "node_id": "PRRC_kwDOABII585Mdtqc",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 331,
      "original_position": 351,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282268679,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It should not request `inflight_parent_AB` even though it's one of the missing parents. I'll add a comment to explain this.",
      "created_at": "2023-08-03T08:44:06Z",
      "updated_at": "2023-08-03T10:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282857628",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282857628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282862310",
      "pull_request_review_id": 1560507719,
      "id": 1282862310,
      "node_id": "PRRC_kwDOABII585Mduzm",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 391,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282274277,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "True this could be combined. The main idea for this test is that this transaction's failure propagates all the way to the grandchild.",
      "created_at": "2023-08-03T08:47:14Z",
      "updated_at": "2023-08-03T10:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282862310",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282862310"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 376,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282889026",
      "pull_request_review_id": 1560507719,
      "id": 1282889026,
      "node_id": "PRRC_kwDOABII585Md1VC",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 258,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282234657,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added",
      "created_at": "2023-08-03T09:07:38Z",
      "updated_at": "2023-08-03T10:13:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282889026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282889026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282919246",
      "pull_request_review_id": 1560507719,
      "id": 1282919246,
      "node_id": "PRRC_kwDOABII585Md8tO",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 326,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282261573,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "changed so we grab the utxos before making any transactions, so they all have to be confirmed and not related",
      "created_at": "2023-08-03T09:32:01Z",
      "updated_at": "2023-08-03T10:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282919246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282919246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 326,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282920253",
      "pull_request_review_id": 1560507719,
      "id": 1282920253,
      "node_id": "PRRC_kwDOABII585Md889",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 256,
      "original_position": 280,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282243358,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure, changed.",
      "created_at": "2023-08-03T09:32:50Z",
      "updated_at": "2023-08-03T10:13:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1282920253",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1282920253"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 256,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283215687",
      "pull_request_review_id": 1561117972,
      "id": 1283215687,
      "node_id": "PRRC_kwDOABII585MfFFH",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 331,
      "original_position": 351,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282268679,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "much clearer, thanks",
      "created_at": "2023-08-03T13:34:58Z",
      "updated_at": "2023-08-03T13:58:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283215687",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283215687"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283217052",
      "pull_request_review_id": 1561117972,
      "id": 1283217052,
      "node_id": "PRRC_kwDOABII585MfFac",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 256,
      "original_position": 280,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282243358,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "didn't realize `preciousblock` also reconsidered the block!\r\n\r\nwas thinking `reconsiderblock`\r\n",
      "created_at": "2023-08-03T13:35:57Z",
      "updated_at": "2023-08-03T13:58:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283217052",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283217052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 256,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283241941",
      "pull_request_review_id": 1561117972,
      "id": 1283241941,
      "node_id": "PRRC_kwDOABII585MfLfV",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 155,
      "original_position": 161,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\r\n        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\r\n```\r\nmy brain for some reason was thinking it was in the orphan pool as well",
      "created_at": "2023-08-03T13:53:57Z",
      "updated_at": "2023-08-03T13:58:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283241941",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283241941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283247917",
      "pull_request_review_id": 1561117972,
      "id": 1283247917,
      "node_id": "PRRC_kwDOABII585MfM8t",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 136,
      "original_position": 144,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok I feel like I understand the test, but I still don't know why it's important the orphan is fake so I'm likely missing something",
      "created_at": "2023-08-03T13:57:57Z",
      "updated_at": "2023-08-03T13:58:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283247917",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283247917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283271742",
      "pull_request_review_id": 1561207055,
      "id": 1283271742,
      "node_id": "PRRC_kwDOABII585MfSw-",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 136,
      "original_position": 144,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1283247917,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not that important :shrug: it can be a real child. I wrote the test trying to illustrate a spy peer trying to get information, i.e. one that doesn't have the ability to spend the transaction's UTXOs.",
      "created_at": "2023-08-03T14:15:25Z",
      "updated_at": "2023-08-03T14:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283271742",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283271742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274009",
      "pull_request_review_id": 1561210429,
      "id": 1283274009,
      "node_id": "PRRC_kwDOABII585MfTUZ",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 391,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282274277,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(I didn't change it but I also don't feel strongly, could combine if you want)",
      "created_at": "2023-08-03T14:17:00Z",
      "updated_at": "2023-08-03T14:17:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283274009",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 376,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274749",
      "pull_request_review_id": 1561211587,
      "id": 1283274749,
      "node_id": "PRRC_kwDOABII585MfTf9",
      "diff_hunk": "@@ -0,0 +1,439 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+- A delay is added to parent requests because they are by txid.\n+- Requests for orphan parents include ones that are not AlreadyHaveTx. This means old confirmed\n+  parents may be requested.\n+- The node does not give up on orphans if the peer responds to a parent request with notfound. This\n+  means that if a parent is an old confirmed transaction (in which notfound is expected), the\n+  orphan should still be resolved.\n+- Rejected parents can cause an orphan to be dropped, but it depends on the reason and only based\n+  on txid.\n+- Rejected parents can cause an orphan to be rejected too.\n+- Requests for orphan parents should be de-duplicated with \"regular\" txrequest. If a missing parent\n+  has the same hash as an in-flight request, it shouldn't be requested.\n+- Multiple orphans with overlapping parents should not cause duplicated parent requests.\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+# Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+# one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+# (though nothing should since state should be cleared) in p2p data structures.\n+LONG_TIME_SKIP = 12 * 60 * 60\n+\n+def cleanup(func):\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_message_ignored(self, message):\n+        \"\"\"Check that the node does not respond to this message with any of\n+        getdata, inv, tx.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test orphan handling delays\")\n+        node = self.nodes[0]\n+        tx_real = self.wallet.create_self_transfer()\n+        # Fake orphan spends a nonexistent output of tx_real\n+        tx_fake_orphan = self.wallet.create_self_transfer(\n+            utxo_to_spend={\"txid\": tx_real[\"txid\"], \"vout\": 10, \"value\": tx_real[\"new_utxo\"][\"value\"]}\n+        )\n+        # Real orphan with its real parent\n+        orphan_wtxid, orphan_tx, parent_tx = self.create_parent_and_child()\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_message_ignored(msg_tx(tx_fake_orphan[\"tx\"]))\n+        # This transaction is also an orphan. Its parent should be requested later.\n+        peer_spy.assert_message_ignored(msg_tx(orphan_tx))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool.\n+        node.sendrawtransaction(tx_real[\"hex\"])\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_real[\"tx\"].getwtxid(), 16))\n+        peer_spy.assert_message_ignored(msg_getdata([parent_inv]))\n+\n+        # The real orphan's parent should be requested, but not until the request delay elapses.\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(parent_tx.rehash(), 16))\n+        # Request is scheduled with this delay because it is by txid and this\n+        # not a preferred relay peer.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.sync_with_ping()\n+\n+        self.log.info(\"Test parent requests don't reveal whether the parent was present when the orphan arrived\")\n+        # The node should have sent a request for the \"real\" orphan's parent.\n+        # None of the fake orphans should have resulted in a parent request.\n+        assert_equal(1, len(peer_spy.getdata_received))\n+        assert_equal(MSG_TX | MSG_WITNESS_FLAG, peer_spy.getdata_received[0].inv[0].type)\n+        assert_equal(int(parent_tx.rehash(), 16), peer_spy.getdata_received[0].inv[0].hash)\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.fastforward(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when segwit parent paid 0 fee\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when parent's witness is stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        self.generate(node, 1)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer()\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer()\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer()\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Both missing parents should be requested.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"The node should not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_orphans.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.fastforward(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 391,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "29ec234654f8490d0d2c608af5c9565819010b4f",
      "in_reply_to_id": 1282274277,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nope it's fine",
      "created_at": "2023-08-03T14:17:31Z",
      "updated_at": "2023-08-03T14:17:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1283274749",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1283274749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 376,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1287224406",
      "pull_request_review_id": 1567470685,
      "id": 1287224406,
      "node_id": "PRRC_kwDOABII585MuXxW",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 136,
      "original_position": 144,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1283247917,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could you say that in the test then? This really throws me off as a reader!",
      "created_at": "2023-08-08T14:38:32Z",
      "updated_at": "2023-08-08T14:38:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1287224406",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1287224406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290819834",
      "pull_request_review_id": 1572911779,
      "id": 1290819834,
      "node_id": "PRRC_kwDOABII585M8Fj6",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 155,
      "original_position": 161,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1283241941,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we add an rpc to allow querying the orphanage?",
      "created_at": "2023-08-11T01:34:09Z",
      "updated_at": "2023-08-11T01:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290819834",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290819834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290823896",
      "pull_request_review_id": 1572916458,
      "id": 1290823896,
      "node_id": "PRRC_kwDOABII585M8GjY",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 184,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Might be better to be clearer about the different behaviours you're testing for, rather than how you're triggering those behaviours? eg:\r\n\r\n * Orphan handling when parent is known to be invalid\r\n * Orphan handling when segwit parent may be retried with alternate witness data",
      "created_at": "2023-08-11T01:46:11Z",
      "updated_at": "2023-08-11T01:53:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290823896",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290823896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290824888",
      "pull_request_review_id": 1572916458,
      "id": 1290824888,
      "node_id": "PRRC_kwDOABII585M8Gy4",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 124,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe name this something that's a bit more clearly related to mocktime (`bumpmocktime`?) and add it to `BitcoinTestFramework` ?",
      "created_at": "2023-08-11T01:49:01Z",
      "updated_at": "2023-08-11T01:53:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1290824888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1290824888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291139542",
      "pull_request_review_id": 1573359133,
      "id": 1291139542,
      "node_id": "PRRC_kwDOABII585M9TnW",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 155,
      "original_position": 161,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1283241941,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Should we add an rpc to allow querying the orphanage?\r\n\r\nCould do that, as there's a bit of black box-ness here. Though I also think that the ideal situation would be to write unit tests if we're interested in the exact contents of the orphanage.",
      "created_at": "2023-08-11T09:54:34Z",
      "updated_at": "2023-08-11T09:54:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291139542",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291139542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291466087",
      "pull_request_review_id": 1573875706,
      "id": 1291466087,
      "node_id": "PRRC_kwDOABII585M-jVn",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.fastforward(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.fastforward(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when nonsegwit parent paid 0 fee\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 184,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1290823896,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, updated the logging",
      "created_at": "2023-08-11T15:13:10Z",
      "updated_at": "2023-08-11T15:13:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291466087",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291466087"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291467564",
      "pull_request_review_id": 1573878072,
      "id": 1291467564,
      "node_id": "PRRC_kwDOABII585M-jss",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": null,
      "original_position": 124,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1290824888,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, added a `bumpmocktime` to test framework, I'll probably use it in other tests in the future.",
      "created_at": "2023-08-11T15:13:36Z",
      "updated_at": "2023-08-11T15:13:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291467564",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291467564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291469104",
      "pull_request_review_id": 1573880351,
      "id": 1291469104,
      "node_id": "PRRC_kwDOABII585M-kEw",
      "diff_hunk": "@@ -0,0 +1,424 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to fastforward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.mocktime += LONG_TIME_SKIP\n+            self.nodes[0].setmocktime(self.mocktime)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+        self.mocktime = int(time.time())\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def fastforward(self, seconds):\n+        \"\"\"Convenience helper function to fast-forward, so we don't need to keep track of the\n+        starting time when we call setmocktime.\"\"\"\n+        self.mocktime += seconds\n+        self.nodes[0].setmocktime(self.mocktime)\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.fastforward(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 136,
      "original_position": 144,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "abe8536192c9f2cd6ba9d0e083f23dec4d20841f",
      "in_reply_to_id": 1283247917,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorree! Added explanation in the comment.",
      "created_at": "2023-08-11T15:13:57Z",
      "updated_at": "2023-08-11T15:13:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291469104",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291469104"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 136,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291514800",
      "pull_request_review_id": 1573953791,
      "id": 1291514800,
      "node_id": "PRRC_kwDOABII585M-vOw",
      "diff_hunk": "@@ -103,6 +103,11 @@ def __init__(self) -> None:\n         self.supports_cli = True\n         self.bind_to_localhost_only = True\n         self.parse_args()\n+        # Note that we haven't called setmocktime on any nodes yet. If a test wants to use\n+        # setmocktime, it should call bumpmocktime(0) at the beginning of run_test in order to\n+        # prevent spurious failures. If the test does not want to use setmocktime, it must not call\n+        # setmocktime because the time will not move forward afterwards.\n+        self.mocktime = int(time.time())",
      "path": "test/functional/test_framework/test_framework.py",
      "position": null,
      "original_position": 8,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "afbc2b17e5e830b273675ee04d337bad304127fb",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Wouldn't it make more sense to have `bumpmocktime` on TestNode and set `self.mocktime` when ever `setmocktime` is called?\r\n\r\n* allows for node independent mocktime bumping\r\n* allows to use an initial mocktime other than time.time()",
      "created_at": "2023-08-11T15:34:43Z",
      "updated_at": "2023-08-11T15:34:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1291514800",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1291514800"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293136573",
      "pull_request_review_id": 1576321643,
      "id": 1293136573,
      "node_id": "PRRC_kwDOABII585NE7K9",
      "diff_hunk": "@@ -103,6 +103,11 @@ def __init__(self) -> None:\n         self.supports_cli = True\n         self.bind_to_localhost_only = True\n         self.parse_args()\n+        # Note that we haven't called setmocktime on any nodes yet. If a test wants to use\n+        # setmocktime, it should call bumpmocktime(0) at the beginning of run_test in order to\n+        # prevent spurious failures. If the test does not want to use setmocktime, it must not call\n+        # setmocktime because the time will not move forward afterwards.\n+        self.mocktime = int(time.time())",
      "path": "test/functional/test_framework/test_framework.py",
      "position": null,
      "original_position": 8,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "afbc2b17e5e830b273675ee04d337bad304127fb",
      "in_reply_to_id": 1291514800,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, moved from TestFramework to TestNode",
      "created_at": "2023-08-14T08:12:56Z",
      "updated_at": "2023-08-14T08:12:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1293136573",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293136573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293423583",
      "pull_request_review_id": 1576791575,
      "id": 1293423583,
      "node_id": "PRRC_kwDOABII585NGBPf",
      "diff_hunk": "@@ -103,6 +103,11 @@ def __init__(self) -> None:\n         self.supports_cli = True\n         self.bind_to_localhost_only = True\n         self.parse_args()\n+        # Note that we haven't called setmocktime on any nodes yet. If a test wants to use\n+        # setmocktime, it should call bumpmocktime(0) at the beginning of run_test in order to\n+        # prevent spurious failures. If the test does not want to use setmocktime, it must not call\n+        # setmocktime because the time will not move forward afterwards.\n+        self.mocktime = int(time.time())",
      "path": "test/functional/test_framework/test_framework.py",
      "position": null,
      "original_position": 8,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "afbc2b17e5e830b273675ee04d337bad304127fb",
      "in_reply_to_id": 1291514800,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "... and set self.mocktime when ever setmocktime is called?",
      "created_at": "2023-08-14T12:55:50Z",
      "updated_at": "2023-08-14T12:55:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1293423583",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293423583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293480751",
      "pull_request_review_id": 1576880643,
      "id": 1293480751,
      "node_id": "PRRC_kwDOABII585NGPMv",
      "diff_hunk": "@@ -103,6 +103,11 @@ def __init__(self) -> None:\n         self.supports_cli = True\n         self.bind_to_localhost_only = True\n         self.parse_args()\n+        # Note that we haven't called setmocktime on any nodes yet. If a test wants to use\n+        # setmocktime, it should call bumpmocktime(0) at the beginning of run_test in order to\n+        # prevent spurious failures. If the test does not want to use setmocktime, it must not call\n+        # setmocktime because the time will not move forward afterwards.\n+        self.mocktime = int(time.time())",
      "path": "test/functional/test_framework/test_framework.py",
      "position": null,
      "original_position": 8,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "afbc2b17e5e830b273675ee04d337bad304127fb",
      "in_reply_to_id": 1291514800,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a wrapper for the RPC to update `TestNode::mocktime` every time `setmocktime` is called.",
      "created_at": "2023-08-14T13:45:49Z",
      "updated_at": "2023-08-14T13:45:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1293480751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293480751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293574085",
      "pull_request_review_id": 1577015320,
      "id": 1293574085,
      "node_id": "PRRC_kwDOABII585NGl_F",
      "diff_hunk": "@@ -144,6 +144,11 @@ def __init__(self, i, datadir, *, chain, rpchost, timewait, timeout_factor, bitc\n         self.p2ps = []\n         self.timeout_factor = timeout_factor\n \n+        # The time doesn't move forwards after we mock it, so don't call setmocktime if the test\n+        # doesn't intend to use it.  If a test wants to use setmocktime, it should call\n+        # bumpmocktime(0) at the beginning of run_test in order to prevent spurious failures.\n+        self.mocktime = int(time.time())",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 7,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "878f066565c2b48fb174e89c069a0be1b91f44e0",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry for being nitty about this but it's a little weird to have this set to some time that is different from the actual mock time of the node.\r\n\r\nI would suggest initializing this to `None`, resetting it to `None` if `setmocktime(0)` was called and additionally assert that it is not None in `bumpmocktime`.\r\n\r\nThis ensures it is not set to some differing value (different from the actual mocktime) and makes sure `bumpmocktime` is used correctly. `TestNode.mocktime` can then also be reliably used as a getter for the node's mocktime.",
      "created_at": "2023-08-14T14:47:14Z",
      "updated_at": "2023-08-14T14:47:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1293574085",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293574085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293586086",
      "pull_request_review_id": 1577035161,
      "id": 1293586086,
      "node_id": "PRRC_kwDOABII585NGo6m",
      "diff_hunk": "@@ -144,6 +144,11 @@ def __init__(self, i, datadir, *, chain, rpchost, timewait, timeout_factor, bitc\n         self.p2ps = []\n         self.timeout_factor = timeout_factor\n \n+        # The time doesn't move forwards after we mock it, so don't call setmocktime if the test\n+        # doesn't intend to use it.  If a test wants to use setmocktime, it should call\n+        # bumpmocktime(0) at the beginning of run_test in order to prevent spurious failures.\n+        self.mocktime = int(time.time())",
      "path": "test/functional/test_framework/test_node.py",
      "position": null,
      "original_position": 7,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "878f066565c2b48fb174e89c069a0be1b91f44e0",
      "in_reply_to_id": 1293574085,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I like that the assertion forces tests to make an initial setmocktime call before calling bumpmocktime.",
      "created_at": "2023-08-14T14:56:08Z",
      "updated_at": "2023-08-14T14:56:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1293586086",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1293586086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1294605712",
      "pull_request_review_id": 1578574354,
      "id": 1294605712,
      "node_id": "PRRC_kwDOABII585NKh2Q",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 281,
      "original_position": 281,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Requesting the already confirmed transaction is surprising to me. Is this expected to change in future work (if so a comment mentioning that would be useful) or is it intended behavior?",
      "created_at": "2023-08-15T13:35:50Z",
      "updated_at": "2023-08-15T13:38:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1294605712",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1294605712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 281,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1294606522",
      "pull_request_review_id": 1578574354,
      "id": 1294606522,
      "node_id": "PRRC_kwDOABII585NKiC6",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        confirmed_utxos = [self.wallet_nonsegwit.get_utxo() for _ in range(4)]\n+        assert all([utxo[\"confirmations\"] > 0 for utxo in confirmed_utxos])\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[0])\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[1])\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[2])\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[3])\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # There are 3 missing parents. missing_parent_A and missing_parent_AB should be requested.\n+        # But inflight_parent_AB should not, because there is already an in-flight request for it.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_txrequest and peer_orphans respectively.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test that an orphan with rejected parents, along with any descendants, cannot be retried with an alternate witness\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee_nonsegwit[\"new_utxo\"])\n+        grandchild = self.wallet.create_self_transfer(utxo_to_spend=child[\"new_utxo\"])\n+        assert child[\"txid\"] != child[\"tx\"].getwtxid()\n+        assert grandchild[\"txid\"] != grandchild[\"tx\"].getwtxid()\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 380,
      "original_position": 380,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could check that `parent_low_fee_nonsegwit` is not in the mempool as done in the other test cases.",
      "created_at": "2023-08-15T13:36:32Z",
      "updated_at": "2023-08-15T13:38:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1294606522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1294606522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 380,
      "original_line": 380,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1294614675",
      "pull_request_review_id": 1578587341,
      "id": 1294614675,
      "node_id": "PRRC_kwDOABII585NKkCT",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 281,
      "original_position": 281,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": 1294605712,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Requesting the already confirmed transaction is surprising to me.\r\n\r\nYep, was strange to me too, but `AlreadyHaveTx` is peerman's best metric for determining what the missing parents are (validation doesn't say which one(s) are missing). Also afaiu it's considered uncommon to (1) have an orphan (2) have a transaction that spends a very old coin, so I'm guessing this is quite rare.\r\n\r\n> Is this expected to change in future work\r\n\r\nI'm not aware of any plans to change the legacy way of requesting orphan parents. But with package relay we'd ask for the list of unconfirmed ancestors, so we wouldn't have this kind of false positive.",
      "created_at": "2023-08-15T13:42:57Z",
      "updated_at": "2023-08-15T13:42:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1294614675",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1294614675"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 281,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298585453",
      "pull_request_review_id": 1584785042,
      "id": 1298585453,
      "node_id": "PRRC_kwDOABII585NZtdt",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 116,
      "original_position": 116,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This function seems unused.",
      "created_at": "2023-08-18T15:27:56Z",
      "updated_at": "2023-08-18T16:50:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1298585453",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298585453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 116,
      "original_line": 116,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298585660",
      "pull_request_review_id": 1584785042,
      "id": 1298585660,
      "node_id": "PRRC_kwDOABII585NZtg8",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 66,
      "original_position": 66,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This seems unused.",
      "created_at": "2023-08-18T15:28:08Z",
      "updated_at": "2023-08-18T16:50:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1298585660",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298585660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298619617",
      "pull_request_review_id": 1584785042,
      "id": 1298619617,
      "node_id": "PRRC_kwDOABII585NZ1zh",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        confirmed_utxos = [self.wallet_nonsegwit.get_utxo() for _ in range(4)]\n+        assert all([utxo[\"confirmations\"] > 0 for utxo in confirmed_utxos])\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[0])\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[1])\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[2])\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[3])\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # There are 3 missing parents. missing_parent_A and missing_parent_AB should be requested.\n+        # But inflight_parent_AB should not, because there is already an in-flight request for it.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_txrequest and peer_orphans respectively.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 359,
      "original_position": 359,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could add another assertion here that `missing_parent_orphan` is indeed only requested once.",
      "created_at": "2023-08-18T16:03:14Z",
      "updated_at": "2023-08-18T16:50:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1298619617",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298619617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 359,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298628089",
      "pull_request_review_id": 1584785042,
      "id": 1298628089,
      "node_id": "PRRC_kwDOABII585NZ335",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        confirmed_utxos = [self.wallet_nonsegwit.get_utxo() for _ in range(4)]\n+        assert all([utxo[\"confirmations\"] > 0 for utxo in confirmed_utxos])\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 301,
      "original_position": 301,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I would argue that the (or the first) log should always be the first line of the test. Otherwise it may be confusing if an error happens in the code above it may look like the previous test failed.",
      "created_at": "2023-08-18T16:11:11Z",
      "updated_at": "2023-08-18T16:50:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1298628089",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298628089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298649533",
      "pull_request_review_id": 1584785042,
      "id": 1298649533,
      "node_id": "PRRC_kwDOABII585NZ9G9",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        confirmed_utxos = [self.wallet_nonsegwit.get_utxo() for _ in range(4)]\n+        assert all([utxo[\"confirmations\"] > 0 for utxo in confirmed_utxos])\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[0])\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[1])\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[2])\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[3])\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # There are 3 missing parents. missing_parent_A and missing_parent_AB should be requested.\n+        # But inflight_parent_AB should not, because there is already an in-flight request for it.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 331,
      "original_position": 331,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I was a bit irritated that that `inflight_parent_AB` not being requested isn't checked here but I see it follows below. For expressiveness you could consider duplicating the check here or adding a small comment.",
      "created_at": "2023-08-18T16:35:59Z",
      "updated_at": "2023-08-18T16:50:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1298649533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298649533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298655437",
      "pull_request_review_id": 1584785042,
      "id": 1298655437,
      "node_id": "PRRC_kwDOABII585NZ-jN",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):\n+        \"\"\"Create package with 1 parent and 1 child, normal fees (no cpfp).\"\"\"\n+        parent = self.wallet.create_self_transfer()\n+        child = self.wallet.create_self_transfer(utxo_to_spend=parent['new_utxo'])\n+        return child[\"tx\"].getwtxid(), child[\"tx\"], parent[\"tx\"]\n+\n+    def relay_transaction(self, peer, tx):\n+        \"\"\"Relay transaction using MSG_WTX\"\"\"\n+        wtxid = int(tx.getwtxid(), 16)\n+        peer.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=wtxid)]))\n+        self.nodes[0].bumpmocktime(TXREQUEST_TIME_SKIP)\n+        peer.wait_for_getdata([wtxid])\n+        peer.send_and_ping(msg_tx(tx))\n+\n+    @cleanup\n+    def test_arrival_timing_orphan(self):\n+        self.log.info(\"Test missing parents that arrive during delay are not requested\")\n+        node = self.nodes[0]\n+        tx_parent_arrives = self.wallet.create_self_transfer()\n+        tx_parent_doesnt_arrive = self.wallet.create_self_transfer()\n+        # Fake orphan spends nonexistent outputs of the two parents\n+        tx_fake_orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[\n+            {\"txid\": tx_parent_doesnt_arrive[\"txid\"], \"vout\": 10, \"value\": tx_parent_doesnt_arrive[\"new_utxo\"][\"value\"]},\n+            {\"txid\": tx_parent_arrives[\"txid\"], \"vout\": 10, \"value\": tx_parent_arrives[\"new_utxo\"][\"value\"]}\n+        ])\n+\n+        peer_spy = node.add_p2p_connection(PeerTxRelayer())\n+        peer_normal = node.add_p2p_connection(PeerTxRelayer())\n+        # This transaction is an orphan because it is missing inputs. It is a \"fake\" orphan that the\n+        # spy peer has crafted to learn information about tx_parent_arrives even though it isn't\n+        # able to spend a real output of it, but it could also just be a normal, real child tx.\n+        # The node should not immediately respond with a request for orphan parents.\n+        # Also, no request should be sent later because it will be resolved by\n+        # the time the request is scheduled to be sent.\n+        peer_spy.assert_no_immediate_response(msg_tx(tx_fake_orphan[\"tx\"]))\n+\n+        # Node receives transaction. It attempts to obfuscate the exact timing at which this\n+        # transaction entered its mempool. Send unsolicited because otherwise we need to wait for\n+        # request delays.\n+        peer_normal.send_and_ping(msg_tx(tx_parent_arrives[\"tx\"]))\n+        assert tx_parent_arrives[\"txid\"] in node.getrawmempool()\n+\n+        # Spy peer should not be able to query the node for the parent yet, since it hasn't been\n+        # announced / insufficient time has elapsed.\n+        parent_inv = CInv(t=MSG_WTX, h=int(tx_parent_arrives[\"tx\"].getwtxid(), 16))\n+        assert_equal(len(peer_spy.get_invs()), 0)\n+        peer_spy.assert_no_immediate_response(msg_getdata([parent_inv]))\n+\n+        # Request would be scheduled with this delay because it is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+        peer_spy.assert_never_requested(int(tx_parent_doesnt_arrive[\"txid\"], 16))\n+        # Request would be scheduled with this delay because it is by txid.\n+        self.nodes[0].bumpmocktime(TXID_RELAY_DELAY)\n+        peer_spy.wait_for_parent_requests([int(tx_parent_doesnt_arrive[\"txid\"], 16)])\n+        peer_spy.assert_never_requested(int(tx_parent_arrives[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_rejected_parents_exceptions(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan handling when a nonsegwit parent is known to be invalid\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())\n+        parent_other = self.wallet_nonsegwit.create_self_transfer()\n+        child_nonsegwit = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_other[\"new_utxo\"], parent_low_fee_nonsegwit[\"new_utxo\"]])\n+\n+        # Relay the parent. It should be rejected because it pays 0 fees.\n+        self.relay_transaction(peer1, parent_low_fee_nonsegwit[\"tx\"])\n+        assert parent_low_fee_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        # Its parent should not be requested because its hash (txid == wtxid) has been added to the rejection filter.\n+        with node.assert_debug_log(['not keeping orphan with rejected parents {}'.format(child_nonsegwit[\"txid\"])]):\n+            self.relay_transaction(peer2, child_nonsegwit[\"tx\"])\n+        assert child_nonsegwit[\"txid\"] not in node.getrawmempool()\n+\n+        # No parents are requested.\n+        self.nodes[0].bumpmocktime(GETDATA_TX_INTERVAL)\n+        peer1.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_other[\"txid\"], 16))\n+        peer2.assert_never_requested(int(parent_low_fee_nonsegwit[\"txid\"], 16))\n+\n+        self.log.info(\"Test orphan handling when a segwit parent was invalid but may be retried with another witness\")\n+        parent_low_fee = self.wallet.create_self_transfer(fee_rate=0)\n+        child_low_fee = self.wallet.create_self_transfer(utxo_to_spend=parent_low_fee[\"new_utxo\"])\n+\n+        # Relay the low fee parent. It should not be accepted.\n+        self.relay_transaction(peer1, parent_low_fee[\"tx\"])\n+        assert parent_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_low_fee[\"tx\"])\n+        assert child_low_fee[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested because even though the txid commits to the fee, it doesn't\n+        # commit to the feerate. Delayed because it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_low_fee[\"tx\"].rehash(), 16)])\n+\n+        self.log.info(\"Test orphan handling when a parent was previously downloaded with witness stripped\")\n+        parent_normal = self.wallet.create_self_transfer()\n+        parent1_witness_stripped = tx_from_hex(parent_normal[\"tx\"].serialize_without_witness().hex())\n+        child_invalid_witness = self.wallet.create_self_transfer(utxo_to_spend=parent_normal[\"new_utxo\"])\n+\n+        # Relay the parent with witness stripped. It should not be accepted.\n+        self.relay_transaction(peer1, parent1_witness_stripped)\n+        assert_equal(parent_normal[\"txid\"], parent1_witness_stripped.rehash())\n+        assert parent1_witness_stripped.rehash() not in node.getrawmempool()\n+\n+        # Relay the child. It should not be accepted because it has missing inputs.\n+        self.relay_transaction(peer2, child_invalid_witness[\"tx\"])\n+        assert child_invalid_witness[\"txid\"] not in node.getrawmempool()\n+\n+        # The parent should be requested since the unstripped wtxid would differ. Delayed because\n+        # it's by txid and this is not a preferred relay peer.\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer2.wait_for_getdata([int(parent_normal[\"tx\"].rehash(), 16)])\n+\n+        # parent_normal can be relayed again even though parent1_witness_stripped was rejected\n+        self.relay_transaction(peer1, parent_normal[\"tx\"])\n+        assert_equal(set(node.getrawmempool()), set([parent_normal[\"txid\"], child_invalid_witness[\"txid\"]]))\n+\n+    @cleanup\n+    def test_orphan_multiple_parents(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test orphan parent requests with a mixture of confirmed, in-mempool and missing parents\")\n+        # This UTXO confirmed a long time ago.\n+        utxo_conf_old = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        txid_conf_old = utxo_conf_old[\"txid\"]\n+        self.generate(self.wallet, 10)\n+\n+        # Create a fake reorg to trigger BlockDisconnected, which resets the rolling bloom filter.\n+        # The alternative is to mine thousands of transactions to push it out of the filter.\n+        last_block = node.getbestblockhash()\n+        node.invalidateblock(last_block)\n+        node.preciousblock(last_block)\n+        node.syncwithvalidationinterfacequeue()\n+\n+        # This UTXO confirmed recently.\n+        utxo_conf_recent = self.wallet.send_self_transfer(from_node=node)[\"new_utxo\"]\n+        self.generate(node, 1)\n+\n+        # This UTXO is unconfirmed and in the mempool.\n+        assert_equal(len(node.getrawmempool()), 0)\n+        mempool_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_unconf_mempool = mempool_tx[\"new_utxo\"]\n+\n+        # This UTXO is unconfirmed and missing.\n+        missing_tx = self.wallet.create_self_transfer()\n+        utxo_unconf_missing = missing_tx[\"new_utxo\"]\n+        assert missing_tx[\"txid\"] not in node.getrawmempool()\n+\n+        orphan = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_conf_old,\n+            utxo_conf_recent, utxo_unconf_mempool, utxo_unconf_missing])\n+\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.sync_with_ping()\n+        assert_equal(len(peer.last_message[\"getdata\"].inv), 2)\n+        peer.wait_for_parent_requests([int(txid_conf_old, 16), int(missing_tx[\"txid\"], 16)])\n+\n+        # Even though the peer would send a notfound for the \"old\" confirmed transaction, the node\n+        # doesn't give up on the orphan. Once all of the missing parents are received, it should be\n+        # submitted to mempool.\n+        peer.send_message(msg_notfound(vec=[CInv(MSG_WITNESS_TX, int(txid_conf_old, 16))]))\n+        peer.send_and_ping(msg_tx(missing_tx[\"tx\"]))\n+        peer.sync_with_ping()\n+        assert_equal(node.getmempoolentry(orphan[\"txid\"])[\"ancestorcount\"], 3)\n+\n+    @cleanup\n+    def test_orphans_overlapping_parents(self):\n+        node = self.nodes[0]\n+        # In the process of relaying inflight_parent_AB\n+        peer_txrequest = node.add_p2p_connection(PeerTxRelayer())\n+        # Sends the orphans\n+        peer_orphans = node.add_p2p_connection(PeerTxRelayer())\n+\n+        confirmed_utxos = [self.wallet_nonsegwit.get_utxo() for _ in range(4)]\n+        assert all([utxo[\"confirmations\"] > 0 for utxo in confirmed_utxos])\n+        self.log.info(\"Test handling of multiple orphans with missing parents that are already being requested\")\n+        # Parent of child_A only\n+        missing_parent_A = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[0])\n+        # Parents of child_A and child_B\n+        missing_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[1])\n+        inflight_parent_AB = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[2])\n+        # Parent of child_B only\n+        missing_parent_B = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=confirmed_utxos[3])\n+        child_A = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_A[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+        child_B = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[missing_parent_B[\"new_utxo\"], missing_parent_AB[\"new_utxo\"], inflight_parent_AB[\"new_utxo\"]]\n+        )\n+\n+        # The wtxid and txid need to be the same for the node to recognize that the missing input\n+        # and in-flight request for inflight_parent_AB are the same transaction.\n+        assert_equal(inflight_parent_AB[\"txid\"], inflight_parent_AB[\"tx\"].getwtxid())\n+\n+        # Announce inflight_parent_AB and wait for getdata\n+        peer_txrequest.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=int(inflight_parent_AB[\"tx\"].getwtxid(), 16))]))\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY)\n+        peer_txrequest.wait_for_getdata([int(inflight_parent_AB[\"tx\"].getwtxid(), 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight txrequest\")\n+        # Relay orphan child_A\n+        self.relay_transaction(peer_orphans, child_A[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # There are 3 missing parents. missing_parent_A and missing_parent_AB should be requested.\n+        # But inflight_parent_AB should not, because there is already an in-flight request for it.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_A[\"txid\"], 16), int(missing_parent_AB[\"txid\"], 16)])\n+\n+        self.log.info(\"Test that the node does not request a parent if it has an in-flight orphan parent request\")\n+        # Relay orphan child_B\n+        self.relay_transaction(peer_orphans, child_B[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        # Only missing_parent_B should be requested. Not inflight_parent_AB or missing_parent_AB\n+        # because they are already being requested from peer_txrequest and peer_orphans respectively.\n+        peer_orphans.wait_for_parent_requests([int(missing_parent_B[\"txid\"], 16)])\n+        peer_orphans.assert_never_requested(int(inflight_parent_AB[\"txid\"], 16))\n+\n+    @cleanup\n+    def test_orphan_of_orphan(self):\n+        node = self.nodes[0]\n+        peer = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test handling of an orphan with a parent who is another orphan\")\n+        missing_grandparent = self.wallet_nonsegwit.create_self_transfer()\n+        missing_parent_orphan = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=missing_grandparent[\"new_utxo\"])\n+        missing_parent = self.wallet_nonsegwit.create_self_transfer()\n+        orphan = self.wallet_nonsegwit.create_self_transfer_multi(utxos_to_spend=[missing_parent[\"new_utxo\"], missing_parent_orphan[\"new_utxo\"]])\n+\n+        # The node should put missing_parent_orphan into the orphanage and request missing_grandparent\n+        self.relay_transaction(peer, missing_parent_orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_grandparent[\"txid\"], 16)])\n+\n+        # The node should put the orphan into the orphanage and request missing_parent, skipping\n+        # missing_parent_orphan because it already has it in the orphanage.\n+        self.relay_transaction(peer, orphan[\"tx\"])\n+        self.nodes[0].bumpmocktime(NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY)\n+        peer.wait_for_parent_requests([int(missing_parent[\"txid\"], 16)])\n+\n+    @cleanup\n+    def test_orphan_inherit_rejection(self):\n+        node = self.nodes[0]\n+        peer1 = node.add_p2p_connection(PeerTxRelayer())\n+        peer2 = node.add_p2p_connection(PeerTxRelayer())\n+        peer3 = node.add_p2p_connection(PeerTxRelayer())\n+\n+        self.log.info(\"Test that an orphan with rejected parents, along with any descendants, cannot be retried with an alternate witness\")\n+        parent_low_fee_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=0)\n+        assert_equal(parent_low_fee_nonsegwit[\"txid\"], parent_low_fee_nonsegwit[\"tx\"].getwtxid())",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 373,
      "original_position": 373,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: This sanity check is repeated multiple times. I think it would be enough to do it once when setting up the `MiniWallet` since that seems to be the only way there could be an issue, if somehow MiniWallet is broken.",
      "created_at": "2023-08-18T16:42:57Z",
      "updated_at": "2023-08-18T16:50:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1298655437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1298655437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 373,
      "original_line": 373,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301705514",
      "pull_request_review_id": 1589538852,
      "id": 1301705514,
      "node_id": "PRRC_kwDOABII585NlnMq",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import time\n+\n+from test_framework.messages import (\n+    CInv,\n+    MSG_TX,\n+    MSG_WITNESS_TX,\n+    MSG_WTX,\n+    msg_getdata,\n+    msg_inv,\n+    msg_notfound,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    GETDATA_TX_INTERVAL,\n+    NONPREF_PEER_TX_DELAY,\n+    OVERLOADED_PEER_TX_DELAY,\n+    p2p_lock,\n+    P2PTxInvStore,\n+    TXID_RELAY_DELAY,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# Time to bump forward (using setmocktime) before waiting for the node to send getdata(tx) in response\n+# to an inv(tx), in seconds. This delay includes all possible delays + 1, so it should only be used\n+# when the value of the delay is not interesting. If we want to test that the node waits x seconds\n+# for one peer and y seconds for another, use specific values instead.\n+TXREQUEST_TIME_SKIP = NONPREF_PEER_TX_DELAY + TXID_RELAY_DELAY + OVERLOADED_PEER_TX_DELAY + 1\n+\n+def cleanup(func):\n+    # Time to fastfoward (using setmocktime) in between subtests to ensure they do not interfere with\n+    # one another, in seconds. Equal to 12 hours, which is enough to expire anything that may exist\n+    # (though nothing should since state should be cleared) in p2p data structures.\n+    LONG_TIME_SKIP = 12 * 60 * 60\n+\n+    def wrapper(self):\n+        try:\n+            func(self)\n+        finally:\n+            # Clear mempool\n+            self.generate(self.nodes[0], 1)\n+            self.nodes[0].disconnect_p2ps()\n+            self.nodes[0].bumpmocktime(LONG_TIME_SKIP)\n+    return wrapper\n+\n+class PeerTxRelayer(P2PTxInvStore):\n+    \"\"\"A P2PTxInvStore that also remembers all of the getdata and tx messages it receives.\"\"\"\n+    def __init__(self):\n+        super().__init__()\n+        self._tx_received = []\n+        self._getdata_received = []\n+\n+    @property\n+    def tx_received(self):\n+        with p2p_lock:\n+            return self._tx_received\n+\n+    @property\n+    def getdata_received(self):\n+        with p2p_lock:\n+            return self._getdata_received\n+\n+    def on_tx(self, message):\n+        self._tx_received.append(message)\n+\n+    def on_getdata(self, message):\n+        self._getdata_received.append(message)\n+\n+    def wait_for_parent_requests(self, txids):\n+        \"\"\"Wait for requests for missing parents by txid with witness data (MSG_WITNESS_TX or\n+        WitnessTx). Requires that the getdata message match these txids exactly; all txids must be\n+        requested and no additional requests are allowed.\"\"\"\n+        def test_function():\n+            last_getdata = self.last_message.get('getdata')\n+            if not last_getdata:\n+                return False\n+            return len(last_getdata.inv) == len(txids) and all([item.type == MSG_WITNESS_TX and item.hash in txids for item in last_getdata.inv])\n+        self.wait_until(test_function, timeout=10)\n+\n+    def assert_no_immediate_response(self, message):\n+        \"\"\"Check that the node does not immediately respond to this message with any of getdata,\n+        inv, tx. The node may respond later.\n+        \"\"\"\n+        prev_lastmessage = self.last_message\n+        self.send_and_ping(message)\n+        after_lastmessage = self.last_message\n+        for msgtype in [\"getdata\", \"inv\", \"tx\"]:\n+            if msgtype not in prev_lastmessage:\n+                assert msgtype not in after_lastmessage\n+            else:\n+                assert_equal(prev_lastmessage[msgtype], after_lastmessage[msgtype])\n+\n+    def assert_never_requested(self, txhash):\n+        \"\"\"Check that the node has never sent us a getdata for this hash (int type)\"\"\"\n+        for getdata in self.getdata_received:\n+            for request in getdata.inv:\n+                assert request.hash != txhash\n+\n+class OrphanHandlingTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [[]]\n+\n+    def create_parent_and_child(self):",
      "path": "test/functional/p2p_orphan_handling.py",
      "position": 116,
      "original_position": 116,
      "commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "original_commit_id": "9eac5a0529f869075f0331e40d322c34fc8fc2af",
      "in_reply_to_id": 1298585453,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My bad!\r\n\r\n> I can also open a follow-up myself if someone feels like merging this as is.\r\n\r\nIf it helps, they were written to be used in #28031. I pulled these tests out to merge before the refactors and I guess forgot to remove the helpers that aren't used (yet).",
      "created_at": "2023-08-22T14:06:11Z",
      "updated_at": "2023-08-22T14:06:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28199#discussion_r1301705514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1301705514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28199"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 116,
      "original_line": 116,
      "side": "RIGHT"
    }
  ]
}