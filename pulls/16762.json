{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
    "id": 312482495,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MzEyNDgyNDk1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/16762",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/16762.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/16762.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/2c0dda33c51324686bc143d8bed89ebba088ab8a",
    "number": 16762,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "Rust-based Backup over-REST block downloader",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is based on #15798.\r\n\r\nI'm increasingly worried about censorship and other attacks in the P2P network (see, eg, https://twitter.com/TheBlueMatt/status/1160620919775211520). While obviously making the net_processing p2p implementation more robust should be the focus (eg #15759), adding more redundancy in every way is also key. To avoid needless review burden on such systems, I think rust is an ideal candidate: it is wholly optional so we don't just right to requiring Rust for Bitcoin Core, but building with it still provides real benefit, plus we can use compile-time checks to catch any overflows and memory corruption bugs to reduce review burden.\r\n\r\nThis PR implements a simple API for Rust code to fetch headers and blocks and then implements a sample client that can sync the chain using a REST endpoint. As a demo, I provide a rest endpoint over cloudflare at http://cloudflare.deanonymizingseed.com/rest/ so you should be able to fully sync the chain (albeit very slowly) with bitcoind -blockfetchrest=http://cloudflare.deanonymizingseed.com/rest/ -connect=0\r\n\r\nThere's a few things to do before this is mergable, but I'd like feedback on the idea, and would like to also have a fully parallel, in rust, P2P net layer that is similarly simple and provides a nice redundant implementation in the future.",
    "labels": [
      {
        "id": 64583,
        "node_id": "MDU6TGFiZWw2NDU4Mw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
        "name": "Feature",
        "color": "7cf575",
        "default": false
      },
      {
        "id": 64584,
        "node_id": "MDU6TGFiZWw2NDU4NA==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming",
        "name": "Brainstorming",
        "color": "ebd775",
        "default": false
      },
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      },
      {
        "id": 955867938,
        "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
        "name": "Needs rebase",
        "description": "",
        "color": "cccccc",
        "default": false
      },
      {
        "id": 1392286103,
        "node_id": "MDU6TGFiZWwxMzkyMjg2MTAz",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20Conceptual%20Review",
        "name": "Needs Conceptual Review",
        "description": "",
        "color": "fef2c0",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/42",
      "html_url": "https://github.com/bitcoin/bitcoin/milestone/42",
      "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/42/labels",
      "id": 4116761,
      "node_id": "MDk6TWlsZXN0b25lNDExNjc2MQ==",
      "number": 42,
      "state": "closed",
      "title": "0.20.0",
      "description": "",
      "creator": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 0,
      "closed_issues": 91,
      "created_at": "2019-03-06T20:02:40Z",
      "updated_at": "2020-06-02T07:55:47Z",
      "closed_at": "2020-06-02T07:55:47Z"
    },
    "active_lock_reason": "resolved",
    "created_at": "2019-08-29T20:30:51Z",
    "updated_at": "2022-02-15T10:41:43Z",
    "closed_at": "2020-03-05T19:48:04Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "c37f5aaffea72b4cc3957f59b66a2274da2543cc",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "TheBlueMatt:2019-08-rusty-block-download",
      "ref": "2019-08-rusty-block-download",
      "sha": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1443291,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDQzMjkx",
        "name": "bitcoin",
        "full_name": "TheBlueMatt/bitcoin",
        "owner": {
          "login": "TheBlueMatt",
          "id": 649246,
          "node_id": "MDQ6VXNlcjY0OTI0Ng==",
          "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/TheBlueMatt",
          "html_url": "https://github.com/TheBlueMatt",
          "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
          "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
          "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
          "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
          "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/TheBlueMatt/bitcoin",
        "description": "Bitcoin (dont fork from here, fork from bitcoin/bitcoin)",
        "fork": true,
        "url": "https://api.github.com/repos/TheBlueMatt/bitcoin",
        "archive_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/events",
        "forks_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/TheBlueMatt/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:TheBlueMatt/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/TheBlueMatt/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/TheBlueMatt/bitcoin/hooks",
        "svn_url": "https://github.com/TheBlueMatt/bitcoin",
        "homepage": "http://www.bitcoin.org/",
        "language": "C++",
        "forks_count": 6,
        "stargazers_count": 19,
        "watchers_count": 19,
        "size": 171686,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T09:41:52Z",
        "created_at": "2011-03-05T14:14:49Z",
        "updated_at": "2022-12-15T18:21:13Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "6fff333c9f00cf379562ed38c2599997f9821cfb",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34348,
        "stargazers_count": 69853,
        "watchers_count": 69853,
        "size": 234261,
        "default_branch": "master",
        "open_issues_count": 631,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T22:17:10Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-09T07:25:15Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1189,
    "deletions": 124,
    "changed_files": 20,
    "commits": 13,
    "review_comments": 29,
    "comments": 18
  },
  "events": [
    {
      "event": "labeled",
      "id": 2595253087,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI1OTUyNTMwODc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595253087",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:31:49Z",
      "label": {
        "name": "Brainstorming",
        "color": "ebd775"
      }
    },
    {
      "event": "labeled",
      "id": 2595253088,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI1OTUyNTMwODg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595253088",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:31:49Z",
      "label": {
        "name": "Needs Conceptual Review",
        "color": "fef2c0"
      }
    },
    {
      "event": "labeled",
      "id": 2595253783,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI1OTUyNTM3ODM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595253783",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T20:32:02Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595395746,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTM5NTc0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595395746",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T21:28:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595584581,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTU4NDU4MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595584581",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T23:18:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595613598,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTYxMzU5OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595613598",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T23:40:44Z"
    },
    {
      "event": "commented",
      "id": 526402501,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjQwMjUwMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526402501",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-29T23:53:44Z",
      "updated_at": "2020-01-03T20:22:54Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#17783](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17783.html) (util: Fix -norpcwhitelist, -norpcallowip, and similar corner case behavior by ryanofsky)\n* [#17581](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17581.html) (refactor: Remove settings merge reverse precedence code by ryanofsky)\n* [#17580](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17580.html) (refactor: Add ALLOW_LIST flags and enforce usage in CheckArgFlags by ryanofsky)\n* [#17493](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17493.html) (util: Forbid ambiguous multiple assignments in config file by ryanofsky)\n* [#17452](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17452.html) (test: update fuzz directory in .gitignore by jonatack)\n* [#17398](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17398.html) (build: Update leveldb to 1.22+ by laanwj)\n* [#17383](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17383.html) (Refactor: Move consts to their correct translation units by jnewbery)\n* [#17227](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17227.html) (Qt: Add Android packaging support by icota)\n* [#16722](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16722.html) (build: Disable warnings for leveldb subtree by default by hebasto)\n* [#15606](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15606.html) ([experimental] UTXO snapshots by jamesob)\n* [#15367](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15367.html) (feature: Added ability for users to add a startup command by benthecarman)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526402501",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2595947862,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NTk0Nzg2Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2595947862",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T04:17:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2596194004,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5NjE5NDAwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2596194004",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T06:57:27Z"
    },
    {
      "event": "reviewed",
      "id": 281872721,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgxODcyNzIx",
      "url": null,
      "actor": null,
      "commit_id": "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#pullrequestreview-281872721",
      "submitted_at": "2019-08-30T07:38:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
    },
    {
      "event": "mentioned",
      "id": 2596299799,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU5NjI5OTc5OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2596299799",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T07:44:25Z"
    },
    {
      "event": "subscribed",
      "id": 2596299801,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1OTYyOTk4MDE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2596299801",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T07:44:25Z"
    },
    {
      "event": "commented",
      "id": 526588120,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjU4ODEyMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526588120",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T12:46:43Z",
      "updated_at": "2019-08-30T13:13:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Interesting idea: cautious concept ACK -- more redundancy is good and it is hard to see how this would make us worse off in any way as long as the existing P2P logic is kept unchanged. (Intentionally not commenting on the implementation and more specifically the pros and cons of pulling in Rust code: that is an implementation detail that I'm sure will be discussed separately post concept ACK/NACK.)\r\n\r\nCensorship scenarios worth thinking about:\r\n\r\nEven if we do the over-REST block downloads over HTTPS it should be noted that the TLS handshake leaks the hostname of the connected to service to passive eavesdroppers. (Unless TLS 1.3 + Encrypted SNI is used: super rare in practice though.)\r\n\r\nThe hostname is obviously also leaked when doing the DNS lookup. (Unless DoH (DNS over HTTPS) or DoT (DNS over TLS) is used: quite rare in practice.)\r\n\r\nThis allows for active censorship attacks if the hostnames used are **only**  used for Bitcoin purposes (such as in the `cloudflare.deanonymizingseed.com` example – I understand it is just used here as an example).\r\n\r\n(The same obviously goes for the IP-address used: if the IP-address connected to is only used for Bitcoin purposes then access to that IP-address could trivially be null routed without any non-Bitcoin users noticing.)\r\n\r\nI guess one way to achieve (partial) censorship resistance is to download over HTTPS URLs where the hostnames used are mostly used for non-Bitcoin purposes (such as `github.com` – just used here as an example: I'm sure we can come up with other examples). That would leak the hostname but since the hostname and the IP address is used for other purposes it would still be hard for an attacker to block it without having non-Bitcoin users complain.\r\n\r\nAnother route would be to use TLS 1.3 + Encrypted SNI + DoH/DoT to connect to a service whose IP-address(es) are used mostly for non-Bitcoin purposes (such as CloudFlare which luckily supports both TLS 1.3 and Encrypted SNI). That wouldn't leak the hostname and the IP-address would be hard to null route for an attacker without having non-Bitcoin users complain.",
      "user": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526588120",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 526704470,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjcwNDQ3MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526704470",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T18:33:03Z",
      "updated_at": "2019-08-30T18:33:03Z",
      "author_association": "MEMBER",
      "body": "> Intentionally not commenting on the implementation and more specifically the pros and cons of pulling in Rust code: that is an implementation detail that I'm sure will be discussed separately post concept ACK/NACK\r\n\r\nRight, there's a few things that would need to happen to get this in mergeable state (notably buildsystem things), so no need for that just yet.\r\n\r\n> Censorship scenarios worth thinking about:\r\n\r\nRight, two things I'd like to support in the blocks-over-REST module: domain fronting avoids most of the gnarly issues with SNI/DNS lookups breaking your privacy, though sadly many providers don't like it anymore, and Tor support, possibly even with some default onion service recommended as a backup cause privacy is less of a concern there.\r\n\r\nI'd also like to build a whole second P2P implementation (though with an explicit goal of being inefficient and simple, with the same trick as here where you wait 30 seconds before deciding to download anything to avoid wasting bandwidth), but first need to land some bit of rust downloading, and this seemed like an easier target.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526704470",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2598095199,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjU5ODA5NTE5OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2598095199",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T19:16:13Z"
    },
    {
      "event": "commented",
      "id": 526725811,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjcyNTgxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526725811",
      "actor": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-30T19:46:50Z",
      "updated_at": "2019-08-30T19:46:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "But why Rust not C++?",
      "user": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526725811",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 526803517,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjgwMzUxNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526803517",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T05:59:49Z",
      "updated_at": "2019-08-31T05:59:49Z",
      "author_association": "MEMBER",
      "body": "> But why Rust not C++?\r\n\r\nBecause we can trivially turn on compile-time checking preventing a ton of classes of vulnerabilities (especially for network-facing code), and runtime checking for many other classes (like buffer overflows, at least those the compiler can't prove aren't possible).",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526803517",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 526803615,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNjgwMzYxNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526803615",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T06:01:14Z",
      "updated_at": "2019-08-31T06:01:14Z",
      "author_association": "MEMBER",
      "body": "I'm fairly Concept ACK on this. It's been in discussion for a little while, and I'm pretty sure it came up at the last Core dev meetup as well?\r\n\r\n> But why Rust not C++?\r\n\r\n@kristapsk This PR isn't really the place to have that discussion and is only going to distract from what's actually trying to be achieved. Although Matt points out one big advantage:\r\n\r\n> plus we can use compile-time checks to catch any overflows and memory corruption bugs to reduce review burden.\r\n\r\n\r\nIf you'd like to discuss Rust inside Bitcoin Core further, I'd suggest taking a look at #15798. Here are Cory's thoughts on Rust from that thread:\r\n\r\n> Why rust? I don't know. Maybe not. But I think it's a fair assumption to say that Rust code will eventually end up in Bitcoin Core as the result of adding a new dependency. Adoption is happing quickly. So, I think it prudent to look ahead and not only be prepared, but actively help usher it in. Already I have a few things that I would like to work on and upstream to rust-lang to make our integration nicer, and I assume that more will be uncovered as it actually gets used.\r\n\r\nI built and tested that this functions using the instructions above. The backup downloader kicked off after a 10 minute wait\r\n```bash\r\nsrc/bitcoind -blockfetchrest=http://cloudflare.deanonymizingseed.com/rest/ -connect=0\r\n\r\n2019-08-31T05:37:06Z nBestHeight = 311015\r\n2019-08-31T05:37:06Z init message: Loading P2P addresses...\r\n2019-08-31T05:37:06Z Imported mempool transactions from disk: 0 succeeded, 0 failed, 0 expired, 0 already there\r\n2019-08-31T05:37:06Z Loaded 63409 addresses from peers.dat  159ms\r\n2019-08-31T05:37:06Z init message: Starting network threads...\r\n2019-08-31T05:37:06Z DNS seeding disabled\r\n2019-08-31T05:37:06Z net thread start\r\n2019-08-31T05:37:06Z msghand thread start\r\n2019-08-31T05:37:06Z addcon thread start\r\n2019-08-31T05:37:06Z init message: Done loading\r\n2019-08-31T05:47:10Z Synchronizing blockheaders, height: 313014 (~53.91%)\r\n2019-08-31T05:47:13Z Synchronizing blockheaders, height: 315013 (~54.23%)\r\n2019-08-31T05:47:15Z Synchronizing blockheaders, height: 317012 (~54.55%)\r\n2019-08-31T05:47:17Z Synchronizing blockheaders, height: 319011 (~54.87%)\r\n< snip >\r\n2019-08-31T05:52:27Z Synchronizing blockheaders, height: 574883 (~97.17%)\r\n2019-08-31T05:52:34Z Synchronizing blockheaders, height: 576882 (~97.49%)\r\n2019-08-31T05:52:36Z Synchronizing blockheaders, height: 578881 (~97.81%)\r\n2019-08-31T05:52:39Z Synchronizing blockheaders, height: 580880 (~98.14%)\r\n2019-08-31T05:52:41Z Synchronizing blockheaders, height: 582879 (~98.46%)\r\n2019-08-31T05:52:44Z Synchronizing blockheaders, height: 584878 (~98.76%)\r\n2019-08-31T05:52:47Z Synchronizing blockheaders, height: 586877 (~99.09%)\r\n2019-08-31T05:52:49Z Synchronizing blockheaders, height: 588876 (~99.40%)\r\n2019-08-31T05:52:56Z Synchronizing blockheaders, height: 590875 (~99.73%)\r\n2019-08-31T05:52:59Z Synchronizing blockheaders, height: 592551 (~100.00%)\r\n2019-08-31T05:53:35Z Pre-allocating up to position 0x3000000 in blk00158.dat\r\n2019-08-31T05:53:35Z Pre-allocating up to position 0x100000 in rev00158.dat\r\n2019-08-31T05:53:35Z UpdateTip: new best=0000000000000000246039d52e90fb6b7cd442dda19861fb948c28e3a44f7a4e height=311016 version=0x00000002 log2_work=79.744641 tx=42644694 date='2014-07-16T13:51:22Z' progress=0.095646 cache=0.5MiB(3475txo)\r\n2019-08-31T05:53:38Z UpdateTip: new best=000000000000000014c552ced25645452a0b8632753e9288e2decedd273c5828 height=311017 version=0x00000002 log2_work=79.744747 tx=42645541 date='2014-07-16T14:10:17Z' progress=0.095648 cache=1.0MiB(7067txo)\r\n2019-08-31T05:53:40Z UpdateTip: new best=0000000000000000260ef522f4875fb0d5207e4e3ac97ce373a47209bcee52b6 height=311018 version=0x00000002 log2_work=79.744853 tx=42645990 date='2014-07-16T14:18:18Z' progress=0.095649 cache=1.2MiB(8621txo)\r\n2019-08-31T05:53:42Z UpdateTip: new best=0000000000000000007dabdebadfde7beaef31d13133600d0d88695146e2fac6 height=311019 version=0x00000002 log2_work=79.744959 tx=42646068 date='2014-07-16T14:19:50Z' progress=0.095649 cache=1.2MiB(8821txo)\r\n2019-08-31T05:53:45Z UpdateTip: new best=00000000000000001fc78d459e2480177ceea92d53f75cdbd856501b60cbdc3a height=311020 version=0x00000002 log2_work=79.745065 tx=42646933 date='2014-07-16T14:34:32Z' progress=0.095651 cache=1.6MiB(11938txo)\r\n< snip >\r\n2019-08-31T06:00:41Z UpdateTip: new best=000000000000000017de2992c0de3e98d711253582fa7ee626645e395e4fd0e5 height=311697 version=0x00000002 log2_work=79.815121 tx=42899222 date='2014-07-20T16:20:21Z' progress=0.096217 cache=67.4MiB(497634txo)\r\n2019-08-31T06:00:44Z UpdateTip: new best=000000000000000022aeedbb76913a3666d997897c23efc8e92fe38ec79728a7 height=311698 version=0x00000002 log2_work=79.815222 tx=42899470 date='2014-07-20T16:25:14Z' progress=0.096217 cache=68.0MiB(502949txo)\r\n2019-08-31T06:00:47Z UpdateTip: new best=000000000000000027a68e70c9c02985173c56e8c8ce210c02eb975530d77f0d height=311699 version=0x00000002 log2_work=79.815323 tx=42899561 date='2014-07-20T16:27:06Z' progress=0.096218 cache=68.3MiB(505709txo)\r\n2019-08-31T06:00:51Z UpdateTip: new best=000000000000000038730cd937f594452e96b97a496afc03a84fc90a18119113 height=311700 version=0x00000002 log2_work=79.815424 tx=42900165 date='2014-07-20T16:40:48Z' progress=0.096219 cache=68.8MiB(509386txo)\r\n```\r\n\r\nFWIW I've also rebased and added another commit for a more recent Rust onto https://github.com/fanquake/bitcoin/tree/theuni-with-rust-example-working-rebased. Will add another commit on top for the `--start-group` workaround. Given that you've dropped `cbindgen` here, I can also maintain a branch with that dropped.",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526803615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "mentioned",
      "id": 2598678118,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjU5ODY3ODExOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2598678118",
      "actor": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T06:01:15Z"
    },
    {
      "event": "subscribed",
      "id": 2598678119,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI1OTg2NzgxMTk=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2598678119",
      "actor": {
        "login": "kristapsk",
        "id": 4500994,
        "node_id": "MDQ6VXNlcjQ1MDA5OTQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4500994?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kristapsk",
        "html_url": "https://github.com/kristapsk",
        "followers_url": "https://api.github.com/users/kristapsk/followers",
        "following_url": "https://api.github.com/users/kristapsk/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kristapsk/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kristapsk/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kristapsk/subscriptions",
        "organizations_url": "https://api.github.com/users/kristapsk/orgs",
        "repos_url": "https://api.github.com/users/kristapsk/repos",
        "events_url": "https://api.github.com/users/kristapsk/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kristapsk/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-08-31T06:01:15Z"
    },
    {
      "event": "commented",
      "id": 527549359,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNzU0OTM1OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527549359",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T17:04:31Z",
      "updated_at": "2019-09-03T21:34:25Z",
      "author_association": "MEMBER",
      "body": "Concept ACK on adding more redundancy.\r\nAgree that Tor support is desirable, and also measures suggested by @practicalswift are important, but this feature even before those measures is already a big improvement (without trading any privacy comparing to the current threat model with unencrypted p2p I believe).",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-527549359",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "mentioned",
      "id": 2604330267,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MjYwNDMzMDI2Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2604330267",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T17:04:31Z"
    },
    {
      "event": "subscribed",
      "id": 2604330270,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDI2MDQzMzAyNzA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2604330270",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-03T17:04:31Z"
    },
    {
      "event": "referenced",
      "id": 2604920038,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI2MDQ5MjAwMzg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2604920038",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8e00a68552404160583f7fb340e53f7b8128a550",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e00a68552404160583f7fb340e53f7b8128a550",
      "created_at": "2019-09-03T20:40:19Z"
    },
    {
      "event": "referenced",
      "id": 2605110552,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI2MDUxMTA1NTI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2605110552",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b3459434c902f1a6a77751dcad048139edcfe00c",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/b3459434c902f1a6a77751dcad048139edcfe00c",
      "created_at": "2019-09-03T21:54:00Z"
    },
    {
      "event": "commented",
      "id": 527816563,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyNzgxNjU2Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527816563",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-04T09:15:40Z",
      "updated_at": "2019-09-04T09:15:40Z",
      "author_association": "MEMBER",
      "body": "Concept ACK!",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-527816563",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 528223954,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODIyMzk1NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528223954",
      "actor": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T06:47:01Z",
      "updated_at": "2019-09-05T06:56:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "Could we try and use something like https://github.com/dtolnay/no-panic on parts of the code? (if we can, this will give us compile time guarantees of no panics)\r\n\r\nAnother Idea, checking nullness at the boundaries and then use https://doc.rust-lang.org/std/ptr/struct.NonNull.html (can even use `NonNull::new()` to check for nullness)\r\n\r\nOther than that I like this and would love to review it when it's reviewable :)",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528223954",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 528459579,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODQ1OTU3OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528459579",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-05T16:53:55Z",
      "updated_at": "2019-09-05T16:53:55Z",
      "author_association": "MEMBER",
      "body": "I'd rather deliberately use panics so that we can enable overflow checking and catch the panics to kill the Rust thread(s) but leave the rest of Core running. Good call on NonNull, will update to use that!",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528459579",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615202955,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTIwMjk1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615202955",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T18:18:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615343866,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTM0Mzg2Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615343866",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:12:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615345437,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTM0NTQzNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615345437",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:13:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615358223,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTM1ODIyMw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615358223",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:19:03Z"
    },
    {
      "event": "ready_for_review",
      "id": 2615358713,
      "node_id": "MDE5OlJlYWR5Rm9yUmV2aWV3RXZlbnQyNjE1MzU4NzEz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615358713",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:19:16Z"
    },
    {
      "event": "commented",
      "id": 528981929,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyODk4MTkyOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528981929",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T19:19:51Z",
      "updated_at": "2019-09-06T19:19:51Z",
      "author_association": "MEMBER",
      "body": "Aside from the final commit working around one last build issue, I believe this is ready for review. Doesn't make sense to land for 19, but would be nice to land early in the cycle for 20.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528981929",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615560818,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTU2MDgxOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615560818",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T20:46:45Z"
    },
    {
      "event": "commented",
      "id": 529010545,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTAxMDU0NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529010545",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T20:53:01Z",
      "updated_at": "2019-09-06T20:53:01Z",
      "author_association": "MEMBER",
      "body": "I'm taking a look at a proper fix for the circular dependency.",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529010545",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2615600922,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNTYwMDkyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2615600922",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-06T21:04:33Z"
    },
    {
      "event": "commented",
      "id": 529074057,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTA3NDA1Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529074057",
      "actor": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T05:13:08Z",
      "updated_at": "2019-09-07T05:13:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "> https://github.com/bitcoin/bitcoin/blob/3f1ceb95edeb9f58b0a702520a2c452012c63974/src/rusty/src/rest_downloader.rs#L254-L262\r\n\r\nIs there any particular reason that the Rust code is using a hand-rolled HTTP client implementation?\r\n\r\n> https://github.com/bitcoin/bitcoin/blob/3f1ceb95edeb9f58b0a702520a2c452012c63974/src/rusty/src/rest_downloader.rs#L246-L248\r\n\r\nTLS support would be more or less free if we didn't roll our own implementation? :-)\r\n\r\nTLS would be really nice to have since our goal with this PR is to increase censorship resistance.",
      "user": {
        "login": "practicalswift",
        "id": 7826565,
        "node_id": "MDQ6VXNlcjc4MjY1NjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/practicalswift",
        "html_url": "https://github.com/practicalswift",
        "followers_url": "https://api.github.com/users/practicalswift/followers",
        "following_url": "https://api.github.com/users/practicalswift/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/practicalswift/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/practicalswift/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
        "organizations_url": "https://api.github.com/users/practicalswift/orgs",
        "repos_url": "https://api.github.com/users/practicalswift/repos",
        "events_url": "https://api.github.com/users/practicalswift/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/practicalswift/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529074057",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "milestoned",
      "id": 2616005895,
      "node_id": "MDE1Ok1pbGVzdG9uZWRFdmVudDI2MTYwMDU4OTU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616005895",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T05:14:22Z",
      "milestone": {
        "title": "0.20.0"
      }
    },
    {
      "event": "labeled",
      "id": 2616159436,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI2MTYxNTk0MzY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616159436",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T11:32:27Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2616324922,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNjMyNDkyMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616324922",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T17:30:05Z"
    },
    {
      "event": "commented",
      "id": 529128639,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUyOTEyODYzOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529128639",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T17:33:12Z",
      "updated_at": "2019-09-07T17:33:12Z",
      "author_association": "MEMBER",
      "body": "Rebased.\r\n\r\nYea, probably makes sense to switch to a non-handrolled-HTTP-parser eventually, but:\r\na) I haven't yet had the time to look into existing rust ones to see if I can find anything suitable (ie doesn't pull in a million dependencies, implying its probably not async/tokio based, and easy to review), which in my previous experience implies this may be hard,\r\nb) if we add any dependencies we have to have a process for vendoring the entire recursive dependency tree, which is gonna be its own hurdle, so I figured leave that for a follow-up PR.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529128639",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "unlabeled",
      "id": 2616330048,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjYxNjMzMDA0OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616330048",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-07T17:42:15Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 285188001,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1MTg4MDAx",
      "url": null,
      "actor": null,
      "commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed all the rust code and FFI except `read_http_resp` which haven't had time to review it with the HTTP specs.\r\n\r\nDon't know enough about bitcoin's P2P to comment if the logic itself makes a lot of sense.\r\nDidn't try to run it yet.",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#pullrequestreview-285188001",
      "submitted_at": "2019-09-07T22:57:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2616988101,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNjk4ODEwMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2616988101",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-08T20:58:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2617243007,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNzI0MzAwNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2617243007",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-09T03:08:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2617248164,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYxNzI0ODE2NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2617248164",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-09T03:13:59Z"
    },
    {
      "event": "reviewed",
      "id": 285575526,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1NTc1NTI2",
      "url": null,
      "actor": null,
      "commit_id": "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#pullrequestreview-285575526",
      "submitted_at": "2019-09-09T15:04:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2620157163,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjYyMDE1NzE2Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2620157163",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-09T21:05:04Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2670289727,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY3MDI4OTcyNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2670289727",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-28T03:15:01Z"
    },
    {
      "event": "labeled",
      "id": 2672851860,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI2NzI4NTE4NjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2672851860",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-30T11:14:27Z",
      "label": {
        "name": "Feature",
        "color": "7cf575"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2675149839,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY3NTE0OTgzOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2675149839",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-30T23:53:19Z"
    },
    {
      "event": "commented",
      "id": 536799717,
      "node_id": "MDEyOklzc3VlQ29tbWVudDUzNjc5OTcxNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/536799717",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-09-30T23:57:35Z",
      "updated_at": "2019-09-30T23:57:35Z",
      "author_association": "MEMBER",
      "body": "Now based on #16834 instead of the other way around, but otherwise this should be mostly good to go!",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-536799717",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2690180328,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY5MDE4MDMyOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2690180328",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-06T22:04:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2690285897,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjY5MDI4NTg5Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2690285897",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-07T01:12:29Z"
    },
    {
      "event": "labeled",
      "id": 2699528733,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI2OTk1Mjg3MzM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2699528733",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-09T15:41:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2704395493,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjcwNDM5NTQ5Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2704395493",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-10T22:22:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2715878314,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjcxNTg3ODMxNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2715878314",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-16T00:52:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2715950519,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjcxNTk1MDUxOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2715950519",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-16T01:47:18Z"
    },
    {
      "event": "unlabeled",
      "id": 2715967350,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjcxNTk2NzM1MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2715967350",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-16T02:00:01Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2746017920,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI3NDYwMTc5MjA=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2746017920",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-26T11:13:21Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2746290780,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc0NjI5MDc4MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2746290780",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-26T20:55:56Z"
    },
    {
      "event": "unlabeled",
      "id": 2746304705,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50Mjc0NjMwNDcwNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2746304705",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-26T21:29:21Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2753504517,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc1MzUwNDUxNw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2753504517",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-10-29T19:26:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2765737779,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc2NTczNzc3OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2765737779",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T04:40:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2765746604,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc2NTc0NjYwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2765746604",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T05:09:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2765782905,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc2NTc4MjkwNQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2765782905",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-03T07:12:21Z"
    },
    {
      "event": "labeled",
      "id": 2784591198,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI3ODQ1OTExOTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2784591198",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-08T21:25:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2789901567,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjc4OTkwMTU2Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2789901567",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-12T02:07:51Z"
    },
    {
      "event": "unlabeled",
      "id": 2790036881,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50Mjc5MDAzNjg4MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2790036881",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-12T03:40:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2810548418,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI4MTA1NDg0MTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2810548418",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-19T09:03:38Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2813400932,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjgxMzQwMDkzMg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2813400932",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-19T23:35:38Z"
    },
    {
      "event": "unlabeled",
      "id": 2813614118,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjgxMzYxNDExOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2813614118",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-20T01:40:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2815868206,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI4MTU4NjgyMDY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2815868206",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-20T16:12:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2821383578,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MjgyMTM4MzU3OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2821383578",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-21T22:24:53Z"
    },
    {
      "event": "unlabeled",
      "id": 2821503870,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50MjgyMTUwMzg3MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2821503870",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-11-21T23:20:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 2855301736,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI4NTUzMDE3MzY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2855301736",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-04T19:48:36Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDBjZTI4ZjVhMzEzYWZhNzcyMTc4ZmJlODk3MDU1NmMxNzYwNWVj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100ce28f5a313afa772178fbe8970556c17605ec",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/100ce28f5a313afa772178fbe8970556c17605ec",
      "tree": {
        "sha": "74e6aa3e04612ee44767f5261babd73c432de486",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/74e6aa3e04612ee44767f5261babd73c432de486"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fff333c9f00cf379562ed38c2599997f9821cfb",
          "sha": "6fff333c9f00cf379562ed38c2599997f9821cfb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6fff333c9f00cf379562ed38c2599997f9821cfb"
        }
      ],
      "message": "Adds a rust library to bitcoin to demonstrate linking and building rust code.\n\nThe demonstration library compiles a rust hello world example and auto-generates\na header which can be included in C++ code.\n\nCo-Authored-By: Jeremy Rubin <j@rubin.io>\nCo-Authored-By: Cory Fields <cory-nospam-@coryfields.com>\nVarious changes by: Matt Corallo <git@bluematt.me>",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-03-29T21:48:20Z"
      },
      "sha": "100ce28f5a313afa772178fbe8970556c17605ec"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODMwZDllMGM4ZDYwZmEzZDE5ZGNkOThkNjkzYWZkNjU1ZjlhY2Ni",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
      "tree": {
        "sha": "15379f2040f943f35335fe4d333e86454335bbfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/15379f2040f943f35335fe4d333e86454335bbfb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/100ce28f5a313afa772178fbe8970556c17605ec",
          "sha": "100ce28f5a313afa772178fbe8970556c17605ec",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/100ce28f5a313afa772178fbe8970556c17605ec"
        }
      ],
      "message": "build: show rust enabled in configure output",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:20Z"
      },
      "sha": "4830d9e0c8d60fa3d19dcd98d693afd655f9accb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MjhhOTgyMmEwMGQwZjlmNzUwMmNlMjNiZDYyNzZiYWUzMDY4MWNm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/828a9822a00d0f9f7502ce23bd6276bae30681cf",
      "tree": {
        "sha": "903433080f7ea84a5f95b3de8bf055b2fb258ae2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/903433080f7ea84a5f95b3de8bf055b2fb258ae2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
          "sha": "4830d9e0c8d60fa3d19dcd98d693afd655f9accb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4830d9e0c8d60fa3d19dcd98d693afd655f9accb"
        }
      ],
      "message": "build: gitignore src/rusty_test",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:58Z"
      },
      "sha": "828a9822a00d0f9f7502ce23bd6276bae30681cf"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmQ1ZjZmYmEwYjU3ZTZmYzI4NzY0M2RkNWYxYTk3ZDZjMDViOTAx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
      "tree": {
        "sha": "597d14d253ba45f068963a50e300d8a75125fc46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/597d14d253ba45f068963a50e300d8a75125fc46"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a9822a00d0f9f7502ce23bd6276bae30681cf",
          "sha": "828a9822a00d0f9f7502ce23bd6276bae30681cf",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/828a9822a00d0f9f7502ce23bd6276bae30681cf"
        }
      ],
      "message": "Add basic ffi bindings for Rust header download\n\nAlso, break circular dependency with a new helper lib courtesy of\nCory Fields <cory-nospam-@coryfields.com>.",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2019-09-30T20:31:47Z"
      },
      "sha": "9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDc2M2IyOGVhMWFhMmNiZDgwNTVlN2ViYzQ1NGU4MmViZDE3OThm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
      "tree": {
        "sha": "b4f5cd77a7e270a93ffa08938b4b979f03cdb95d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b4f5cd77a7e270a93ffa08938b4b979f03cdb95d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
          "sha": "9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd5f6fba0b57e6fc287643dd5f1a97d6c05b901"
        }
      ],
      "message": "Add headers-over-DNS fetcher in Rust",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T21:58:42Z"
      },
      "sha": "f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYjIxYjY5ODEwYzZjNzBjZTdkMTZjNWMwZmMxOWJmMTI5MjdkYzZl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
      "tree": {
        "sha": "ef285217f45acd5e6c7732e34ed53f5f8f2ea4d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef285217f45acd5e6c7732e34ed53f5f8f2ea4d2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
          "sha": "f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f0763b28ea1aa2cbd8055e7ebc454e82ebd1798f"
        }
      ],
      "message": "Limit total memory allocated by all Rust code to 128MB",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-06T16:16:14Z"
      },
      "sha": "eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NDA1MWFkZGQ5OWM5MzMzMzhkNDBhNDg4Y2Y4ZTgxMGQ5Y2ZkZDM0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/94051addd99c933338d40a488cf8e810d9cfdd34",
      "tree": {
        "sha": "1fb764403fdeb8e4d18f1fa141741562ae495674",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1fb764403fdeb8e4d18f1fa141741562ae495674"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
          "sha": "eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/eb21b69810c6c70ce7d16c5c0fc19bf12927dc6e"
        }
      ],
      "message": "Enable rustc building + testing on xenial Tsan Travis job",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T22:28:27Z"
      },
      "sha": "94051addd99c933338d40a488cf8e810d9cfdd34"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjY2JkOTI4Y2Y1MWYyZWJmZTBmZDc4MjdkMGU2MzJjMjJmY2ZkNDE5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
      "tree": {
        "sha": "25146882ed9d538226686038415b6a018f5d5f40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25146882ed9d538226686038415b6a018f5d5f40"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94051addd99c933338d40a488cf8e810d9cfdd34",
          "sha": "94051addd99c933338d40a488cf8e810d9cfdd34",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/94051addd99c933338d40a488cf8e810d9cfdd34"
        }
      ],
      "message": "Move CNode's FindNextBlocksToDownload state into its own strut\n\nThis starts the process of moving the last bits of\nvalidation-critical logic out of net_processing - the fallback\nlogic of which blocks to download is incredibly critical to\nvalidation and would likely also be used for any parallel block\nsync systems. Further, assumeutxo will require additional ability\nto select blocks for download, which is a validation-specific\nconcept and shouldn't really live in net_processing.\n\nThis moves a few responsibilities to the FindNextBlocksToDownload\ncallsite instead of passing in a CNodeId, but otherwise has no\nfunctional changes.",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-21T20:25:04Z"
      },
      "sha": "ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNjk2YWIxYmFiMjhiMWM5YzJmMGNjY2NhMjc1OTBmZDUzZDk2ODY1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
      "tree": {
        "sha": "82bc403b88b0f892e7337397fce5a9aae921d27b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/82bc403b88b0f892e7337397fce5a9aae921d27b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
          "sha": "ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ccbd928cf51f2ebfe0fd7827d0e632c22fcfd419"
        }
      ],
      "message": "Make FindNextBlocksToDownload a member func on BlockProviderState",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T21:28:57Z"
      },
      "sha": "0696ab1bab28b1c9c2f0cccca27590fd53d96865"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZmM1NTZkMWY4NmJiMjcxZTViMDhhMWNhMTVkYTg4ZmMxOTRlOWFi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
      "tree": {
        "sha": "414f9343dbe73be48dcec7fe5d629d2fb8293de9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/414f9343dbe73be48dcec7fe5d629d2fb8293de9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0696ab1bab28b1c9c2f0cccca27590fd53d96865",
          "sha": "0696ab1bab28b1c9c2f0cccca27590fd53d96865",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0696ab1bab28b1c9c2f0cccca27590fd53d96865"
        }
      ],
      "message": "Make FindNextBlocksToDownload not use mapBlockIndex for in-progress\n\nThis makes it more general than just net_processing",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:00:36Z"
      },
      "sha": "6fc556d1f86bb271e5b08a1ca15da88fc194e9ab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNTEzODM1ZTIwMTA2NWNhZDIyZmRjN2E3ODMwYjUxZDgxYTkzNDEw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e513835e201065cad22fdc7a7830b51d81a93410",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e513835e201065cad22fdc7a7830b51d81a93410",
      "tree": {
        "sha": "ba60797a2dfcd6ebb2139cd0e7df008919efc989",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba60797a2dfcd6ebb2139cd0e7df008919efc989"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
          "sha": "6fc556d1f86bb271e5b08a1ca15da88fc194e9ab",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6fc556d1f86bb271e5b08a1ca15da88fc194e9ab"
        }
      ],
      "message": "Move BlockProvider to validation.{h,cpp} from net_processing",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:07:19Z"
      },
      "sha": "e513835e201065cad22fdc7a7830b51d81a93410"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzYxMTA3Yzg5ZDk1ODFhOTU3NjM4NjZhMzlkOTU0MTk3ZjcxZTcw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1361107c89d9581a95763866a39d954197f71e70",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1361107c89d9581a95763866a39d954197f71e70",
      "tree": {
        "sha": "13d9921413636f153dc0faf956a948775c8b306e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13d9921413636f153dc0faf956a948775c8b306e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e513835e201065cad22fdc7a7830b51d81a93410",
          "sha": "e513835e201065cad22fdc7a7830b51d81a93410",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e513835e201065cad22fdc7a7830b51d81a93410"
        }
      ],
      "message": "Add ffis to access BlockProviderState and hand blocks to C++",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-12T04:53:41Z"
      },
      "sha": "1361107c89d9581a95763866a39d954197f71e70"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYzBkZGEzM2M1MTMyNDY4NmJjMTQzZDhiZWQ4OWViYmEwODhhYjhh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "tree": {
        "sha": "84dfd0322bad2df6531242b58489123328c05e34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84dfd0322bad2df6531242b58489123328c05e34"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1361107c89d9581a95763866a39d954197f71e70",
          "sha": "1361107c89d9581a95763866a39d954197f71e70",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1361107c89d9581a95763866a39d954197f71e70"
        }
      ],
      "message": "Add a rust-based backup over-REST block downloader",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-12-05T15:22:14Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-18T19:30:52Z"
      },
      "sha": "2c0dda33c51324686bc143d8bed89ebba088ab8a"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 2858233731,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mjg1ODIzMzczMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2858233731",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-05T15:24:05Z"
    },
    {
      "event": "unlabeled",
      "id": 2858499692,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50Mjg1ODQ5OTY5Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2858499692",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2019-12-05T16:35:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 571825358,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU3MTgyNTM1OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/571825358",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-07T23:43:11Z",
      "updated_at": "2020-01-07T23:43:11Z",
      "author_association": "MEMBER",
      "body": "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-571825358",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "labeled",
      "id": 2929421662,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDI5Mjk0MjE2NjI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2929421662",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-07T23:43:11Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 575867541,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU3NTg2NzU0MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/575867541",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-01-18T05:08:04Z",
      "updated_at": "2020-01-18T05:08:04Z",
      "author_association": "MEMBER",
      "body": ">would be nice to land early in the cycle for 20.\r\n\r\nRust is still a concept NACK...",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-575867541",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "commented",
      "id": 595413891,
      "node_id": "MDEyOklzc3VlQ29tbWVudDU5NTQxMzg5MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/595413891",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-05T19:48:04Z",
      "updated_at": "2020-03-05T19:48:04Z",
      "author_association": "MEMBER",
      "body": "Closing due to lack of interest.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-595413891",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/16762"
    },
    {
      "event": "closed",
      "id": 3102656353,
      "node_id": "MDExOkNsb3NlZEV2ZW50MzEwMjY1NjM1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/3102656353",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-03-05T19:48:04Z"
    },
    {
      "event": "referenced",
      "id": 5612481392,
      "node_id": "REFE_lADOABII584dCYAYzwAAAAFOh6tw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5612481392",
      "actor": {
        "login": "humbleDasher",
        "id": 93728168,
        "node_id": "U_kgDOBZYtqA",
        "avatar_url": "https://avatars.githubusercontent.com/u/93728168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/humbleDasher",
        "html_url": "https://github.com/humbleDasher",
        "followers_url": "https://api.github.com/users/humbleDasher/followers",
        "following_url": "https://api.github.com/users/humbleDasher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/humbleDasher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/humbleDasher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/humbleDasher/subscriptions",
        "organizations_url": "https://api.github.com/users/humbleDasher/orgs",
        "repos_url": "https://api.github.com/users/humbleDasher/repos",
        "events_url": "https://api.github.com/users/humbleDasher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/humbleDasher/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2996f593ef2e829f2d2c3310aac3edc9fdb011a1",
      "commit_url": "https://api.github.com/repos/humbleDasher/dash/commits/2996f593ef2e829f2d2c3310aac3edc9fdb011a1",
      "created_at": "2021-11-13T00:17:54Z"
    },
    {
      "event": "referenced",
      "id": 5640695343,
      "node_id": "REFE_lADOABII584dCYAYzwAAAAFQNi4v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5640695343",
      "actor": {
        "login": "pravblockc",
        "id": 51935684,
        "node_id": "MDQ6VXNlcjUxOTM1Njg0",
        "avatar_url": "https://avatars.githubusercontent.com/u/51935684?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pravblockc",
        "html_url": "https://github.com/pravblockc",
        "followers_url": "https://api.github.com/users/pravblockc/followers",
        "following_url": "https://api.github.com/users/pravblockc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pravblockc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pravblockc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pravblockc/subscriptions",
        "organizations_url": "https://api.github.com/users/pravblockc/orgs",
        "repos_url": "https://api.github.com/users/pravblockc/repos",
        "events_url": "https://api.github.com/users/pravblockc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pravblockc/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0b4f279949590a5ee4d351decb9667ec068672b2",
      "commit_url": "https://api.github.com/repos/pravblockc/dash/commits/0b4f279949590a5ee4d351decb9667ec068672b2",
      "created_at": "2021-11-18T18:27:58Z"
    },
    {
      "event": "locked",
      "id": 6073861860,
      "node_id": "LOE_lADOABII584dCYAYzwAAAAFqB8bk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6073861860",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-02-15T10:41:43Z",
      "lock_reason": "resolved"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319390967",
      "pull_request_review_id": 281872721,
      "id": 319390967,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTM5MDk2Nw==",
      "diff_hunk": "@@ -529,7 +537,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_SOURCES = bitcoind.cpp\n bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bitcoind_LDFLAGS = -Wl,--start-group $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "path": "src/Makefile.am",
      "position": null,
      "original_position": 38,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "AFAICS `--start-group` is not supported in clang (https://bitcoinbuilds.org/index.php?ansilog=6ccfb93d-3437-41c0-99d4-3b6653264739.log#l1705)",
      "created_at": "2019-08-30T07:38:07Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319390967",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319390967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 538,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319393006",
      "pull_request_review_id": 281875349,
      "id": 319393006,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTM5MzAwNg==",
      "diff_hunk": "@@ -529,7 +537,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_SOURCES = bitcoind.cpp\n bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bitcoind_LDFLAGS = -Wl,--start-group $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "path": "src/Makefile.am",
      "position": null,
      "original_position": 38,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "in_reply_to_id": 319390967,
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasschnelli Yes `ld` on macOS doesn't support `--start-group` or `--end-group`. This was a bit of a hack to fix a circular dependency issue Matt was seeing on his Debian machine. If you want to compile on macOS you should just be able to drop the `-Wl,--start-group` additions, as that has been working for me. We'll need to fix this **properly** soon.",
      "created_at": "2019-08-30T07:44:25Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319393006",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319393006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 538,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983533",
      "pull_request_review_id": 285188001,
      "id": 321983533,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4MzUzMw==",
      "diff_hunk": "@@ -137,3 +137,7 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+# Rust\n+src/rusty/Cargo.lock",
      "path": ".gitignore",
      "position": null,
      "original_position": 6,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think tracking changes to Cargo.lock might be a good thing. (especially if we will have some dependencies in the future)\r\n\r\n(I know it's against the official recommendation)",
      "created_at": "2019-09-07T21:10:57Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983533",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983747",
      "pull_request_review_id": 285188001,
      "id": 321983747,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzc0Nw==",
      "diff_hunk": "@@ -1824,5 +1831,13 @@ bool AppInitMain(InitInterfaces& interfaces)\n         g_banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks((const unsigned char*)uri.c_str());",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "why not use the regular `const char*`? why cast it into an unsigned char pointer?\r\nYou could then use rust's `CStr` instead of manually looping and offsetting the pointer:\r\nhttps://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_ptr",
      "created_at": "2019-09-07T21:20:17Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983747",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1838,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983940",
      "pull_request_review_id": 285188001,
      "id": 321983940,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzk0MA==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 212,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A. I'm not sure dereferencing a char* casted to *const u8, is safe.\r\nB. if you pass this as `*const c_char` and then use rust's `CStr` (as I wrote above) you can replace these ~10 lines with:\r\n```\r\nlet uri_str = match CStr::from_ptr(uri).to_str() {\r\n    Ok(r) => r,\r\n    Err(_) => return false,\r\n};\r\n```",
      "created_at": "2019-09-07T21:28:29Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983940",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983986",
      "pull_request_review_id": 285188001,
      "id": 321983986,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzk4Ng==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 60,
      "original_position": 56,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "currently the test is pretty small, but maybe still feature gate it with `#[cfg(test)]` so that it won't be compiled normally?",
      "created_at": "2019-09-07T21:30:28Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983986",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 60,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984009",
      "pull_request_review_id": 285188001,
      "id": 321984009,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDAwOQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 15,
      "original_position": 10,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could you add a doc explaining what the function is doing?",
      "created_at": "2019-09-07T21:31:50Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984146",
      "pull_request_review_id": 285188001,
      "id": 321984146,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDE0Ng==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 21,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe replace with `host_path.starts_with(\"/\")`? (which also solves possible utf-8 problems)",
      "created_at": "2019-09-07T21:39:18Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984146",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984187",
      "pull_request_review_id": 285188001,
      "id": 321984187,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDE4Nw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 22,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Then you can replace this with `host_path = host_path.trim_start_matches(\"/\");`",
      "created_at": "2019-09-07T21:41:36Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984187",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984418",
      "pull_request_review_id": 285188001,
      "id": 321984418,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDQxOA==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 27,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same, unless we have something that `if !uri.is_ascii() return None;` at the start of the function we should really try and not index into strings",
      "created_at": "2019-09-07T21:52:33Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984465",
      "pull_request_review_id": 285188001,
      "id": 321984465,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDQ2NQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 27,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984418,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "and btw you can do `b'['` instead of `'[' as u8` :)",
      "created_at": "2019-09-07T21:54:19Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984465",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984701",
      "pull_request_review_id": 285188001,
      "id": 321984701,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDcwMQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 231,
      "original_position": 225,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could we easily log a panic easily somehow? (although this introduces a lot of complications to pass the `datadir` location somehow, could we maybe use some tmp location just as a jump start?)",
      "created_at": "2019-09-07T22:03:14Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984701",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984797",
      "pull_request_review_id": 285188001,
      "id": 321984797,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDc5Nw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 226,
      "original_position": 221,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this should be reversed to check if SSL is true.\r\nBecause if this returns None we might as well also return false and finish this early, because we unwrap this few lines after \r\n\r\nBetter yet, run it once and check for `if ssl {return False;}` so that we won't need to run this twice(not that it really matters that much...)",
      "created_at": "2019-09-07T22:06:33Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984797",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 226,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985047",
      "pull_request_review_id": 285188001,
      "id": 321985047,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTA0Nw==",
      "diff_hunk": "@@ -367,6 +371,9 @@ void SetupServerArgs()\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Transactions from the wallet, RPC and relay whitelisted inbound peers are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe add an example of how the uri should be formatted? (especially because currently there's no feedback from `split_uri`)",
      "created_at": "2019-09-07T22:18:22Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985329",
      "pull_request_review_id": 285188001,
      "id": 321985329,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTMyOQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 243,
      "original_position": 237,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ideally we would match against the exact error match so that if it returns something like `InvalidData` then there's no need to keep the loop running. (so stop unless it's a timeout, broken pipe, would block etc.)  ",
      "created_at": "2019-09-07T22:31:49Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985329",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 243,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985493",
      "pull_request_review_id": 285188001,
      "id": 321985493,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTQ5Mw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 268,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Add a comment that this should only ever trip on the *second* connection?",
      "created_at": "2019-09-07T22:40:51Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985493",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985515",
      "pull_request_review_id": 285188001,
      "id": 321985515,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTUxNQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 269,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we're on completely separate chains why reconnect?",
      "created_at": "2019-09-07T22:41:39Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985689",
      "pull_request_review_id": 285188001,
      "id": 321985689,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTY4OQ==",
      "diff_hunk": "@@ -0,0 +1,178 @@\n+use std::ffi::c_void;\n+extern \"C\" {\n+    pub fn rusty_IsInitialBlockDownload() -> bool;\n+    pub fn rusty_ShutdownRequested() -> bool;\n+\n+    fn rusty_ProcessNewBlock(blockdata: *const u8, blockdatalen: usize, blockindex_requested: *const c_void);\n+\n+    /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n+    /// Returns the last header which was connected, if any (or NULL).\n+    fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n+\n+    // Utilities to work with CBlockIndex pointers. Wrapped in a safe wrapper below.\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the current tip.\n+    /// Guaranteed to never be NULL (but may be genesis)\n+    fn rusty_GetChainTip() -> *const c_void;\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the genesis block.\n+    /// Guaranteed to never be NULL\n+    fn rusty_GetGenesisIndex() -> *const c_void;\n+\n+    #[allow(dead_code)]\n+    /// Finds a CBlockIndex* for a given block hash, or NULL if none is found\n+    fn rusty_HashToIndex(hash: *const u8) -> *const c_void;\n+\n+    #[allow(dead_code)]\n+    /// Gets the height of a given CBlockIndex* pointer\n+    fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+\n+    /// Gets the hash of a given CBlockIndex* pointer\n+    fn rusty_IndexToHash(index: *const c_void) -> *const u8;\n+}\n+\n+#[allow(dead_code)]\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers(headers: &[[u8; 80]]) -> Option<BlockIndex> {\n+    if headers.is_empty() { return None; }\n+    let first_header = headers[0].as_ptr();\n+    let index = if headers.len() == 1 {\n+        unsafe { rusty_ConnectHeaders(first_header, 80, 1) }\n+    } else {\n+        let second_header = headers[1].as_ptr();\n+        let stride = second_header as usize - first_header as usize;\n+        unsafe { rusty_ConnectHeaders(first_header, stride, headers.len()) }\n+    };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n+    if headers.len() % 80 != 0 { return None; }\n+    if headers.is_empty() { return None; }\n+    let index = unsafe { rusty_ConnectHeaders(headers.as_ptr(), 80, headers.len() / 80) };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+/// Processes a new block, in serialized form.\n+/// blockindex_requested_by_state shouild be set *only* if the given BlockIndex was provided by\n+/// BlockProviderState::get_next_block_to_download(), and may be set to None always.\n+pub fn connect_block(blockdata: &[u8], blockindex_requested_by_state: Option<BlockIndex>) {\n+    let blockindex = match blockindex_requested_by_state { Some(index) => index.index, None => std::ptr::null(), };\n+    unsafe {\n+        rusty_ProcessNewBlock(blockdata.as_ptr(), blockdata.len(), blockindex);\n+    }\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex {\n+    index: *const c_void,\n+}\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetChainTip() },\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn get_from_hash(hash: &[u8; 32]) -> Option<Self> {\n+        let index = unsafe { rusty_HashToIndex(hash.as_ptr()) };\n+        if index.is_null() {\n+            None\n+        } else {\n+            Some(Self { index })\n+        }\n+    }\n+\n+    pub fn genesis() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetGenesisIndex() },\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn height(&self) -> i32 {\n+        unsafe { rusty_IndexToHeight(self.index) }\n+    }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        let hashptr = unsafe { rusty_IndexToHash(self.index) };\n+        let mut res = [0u8; 32];\n+        unsafe { std::ptr::copy(hashptr, (&mut res).as_mut_ptr(), 32) };",
      "path": "src/rusty/src/bridge.rs",
      "position": null,
      "original_position": 105,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`res.as_mut_ptr()` should also work",
      "created_at": "2019-09-07T22:51:47Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985689",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028115",
      "pull_request_review_id": 285234118,
      "id": 322028115,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjAyODExNQ==",
      "diff_hunk": "@@ -137,3 +137,7 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+# Rust\n+src/rusty/Cargo.lock",
      "path": ".gitignore",
      "position": null,
      "original_position": 6,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321983533,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we'll vendor all our dependencies, so hopefully no need, but we can look into it more once we have a dependency.",
      "created_at": "2019-09-08T20:37:05Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028115",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028393",
      "pull_request_review_id": 285234379,
      "id": 322028393,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjAyODM5Mw==",
      "diff_hunk": "@@ -1824,5 +1831,13 @@ bool AppInitMain(InitInterfaces& interfaces)\n         g_banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks((const unsigned char*)uri.c_str());",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321983747,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Cause I didn't know CStr existed :p",
      "created_at": "2019-09-08T20:43:48Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1838,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050160",
      "pull_request_review_id": 285261436,
      "id": 322050160,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDE2MA==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 269,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985515,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The server may also be broken and be returning empty responses, so best to keep trying.",
      "created_at": "2019-09-09T02:58:45Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050160",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050241",
      "pull_request_review_id": 285261556,
      "id": 322050241,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDI0MQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 268,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985493,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I mean that seems pretty obvious given the code?",
      "created_at": "2019-09-09T02:59:39Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050241",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050241"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050361",
      "pull_request_review_id": 285261700,
      "id": 322050361,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDM2MQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 243,
      "original_position": 237,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985329,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ehh, I'd rather keep polling. Better to keep polling so that when the rest endpoint fixes their misconfiguration (eg its returning a 500 or 404 or whatever) the downloader picks back up.",
      "created_at": "2019-09-09T03:00:42Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050361",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 243,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050537",
      "pull_request_review_id": 285261919,
      "id": 322050537,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDUzNw==",
      "diff_hunk": "@@ -367,6 +371,9 @@ void SetupServerArgs()\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Transactions from the wallet, RPC and relay whitelisted inbound peers are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 16,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321985047,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I went ahead and added the deanonymizingseed.com one, if folks complain I can use example.com.",
      "created_at": "2019-09-09T03:02:14Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050537",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050675",
      "pull_request_review_id": 285262098,
      "id": 322050675,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDY3NQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 226,
      "original_position": 221,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984797,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm? The pattern hers is if let Some() {} else { return; }. It reads a bit weird but its the easiest way to write it out.",
      "created_at": "2019-09-09T03:03:34Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050675",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050675"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 226,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050763",
      "pull_request_review_id": 285262204,
      "id": 322050763,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDc2Mw==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 231,
      "original_position": 225,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984701,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, it would be really nice to be able to call LogPrintf from rust code, but I'd prefer to leave that to a future PR.",
      "created_at": "2019-09-09T03:04:15Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050941",
      "pull_request_review_id": 285262464,
      "id": 322050941,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDk0MQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 22,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984187,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, thats only available in 1.30. For now lets avoid it until we have a clear min version.",
      "created_at": "2019-09-09T03:06:12Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050941",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322292885",
      "pull_request_review_id": 285573787,
      "id": 322292885,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjI5Mjg4NQ==",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": null,
      "original_position": 22,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "14bc05537fb2522aad61f119a71949723baaa9b8",
      "in_reply_to_id": 321984187,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So you have `trim_left_matches()` which predates it (is in rust since 1.0)\r\nhttps://doc.rust-lang.org/std/primitive.str.html#method.trim_left_matches",
      "created_at": "2019-09-09T15:01:43Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322292885",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322292885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322294202",
      "pull_request_review_id": 285575526,
      "id": 322294202,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjI5NDIwMg==",
      "diff_hunk": "@@ -0,0 +1,324 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+/// Splits an HTTP URI into its component part - (is_ssl, hostname, port number, and HTTP path)\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while host_path.starts_with(\"/\") {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = r.starts_with(\"[\");\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const c_char) -> bool {\n+    let uri_str: String = match unsafe { CStr::from_ptr(uri) }.to_str() {\n+        Ok(r) => r.to_string(),",
      "path": "src/rusty/src/rest_downloader.rs",
      "position": 222,
      "original_position": 216,
      "commit_id": "2c0dda33c51324686bc143d8bed89ebba088ab8a",
      "original_commit_id": "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "in_reply_to_id": null,
      "user": {
        "login": "elichai",
        "id": 2167860,
        "node_id": "MDQ6VXNlcjIxNjc4NjA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2167860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/elichai",
        "html_url": "https://github.com/elichai",
        "followers_url": "https://api.github.com/users/elichai/followers",
        "following_url": "https://api.github.com/users/elichai/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/elichai/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/elichai/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/elichai/subscriptions",
        "organizations_url": "https://api.github.com/users/elichai/orgs",
        "repos_url": "https://api.github.com/users/elichai/repos",
        "events_url": "https://api.github.com/users/elichai/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/elichai/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Great catch :)\r\nthat way we won't have a dangling pointer at some point",
      "created_at": "2019-09-09T15:04:02Z",
      "updated_at": "2019-12-05T15:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322294202",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322294202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 222,
      "original_line": 222,
      "side": "RIGHT"
    }
  ]
}