{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629",
    "id": 2914847026,
    "node_id": "PR_kwDOABII586tvQky",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33629",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33629.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33629.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
    "number": 33629,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Cluster mempool",
    "user": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "[Reopening #28676 here as a new PR, because GitHub is slow to load the page making it hard to scroll through and see comments.  Also, that PR was originally opened with a prototype implementation which has changed significantly with the introduction of `TxGraph`.]\r\n\r\nThis is an implementation of the [cluster mempool proposal](https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393).\r\n\r\nThis branch implements the following observable behavior changes:\r\n\r\n - Maintains a partitioning of the mempool into connected clusters (via the `txgraph` class), which are limited in vsize to 101 kvB by default, and limited in count to 64 by default.\r\n - Each cluster is sorted (\"linearized\") to try to optimize for selecting highest-feerate-subsets of a cluster first\r\n - Transaction selection for mining is updated to use the cluster linearizations, selecting highest feerate \"chunks\" first for inclusion in a block template.\r\n - Mempool eviction is updated to use the cluster linearizations, selecting lowest feerate \"chunks\" first for removal.\r\n - The RBF rules are updated to: (a) drop the requirement that no new inputs are introduced; (b) change the feerate requirement to instead check that the feerate diagram of the mempool will strictly improve; (c) replace the direct conflicts limit with a directly-conflicting-clusters limit.\r\n - The CPFP carveout rule is eliminated (it doesn't make sense in a cluster-limited mempool)\r\n - The ancestor and descendant limits are no longer enforced.\r\n - New cluster count/cluster vsize limits are now enforced instead.\r\n - Transaction relay now uses chunk feerate comparisons to determine the order that newly received transactions are announced to peers.\r\n\r\nAdditionally, the cached ancestor and descendant data are dropped from the mempool, along with the multi_index indices that were maintained to sort the mempool by ancestor and descendant feerates. For compatibility (eg with wallet behavior or RPCs exposing this), this information is now calculated dynamically instead.",
    "labels": [
      {
        "id": 82428251,
        "node_id": "MDU6TGFiZWw4MjQyODI1MQ==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/TX%20fees%20and%20policy",
        "name": "TX fees and policy",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 118379652,
        "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
        "name": "Validation",
        "color": "6060aa",
        "default": false
      },
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/74",
      "html_url": "https://github.com/bitcoin/bitcoin/milestone/74",
      "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/74/labels",
      "id": 12610874,
      "node_id": "MI_kwDOABII584AwG06",
      "number": 74,
      "state": "open",
      "title": "31.0",
      "creator": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "open_issues": 6,
      "closed_issues": 4,
      "created_at": "2025-03-25T18:44:16Z",
      "updated_at": "2025-11-04T15:38:52Z"
    },
    "created_at": "2025-10-14T19:50:07Z",
    "updated_at": "2025-11-10T20:38:21Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "5f313c84003a159dd496aecb02f856b21ebd030a",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sdaftuar:2025-02-cluster-mempool",
      "ref": "2025-02-cluster-mempool",
      "sha": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 28761781,
        "node_id": "MDEwOlJlcG9zaXRvcnkyODc2MTc4MQ==",
        "name": "bitcoin",
        "full_name": "sdaftuar/bitcoin",
        "owner": {
          "login": "sdaftuar",
          "id": 7463573,
          "node_id": "MDQ6VXNlcjc0NjM1NzM=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sdaftuar",
          "html_url": "https://github.com/sdaftuar",
          "followers_url": "https://api.github.com/users/sdaftuar/followers",
          "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
          "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
          "repos_url": "https://api.github.com/users/sdaftuar/repos",
          "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/sdaftuar/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sdaftuar/bitcoin",
        "archive_url": "https://api.github.com/repos/sdaftuar/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sdaftuar/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sdaftuar/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sdaftuar/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sdaftuar/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sdaftuar/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sdaftuar/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sdaftuar/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sdaftuar/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sdaftuar/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sdaftuar/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sdaftuar/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sdaftuar/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sdaftuar/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sdaftuar/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sdaftuar/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sdaftuar/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sdaftuar/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sdaftuar/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sdaftuar/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sdaftuar/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sdaftuar/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sdaftuar/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sdaftuar/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sdaftuar/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sdaftuar/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sdaftuar/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sdaftuar/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sdaftuar/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sdaftuar/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sdaftuar/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sdaftuar/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sdaftuar/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sdaftuar/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sdaftuar/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sdaftuar/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sdaftuar/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sdaftuar/bitcoin/hooks",
        "svn_url": "https://github.com/sdaftuar/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 2,
        "stargazers_count": 4,
        "watchers_count": 4,
        "size": 304611,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-11-01T17:57:13Z",
        "created_at": "2015-01-04T02:52:13Z",
        "updated_at": "2024-02-09T22:47:48Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "25c45bb0d0bd6618ec9296a1a43605657124e5de",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38192,
        "stargazers_count": 86746,
        "watchers_count": 86746,
        "size": 295858,
        "default_branch": "master",
        "open_issues_count": 734,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-11-10T17:16:07Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-11-10T20:52:27Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1844,
    "deletions": 3212,
    "changed_files": 60,
    "commits": 66,
    "review_comments": 155,
    "comments": 6
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUxNDMwNjgwZWNiNzIyZTFkNGVlNGEyNmRhYzU3MjQwNTBmNDFjOWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51430680ecb722e1d4ee4a26dac5724050f41c9e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/51430680ecb722e1d4ee4a26dac5724050f41c9e",
      "tree": {
        "sha": "e3a027557cc7b958155db80bd814f882e28f3912",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e3a027557cc7b958155db80bd814f882e28f3912"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9314113b295af0f4eab6397c5870115b647721d1",
          "sha": "9314113b295af0f4eab6397c5870115b647721d1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9314113b295af0f4eab6397c5870115b647721d1"
        }
      ],
      "message": "Allow moving an Epoch::Marker",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-14T18:03:42Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-09T15:28:57Z"
      },
      "sha": "51430680ecb722e1d4ee4a26dac5724050f41c9e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZjNzNlNDc0NDgzN2E3ZGMxMzhhOTE3N2RmM2E0OGYzMGExYmE2YzE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c73e4744837a7dc138a9177df3a48f30a1ba6c1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6c73e4744837a7dc138a9177df3a48f30a1ba6c1",
      "tree": {
        "sha": "c77806bebf1ee13b36a2665aa8ba148b874815e0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c77806bebf1ee13b36a2665aa8ba148b874815e0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51430680ecb722e1d4ee4a26dac5724050f41c9e",
          "sha": "51430680ecb722e1d4ee4a26dac5724050f41c9e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/51430680ecb722e1d4ee4a26dac5724050f41c9e"
        }
      ],
      "message": "mempool: Store iterators into mapTx in mapNextTx\n\nThis takes the same amount of space as CTransaction pointers, and saves a map\nlookup in many common uses.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-14T18:03:42Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-02-05T23:39:07Z"
      },
      "sha": "6c73e4744837a7dc138a9177df3a48f30a1ba6c1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNkMGJlYTIxOTdkOGUxY2E5N2FmNTU4NjMyN2MxYzgwZGJhMmUzNmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd0bea2197d8e1ca97af5586327c1c80dba2e36a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cd0bea2197d8e1ca97af5586327c1c80dba2e36a",
      "tree": {
        "sha": "3652d89543bff03d8c0509c3531ea938521c23d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3652d89543bff03d8c0509c3531ea938521c23d1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c73e4744837a7dc138a9177df3a48f30a1ba6c1",
          "sha": "6c73e4744837a7dc138a9177df3a48f30a1ba6c1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6c73e4744837a7dc138a9177df3a48f30a1ba6c1"
        }
      ],
      "message": "Allow moving CTxMemPoolEntry objects, disallow copying",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-14T18:03:42Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-09T15:30:12Z"
      },
      "sha": "cd0bea2197d8e1ca97af5586327c1c80dba2e36a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM1NzA2ZWE0NjJhODFiYTMxOGExNDVkZTE4NjljNzhjNzdjNTczNDE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5706ea462a81ba318a145de1869c78c77c57341",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c5706ea462a81ba318a145de1869c78c77c57341",
      "tree": {
        "sha": "e5553228e21c7ccce891257182c1ad16edf1a460",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e5553228e21c7ccce891257182c1ad16edf1a460"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd0bea2197d8e1ca97af5586327c1c80dba2e36a",
          "sha": "cd0bea2197d8e1ca97af5586327c1c80dba2e36a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cd0bea2197d8e1ca97af5586327c1c80dba2e36a"
        }
      ],
      "message": "Make CTxMemPoolEntry derive from TxGraph::Ref",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-14T18:03:42Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-09T15:36:34Z"
      },
      "sha": "c5706ea462a81ba318a145de1869c78c77c57341"
    },
    {
      "event": "labeled",
      "id": 20278488088,
      "node_id": "LE_lADOABII587RhpYCzwAAAAS4sSwY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20278488088",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-14T20:05:03Z",
      "label": {
        "name": "TX fees and policy",
        "color": "5319e7"
      }
    },
    {
      "event": "labeled",
      "id": 20278488104,
      "node_id": "LE_lADOABII587RhpYCzwAAAAS4sSwo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20278488104",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-14T20:05:03Z",
      "label": {
        "name": "Validation",
        "color": "6060aa"
      }
    },
    {
      "event": "labeled",
      "id": 20278488114,
      "node_id": "LE_lADOABII587RhpYCzwAAAAS4sSwy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20278488114",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-14T20:05:03Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "milestoned",
      "id": 20278491841,
      "node_id": "MIE_lADOABII587RhpYCzwAAAAS4sTrB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20278491841",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-14T20:05:15Z",
      "milestone": {
        "title": "31.0"
      }
    },
    {
      "event": "reviewed",
      "id": 3341892072,
      "node_id": "PRR_kwDOABII587HMTno",
      "url": null,
      "actor": null,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-15T20:32:55Z",
      "author_association": "MEMBER",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3341892072",
      "submitted_at": "2025-10-15T20:32:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3340512731,
      "node_id": "PRR_kwDOABII587HHC3b",
      "url": null,
      "actor": null,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-15T21:58:25Z",
      "author_association": "MEMBER",
      "body": "reviewed through 8cdd7bb11adeaeb4709c670bef4b57362cfbebcb\r\n\r\nfocusing on logic this time around, only glanced at tests",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3340512731",
      "submitted_at": "2025-10-15T21:58:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20307299673,
      "node_id": "HRFPE_lADOABII587RhpYCzwAAAAS6aM1Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20307299673",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "63b1180b142a83d4c266820e0a4415ee95cf1e26",
      "commit_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits/63b1180b142a83d4c266820e0a4415ee95cf1e26",
      "created_at": "2025-10-16T00:02:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20307441697,
      "node_id": "HRFPE_lADOABII587RhpYCzwAAAAS6avgh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20307441697",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "commit_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits/10872f7ec923803f711cd2c3af93a0e17121330e",
      "created_at": "2025-10-16T00:20:20Z"
    },
    {
      "event": "reviewed",
      "id": 3339641710,
      "node_id": "PRR_kwDOABII587HDuNu",
      "url": null,
      "actor": null,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-16T15:15:47Z",
      "author_association": "MEMBER",
      "body": "Reviewed the main implementation e6315c24326016cfaee5bd046e8b2e4e1088ac6b\r\n\r\nI've not noticed any major issue, dropped a few minor comments and nits.\r\nIf any comment become stale after the update feel free to ignore it",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3339641710",
      "submitted_at": "2025-10-16T15:15:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3345064005,
      "node_id": "PRR_kwDOABII587HYaBF",
      "url": null,
      "actor": null,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-16T15:38:51Z",
      "author_association": "MEMBER",
      "body": "reviewed through 10872f7ec923803f711cd2c3af93a0e17121330e\r\n\r\nfocused on commit structure and comprehension only, next will be focusing on testing",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3345064005",
      "submitted_at": "2025-10-16T15:38:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3342174984,
      "node_id": "PRR_kwDOABII587HNYsI",
      "url": null,
      "actor": null,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-17T17:49:59Z",
      "author_association": "MEMBER",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3342174984",
      "submitted_at": "2025-10-17T17:49:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3351431350,
      "node_id": "PRR_kwDOABII587Hwsi2",
      "url": null,
      "actor": null,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-17T20:19:45Z",
      "author_association": "MEMBER",
      "body": "Focused on reviewing the RBF logic in e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3351431350",
      "submitted_at": "2025-10-17T20:19:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3350483416,
      "node_id": "PRR_kwDOABII587HtFHY",
      "url": null,
      "actor": null,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-21T06:58:23Z",
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3350483416",
      "submitted_at": "2025-10-21T06:58:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20402983158,
      "node_id": "HRFPE_lADOABII587RhpYCzwAAAATAHND2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20402983158",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "f356bb9b75d0b1e65768d578eb553036177c3424",
      "commit_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits/f356bb9b75d0b1e65768d578eb553036177c3424",
      "created_at": "2025-10-21T12:15:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20406552428,
      "node_id": "HRFPE_lADOABII587RhpYCzwAAAATAU0ds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20406552428",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "commit_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits/1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "created_at": "2025-10-21T14:22:29Z"
    },
    {
      "event": "reviewed",
      "id": 3363955723,
      "node_id": "PRR_kwDOABII587IgeQL",
      "url": null,
      "actor": null,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-22T10:00:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "I ran a mutation testing analysis on this PR. The mutants were generated incrementally. Unit and functional tests look great overall - over 80% of mutation score. I've dropped some unkilled mutants here, feel free to address them (write tests to kill) or ignore if unproductive.",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3363955723",
      "submitted_at": "2025-10-22T10:00:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3388723571,
      "node_id": "PRR_kwDOABII587J-9Fz",
      "url": null,
      "actor": null,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T15:15:25Z",
      "author_association": "MEMBER",
      "body": "The empty commits can be dropped. You could prefix some commits with \"prep\" or \"cleanup,\" but I think it's pretty clear already.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3388723571",
      "submitted_at": "2025-10-28T15:15:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3363982025,
      "node_id": "PRR_kwDOABII587IgkrJ",
      "url": null,
      "actor": null,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T20:41:26Z",
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3363982025",
      "submitted_at": "2025-10-28T20:41:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "reviewed",
      "id": 3394857863,
      "node_id": "PRR_kwDOABII587KWWuH",
      "url": null,
      "actor": null,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-29T19:40:02Z",
      "author_association": "MEMBER",
      "body": "ACK 1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a\r\n\r\nlots of less important things to clean up, I'd rather get this branch further under (fuzz) test and have iteration done on cleanup PR\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3394857863",
      "submitted_at": "2025-10-29T19:36:54Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE2NjQ5ZGZmZTkyMzE5YTE3NzkwYmYyYWRkNTIwNmE4NDcyNmYzNGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6649dffe92319a17790bf2add5206a84726f34d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a6649dffe92319a17790bf2add5206a84726f34d",
      "tree": {
        "sha": "4f35c9ec65e5815ef528e86cdf46c23133fee056",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4f35c9ec65e5815ef528e86cdf46c23133fee056"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5706ea462a81ba318a145de1869c78c77c57341",
          "sha": "c5706ea462a81ba318a145de1869c78c77c57341",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c5706ea462a81ba318a145de1869c78c77c57341"
        }
      ],
      "message": "Create a txgraph inside CTxMemPool",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-30T12:46:15Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-09T16:04:14Z"
      },
      "sha": "a6649dffe92319a17790bf2add5206a84726f34d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQzYmEyMGZmOTk3YTlhMDI3MzlkMDVkNmJjNzY4YmU3MTFmYzU4Zjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43ba20ff997a9a02739d05d6bc768be711fc58f7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/43ba20ff997a9a02739d05d6bc768be711fc58f7",
      "tree": {
        "sha": "78e3e52420be4992e57a341895d436910ffaf6b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78e3e52420be4992e57a341895d436910ffaf6b0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a6649dffe92319a17790bf2add5206a84726f34d",
          "sha": "a6649dffe92319a17790bf2add5206a84726f34d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a6649dffe92319a17790bf2add5206a84726f34d"
        }
      ],
      "message": "Add sigops adjusted weight calculator",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-30T12:46:15Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-30T18:16:21Z"
      },
      "sha": "43ba20ff997a9a02739d05d6bc768be711fc58f7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhjYTNiYjM4NGE3MDM0OWE5Yzg1OGRlYmE4NGEyZDliNmY1OGFjOTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ca3bb384a70349a9c858deba84a2d9b6f58ac96",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8ca3bb384a70349a9c858deba84a2d9b6f58ac96",
      "tree": {
        "sha": "c49443310507323d07fb75427520d4758ae12c16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c49443310507323d07fb75427520d4758ae12c16"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43ba20ff997a9a02739d05d6bc768be711fc58f7",
          "sha": "43ba20ff997a9a02739d05d6bc768be711fc58f7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/43ba20ff997a9a02739d05d6bc768be711fc58f7"
        }
      ],
      "message": "Add accessor for sigops-adjusted weight",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-30T12:46:15Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-02-04T19:54:20Z"
      },
      "sha": "8ca3bb384a70349a9c858deba84a2d9b6f58ac96"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIwYzgwODEyNThmYzM3ODE2ZTQ2NzVlMTdmYTllYThkMzA4OTIxZjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0c8081258fc37816e4675e17fa9ea8d308921f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b0c8081258fc37816e4675e17fa9ea8d308921f3",
      "tree": {
        "sha": "9e3654f3714a44b048af3bbfe54d575d5db27a63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9e3654f3714a44b048af3bbfe54d575d5db27a63"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8ca3bb384a70349a9c858deba84a2d9b6f58ac96",
          "sha": "8ca3bb384a70349a9c858deba84a2d9b6f58ac96",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8ca3bb384a70349a9c858deba84a2d9b6f58ac96"
        }
      ],
      "message": "Add transactions to txgraph, but without cluster dependencies\n\nEffectively this is treating all transactions in txgraph as being in a cluster\nof size 1.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-30T12:47:57Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-09T17:43:43Z"
      },
      "sha": "b0c8081258fc37816e4675e17fa9ea8d308921f3"
    },
    {
      "event": "review_requested",
      "id": 20613751542,
      "node_id": "RRE_lADOABII587RhpYCzwAAAATMrOL2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20613751542",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T16:13:38Z",
      "requested_reviewer": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20617573412,
      "node_id": "HRFPE_lADOABII587RhpYCzwAAAATM5zQk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20617573412",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ed23b4537ae8a8a814738909fe9a84c548f2855d",
      "commit_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits/ed23b4537ae8a8a814738909fe9a84c548f2855d",
      "created_at": "2025-10-30T19:08:40Z"
    },
    {
      "event": "commented",
      "id": 3472188061,
      "node_id": "IC_kwDOABII587O9WKd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3472188061",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-31T09:49:25Z",
      "updated_at": "2025-10-31T09:49:25Z",
      "author_association": "MEMBER",
      "body": "I've addressed most of the review feedback, other than the mutation testing notes from @brunoerg which I still need to review (thank you for the analysis!), and some documentation items that were brought up [here](https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440825043) and [here](https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440904975).\r\n\r\nI'll work on incorporating the documentation improvements in #33591.  ",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#issuecomment-3472188061",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629"
    },
    {
      "event": "mentioned",
      "id": 20629539319,
      "node_id": "MEE_lADOABII587RhpYCzwAAAATNncn3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20629539319",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-31T09:49:27Z"
    },
    {
      "event": "subscribed",
      "id": 20629539346,
      "node_id": "SE_lADOABII587RhpYCzwAAAATNncoS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20629539346",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-31T09:49:27Z"
    },
    {
      "event": "reviewed",
      "id": 3404624528,
      "node_id": "PRR_kwDOABII587K7nKQ",
      "url": null,
      "actor": null,
      "commit_id": "ed23b4537ae8a8a814738909fe9a84c548f2855d",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-31T14:43:11Z",
      "author_association": "MEMBER",
      "body": "reACK ed23b4537ae8a8a814738909fe9a84c548f2855d\r\n\r\n`git range-diff master 1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a ed23b4537ae8a8a814738909fe9a84c548f2855d`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3404624528",
      "submitted_at": "2025-10-31T14:43:11Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    },
    {
      "event": "commented",
      "id": 3475369269,
      "node_id": "IC_kwDOABII587PJe01",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3475369269",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-01T01:26:24Z",
      "updated_at": "2025-11-01T01:26:24Z",
      "author_association": "MEMBER",
      "body": "Looks like there's a thread safety issue ([CI run in #33591 caught it](https://github.com/bitcoin/bitcoin/actions/runs/18986107827/job/54230018048?pr=33591)); if I understand correctly, it looks like in `AcceptSingleTransaction()` we acquire the lock and release it before the `MemPoolAccept` object is destroyed, causing a change to txgraph (when the changeset is destroyed) while the lock is not held.  Will fix.",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#issuecomment-3475369269",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUxZDIxM2QxNDQ5YjYxNjY1NjI4Y2U5YjRlMDIwOWNmZjNjNGY4MTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51d213d1449b61665628ce9b4e0209cff3c4f818",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/51d213d1449b61665628ce9b4e0209cff3c4f818",
      "tree": {
        "sha": "aee796de02b415f07c7432d9da3881417cef70c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aee796de02b415f07c7432d9da3881417cef70c4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0c8081258fc37816e4675e17fa9ea8d308921f3",
          "sha": "b0c8081258fc37816e4675e17fa9ea8d308921f3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b0c8081258fc37816e4675e17fa9ea8d308921f3"
        }
      ],
      "message": "squashme: fix locking so that mempool lock is held through subpackage destruction",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:42:06Z"
      },
      "sha": "51d213d1449b61665628ce9b4e0209cff3c4f818"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM5NjNlMWRmNWU5OGRlNmMzMzY2NzE1ODFiMWRkYzI5ZmQ3N2JhM2M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3963e1df5e98de6c336671581b1ddc29fd77ba3c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3963e1df5e98de6c336671581b1ddc29fd77ba3c",
      "tree": {
        "sha": "f9905a835d733bdebedc071ef4c99b866db69a6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f9905a835d733bdebedc071ef4c99b866db69a6c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51d213d1449b61665628ce9b4e0209cff3c4f818",
          "sha": "51d213d1449b61665628ce9b4e0209cff3c4f818",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/51d213d1449b61665628ce9b4e0209cff3c4f818"
        }
      ],
      "message": "Add new (unused) limits for cluster size/count",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-21T10:17:40Z"
      },
      "sha": "3963e1df5e98de6c336671581b1ddc29fd77ba3c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVkZTI2MTE2ZGVmM2RhYzFiZGZhMzRkYTRhZGRkZDZlYjA4ZWI1NTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ede26116def3dac1bdfa34da4adddd6eb08eb551",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ede26116def3dac1bdfa34da4adddd6eb08eb551",
      "tree": {
        "sha": "1fa04b19d5f5d2541c1165212249630264bced00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1fa04b19d5f5d2541c1165212249630264bced00"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3963e1df5e98de6c336671581b1ddc29fd77ba3c",
          "sha": "3963e1df5e98de6c336671581b1ddc29fd77ba3c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3963e1df5e98de6c336671581b1ddc29fd77ba3c"
        }
      ],
      "message": "test: update feature_rbf.py replacement test\n\nPreparatory commit to the rbf functional test, before changes are made to the\nrbf rules as part of cluster mempool.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-02-09T19:58:41Z"
      },
      "sha": "ede26116def3dac1bdfa34da4adddd6eb08eb551"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM4ODI3MjQ0N2RmZGY4NjE4NzNmNzE1Njc3ODM3MmY1YWRlZGU2NzE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c88272447dfdf861873f7156778372f5adede671",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c88272447dfdf861873f7156778372f5adede671",
      "tree": {
        "sha": "628d641e627f547302aed6442e465b60cc35ea53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/628d641e627f547302aed6442e465b60cc35ea53"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ede26116def3dac1bdfa34da4adddd6eb08eb551",
          "sha": "ede26116def3dac1bdfa34da4adddd6eb08eb551",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ede26116def3dac1bdfa34da4adddd6eb08eb551"
        }
      ],
      "message": "[test] rework/delete feature_rbf tests requiring large clusters",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2025-09-03T17:09:47Z"
      },
      "sha": "c88272447dfdf861873f7156778372f5adede671"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZiNzkxY2M0ZWU5ZWRhNWNjY2MzMTBlM2VmYjg2OWFmMzYwNTc5MzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b791cc4ee9eda5cccc310e3efb869af36057935",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6b791cc4ee9eda5cccc310e3efb869af36057935",
      "tree": {
        "sha": "3a64ae76dce781614d9bc717c0b0de94cb0e1ff0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a64ae76dce781614d9bc717c0b0de94cb0e1ff0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c88272447dfdf861873f7156778372f5adede671",
          "sha": "c88272447dfdf861873f7156778372f5adede671",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c88272447dfdf861873f7156778372f5adede671"
        }
      ],
      "message": "Do not allow mempool clusters to exceed configured limits\n\nInclude an adjustment to mempool_tests.cpp due to the additional memory used by\ntxgraph.\n\nIncludes a temporary change to the mempool_ephemeral_dust.py functional test,\ndue to validation checks being reordered. This change will revert once the RBF\nrules are changed in a later commit.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-21T12:58:04Z"
      },
      "sha": "6b791cc4ee9eda5cccc310e3efb869af36057935"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI1OTM5OTViNTllNDcxYTQ1YmFmZjQ2MmY0MWNlZTIyZTNmZTI1ODQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2593995b59e471a45baff462f41cee22e3fe2584",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2593995b59e471a45baff462f41cee22e3fe2584",
      "tree": {
        "sha": "8c80ef00adcb82cc0a89fe25cd9b74b8840127a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c80ef00adcb82cc0a89fe25cd9b74b8840127a6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b791cc4ee9eda5cccc310e3efb869af36057935",
          "sha": "6b791cc4ee9eda5cccc310e3efb869af36057935",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6b791cc4ee9eda5cccc310e3efb869af36057935"
        }
      ],
      "message": "Check cluster limits when using -walletrejectlongchains",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-23T14:26:05Z"
      },
      "sha": "2593995b59e471a45baff462f41cee22e3fe2584"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDgzNTU1Nzg5ZjQyMjMzODM5NTE5ZGU1YTY0M2I0OTJhODFlNGJmYjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/83555789f42233839519de5a643b492a81e4bfb2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/83555789f42233839519de5a643b492a81e4bfb2",
      "tree": {
        "sha": "efffac465f58ef1de00109dbb9119a666f4e8c56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efffac465f58ef1de00109dbb9119a666f4e8c56"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2593995b59e471a45baff462f41cee22e3fe2584",
          "sha": "2593995b59e471a45baff462f41cee22e3fe2584",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2593995b59e471a45baff462f41cee22e3fe2584"
        }
      ],
      "message": "Rework miner_tests to not require large cluster limit",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-02-08T18:36:48Z"
      },
      "sha": "83555789f42233839519de5a643b492a81e4bfb2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg3ZDllMjg1NmY5Y2FhZTYyMjg3ZDMwYmM3NmQ0OTBhMWQ0MWZlZmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87d9e2856f9caae62287d30bc76d490a1d41fefb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/87d9e2856f9caae62287d30bc76d490a1d41fefb",
      "tree": {
        "sha": "75f17ddec6f0353162e220af4b20948db12e7a5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/75f17ddec6f0353162e220af4b20948db12e7a5b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/83555789f42233839519de5a643b492a81e4bfb2",
          "sha": "83555789f42233839519de5a643b492a81e4bfb2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/83555789f42233839519de5a643b492a81e4bfb2"
        }
      ],
      "message": "Limit mempool size based on chunk feerate\n\nRather than evicting the transactions with the lowest descendant feerate,\ninstead evict transactions that have the lowest chunk feerate.\n\nOnce mining is implemented based on choosing transactions with highest chunk\nfeerate (see next commit), mining and eviction will be opposites, so that we\nwill evict the transactions that would be mined last.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-21T00:55:50Z"
      },
      "sha": "87d9e2856f9caae62287d30bc76d490a1d41fefb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDYzYzJiNThkMDdjNWRlNTc3YWJkOWQxNTZhMWI4Y2JhNmJjYmM5Yjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63c2b58d07c5de577abd9d156a1b8cba6bcbc9b9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/63c2b58d07c5de577abd9d156a1b8cba6bcbc9b9",
      "tree": {
        "sha": "e21a73b9fc0889811ea7a7ddac44ed0dcfdc9fe3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e21a73b9fc0889811ea7a7ddac44ed0dcfdc9fe3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87d9e2856f9caae62287d30bc76d490a1d41fefb",
          "sha": "87d9e2856f9caae62287d30bc76d490a1d41fefb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/87d9e2856f9caae62287d30bc76d490a1d41fefb"
        }
      ],
      "message": "bench: rewrite ComplexMemPool to not create oversized clusters",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-09T14:35:55Z"
      },
      "sha": "63c2b58d07c5de577abd9d156a1b8cba6bcbc9b9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM1Njc5ZGJlMDRkMmM5OTgzMjVhZTY1MDBjN2QwYWMxOWY2NTlmZWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35679dbe04d2c998325ae6500c7d0ac19f659feb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/35679dbe04d2c998325ae6500c7d0ac19f659feb",
      "tree": {
        "sha": "a59ffb1eefa21b2ffbfa5721c8391210c3c8286e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a59ffb1eefa21b2ffbfa5721c8391210c3c8286e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63c2b58d07c5de577abd9d156a1b8cba6bcbc9b9",
          "sha": "63c2b58d07c5de577abd9d156a1b8cba6bcbc9b9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/63c2b58d07c5de577abd9d156a1b8cba6bcbc9b9"
        }
      ],
      "message": "Select transactions for blocks based on chunk feerate\n\nCo-Authored-By: Gregory Sanders <gsanders87@gmail.com>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-21T01:16:36Z"
      },
      "sha": "35679dbe04d2c998325ae6500c7d0ac19f659feb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQyNDk2YmI1YTc3YjZlZTMyODE4MDU2MmQwMzEzZmRiODljODFmMGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2496bb5a77b6ee328180562d0313fdb89c81f0f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d2496bb5a77b6ee328180562d0313fdb89c81f0f",
      "tree": {
        "sha": "6222a641d3fb85d4877aff02e12dfbb3a3a3f91c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6222a641d3fb85d4877aff02e12dfbb3a3a3f91c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/35679dbe04d2c998325ae6500c7d0ac19f659feb",
          "sha": "35679dbe04d2c998325ae6500c7d0ac19f659feb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/35679dbe04d2c998325ae6500c7d0ac19f659feb"
        }
      ],
      "message": "test: rewrite PopulateMempool to not violate mempool policy (cluster size) limits",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-09T14:43:11Z"
      },
      "sha": "d2496bb5a77b6ee328180562d0313fdb89c81f0f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIxYjEwYjI5MjNlYjcyOGEyZTVjNWM3MTE3ZGQ3NTNlYzQ0OTQyZmU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1b10b2923eb728a2e5c5c7117dd753ec44942fe",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b1b10b2923eb728a2e5c5c7117dd753ec44942fe",
      "tree": {
        "sha": "deec5e2ae299e07597029c51fd4b9f329e640ef9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/deec5e2ae299e07597029c51fd4b9f329e640ef9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2496bb5a77b6ee328180562d0313fdb89c81f0f",
          "sha": "d2496bb5a77b6ee328180562d0313fdb89c81f0f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d2496bb5a77b6ee328180562d0313fdb89c81f0f"
        }
      ],
      "message": "policy: Remove CPFP carveout rule\n\nThe addition of a cluster size limit makes the CPFP carveout rule useless,\nbecause carveout cannot be used to bypass the cluster size limit. Remove this\npolicy rule and update tests to no longer rely on the behavior.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-03T14:54:30Z"
      },
      "sha": "b1b10b2923eb728a2e5c5c7117dd753ec44942fe"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE4N2Y3ODk5MWZhZDNjNTIxZTU1NTA4YTlkMTkwMWQzNzY3YzJmODk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/187f78991fad3c521e55508a9d1901d3767c2f89",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/187f78991fad3c521e55508a9d1901d3767c2f89",
      "tree": {
        "sha": "c9fa50f154b66209fef2c7543c19984ebf221656",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c9fa50f154b66209fef2c7543c19984ebf221656"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1b10b2923eb728a2e5c5c7117dd753ec44942fe",
          "sha": "b1b10b2923eb728a2e5c5c7117dd753ec44942fe",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b1b10b2923eb728a2e5c5c7117dd753ec44942fe"
        }
      ],
      "message": "Implement new RBF logic for cluster mempool\n\nWith a total ordering on mempool transactions, we are now able to calculate a\ntransaction's mining score at all times. Use this to improve the RBF logic:\n\n- we no longer enforce a \"no new unconfirmed parents\" rule\n\n- we now require that the mempool's feerate diagram must improve in order\n  to accept a replacement\n\n- the topology restrictions for conflicts in the package rbf setting have been\n  eliminated\n\nRevert the temporary change to mempool_ephemeral_dust.py that were previously\nmade due to RBF validation checks being reordered.\n\nCo-authored-by: Gregory Sanders <gsanders87@gmail.com>, glozow <gloriajzhao@gmail.com>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-21T17:19:32Z"
      },
      "sha": "187f78991fad3c521e55508a9d1901d3767c2f89"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNlNDQ5MDNkNDk2MWYxY2FhMjY4YWZiZTdjNWExMmMwMWNhMjM3NDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce44903d4961f1caa268afbe7c5a12c01ca23745",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ce44903d4961f1caa268afbe7c5a12c01ca23745",
      "tree": {
        "sha": "94e5b1e86682d5933da7ce3f0b333b6dc63df057",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94e5b1e86682d5933da7ce3f0b333b6dc63df057"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/187f78991fad3c521e55508a9d1901d3767c2f89",
          "sha": "187f78991fad3c521e55508a9d1901d3767c2f89",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/187f78991fad3c521e55508a9d1901d3767c2f89"
        }
      ],
      "message": "Remove the ancestor and descendant indices from the mempool",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-21T18:45:20Z"
      },
      "sha": "ce44903d4961f1caa268afbe7c5a12c01ca23745"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQyZTRlZWRkOGZhOTQ3ZGY1YmVkMGY4YjgzMTEwYzIzYmY3OTVhYzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2e4eedd8fa947df5bed0f8b83110c23bf795ac4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d2e4eedd8fa947df5bed0f8b83110c23bf795ac4",
      "tree": {
        "sha": "c3d61f8116ed33be93a8b511a6c841df67d53d14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c3d61f8116ed33be93a8b511a6c841df67d53d14"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce44903d4961f1caa268afbe7c5a12c01ca23745",
          "sha": "ce44903d4961f1caa268afbe7c5a12c01ca23745",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ce44903d4961f1caa268afbe7c5a12c01ca23745"
        }
      ],
      "message": "Use cluster linearization for transaction relay sort order\n\nPreviously, transaction batches were first sorted by ancestor count and then\nfeerate, to ensure transactions are announced in a topologically valid order,\nwhile prioritizing higher feerate transactions. Ancestor count is a crude\ntopological sort criteria, so replace this with linearization order so that the\nhighest feerate transactions (as would be observed by the mining algorithm) are\nrelayed before lower feerate ones, in a topologically valid way.\n\nThis also fixes a test that only worked due to the ancestor-count-based sort\norder.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-27T18:47:42Z"
      },
      "sha": "d2e4eedd8fa947df5bed0f8b83110c23bf795ac4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRhNWE1MzA3NjFlNDI2OWRmNjllY2I3ZjhiODQ3N2MwY2EyNmY1ZDc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da5a530761e4269df69ecb7f8b8477c0ca26f5d7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/da5a530761e4269df69ecb7f8b8477c0ca26f5d7",
      "tree": {
        "sha": "3459452de23f5962f7fc9e45c21302a86122ff88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3459452de23f5962f7fc9e45c21302a86122ff88"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2e4eedd8fa947df5bed0f8b83110c23bf795ac4",
          "sha": "d2e4eedd8fa947df5bed0f8b83110c23bf795ac4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d2e4eedd8fa947df5bed0f8b83110c23bf795ac4"
        }
      ],
      "message": "Remove CTxMemPool::GetSortedDepthAndScore\n\nThe mempool clusters and linearization permit sorting the mempool topologically\nwithout making use of ancestor counts (as long as the graph is not oversized).\n\nCo-authored-by: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-28T14:20:04Z"
      },
      "sha": "da5a530761e4269df69ecb7f8b8477c0ca26f5d7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU3YTFjZjgyYmQ3YjU1ZjQ2YWQ1MWYwZDgxYjBhZDRhN2Q0OTEwYWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af",
      "tree": {
        "sha": "6b24a9f3ad1e84d2d29c5e54af9c881271645bf7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b24a9f3ad1e84d2d29c5e54af9c881271645bf7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da5a530761e4269df69ecb7f8b8477c0ca26f5d7",
          "sha": "da5a530761e4269df69ecb7f8b8477c0ca26f5d7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/da5a530761e4269df69ecb7f8b8477c0ca26f5d7"
        }
      ],
      "message": "Reimplement GetTransactionAncestry() to not rely on cached data\n\nIn preparation for removing ancestor data from CTxMemPoolEntry, recalculate the\nancestor statistics on demand wherever needed.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-28T18:47:40Z"
      },
      "sha": "e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1OWY5ZWFmZTA1NmEwMjE4N2QwMGMyZWZjYWM2NWJmNjllNzllM2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e59f9eafe056a02187d00c2efcac65bf69e79e3b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e59f9eafe056a02187d00c2efcac65bf69e79e3b",
      "tree": {
        "sha": "d0e9f81f4f3175ef7113c4e3d936c2f82a09574a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d0e9f81f4f3175ef7113c4e3d936c2f82a09574a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af",
          "sha": "e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af"
        }
      ],
      "message": "rpc: Calculate ancestor data from scratch for mempool rpc calls",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-28T19:07:05Z"
      },
      "sha": "e59f9eafe056a02187d00c2efcac65bf69e79e3b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIwZjFjZjg5NzdhZTQzNDU2YWExZjg2NTA1NjRhMGYzMTRjYjJhZjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0f1cf8977ae43456aa1f8650564a0f314cb2af0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b0f1cf8977ae43456aa1f8650564a0f314cb2af0",
      "tree": {
        "sha": "aec87ff1a2919f50974287fd6dc100616dc44e62",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aec87ff1a2919f50974287fd6dc100616dc44e62"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e59f9eafe056a02187d00c2efcac65bf69e79e3b",
          "sha": "e59f9eafe056a02187d00c2efcac65bf69e79e3b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e59f9eafe056a02187d00c2efcac65bf69e79e3b"
        }
      ],
      "message": "Remove dependency on cached ancestor data in mini-miner",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-28T21:55:16Z"
      },
      "sha": "b0f1cf8977ae43456aa1f8650564a0f314cb2af0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRmNzgzZmQyZjc5MDVlMTBjMTBiOTk5OThjOTIwYzJkMjhiN2Q0ODI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df783fd2f7905e10c10b99998c920c2d28b7d482",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/df783fd2f7905e10c10b99998c920c2d28b7d482",
      "tree": {
        "sha": "e59363019899530f41f31cee6f29e6c9e5fbf0df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e59363019899530f41f31cee6f29e6c9e5fbf0df"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0f1cf8977ae43456aa1f8650564a0f314cb2af0",
          "sha": "b0f1cf8977ae43456aa1f8650564a0f314cb2af0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b0f1cf8977ae43456aa1f8650564a0f314cb2af0"
        }
      ],
      "message": "Stop enforcing ancestor size/count limits\n\nThe cluster limits should be sufficient.\n\nCo-Authored-By: Gregory Sanders <gsanders87@gmail.com>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-09-28T21:59:15Z"
      },
      "sha": "df783fd2f7905e10c10b99998c920c2d28b7d482"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdhMjVmYjdlOGUxY2M0YjcwZDE1Y2E1YmY2ZDg5ODU0ODQ5ZWYwM2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a25fb7e8e1cc4b70d15ca5bf6d89854849ef03b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7a25fb7e8e1cc4b70d15ca5bf6d89854849ef03b",
      "tree": {
        "sha": "9029b373a8cf533ae9f60cbee2f23e8a48df97f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9029b373a8cf533ae9f60cbee2f23e8a48df97f4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df783fd2f7905e10c10b99998c920c2d28b7d482",
          "sha": "df783fd2f7905e10c10b99998c920c2d28b7d482",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/df783fd2f7905e10c10b99998c920c2d28b7d482"
        }
      ],
      "message": "Add test case for cluster size limits to TRUC logic",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-14T10:59:01Z"
      },
      "sha": "7a25fb7e8e1cc4b70d15ca5bf6d89854849ef03b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDExZjBmOGQ1MTA5Mzk0YWJjZTE0ODUwNGQxOTcwNzEyZmI3ZDU3YWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11f0f8d5109394abce148504d1970712fb7d57ab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/11f0f8d5109394abce148504d1970712fb7d57ab",
      "tree": {
        "sha": "4680093f82c4151df81a3fb86178a8d728d4c940",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4680093f82c4151df81a3fb86178a8d728d4c940"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a25fb7e8e1cc4b70d15ca5bf6d89854849ef03b",
          "sha": "7a25fb7e8e1cc4b70d15ca5bf6d89854849ef03b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7a25fb7e8e1cc4b70d15ca5bf6d89854849ef03b"
        }
      ],
      "message": "Use mempool/txgraph to determine if a tx has descendants\n\nRemove a reference to GetCountWithDescendants() in preparation for removing\nthis function and the associated cached state from the mempool.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-03T15:19:15Z"
      },
      "sha": "11f0f8d5109394abce148504d1970712fb7d57ab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI3OWVlNmZkZWZlOGNiMmFiMzhlYjU1MTY5YTUzNTllZGZhZDE5YTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/279ee6fdefe8cb2ab38eb55169a5359edfad19a9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/279ee6fdefe8cb2ab38eb55169a5359edfad19a9",
      "tree": {
        "sha": "e0055fe3a6e35478a82198905282af4ae313a47c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e0055fe3a6e35478a82198905282af4ae313a47c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11f0f8d5109394abce148504d1970712fb7d57ab",
          "sha": "11f0f8d5109394abce148504d1970712fb7d57ab",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/11f0f8d5109394abce148504d1970712fb7d57ab"
        }
      ],
      "message": "Calculate descendant information for mempool RPC output on-the-fly\n\nThis is in preparation for removing the cached descendant state from the\nmempool.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-03T15:57:16Z"
      },
      "sha": "279ee6fdefe8cb2ab38eb55169a5359edfad19a9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ3NTU5NDc3N2MxM2M4ZDI3MmMxNTk1MmMzNjNhYWZjMTIyYjBkOTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d75594777c13c8d272c15952c363aafc122b0d92",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d75594777c13c8d272c15952c363aafc122b0d92",
      "tree": {
        "sha": "03a3c3d7bced2f838e96489604700940845fdf21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/03a3c3d7bced2f838e96489604700940845fdf21"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/279ee6fdefe8cb2ab38eb55169a5359edfad19a9",
          "sha": "279ee6fdefe8cb2ab38eb55169a5359edfad19a9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/279ee6fdefe8cb2ab38eb55169a5359edfad19a9"
        }
      ],
      "message": "test: remove rbf carveout test from mempool_limit.py",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-18T17:22:09Z"
      },
      "sha": "d75594777c13c8d272c15952c363aafc122b0d92"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3YzgwM2Q4NWEzN2ExY2NlMGVjYWJhNTZkYWYyMTE3ZTdjZmJiYTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97c803d85a37a1cce0ecaba56daf2117e7cfbba0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/97c803d85a37a1cce0ecaba56daf2117e7cfbba0",
      "tree": {
        "sha": "eb11177f19a06f40576acf8ca0d79e1b0e14adf2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eb11177f19a06f40576acf8ca0d79e1b0e14adf2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d75594777c13c8d272c15952c363aafc122b0d92",
          "sha": "d75594777c13c8d272c15952c363aafc122b0d92",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d75594777c13c8d272c15952c363aafc122b0d92"
        }
      ],
      "message": "Stop enforcing descendant size/count limits\n\nCluster size limits should be enough.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-03T17:56:22Z"
      },
      "sha": "97c803d85a37a1cce0ecaba56daf2117e7cfbba0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRhZmExZGEwOTMwYzgxNTVhMmJhM2EyZDA5OTMyYjMxNWQwZjUwODM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dafa1da0930c8155a2ba3a2d09932b315d0f5083",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dafa1da0930c8155a2ba3a2d09932b315d0f5083",
      "tree": {
        "sha": "efa14fea8f88377d718ddba8f473915203012842",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efa14fea8f88377d718ddba8f473915203012842"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97c803d85a37a1cce0ecaba56daf2117e7cfbba0",
          "sha": "97c803d85a37a1cce0ecaba56daf2117e7cfbba0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/97c803d85a37a1cce0ecaba56daf2117e7cfbba0"
        }
      ],
      "message": "Eliminate RBF workaround for CPFP carveout transactions\n\nThe new cluster mempool RBF rules take into account clusters sizes exactly, so\nwith the removal of descendant count enforcement this idea is obsolete.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2024-06-12T18:50:47Z"
      },
      "sha": "dafa1da0930c8155a2ba3a2d09932b315d0f5083"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNmMWJjYmJiOGUxYTRjYjcyY2QzN2E0NGRjZDg4MTFkYjhhMTk1OGI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b",
      "tree": {
        "sha": "369064def164870da12b55cc6cb2b030e2a941a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/369064def164870da12b55cc6cb2b030e2a941a6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dafa1da0930c8155a2ba3a2d09932b315d0f5083",
          "sha": "dafa1da0930c8155a2ba3a2d09932b315d0f5083",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dafa1da0930c8155a2ba3a2d09932b315d0f5083"
        }
      ],
      "message": "wallet: Replace max descendantsize with clustersize\n\nWith the descendant size limits removed, replace the concept of \"max number of\ndescendants of any ancestor of a given tx\" with the cluster count of the cluster\nthat the transaction belongs to.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-03T19:00:00Z"
      },
      "sha": "cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI2OTkyZjliNDhiZGIzZDNkZGQ3ZWVlZGE3NjJjYTc3Yjk1ZDc1OTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6992f9b48bdb3d3ddd7eeeda762ca77b95d7596",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b6992f9b48bdb3d3ddd7eeeda762ca77b95d7596",
      "tree": {
        "sha": "9723e12b0bd054fc13bf5a0f45c305af097a6311",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9723e12b0bd054fc13bf5a0f45c305af097a6311"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b",
          "sha": "cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b"
        }
      ],
      "message": "mempool: Remove unused function CalculateDescendantMaximum",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-04T13:19:21Z"
      },
      "sha": "b6992f9b48bdb3d3ddd7eeeda762ca77b95d7596"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJkODE2NGJlMWY2MTljZjcxMTczYzA5MTNlZWIwZmIyNTEzNTQ2OGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd8164be1f619cf71173c0913eeb0fb25135468f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bd8164be1f619cf71173c0913eeb0fb25135468f",
      "tree": {
        "sha": "d844ac6782724b2e2cfc02f6bce130836983b1c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d844ac6782724b2e2cfc02f6bce130836983b1c3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b6992f9b48bdb3d3ddd7eeeda762ca77b95d7596",
          "sha": "b6992f9b48bdb3d3ddd7eeeda762ca77b95d7596",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b6992f9b48bdb3d3ddd7eeeda762ca77b95d7596"
        }
      ],
      "message": "Eliminate use of cached ancestor data in miniminer_tests and truc_policy",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-14T17:49:03Z"
      },
      "sha": "bd8164be1f619cf71173c0913eeb0fb25135468f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3MTI2Y2E2MDVlMWU2OTMwNmJhY2UwMDkxYWRjYjJlNDhlN2Q3MDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97126ca605e1e69306bace0091adcb2e48e7d708",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/97126ca605e1e69306bace0091adcb2e48e7d708",
      "tree": {
        "sha": "13f3f948011b1b066fb1b36b2bcf46322c8839fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13f3f948011b1b066fb1b36b2bcf46322c8839fb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd8164be1f619cf71173c0913eeb0fb25135468f",
          "sha": "bd8164be1f619cf71173c0913eeb0fb25135468f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bd8164be1f619cf71173c0913eeb0fb25135468f"
        }
      ],
      "message": "mempool: eliminate accessors to mempool entry ancestor/descendant cached state",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-04T13:28:05Z"
      },
      "sha": "97126ca605e1e69306bace0091adcb2e48e7d708"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRmM2M3MmRhMWNkYTdmY2VkNmQxNTU5Yzc1OTE3MTNiNDM2NGUwOGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f3c72da1cda7fced6d1559c7591713b4364e08c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4f3c72da1cda7fced6d1559c7591713b4364e08c",
      "tree": {
        "sha": "1930e84a33c551b0962251455be935746f6f14e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1930e84a33c551b0962251455be935746f6f14e3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97126ca605e1e69306bace0091adcb2e48e7d708",
          "sha": "97126ca605e1e69306bace0091adcb2e48e7d708",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/97126ca605e1e69306bace0091adcb2e48e7d708"
        }
      ],
      "message": "Remove unused members from CTxMemPoolEntry",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-04T13:48:04Z"
      },
      "sha": "4f3c72da1cda7fced6d1559c7591713b4364e08c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDliMjhlN2I5MzU0ZGVkMmJhODI0ZjY2YzE3ZTJkN2NjYmMzNTIwNDE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b28e7b9354ded2ba824f66c17e2d7ccbc352041",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9b28e7b9354ded2ba824f66c17e2d7ccbc352041",
      "tree": {
        "sha": "7a3ab4f78b34fdfc8abd5bd09c0faa8623302cde",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a3ab4f78b34fdfc8abd5bd09c0faa8623302cde"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f3c72da1cda7fced6d1559c7591713b4364e08c",
          "sha": "4f3c72da1cda7fced6d1559c7591713b4364e08c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4f3c72da1cda7fced6d1559c7591713b4364e08c"
        }
      ],
      "message": "Remove mempool logic designed to maintain ancestor/descendant state",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-04T14:47:14Z"
      },
      "sha": "9b28e7b9354ded2ba824f66c17e2d7ccbc352041"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ0ZDcwNDQ5ZDJlMzMzZGZmMjBkMDZjYzhmNDNhZTk2ZDk1NWI5MjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/44d70449d2e333dff20d06cc8f43ae96d955b924",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/44d70449d2e333dff20d06cc8f43ae96d955b924",
      "tree": {
        "sha": "866c1a6780f668450cb87e184f73cd74ad69fcd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/866c1a6780f668450cb87e184f73cd74ad69fcd7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b28e7b9354ded2ba824f66c17e2d7ccbc352041",
          "sha": "9b28e7b9354ded2ba824f66c17e2d7ccbc352041",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9b28e7b9354ded2ba824f66c17e2d7ccbc352041"
        }
      ],
      "message": "mempool: addUnchecked no longer needs ancestors",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-05T13:33:41Z"
      },
      "sha": "44d70449d2e333dff20d06cc8f43ae96d955b924"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIwYTAzNDg5NDc5OGFkYzQyYzQyMTYyYjIyOWNjNWZiNTZjMDc3OWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0a034894798adc42c42162b229cc5fb56c0779c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b0a034894798adc42c42162b229cc5fb56c0779c",
      "tree": {
        "sha": "ea6a495f37704512d62739f7a93354b5b825db6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ea6a495f37704512d62739f7a93354b5b825db6a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/44d70449d2e333dff20d06cc8f43ae96d955b924",
          "sha": "44d70449d2e333dff20d06cc8f43ae96d955b924",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/44d70449d2e333dff20d06cc8f43ae96d955b924"
        }
      ],
      "message": "Remove unused limits from CalculateMemPoolAncestors",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-15T01:15:06Z"
      },
      "sha": "b0a034894798adc42c42162b229cc5fb56c0779c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRhOGIzOGI5Y2Q0MTI3ZDYyMTllNzIxNWI1MzBjZDNiYzE5YjI4MjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a8b38b9cd4127d6219e7215b530cd3bc19b2821",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4a8b38b9cd4127d6219e7215b530cd3bc19b2821",
      "tree": {
        "sha": "0a4b51adc067c20890d53be0642011121acc81f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a4b51adc067c20890d53be0642011121acc81f0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0a034894798adc42c42162b229cc5fb56c0779c",
          "sha": "b0a034894798adc42c42162b229cc5fb56c0779c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b0a034894798adc42c42162b229cc5fb56c0779c"
        }
      ],
      "message": "Make removeConflicts private",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-15T10:12:22Z"
      },
      "sha": "4a8b38b9cd4127d6219e7215b530cd3bc19b2821"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY1OGE2YTgxN2QyM2I2MmY1MDAwNGFjZTY5MWU0MDJmNmM2NmM0ZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/658a6a817d23b62f50004ace691e402f6c66c4e6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/658a6a817d23b62f50004ace691e402f6c66c4e6",
      "tree": {
        "sha": "456aa4aaa1b54220eb73e6c7146d990ccffe9de2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/456aa4aaa1b54220eb73e6c7146d990ccffe9de2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a8b38b9cd4127d6219e7215b530cd3bc19b2821",
          "sha": "4a8b38b9cd4127d6219e7215b530cd3bc19b2821",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4a8b38b9cd4127d6219e7215b530cd3bc19b2821"
        }
      ],
      "message": "Simplify ancestor calculation functions\n\nNow that ancestor calculation never fails (due to ancestor/descendant limits\nbeing eliminated), we can eliminate the error handling from\nCalculateMemPoolAncestors.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-15T01:31:51Z"
      },
      "sha": "658a6a817d23b62f50004ace691e402f6c66c4e6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZhNDI4YWYwYmM2NzBkNmUyZDUyMGZlOTEwOTA5ZmJjNGI0YzFjYjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa428af0bc670d6e2d520fe910909fbc4b4c1cb8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fa428af0bc670d6e2d520fe910909fbc4b4c1cb8",
      "tree": {
        "sha": "f38f23064c56caa4e16dcaaa8e60e1f053f14023",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f38f23064c56caa4e16dcaaa8e60e1f053f14023"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/658a6a817d23b62f50004ace691e402f6c66c4e6",
          "sha": "658a6a817d23b62f50004ace691e402f6c66c4e6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/658a6a817d23b62f50004ace691e402f6c66c4e6"
        }
      ],
      "message": "Use txgraph to calculate ancestors",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-14T22:21:34Z"
      },
      "sha": "fa428af0bc670d6e2d520fe910909fbc4b4c1cb8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDgyOGE3NTgzMjQ1MDljNmU4YTI4MjMzNTExNGUwYWE1OTZiM2NiZjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a758324509c6e8a282335114e0aa596b3cbf9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/828a758324509c6e8a282335114e0aa596b3cbf9",
      "tree": {
        "sha": "6d748c9b2c52b286b8e643526800c2c7409c2ff6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d748c9b2c52b286b8e643526800c2c7409c2ff6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa428af0bc670d6e2d520fe910909fbc4b4c1cb8",
          "sha": "fa428af0bc670d6e2d520fe910909fbc4b4c1cb8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fa428af0bc670d6e2d520fe910909fbc4b4c1cb8"
        }
      ],
      "message": "Use txgraph to calculate descendants",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-14T23:28:25Z"
      },
      "sha": "828a758324509c6e8a282335114e0aa596b3cbf9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ2ZmZjYTc4ZWVjZmY3YTZhYzIzZGNlYTNhODFkODhjNmM4NjE0MGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6ffca78eecff7a6ac23dcea3a81d88c6c86140d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d6ffca78eecff7a6ac23dcea3a81d88c6c86140d",
      "tree": {
        "sha": "7c09ddf0a17a064524b7f9b7768c6366f24856a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7c09ddf0a17a064524b7f9b7768c6366f24856a1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/828a758324509c6e8a282335114e0aa596b3cbf9",
          "sha": "828a758324509c6e8a282335114e0aa596b3cbf9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/828a758324509c6e8a282335114e0aa596b3cbf9"
        }
      ],
      "message": "Rework truc_policy to use descendants, not children",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-23T20:49:00Z"
      },
      "sha": "d6ffca78eecff7a6ac23dcea3a81d88c6c86140d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDViZTg0NzhkZDJlNTBhNDU4ODIxYjg1MmRjNDAzYTE4Mzc3ZWM1MDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5be8478dd2e50a458821b852dc403a18377ec502",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5be8478dd2e50a458821b852dc403a18377ec502",
      "tree": {
        "sha": "2811b9adba34187891bb953ef778b25f984d8476",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2811b9adba34187891bb953ef778b25f984d8476"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6ffca78eecff7a6ac23dcea3a81d88c6c86140d",
          "sha": "d6ffca78eecff7a6ac23dcea3a81d88c6c86140d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d6ffca78eecff7a6ac23dcea3a81d88c6c86140d"
        }
      ],
      "message": "Rework RBF and TRUC validation\n\nCalculating mempool ancestors for a new transaction should not be done until\nafter cluster size limits have been enforced, to limit CPU DoS potential.\n\nAchieve this by reworking TRUC and RBF validation logic:\n\n- TRUC policy enforcement is now done using only mempool parents of\n  new transactions, not all mempool ancestors (note that it's fine to calculate\n  ancestors of in-mempool transactions, if the number of such calls is\n  reasonably bounded).\n- RBF replacement checks are performed earlier (which allows for checking\n  cluster size limits earlier, because cluster size checks cannot happen until\n  after all conflicts are staged for removal).\n- Verifying that a new transaction doesn't conflict with an ancestor now\n  happens later, in AcceptSingleTransaction() rather than in PreChecks(). This\n  means that the test is not performed at all in AcceptMultipleTransactions(),\n  but in package acceptance we already disallow RBF in situations where a\n  package transaction has in-mempool parents.\n\nAlso to ensure that all RBF validation logic is applied in both the single\ntransaction and multiple transaction cases, remove the optimization that skips\nthe PackageMempoolChecks() in the case of a single transaction being validated\nin AcceptMultipleTransactions().",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-09-21T16:52:05Z"
      },
      "sha": "5be8478dd2e50a458821b852dc403a18377ec502"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU5ZTI2OTAxMDA4MzEwNjdiYWU0YzJiYTIwMmM5OTQ1MWQ3NjczZTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9e2690100831067bae4c2ba202c99451d7673e3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e9e2690100831067bae4c2ba202c99451d7673e3",
      "tree": {
        "sha": "8c3529aa93c45315f678e18687427b7d19b8e5a8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c3529aa93c45315f678e18687427b7d19b8e5a8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5be8478dd2e50a458821b852dc403a18377ec502",
          "sha": "5be8478dd2e50a458821b852dc403a18377ec502",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5be8478dd2e50a458821b852dc403a18377ec502"
        }
      ],
      "message": "Make getting parents/children a function of the mempool, not a mempool entry",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-16T15:02:26Z"
      },
      "sha": "e9e2690100831067bae4c2ba202c99451d7673e3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU4YWVhMTM0NzEzNjc3ODc5NTU4Mjg0YzMxYmExNmNjZjVlYzhkNWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e8aea134713677879558284c31ba16ccf5ec8d5a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e8aea134713677879558284c31ba16ccf5ec8d5a",
      "tree": {
        "sha": "4a12cb4cbfdc117acf2e63638d0694b631ceb935",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4a12cb4cbfdc117acf2e63638d0694b631ceb935"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e9e2690100831067bae4c2ba202c99451d7673e3",
          "sha": "e9e2690100831067bae4c2ba202c99451d7673e3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e9e2690100831067bae4c2ba202c99451d7673e3"
        }
      ],
      "message": "Eliminate CheckPackageLimits, which no longer does anything",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-01-25T16:30:50Z"
      },
      "sha": "e8aea134713677879558284c31ba16ccf5ec8d5a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQyY2FlMDM4NjY4YjlkMWJiYmFjOGE4MzI4ZTFiMjQxNTExNGU2ZmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2cae038668b9d1bbbac8a8328e1b2415114e6fc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d2cae038668b9d1bbbac8a8328e1b2415114e6fc",
      "tree": {
        "sha": "13964d37b7b6cd3ab990656a38a1489d22b91126",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/13964d37b7b6cd3ab990656a38a1489d22b91126"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e8aea134713677879558284c31ba16ccf5ec8d5a",
          "sha": "e8aea134713677879558284c31ba16ccf5ec8d5a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e8aea134713677879558284c31ba16ccf5ec8d5a"
        }
      ],
      "message": "Fix miniminer_tests to work with cluster limits",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-02-08T18:38:19Z"
      },
      "sha": "d2cae038668b9d1bbbac8a8328e1b2415114e6fc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1NWM5MmUzY2YxY2I2MmU5MmVjMmUxMGI3ODQxMTFlZDkzZjA4NmQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e55c92e3cf1cb62e92ec2e10b784111ed93f086d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e55c92e3cf1cb62e92ec2e10b784111ed93f086d",
      "tree": {
        "sha": "86dfb033109f0e45d2a8a167b15c8c101ba9d009",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/86dfb033109f0e45d2a8a167b15c8c101ba9d009"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2cae038668b9d1bbbac8a8328e1b2415114e6fc",
          "sha": "d2cae038668b9d1bbbac8a8328e1b2415114e6fc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d2cae038668b9d1bbbac8a8328e1b2415114e6fc"
        }
      ],
      "message": "Rewrite GatherClusters to use the txgraph implementation",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-16T15:10:07Z"
      },
      "sha": "e55c92e3cf1cb62e92ec2e10b784111ed93f086d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE5YmM2YmIyOTI4ZmQzY2U5NGNmNGFhZDlhYmZiZDQwOGU2NDU3Mjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9bc6bb2928fd3ce94cf4aad9abfbd408e645727",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a9bc6bb2928fd3ce94cf4aad9abfbd408e645727",
      "tree": {
        "sha": "1311182f48b8d876c1ce887916364264a2cfa651",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1311182f48b8d876c1ce887916364264a2cfa651"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e55c92e3cf1cb62e92ec2e10b784111ed93f086d",
          "sha": "e55c92e3cf1cb62e92ec2e10b784111ed93f086d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e55c92e3cf1cb62e92ec2e10b784111ed93f086d"
        }
      ],
      "message": "Stop tracking parents/children outside of txgraph",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2024-04-16T16:13:42Z"
      },
      "sha": "a9bc6bb2928fd3ce94cf4aad9abfbd408e645727"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNhMjUxNGM2ODU2Yjc5MzIyODhhZWQ5YmJmZjFiY2VlN2M2Njk5NTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca2514c6856b7932288aed9bbff1bcee7c669950",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ca2514c6856b7932288aed9bbff1bcee7c669950",
      "tree": {
        "sha": "46e2b732fbab635fcb004f83dada666cc16935ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/46e2b732fbab635fcb004f83dada666cc16935ca"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9bc6bb2928fd3ce94cf4aad9abfbd408e645727",
          "sha": "a9bc6bb2928fd3ce94cf4aad9abfbd408e645727",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a9bc6bb2928fd3ce94cf4aad9abfbd408e645727"
        }
      ],
      "message": "Avoid violating mempool policy limits in tests\n\nChanges AddToMempool() helper to only apply changes if the mempool limits are\nrespected.\n\nFix package_rbf fuzz target to handle mempool policy violations",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-02-04T20:03:25Z"
      },
      "sha": "ca2514c6856b7932288aed9bbff1bcee7c669950"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkyMDNhMzc3NGUwYTg0MDA2ZWIyZGJkNTE2ZGUxNTg3MDg4NjJiMmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9203a3774e0a84006eb2dbd516de158708862b2b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9203a3774e0a84006eb2dbd516de158708862b2b",
      "tree": {
        "sha": "99de6bee59408208319373444b84a81612bbe78e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/99de6bee59408208319373444b84a81612bbe78e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca2514c6856b7932288aed9bbff1bcee7c669950",
          "sha": "ca2514c6856b7932288aed9bbff1bcee7c669950",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ca2514c6856b7932288aed9bbff1bcee7c669950"
        }
      ],
      "message": "bench: add more mempool benchmarks\n\nAdd benchmarks for:\n\n  - adding a transaction\n  - calculating mempool ancestors/descendants",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-10-11T15:34:16Z"
      },
      "sha": "9203a3774e0a84006eb2dbd516de158708862b2b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA0YTFmMGQyMjUzMzc3NjY3MjM2NDEwYThjYjNkMTNmMmQ2YjdiOTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04a1f0d2253377667236410a8cb3d13f2d6b7b97",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/04a1f0d2253377667236410a8cb3d13f2d6b7b97",
      "tree": {
        "sha": "0beaeabeed4f92dba4bbbf10051e67ce01a9822a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0beaeabeed4f92dba4bbbf10051e67ce01a9822a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9203a3774e0a84006eb2dbd516de158708862b2b",
          "sha": "9203a3774e0a84006eb2dbd516de158708862b2b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9203a3774e0a84006eb2dbd516de158708862b2b"
        }
      ],
      "message": "fuzz: try to add more code coverage for mempool fuzzing\n\nIncluding test coverage for mempool eviction and expiry",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@gmail.com",
        "date": "2023-10-12T14:48:55Z"
      },
      "sha": "04a1f0d2253377667236410a8cb3d13f2d6b7b97"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMyZjAxZTc1YzZkODM4OTE3MjJiMWM5OTcyYjlkMjlkMTg4ZmIyODY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32f01e75c6d83891722b1c9972b9d29d188fb286",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/32f01e75c6d83891722b1c9972b9d29d188fb286",
      "tree": {
        "sha": "2af96d374afc6017ee0a5418f41fe4c3ef5b3f85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2af96d374afc6017ee0a5418f41fe4c3ef5b3f85"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04a1f0d2253377667236410a8cb3d13f2d6b7b97",
          "sha": "04a1f0d2253377667236410a8cb3d13f2d6b7b97",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/04a1f0d2253377667236410a8cb3d13f2d6b7b97"
        }
      ],
      "message": "Expose cluster information via rpc\n\nCo-authored-by: glozow <gloriajzhao@gmail.com>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2023-04-19T21:12:04Z"
      },
      "sha": "32f01e75c6d83891722b1c9972b9d29d188fb286"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIxZDhjNWYzOTU1Y2UwYjQzNjczZmQ5YWZlMmIxZmVhZWQ1ZjUzNzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1d8c5f3955ce0b43673fd9afe2b1feaed5f5375",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b1d8c5f3955ce0b43673fd9afe2b1feaed5f5375",
      "tree": {
        "sha": "d6bcbd528c3a38f7e4946d95a804856371b0b83b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6bcbd528c3a38f7e4946d95a804856371b0b83b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/32f01e75c6d83891722b1c9972b9d29d188fb286",
          "sha": "32f01e75c6d83891722b1c9972b9d29d188fb286",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/32f01e75c6d83891722b1c9972b9d29d188fb286"
        }
      ],
      "message": "doc: Update mempool_replacements.md to reflect feerate diagram checks",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2024-04-24T23:52:18Z"
      },
      "sha": "b1d8c5f3955ce0b43673fd9afe2b1feaed5f5375"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlmZjQxYzM0Yjk5YjdjMTI5ZDljOGJkYmY2YWNhZTkxNjZiZDE1ZmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ff41c34b99b7c129d9c8bdbf6acae9166bd15fa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9ff41c34b99b7c129d9c8bdbf6acae9166bd15fa",
      "tree": {
        "sha": "390c631f5b86453ef0997fae6d3e544c120e67f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/390c631f5b86453ef0997fae6d3e544c120e67f4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1d8c5f3955ce0b43673fd9afe2b1feaed5f5375",
          "sha": "b1d8c5f3955ce0b43673fd9afe2b1feaed5f5375",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b1d8c5f3955ce0b43673fd9afe2b1feaed5f5375"
        }
      ],
      "message": "test: add functional test for new cluster mempool RPCs\n\nCo-authored-by: glozow <gloriajzhao@gmail.com>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2024-04-27T13:31:59Z"
      },
      "sha": "9ff41c34b99b7c129d9c8bdbf6acae9166bd15fa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3ZTAzYmVjNDY0MWIxMzdkYzQ1Yzc1NGVhZGU5NTA3MGJiNDcxODc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97e03bec4641b137dc45c754eade95070bb47187",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/97e03bec4641b137dc45c754eade95070bb47187",
      "tree": {
        "sha": "273876dd78fc413ec70e5357a375f2a3e48b1529",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/273876dd78fc413ec70e5357a375f2a3e48b1529"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9ff41c34b99b7c129d9c8bdbf6acae9166bd15fa",
          "sha": "9ff41c34b99b7c129d9c8bdbf6acae9166bd15fa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9ff41c34b99b7c129d9c8bdbf6acae9166bd15fa"
        }
      ],
      "message": "fuzz: remove comparison between mini_miner block construction and miner\n\nThis is in preparation for eliminating the block template building happening in\nmini_miner, in favor of directly using the linearizations done in the mempool.",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2024-04-28T11:34:48Z"
      },
      "sha": "97e03bec4641b137dc45c754eade95070bb47187"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMwMjQzMzc1MTMyMjI0NjhhZmM3YWU3NjEwOTdhNmI4NjUzZjRmOTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3024337513222468afc7ae761097a6b8653f4f93",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3024337513222468afc7ae761097a6b8653f4f93",
      "tree": {
        "sha": "b112ddc2333eef5a084a579ad4876c74e984a4a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b112ddc2333eef5a084a579ad4876c74e984a4a6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97e03bec4641b137dc45c754eade95070bb47187",
          "sha": "97e03bec4641b137dc45c754eade95070bb47187",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/97e03bec4641b137dc45c754eade95070bb47187"
        }
      ],
      "message": "Invoke TxGraph::DoWork() at appropriate times",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-07-29T20:16:18Z"
      },
      "sha": "3024337513222468afc7ae761097a6b8653f4f93"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNhNWM5NmQ3MjgyMWVjYzY1Y2E5NDgxZTEwN2IwMmY3NzZmM2ExZjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca5c96d72821ecc65ca9481e107b02f776f3a1f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ca5c96d72821ecc65ca9481e107b02f776f3a1f3",
      "tree": {
        "sha": "6efc83502179e6cbb256bc224b3981aa78a5bf3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6efc83502179e6cbb256bc224b3981aa78a5bf3d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3024337513222468afc7ae761097a6b8653f4f93",
          "sha": "3024337513222468afc7ae761097a6b8653f4f93",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3024337513222468afc7ae761097a6b8653f4f93"
        }
      ],
      "message": "Update comments for CTxMemPool class",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-09-02T23:01:10Z"
      },
      "sha": "ca5c96d72821ecc65ca9481e107b02f776f3a1f3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDYzNjJiZjhlMjNkY2IyNTI3MzYxNWQyOTdhZDc0ZmVmZGM4OWQxYTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6362bf8e23dcb25273615d297ad74fefdc89d1a5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6362bf8e23dcb25273615d297ad74fefdc89d1a5",
      "tree": {
        "sha": "47b2663783a3ae3af92aa41f6385b431b1de84c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47b2663783a3ae3af92aa41f6385b431b1de84c4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca5c96d72821ecc65ca9481e107b02f776f3a1f3",
          "sha": "ca5c96d72821ecc65ca9481e107b02f776f3a1f3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ca5c96d72821ecc65ca9481e107b02f776f3a1f3"
        }
      ],
      "message": "Add check that GetSortedScoreWithTopology() agrees with CompareMiningScoreWithTopology()\n\nWe use CompareMiningScoreWithTopology() for sorting transaction announcements\nduring tx relay, and we use GetSortedScoreWithTopology() in\nCTxMemPool::check().",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-09-17T17:26:45Z"
      },
      "sha": "6362bf8e23dcb25273615d297ad74fefdc89d1a5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM2Yzk0ZDI1NjljNGM0OTNhMjJhMzdjZmY1MzBkYjk2MWQ3MmM2ZmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36c94d2569c4c493a22a37cff530db961d72c6ff",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/36c94d2569c4c493a22a37cff530db961d72c6ff",
      "tree": {
        "sha": "ccd4ecda84e4bd252caae5751fcffa664637cff2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ccd4ecda84e4bd252caae5751fcffa664637cff2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6362bf8e23dcb25273615d297ad74fefdc89d1a5",
          "sha": "6362bf8e23dcb25273615d297ad74fefdc89d1a5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6362bf8e23dcb25273615d297ad74fefdc89d1a5"
        }
      ],
      "message": "doc: update policy/packages.md for new package acceptance logic",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-19T14:31:52Z"
      },
      "sha": "36c94d2569c4c493a22a37cff530db961d72c6ff"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI0MWQ5MDk2ZTkzMzZiMjk4ZTJiNjVjMzdkOGUwY2UwODQ2YjQ2MDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/241d9096e9336b298e2b65c37d8e0ce0846b4603",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/241d9096e9336b298e2b65c37d8e0ce0846b4603",
      "tree": {
        "sha": "8fa7098146bf55a64a0b3f09dec07ed14479a0b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8fa7098146bf55a64a0b3f09dec07ed14479a0b8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/36c94d2569c4c493a22a37cff530db961d72c6ff",
          "sha": "36c94d2569c4c493a22a37cff530db961d72c6ff",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/36c94d2569c4c493a22a37cff530db961d72c6ff"
        }
      ],
      "message": "test: extend package rbf functional test to larger clusters\n\nCo-Authored-By: Gregory Sanders <gsanders87@gmail.com>",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-30T11:58:33Z"
      },
      "sha": "241d9096e9336b298e2b65c37d8e0ce0846b4603"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAyYWM0YTFlN2MzMGU4Y2YxYTg2MmVjMWUyZGRhYjU1MjczYzJkNjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "tree": {
        "sha": "caf5d726ea1db984d033280fea603a9add7d47c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/caf5d726ea1db984d033280fea603a9add7d47c9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/241d9096e9336b298e2b65c37d8e0ce0846b4603",
          "sha": "241d9096e9336b298e2b65c37d8e0ce0846b4603",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/241d9096e9336b298e2b65c37d8e0ce0846b4603"
        }
      ],
      "message": "Sanity check `GetFeerateDiagram()` in CTxMemPool::check()",
      "committer": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-11-01T17:45:01Z"
      },
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2025-10-30T17:48:46Z"
      },
      "sha": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20653391405,
      "node_id": "HRFPE_lADOABII587RhpYCzwAAAATPCb4t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20653391405",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "commit_url": "https://api.github.com/repos/sdaftuar/bitcoin/commits/02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "created_at": "2025-11-01T17:57:15Z"
    },
    {
      "event": "commented",
      "id": 3476628311,
      "node_id": "IC_kwDOABII587POSNX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3476628311",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-01T17:59:39Z",
      "updated_at": "2025-11-01T17:59:39Z",
      "author_association": "MEMBER",
      "body": "Implemented a fix for the locking issue in 51d213d1449b61665628ce9b4e0209cff3c4f818.  Left it unsquashed for easier review; if this approach seems ok I'll squash it with the prior commit.\r\n\r\nFYI for reviewers: the insertion of the `AssertLockHeld()` in txmempool.h in that commit is what made the bug easy to reproduce in our tests (using a debug build).",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#issuecomment-3476628311",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629"
    },
    {
      "event": "commented",
      "id": 3486049487,
      "node_id": "IC_kwDOABII587PyOTP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3486049487",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-04T13:37:35Z",
      "updated_at": "2025-11-04T13:37:35Z",
      "author_association": "MEMBER",
      "body": "https://github.com/bitcoin/bitcoin/commit/51d213d1449b61665628ce9b4e0209cff3c4f818#r169601405 left a comment in the non-PR review mode, just making sure it gets noticed",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#issuecomment-3486049487",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629"
    },
    {
      "event": "commented",
      "id": 3499901560,
      "node_id": "IC_kwDOABII587QnEJ4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3499901560",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-07T00:04:01Z",
      "updated_at": "2025-11-10T14:24:58Z",
      "author_association": "MEMBER",
      "body": "> it looks like in AcceptSingleTransaction() we acquire the lock and release it before the MemPoolAccept object is destroyed, causing a change to txgraph (when the changeset is destroyed) while the lock is not held. Will fix.\r\n\r\n> Implemented a fix for the locking issue in https://github.com/bitcoin/bitcoin/commit/51d213d1449b61665628ce9b4e0209cff3c4f818.\r\n\r\nIIUC we need to ensure we dont release the mempool lock until after the changeset (i.e. SubPackageState) is destroyed.\r\n\r\nThe approach in 51d213d1449b61665628ce9b4e0209cff3c4f818 is to introduce wrappers that grab locks and do cleanup. Makes sense to me \r\n\r\n<details><summary>(EDIT: can just be in a followup)</summary>\r\nbut I think we can just use the existing wrapper, `AcceptSubPackage`? https://github.com/glozow/bitcoin/tree/2025-10-mempoolaccept-layers\r\n\r\nIt gives us these layers of `MemPoolAccept` functions:\r\n- 1 narrow public-facing interface for validating any number of transactions, `AcceptPackage`. It handles subpackaging and dispatches to the other functions.\r\n    - On master, this function is already able to handle a package of size 1.\r\n    - This is the only function that acquires any locks; everything below needs to already have it held.\r\n- The `AcceptSubPackage` wrapper, which handles cleaning up `SubPackageState`. It requires locks to already be held. Everything goes through this wrapper to be submitted.\r\n- `AcceptSingleTransaction` and `AcceptMultipleTransactions`, which each run a set of comprehensive checks for their respective categories. Sometimes they are given \"subpackages\" of a larger package, so they can be using a dirty `m_view`. However, they can expect a clean `SubPackageState`.\r\n- The internal helpers that apply some subset of validation rules: `PreChecks`, `ReplacementChecks`, `PackageMempoolChecks`, *ScriptChecks`, and the submission helpers`FinalizeSubpackage` and `SubmitPackage`. They usually work on `Workspace`s and `SubPackageState`s that have been modified by each other.\r\n\r\nIt also consolidates the public interface. There are currently 3 ways to use `MemPoolAccept`:\r\n(1) Single tx, test_accept or not\r\n(2) Multi-tx test_accept\r\n(3) Package, not test_accept, restricted to child-with-parents package\r\n\r\n(3) also accepts packages of size 1, but the api is slightly different and should be made consistent. (2) and (3) are separate right now because they have different requirements and results (we can't just reuse it with `test_accept=true`). But after cluster mempool, we can unify them by improving the subchunking in `AcceptPackage`. TLDR I think they should all route through 1 function.\r\n</details>",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#issuecomment-3499901560",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629"
    },
    {
      "event": "commented",
      "id": 3506898619,
      "node_id": "IC_kwDOABII587RBwa7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3506898619",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-08T20:59:42Z",
      "updated_at": "2025-11-08T20:59:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "> FYI for reviewers: the insertion of the `AssertLockHeld()` in txmempool.h in that commit is what made the bug easy to reproduce in our tests (using a debug build).\r\n\r\nAIUI, constructors and destructors ignore lock annotations `~ChangeSet() EXCLUSIVE_LOCKS_REQUIRED(m_pool->cs) { AssertLockHeld(m_pool->cs);` -- so a runtime assertion makes sense. (Short of changing the thread safety model entirely, I guess)",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#issuecomment-3506898619",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33629"
    },
    {
      "event": "reviewed",
      "id": 3443855926,
      "node_id": "PRR_kwDOABII587NRRI2",
      "url": null,
      "actor": null,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-10T19:41:23Z",
      "author_association": "MEMBER",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#pullrequestreview-3443855926",
      "submitted_at": "2025-11-10T19:41:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432032703",
      "pull_request_review_id": 3339641710,
      "id": 2432032703,
      "node_id": "PRRC_kwDOABII586Q9d-_",
      "diff_hunk": "@@ -188,4 +189,8 @@ static inline int64_t GetVirtualTransactionInputSize(const CTxIn& tx)\n     return GetVirtualTransactionInputSize(tx, 0, 0);\n }\n \n+int64_t GetSigOpsAdjustedWeight(int64_t nWeight, int64_t nSigOpCost, unsigned int bytes_per_sigop);",
      "path": "src/policy/policy.h",
      "position": 1,
      "original_position": 12,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "f2eff17c6c4fc945f6fd761564212802107a1d7d",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Add sigops adjusted weight calculator\" f2eff17c6c4fc945f6fd761564212802107a1d7d\r\n\r\nnit: use snake case.",
      "created_at": "2025-10-15T10:27:58Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432032703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432032703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432258434",
      "pull_request_review_id": 3339641710,
      "id": 2432258434,
      "node_id": "PRRC_kwDOABII586Q-VGC",
      "diff_hunk": "@@ -641,6 +641,8 @@ void SetupServerArgs(ArgsManager& argsman, bool can_listen_ipc)\n     argsman.AddArg(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-test=<option>\", \"Pass a test-only option. Options include : \" + Join(TEST_OPTIONS_DOC, \", \") + \".\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustercount=<n>\", strprintf(\"Do not accept transactions connected to <n> or more existing in-mempool transactions (default: %u, maximum: %u)\", DEFAULT_CLUSTER_LIMIT, MAX_CLUSTER_COUNT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustersize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool connected transactions exceeds <n> kilobytes (default: %u)\", DEFAULT_CLUSTER_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);",
      "path": "src/init.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "2801e80528a3a1c2949a8fda6338882613a673e5",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Add new (unused) limits for cluster size/count\" 2801e80528a3a1c2949a8fda6338882613a673e5\r\n\r\n\r\nnit: be specific it is in virtual size\r\n```suggestion\r\n    argsman.AddArg(\"-limitclustersize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool connected transactions exceeds <n> virtual kilobytes (default: %u)\", DEFAULT_CLUSTER_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\r\n\r\n```",
      "created_at": "2025-10-15T11:47:06Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432258434",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432258434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 645,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432321152",
      "pull_request_review_id": 3339641710,
      "id": 2432321152,
      "node_id": "PRRC_kwDOABII586Q-kaA",
      "diff_hunk": "@@ -21,6 +21,8 @@\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n \n MAX_REPLACEMENT_LIMIT = 100\n+MAX_CLUSTER_LIMIT = 64",
      "path": "test/functional/feature_rbf.py",
      "position": 1,
      "original_position": 4,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "429bdbecfde93c54374fb3098e357e18556e7e21",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"test: update feature_rbf.py replacement test\"  429bdbecfde93c54374fb3098e357e18556e7e21\r\n\r\nnit: This should live in `functional/test_framework/mempool_util.py`",
      "created_at": "2025-10-15T12:10:57Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432321152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432321152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432430377",
      "pull_request_review_id": 3339641710,
      "id": 2432430377,
      "node_id": "PRRC_kwDOABII586Q-_Ep",
      "diff_hunk": "@@ -220,7 +220,7 @@ def test_chainlimits_exceeded(self):\n \n     def run_test(self):\n         # Mine in batches of 25 to test multi-block reorg under chain limits\n-        self.transaction_graph_test(size=CUSTOM_ANCESTOR_COUNT, n_tx_to_mine=[25, 50, 75])\n+        self.transaction_graph_test(size=64, n_tx_to_mine=[25, 50, 75])",
      "path": "test/functional/mempool_updatefromblock.py",
      "position": 1,
      "original_position": 28,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Do not allow mempool clusters to exceed configured limits\" 5a388c0d595b2318fea4b1dce977e2d5ff1abc48\r\n\r\nIf you define the max cluster count in mempool util it can be reused here.",
      "created_at": "2025-10-15T12:47:27Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432430377",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432430377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432516613",
      "pull_request_review_id": 3339641710,
      "id": 2432516613,
      "node_id": "PRRC_kwDOABII586Q_UIF",
      "diff_hunk": "@@ -547,7 +547,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n         AddToMempool(pool, entry.Fee(100LL).FromTx(tx5));\n     AddToMempool(pool, entry.Fee(900LL).FromTx(tx7));\n \n-    pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7\n+    pool.TrimToSize(pool.DynamicMemoryUsage() * 0.75); // should maximize mempool size by only removing 5/7",
      "path": "src/test/mempool_tests.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Do not allow mempool clusters to exceed configured limits\" 5a388c0d595b2318fea4b1dce977e2d5ff1abc48\r\n\r\nI try to not use the magic number by trimming using\r\n\r\n`pool.DynamicMemoryUsage() - usage_of_5 - usage_of_7` but test fail because tx 6 is also evicted.\r\nHowever when I subtract only the usage of 5 the test succeed.\r\n\r\nI grab the usages by computing the delta in memory usage after insertion of the tx.\r\n\r\n\r\n",
      "created_at": "2025-10-15T13:12:35Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432516613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432516613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 550,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432642810",
      "pull_request_review_id": 3340512731,
      "id": 2432642810,
      "node_id": "PRRC_kwDOABII586Q_y76",
      "diff_hunk": "@@ -59,8 +59,8 @@ class LOCKABLE Epoch\n     public:\n         Marker() = default;\n         Marker(const Marker&) = default;\n-        Marker(Marker&&) = delete;\n-        Marker& operator=(Marker&&) = delete;\n+        Marker(Marker&&) = default;",
      "path": "src/util/epochguard.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "51430680ecb722e1d4ee4a26dac5724050f41c9e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "51430680ecb722e1d4ee4a26dac5724050f41c9e\r\n\r\nThe why of this is unclear to me through 8cdd7bb11adeaeb4709c670bef4b57362cfbebcb , worth reordering or expanding commit message?",
      "created_at": "2025-10-15T13:48:33Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432642810",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432642810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 62,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432661442",
      "pull_request_review_id": 3339641710,
      "id": 2432661442,
      "node_id": "PRRC_kwDOABII586Q_3fC",
      "diff_hunk": "@@ -719,10 +719,16 @@ class ChainImpl : public Chain\n     util::Result<void> checkChainLimits(const CTransactionRef& tx) override\n     {\n         if (!m_node.mempool) return {};\n-        LockPoints lp;\n-        CTxMemPoolEntry entry(TxGraph::Ref(), tx, 0, 0, 0, 0, false, 0, lp);\n         LOCK(m_node.mempool->cs);\n-        return m_node.mempool->CheckPackageLimits({tx}, entry.GetTxSize());\n+        // Use CTxMemPool's ChangeSet interface to check whether the chain\n+        // limits would be violated. Note that the changeset will be destroyed\n+        // when it goes out of scope.\n+        auto changeset = m_node.mempool->GetChangeSet();",
      "path": "src/node/interfaces.cpp",
      "position": 68,
      "original_position": 11,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1102ac7f74ac2f48760b46be58c7deb70fa727cf",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Check cluster limits when using -walletrejectlongchains\"  1102ac7f74ac2f48760b46be58c7deb70fa727cf\r\n\r\nnit: also state that it should be safe to create a new change set here because we lock mempool cs.  ",
      "created_at": "2025-10-15T13:53:44Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432661442",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432661442"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 723,
      "original_line": 723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432836478",
      "pull_request_review_id": 3340512731,
      "id": 2432836478,
      "node_id": "PRRC_kwDOABII586RAiN-",
      "diff_hunk": "@@ -137,12 +137,11 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToU\n         {",
      "path": "src/txmempool.cpp",
      "position": 110,
      "original_position": 1,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "6c73e4744837a7dc138a9177df3a48f30a1ba6c1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "6c73e4744837a7dc138a9177df3a48f30a1ba6c1\r\n\r\nHad to double-check the claim on space usage, seems to hold\r\n\r\nhttps://www.boost.org/doc/libs/1_73_0/libs/multi_index/doc/performance.html#:~:text=On%20the%20other%20hand%2C%20the,N%2D1)p%2C%20where",
      "created_at": "2025-10-15T14:39:31Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2432836478",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2432836478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433318113",
      "pull_request_review_id": 3340512731,
      "id": 2433318113,
      "node_id": "PRRC_kwDOABII586RCXzh",
      "diff_hunk": "@@ -1604,6 +1611,12 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n         return PackageMempoolAcceptResult(package_state, std::move(results));\n     }\n \n+    // Check if the transaction would exceed the cluster size limit.",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 46,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48\r\n\r\n```Suggestion\r\n    // Check if the transactions would exceed the cluster size limit.\r\n```",
      "created_at": "2025-10-15T16:47:41Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433318113",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433318113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1614,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433669609",
      "pull_request_review_id": 3341892072,
      "id": 2433669609,
      "node_id": "PRRC_kwDOABII586RDtnp",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_raises_rpc_error,\n+)\n+\n+MAX_CLUSTER_COUNT = 64\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n+\n+        node = self.nodes[0]\n+        parent_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        ancestors = [parent_tx[\"txid\"]]\n+        while len(node.getrawmempool()) < MAX_CLUSTER_COUNT:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert node.getmempoolcluster(next_tx['txid']) == node.getmempoolcluster(parent_tx['txid'])\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert sorted(mempool_ancestors) == sorted(ancestors)\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in ancestors ])\n+\n+            # Update for next iteration\n+            ancestors.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == MAX_CLUSTER_COUNT\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            assert last_val[0]*x['fee'] >= last_val[1]*x['vsize']\n+            last_val = [x['vsize'], x['fee']]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_spend)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # TODO: verify that the size limits are also enforced.\n+        # TODO: add tests that exercise rbf, package submission, and package\n+        # rbf and verify that cluster limits are enforced.",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 59,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Wrote up some tests for cluster count and size limits in RBFs, package RBFs, package submission, at different configs of `-limitclustercount` and `-limitclustersize`, etc:\r\n\r\n<details>\r\n\r\n\r\n```diff\r\ndiff --git a/test/functional/mempool_cluster.py b/test/functional/mempool_cluster.py\r\nindex 3da8b477a2f..c75eb22bf9b 100755\r\n--- a/test/functional/mempool_cluster.py\r\n+++ b/test/functional/mempool_cluster.py\r\n@@ -4,59 +4,322 @@\r\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \"\"\"Test cluster mempool accessors and limits\"\"\"\r\n \r\n+from decimal import Decimal\r\n+\r\n+from test_framework.mempool_util import (\r\n+    DEFAULT_CLUSTER_LIMIT,\r\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\r\n+)\r\n+from test_framework.messages import (\r\n+    COIN,\r\n+)\r\n from test_framework.test_framework import BitcoinTestFramework\r\n from test_framework.wallet import (\r\n     MiniWallet,\r\n )\r\n from test_framework.util import (\r\n+    assert_equal,\r\n+    assert_greater_than,\r\n+    assert_greater_than_or_equal,\r\n     assert_raises_rpc_error,\r\n )\r\n \r\n-MAX_CLUSTER_COUNT = 64\r\n+def cleanup(func):\r\n+    def wrapper(self, *args, **kwargs):\r\n+        try:\r\n+            func(self, *args, **kwargs)\r\n+        finally:\r\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\r\n+            while (len(self.nodes[0].getrawmempool()) > 0):\r\n+                self.generate(self.nodes[0], 1)\r\n+            self.wallet.rescan_utxos(include_mempool=True)\r\n+    return wrapper\r\n \r\n class MempoolClusterTest(BitcoinTestFramework):\r\n     def set_test_params(self):\r\n         self.num_nodes = 1\r\n \r\n-    def run_test(self):\r\n-        node = self.nodes[0]\r\n-        self.wallet = MiniWallet(node)\r\n-\r\n-        node = self.nodes[0]\r\n-        parent_tx = self.wallet.send_self_transfer(from_node=node)\r\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\r\n+        \"\"\"Create a cluster of transactions, with the count specified.\r\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\r\n+        Optionally provide a target_vsize for each transaction.\r\n+        \"\"\"\r\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\r\n         utxo_to_spend = parent_tx[\"new_utxo\"]\r\n-        ancestors = [parent_tx[\"txid\"]]\r\n-        while len(node.getrawmempool()) < MAX_CLUSTER_COUNT:\r\n-            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)\r\n+        all_txids = [parent_tx[\"txid\"]]\r\n+        all_results = [parent_tx]\r\n+\r\n+        while len(all_results) < cluster_count:\r\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\r\n+            assert next_tx[\"txid\"] in node.getrawmempool()\r\n+\r\n             # Confirm that each transaction is in the same cluster as the first.\r\n-            assert node.getmempoolcluster(next_tx['txid']) == node.getmempoolcluster(parent_tx['txid'])\r\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\r\n \r\n             # Confirm that the ancestors are what we expect\r\n             mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\r\n-            assert sorted(mempool_ancestors) == sorted(ancestors)\r\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\r\n \r\n             # Confirm that each successive transaction is added as a descendant.\r\n-            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in ancestors ])\r\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\r\n \r\n             # Update for next iteration\r\n-            ancestors.append(next_tx[\"txid\"])\r\n+            all_results.append(next_tx)\r\n+            all_txids.append(next_tx[\"txid\"])\r\n             utxo_to_spend = next_tx[\"new_utxo\"]\r\n \r\n-        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == MAX_CLUSTER_COUNT\r\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\r\n+        return all_results\r\n+\r\n+    def check_feerate_diagram(self, node):\r\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\r\n         feeratediagram = node.getmempoolfeeratediagram()\r\n         last_val = [0, 0]\r\n         for x in feeratediagram:\r\n+            # The vsize is always positive, except for the first iteration\r\n             assert x['vsize'] > 0 or x['fee'] == 0\r\n-            assert last_val[0]*x['fee'] >= last_val[1]*x['vsize']\r\n+            # Monotonically decreasing fee per vsize\r\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])\r\n             last_val = [x['vsize'], x['fee']]\r\n \r\n+    def test_limit_enforcement(self, cluster_submitted, target_vsize_per_tx=None):\r\n+        \"\"\"\r\n+        the cluster may change as a result of these transactions, so cluster_submitted is mutated accordingly\r\n+        \"\"\"\r\n+        # Cluster has already been submitted and has at least 3 transactions, otherwise this test won't work.\r\n+        assert_greater_than_or_equal(len(cluster_submitted), 3)\r\n+        node = self.nodes[0]\r\n+        last_result = cluster_submitted[-1]\r\n+        # We assume that this is the maximum cluster count\r\n+        cluster_limit = node.getmempoolcluster(cluster_submitted[-1][\"txid\"])['txcount']\r\n+\r\n         # Test that adding one more transaction to the cluster will fail.\r\n-        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_spend)\r\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=last_result[\"new_utxo\"], target_vsize=target_vsize_per_tx)\r\n         assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\r\n \r\n-        # TODO: verify that the size limits are also enforced.\r\n-        # TODO: add tests that exercise rbf, package submission, and package\r\n-        # rbf and verify that cluster limits are enforced.\r\n+        # It should also work during replacement\r\n+        utxo_to_double_spend = self.wallet.get_utxo(confirmed_only=True)\r\n+        fee = Decimal(\"0.000001\")\r\n+        tx_to_replace = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_double_spend, fee=fee)\r\n+        node.sendrawtransaction(tx_to_replace[\"hex\"])\r\n+\r\n+        # Multiply fee by 5, which should easily cover the cost to replace. Otherwise, use the target vsize at 10sat/vB\r\n+        fee_to_use = target_vsize_per_tx * 10 if target_vsize_per_tx is not None else int(fee * COIN * 5)\r\n+        bad_tx_also_replacement = self.wallet.create_self_transfer_multi(\r\n+            utxos_to_spend=[last_result[\"new_utxo\"], utxo_to_double_spend],\r\n+            target_vsize=target_vsize_per_tx,\r\n+            fee_per_output=fee_to_use,\r\n+        )\r\n+        assert_raises_rpc_error(-26, \"replacement-failed\", node.sendrawtransaction, bad_tx_also_replacement[\"hex\"])\r\n+\r\n+        # Replace the last transaction. We are extending the cluster by one, but also removing one: 64 + 1 - 1 = 64\r\n+        # In the case of vsize, it should similarly cancel out.\r\n+        second_to_last_utxo = cluster_submitted[-2][\"new_utxo\"]\r\n+        fee_to_beat = cluster_submitted[-1][\"fee\"]\r\n+        vsize_to_use = cluster_submitted[-1][\"tx\"].get_vsize() if target_vsize_per_tx is not None else None\r\n+        good_tx_replacement = self.wallet.create_self_transfer(utxo_to_spend=second_to_last_utxo, fee=fee_to_beat * 5, target_vsize=vsize_to_use)\r\n+        node.sendrawtransaction(good_tx_replacement[\"hex\"], maxfeerate=0)\r\n+\r\n+        cluster_submitted[-1] = good_tx_replacement\r\n+\r\n+    def test_limit_enforcement_package(self, cluster_submitted):\r\n+        node = self.nodes[0]\r\n+        # Create a package from the second to last transaction. This shouldn't work because the effect is 64 + 2 - 1 = 65\r\n+        last_utxo = cluster_submitted[-2][\"new_utxo\"]\r\n+        fee_to_beat = cluster_submitted[-1][\"fee\"]\r\n+        # We do not use package RBF here because it has additional restrictions on mempool ancestors.\r\n+        parent_tx_bad = self.wallet.create_self_transfer(utxo_to_spend=last_utxo, fee=fee_to_beat * 5)\r\n+        child_tx_bad = self.wallet.create_self_transfer(utxo_to_spend=parent_tx_bad[\"new_utxo\"])\r\n+        package_result = node.submitpackage([parent_tx_bad[\"hex\"], child_tx_bad[\"hex\"]], maxfeerate=0)\r\n+        # The parent should be submitted, but the child rejected.\r\n+        result_parent_only = node.submitpackage([parent_tx_bad[\"hex\"], child_tx_bad[\"hex\"]])\r\n+\r\n+        assert parent_tx_bad[\"txid\"] in node.getrawmempool()\r\n+        assert child_tx_bad[\"txid\"] not in node.getrawmempool()\r\n+        assert_equal(result_parent_only[\"package_msg\"], \"transaction failed\")\r\n+        assert_equal(result_parent_only[\"tx-results\"][child_tx_bad[\"wtxid\"]][\"error\"], \"too-large-cluster\")\r\n+\r\n+        # Now, create a package from the second to last transaction. This should work because the effect is 64 + 2 - 2 = 64\r\n+        third_to_last_utxo = cluster_submitted[-3][\"new_utxo\"]\r\n+        parent_tx_good = self.wallet.create_self_transfer(utxo_to_spend=third_to_last_utxo)\r\n+        child_tx_good = self.wallet.create_self_transfer(utxo_to_spend=parent_tx_good[\"new_utxo\"], fee=fee_to_beat * 5)\r\n+        result_both_good = node.submitpackage([parent_tx_good[\"hex\"], child_tx_good[\"hex\"]], maxfeerate=0)\r\n+        assert_equal(result_both_good[\"package_msg\"], \"success\")\r\n+        assert parent_tx_good[\"txid\"] in node.getrawmempool()\r\n+        assert child_tx_good[\"txid\"] in node.getrawmempool()\r\n+\r\n+    @cleanup\r\n+    def test_cluster_count_limit(self, max_cluster_count):\r\n+        node = self.nodes[0]\r\n+        cluster_submitted = self.add_chain_cluster(node, max_cluster_count)\r\n+        self.check_feerate_diagram(node)\r\n+        for result in cluster_submitted:\r\n+            assert_equal(node.getmempoolcluster(result[\"txid\"])['txcount'], max_cluster_count)\r\n+\r\n+        self.log.info(\"Test that cluster count limit is enforced\")\r\n+        self.test_limit_enforcement(cluster_submitted)\r\n+        self.log.info(\"Test that the resulting cluster count is correctly calculated in a package\")\r\n+        self.test_limit_enforcement_package(cluster_submitted)\r\n+\r\n+    @cleanup\r\n+    def test_cluster_size_limit(self, max_cluster_size_vbytes):\r\n+        node = self.nodes[0]\r\n+        # This number should be smaller than the cluster count limit.\r\n+        num_txns = 10\r\n+        # Leave some buffer so it is possible to add a reasonably-sized transaction.\r\n+        target_vsize_per_tx = int((max_cluster_size_vbytes - 500) / num_txns)\r\n+        cluster_submitted = self.add_chain_cluster(node, num_txns, target_vsize_per_tx)\r\n+\r\n+        vsize_remaining = max_cluster_size_vbytes - node.getmempoolcluster(cluster_submitted[0][\"txid\"])['vsize']\r\n+        self.log.info(\"Test that cluster size limit is enforced\")\r\n+        self.test_limit_enforcement(cluster_submitted, target_vsize_per_tx=vsize_remaining + 4)\r\n+\r\n+        # Try another cluster and add a small transaction: it should succeed\r\n+        last_result = cluster_submitted[-1]\r\n+        small_tx = self.wallet.create_self_transfer(utxo_to_spend=last_result[\"new_utxo\"], target_vsize=vsize_remaining)\r\n+        node.sendrawtransaction(small_tx[\"hex\"])\r\n+\r\n+    @cleanup\r\n+    def test_cluster_merging(self, max_cluster_count):\r\n+        node = self.nodes[0]\r\n+\r\n+        self.log.info(f\"Test merging 2 clusters with transaction counts totaling {max_cluster_count}\")\r\n+        for num_txns_cluster1 in [1, 5, 10]:\r\n+            # Create a chain of transactions\r\n+            cluster1 = self.add_chain_cluster(node, num_txns_cluster1)\r\n+            for result in cluster1:\r\n+                node.sendrawtransaction(result[\"hex\"])\r\n+            utxo_from_cluster1 = cluster1[-1][\"new_utxo\"]\r\n+\r\n+            # Make the next cluster, which contains the remaining transactions\r\n+            assert_greater_than(max_cluster_count, num_txns_cluster1)\r\n+            num_txns_cluster2 = max_cluster_count - num_txns_cluster1\r\n+            cluster2 = self.add_chain_cluster(node, num_txns_cluster2)\r\n+            for result in cluster2:\r\n+                node.sendrawtransaction(result[\"hex\"])\r\n+            utxo_from_cluster2 = cluster2[-1][\"new_utxo\"]\r\n+\r\n+            # Now create a transaction that spends from both clusters, which would merge them.\r\n+            tx_merger = self.wallet.create_self_transfer_multi(utxos_to_spend=[utxo_from_cluster1, utxo_from_cluster2])\r\n+            assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, tx_merger[\"hex\"])\r\n+\r\n+            # Spending from the clusters independently should work\r\n+            tx_spending_cluster1 = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_from_cluster1)\r\n+            tx_spending_cluster2 = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_from_cluster2)\r\n+            assert tx_spending_cluster1[\"txid\"] in node.getrawmempool()\r\n+            assert tx_spending_cluster2[\"txid\"] in node.getrawmempool()\r\n+\r\n+        self.log.info(f\"Test merging {max_cluster_count} clusters with 1 transaction spending from all of them\")\r\n+        utxos_to_merge = []\r\n+        for _ in range(max_cluster_count):\r\n+            # Use a confirmed utxo to ensure distinct clusters\r\n+            confirmed_utxo = self.wallet.get_utxo(confirmed_only=True)\r\n+            singleton = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=confirmed_utxo)\r\n+            assert singleton[\"txid\"] in node.getrawmempool()\r\n+            utxos_to_merge.append(singleton[\"new_utxo\"])\r\n+\r\n+        assert_equal(len(utxos_to_merge), max_cluster_count)\r\n+        tx_merger = self.wallet.create_self_transfer_multi(utxos_to_spend=utxos_to_merge)\r\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, tx_merger[\"hex\"])\r\n+\r\n+        # Spending from 1 fewer cluster should work\r\n+        tx_merger_all_but_one = self.wallet.create_self_transfer_multi(utxos_to_spend=utxos_to_merge[:-1])\r\n+        node.sendrawtransaction(tx_merger_all_but_one[\"hex\"])\r\n+        assert tx_merger_all_but_one[\"txid\"] in node.getrawmempool()\r\n+\r\n+    @cleanup\r\n+    def test_cluster_merging_size(self, max_cluster_size_vbytes):\r\n+        node = self.nodes[0]\r\n+\r\n+        self.log.info(f\"Test merging clusters with sizes totaling {max_cluster_size_vbytes} vB\")\r\n+        num_txns = 10\r\n+        # Leave some buffer so it is possible to add a reasonably-sized transaction.\r\n+        target_vsize_per_tx = int((max_cluster_size_vbytes - 500) / num_txns)\r\n+        utxos_to_merge = []\r\n+        vsize_remaining = max_cluster_size_vbytes\r\n+        for _ in range(num_txns):\r\n+            confirmed_utxo = self.wallet.get_utxo(confirmed_only=True)\r\n+            singleton = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=confirmed_utxo)\r\n+            assert singleton[\"txid\"] in node.getrawmempool()\r\n+            utxos_to_merge.append(singleton[\"new_utxo\"])\r\n+            vsize_remaining -= singleton[\"tx\"].get_vsize()\r\n+\r\n+        assert_greater_than_or_equal(vsize_remaining, 500)\r\n+\r\n+        # Create a transaction spending from all clusters that exceeds the cluster size limit.\r\n+        tx_merger_too_big = self.wallet.create_self_transfer_multi(utxos_to_spend=utxos_to_merge, target_vsize=vsize_remaining + 4, fee_per_output=10000)\r\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, tx_merger_too_big[\"hex\"])\r\n+\r\n+        # A transaction that is slightly smaller should work.\r\n+        tx_merger_small = self.wallet.create_self_transfer_multi(utxos_to_spend=utxos_to_merge[:-1], target_vsize=vsize_remaining - 4, fee_per_output=10000)\r\n+        node.sendrawtransaction(tx_merger_small[\"hex\"])\r\n+        assert tx_merger_small[\"txid\"] in node.getrawmempool()\r\n+\r\n+    @cleanup\r\n+    def test_cluster_limit_rbf(self, max_cluster_count):\r\n+        node = self.nodes[0]\r\n+\r\n+        # Use min feerate for the to-be-replaced transactions. There are many, so replacement cost can be expensive.\r\n+        min_feerate = node.getmempoolinfo()[\"mempoolminfee\"]\r\n+\r\n+        self.log.info(\"Test that cluster size calculation takes RBF into account\")\r\n+        utxos_created_by_parents = []\r\n+        fees_rbf_sats = 0\r\n+        for _ in range(max_cluster_count - 1):\r\n+            parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True)\r\n+            utxo_to_replace = parent_tx[\"new_utxo\"]\r\n+            child_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_replace, fee_rate=min_feerate)\r\n+\r\n+            fees_rbf_sats += int(child_tx[\"fee\"] * COIN)\r\n+            utxos_created_by_parents.append(utxo_to_replace)\r\n+\r\n+        # This transaction would create a cluster of size max_cluster_count\r\n+        # Importantly, the node should account for the fact that half of the transactions will be replaced.\r\n+        tx_merger_replacer = self.wallet.create_self_transfer_multi(utxos_to_spend=utxos_created_by_parents, fee_per_output=fees_rbf_sats * 2)\r\n+        node.sendrawtransaction(tx_merger_replacer[\"hex\"])\r\n+        assert tx_merger_replacer[\"txid\"] in node.getrawmempool()\r\n+        assert_equal(node.getmempoolcluster(tx_merger_replacer[\"txid\"])['txcount'], max_cluster_count)\r\n+\r\n+        self.log.info(\"Test that cluster size calculation takes package RBF into account\")\r\n+        utxos_to_replace = []\r\n+        fee_rbf_decimal = 0\r\n+        for _ in range(max_cluster_count):\r\n+            confirmed_utxo = self.wallet.get_utxo(confirmed_only=True)\r\n+            tx_to_replace = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=confirmed_utxo, fee_rate=min_feerate)\r\n+            fee_rbf_decimal += tx_to_replace[\"fee\"]\r\n+            utxos_to_replace.append(confirmed_utxo)\r\n+\r\n+        tx_replacer = self.wallet.create_self_transfer_multi(utxos_to_spend=utxos_to_replace)\r\n+        tx_replacer_sponsor = self.wallet.create_self_transfer(utxo_to_spend=tx_replacer[\"new_utxos\"][0], fee=fee_rbf_decimal * 2)\r\n+        node.submitpackage([tx_replacer[\"hex\"], tx_replacer_sponsor[\"hex\"]], maxfeerate=0)\r\n+        assert tx_replacer[\"txid\"] in node.getrawmempool()\r\n+        assert tx_replacer_sponsor[\"txid\"] in node.getrawmempool()\r\n+        assert_equal(node.getmempoolcluster(tx_replacer[\"txid\"])['txcount'], 2)\r\n+\r\n+\r\n+    def run_test(self):\r\n+        node = self.nodes[0]\r\n+        self.wallet = MiniWallet(node)\r\n+        self.generate(self.wallet, 400)\r\n+\r\n+        self.test_cluster_limit_rbf(DEFAULT_CLUSTER_LIMIT)\r\n+\r\n+        for cluster_size_limit_kvb in [10, 20, 33, 100, DEFAULT_CLUSTER_SIZE_LIMIT_KVB]:\r\n+            self.log.info(f\"-> Resetting node with -limitclustersize={cluster_size_limit_kvb}\")\r\n+            self.restart_node(0, extra_args=[f\"-limitclustersize={cluster_size_limit_kvb}\"])\r\n+\r\n+            cluster_size_limit = cluster_size_limit_kvb * 1000\r\n+            self.test_cluster_size_limit(cluster_size_limit)\r\n+            self.test_cluster_merging_size(cluster_size_limit)\r\n+\r\n+        for cluster_count_limit in [4, 10, 16, 32, DEFAULT_CLUSTER_LIMIT]:\r\n+            self.log.info(f\"-> Resetting node with -limitclustercount={cluster_count_limit}\")\r\n+            self.restart_node(0, extra_args=[f\"-limitclustercount={cluster_count_limit}\"])\r\n+\r\n+            self.test_cluster_count_limit(cluster_count_limit)\r\n+            if cluster_count_limit > 10:\r\n+                self.test_cluster_merging(cluster_count_limit)\r\n+\r\n \r\n if __name__ == '__main__':\r\n     MempoolClusterTest(__file__).main()\r\ndiff --git a/test/functional/test_framework/mempool_util.py b/test/functional/test_framework/mempool_util.py\r\nindex 3c4609c0b44..89e2558307e 100644\r\n--- a/test/functional/test_framework/mempool_util.py\r\n+++ b/test/functional/test_framework/mempool_util.py\r\n@@ -33,6 +33,8 @@ from .wallet import (\r\n DEFAULT_MIN_RELAY_TX_FEE = 100\r\n # Default for -incrementalrelayfee in sat/kvB\r\n DEFAULT_INCREMENTAL_RELAY_FEE = 100\r\n+DEFAULT_CLUSTER_LIMIT = 64\r\n+DEFAULT_CLUSTER_SIZE_LIMIT_KVB = 101\r\n \r\n TRUC_MAX_VSIZE = 10000\r\n TRUC_CHILD_MAX_VSIZE = 1000\r\n```\r\n\r\n</details>",
      "created_at": "2025-10-15T19:11:35Z",
      "updated_at": "2025-10-17T17:52:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433669609",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433669609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 57,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433686891",
      "pull_request_review_id": 3341892072,
      "id": 2433686891,
      "node_id": "PRRC_kwDOABII586RDx1r",
      "diff_hunk": "@@ -641,6 +641,8 @@ void SetupServerArgs(ArgsManager& argsman, bool can_listen_ipc)\n     argsman.AddArg(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-test=<option>\", \"Pass a test-only option. Options include : \" + Join(TEST_OPTIONS_DOC, \", \") + \".\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustercount=<n>\", strprintf(\"Do not accept transactions connected to <n> or more existing in-mempool transactions (default: %u, maximum: %u)\", DEFAULT_CLUSTER_LIMIT, MAX_CLUSTER_COUNT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustersize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool connected transactions exceeds <n> kilobytes (default: %u)\", DEFAULT_CLUSTER_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);",
      "path": "src/init.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It would be nice to expose these through the `getmempoolinfo` RPC.\r\n\r\n```diff\r\ndiff --git a/src/rpc/mempool.cpp b/src/rpc/mempool.cpp\r\nindex 492693c9cef..1b62c74f0b3 100644\r\n--- a/src/rpc/mempool.cpp\r\n+++ b/src/rpc/mempool.cpp\r\n@@ -812,6 +812,8 @@ UniValue MempoolInfoToJSON(const CTxMemPool& pool)\r\n     ret.pushKV(\"fullrbf\", true);\r\n     ret.pushKV(\"permitbaremultisig\", pool.m_opts.permit_bare_multisig);\r\n     ret.pushKV(\"maxdatacarriersize\", pool.m_opts.max_datacarrier_bytes.value_or(0));\r\n+    ret.pushKV(\"limitclustercount\", pool.m_opts.limits.cluster_count);\r\n+    ret.pushKV(\"limitclustersize\", pool.m_opts.limits.cluster_size_vbytes);\r\n     return ret;\r\n }\r\n \r\n@@ -836,6 +838,8 @@ static RPCHelpMan getmempoolinfo()\r\n                 {RPCResult::Type::BOOL, \"fullrbf\", \"True if the mempool accepts RBF without replaceability signaling inspection (DEPRECATED)\"},\r\n                 {RPCResult::Type::BOOL, \"permitbaremultisig\", \"True if the mempool accepts transactions with bare multisig outputs\"},\r\n                 {RPCResult::Type::NUM, \"maxdatacarriersize\", \"Maximum number of bytes that can be used by OP_RETURN outputs in the mempool\"},\r\n+                {RPCResult::Type::NUM, \"limitclustercount\", \"Maximum number of transactions that can be in a cluster (configured by -limitclustercount)\"},\r\n+                {RPCResult::Type::NUM, \"limitclustersize\", \"Maximum size of a cluster in virtual bytes (configured by -limitclustersize)\"},\r\n             }},\r\n         RPCExamples{\r\n             HelpExampleCli(\"getmempoolinfo\", \"\")\r\n\r\n```",
      "created_at": "2025-10-15T19:18:04Z",
      "updated_at": "2025-10-15T20:32:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433686891",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433686891"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 644,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 645,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433860250",
      "pull_request_review_id": 3340512731,
      "id": 2433860250,
      "node_id": "PRRC_kwDOABII586REcKa",
      "diff_hunk": "@@ -145,10 +143,11 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock()\n     pblock->nTime = TicksSinceEpoch<std::chrono::seconds>(NodeClock::now());\n     m_lock_time_cutoff = pindexPrev->GetMedianTimePast();\n \n-    int nPackagesSelected = 0;\n-    int nDescendantsUpdated = 0;\n     if (m_mempool) {\n-        addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+        LOCK(m_mempool->cs);\n+        m_mempool->StartBlockBuilding();\n+        addChunks();",
      "path": "src/node/miner.cpp",
      "position": 27,
      "original_position": 19,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ae1ac5410383e57ed16867580a5fd355a46953de\r\n\r\nSeems more self-contained to start/stop the builder inside `addChunks`",
      "created_at": "2025-10-15T20:30:53Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433860250",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433860250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433884234",
      "pull_request_review_id": 3340512731,
      "id": 2433884234,
      "node_id": "PRRC_kwDOABII586REiBK",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);",
      "path": "src/node/miner.cpp",
      "position": 250,
      "original_position": 240,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ae1ac5410383e57ed16867580a5fd355a46953de\r\n\r\nif we're essentially only using this, why not inline `chunk_feerate` instead?",
      "created_at": "2025-10-15T20:40:00Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433884234",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433884234"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433925096",
      "pull_request_review_id": 3340512731,
      "id": 2433925096,
      "node_id": "PRRC_kwDOABII586REr_o",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;",
      "path": "src/node/miner.cpp",
      "position": 232,
      "original_position": 224,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ae1ac5410383e57ed16867580a5fd355a46953de\r\n\r\nWas getting confused with the two vectors, are they even needed?\r\n\r\n```\r\ndiff --git a/src/node/miner.cpp b/src/node/miner.cpp\r\nindex 52103bda82..1bfe771444 100644\r\n--- a/src/node/miner.cpp\r\n+++ b/src/node/miner.cpp\r\n@@ -206,8 +206,8 @@ bool BlockAssembler::TestPackage(FeePerWeight package_feerate, int64_t packageSi\r\n // Perform transaction-level checks before adding to block:\r\n // - transaction finality (locktime)\r\n-bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\r\n+bool BlockAssembler::TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const\r\n {\r\n-    for (auto tx : txs) {\r\n-        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\r\n+    for (const auto tx : txs) {\r\n+        if (!IsFinalTx(tx.get().GetTx(), nHeight, m_lock_time_cutoff)) {\r\n             return false;\r\n         }\r\n@@ -243,13 +243,11 @@ void BlockAssembler::addChunks()\r\n \r\n     std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\r\n+    selected_transactions.reserve(MAX_CLUSTER_COUNT_LIMIT);\r\n     FeePerWeight chunk_feerate;\r\n \r\n+    // This fills selected_transactions\r\n     chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\r\n     FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);\r\n \r\n-    std::vector<const CTxMemPoolEntry*> chunk_txs;\r\n-    // We'll add at most one chunk per iteration below, and chunk count is bounded by\r\n-    // the cluster size limit.\r\n-    chunk_txs.reserve(MAX_CLUSTER_COUNT_LIMIT);\r\n     while (selected_transactions.size() > 0) {\r\n         // Check to see if min fee rate is still respected.\r\n@@ -260,12 +258,10 @@ void BlockAssembler::addChunks()\r\n \r\n         int64_t package_sig_ops = 0;\r\n-        chunk_txs.clear();\r\n         for (const auto& tx : selected_transactions) {\r\n-            chunk_txs.emplace_back(&tx.get());\r\n             package_sig_ops += tx.get().GetSigOpCost();\r\n         }\r\n \r\n         // Check to see if this chunk will fit.\r\n-        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(chunk_txs)) {\r\n+        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(selected_transactions)) {\r\n             m_mempool->SkipBuilderChunk();\r\n             // This chunk won't fit, so we let it be removed from the heap and\r\n@@ -283,6 +279,6 @@ void BlockAssembler::addChunks()\r\n             // This chunk will fit, so add it to the block.\r\n             nConsecutiveFailed = 0;\r\n-            for (const auto& tx : chunk_txs) {\r\n-                AddToBlock(*tx);\r\n+            for (const auto& tx : selected_transactions) {\r\n+                AddToBlock(tx);\r\n             }\r\n             pblocktemplate->m_package_feerates.emplace_back(chunk_feerate_vsize);\r\ndiff --git a/src/node/miner.h b/src/node/miner.h\r\nindex 58fedcc1af..a42e2e2cb4 100644\r\n--- a/src/node/miner.h\r\n+++ b/src/node/miner.h\r\n@@ -117,5 +117,5 @@ private:\r\n       * These checks should always succeed, and they're here\r\n       * only as an extra check in case of suboptimal node configuration */\r\n-    bool TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const;\r\n+    bool TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const;\r\n };\r\n ```",
      "created_at": "2025-10-15T20:57:07Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433925096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433925096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433939831",
      "pull_request_review_id": 3340512731,
      "id": 2433939831,
      "node_id": "PRRC_kwDOABII586REvl3",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);\n \n-        if (packageFees < m_options.blockMinFeeRate.GetFee(packageSize)) {\n-            // Everything else we might consider has a lower fee rate\n+    std::vector<const CTxMemPoolEntry*> chunk_txs;\n+    // We'll add at most one chunk per iteration below, and chunk count is bounded by\n+    // the cluster size limit.\n+    chunk_txs.reserve(MAX_CLUSTER_COUNT_LIMIT);\n+    while (selected_transactions.size() > 0) {\n+        // Check to see if min fee rate is still respected.\n+        if (chunk_feerate.fee < m_options.blockMinFeeRate.GetFee(chunk_feerate_vsize.size)) {\n+            // Everything else we might consider has a lower feerate\n             return;\n         }\n \n-        if (!TestPackage(packageSize, packageSigOpsCost)) {\n-            if (fUsingModified) {\n-                // Since we always look at the best entry in mapModifiedTx,\n-                // we must erase failed entries so that we can consider the\n-                // next best entry on the next loop iteration\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter->GetSharedTx()->GetHash());\n-            }\n+        int64_t package_sig_ops = 0;\n+        chunk_txs.clear();\n+        for (const auto& tx : selected_transactions) {\n+            chunk_txs.emplace_back(&tx.get());\n+            package_sig_ops += tx.get().GetSigOpCost();\n+        }\n \n+        // Check to see if this chunk will fit.\n+        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(chunk_txs)) {",
      "path": "src/node/miner.cpp",
      "position": 1,
      "original_position": 271,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "ae1ac5410383e57ed16867580a5fd355a46953de\r\n\r\nnit: I think renaming `TestPackage` to `TestPackageBlockLimits` or something might help readability going forward",
      "created_at": "2025-10-15T21:04:20Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2433939831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2433939831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434013019",
      "pull_request_review_id": 3340512731,
      "id": 2434013019,
      "node_id": "PRRC_kwDOABII586RFBdb",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 50,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "2aad9f01e514b77538eb780138a8e52484eaf5a8\r\n\r\nis this right? If so this warrants a test (note to self and others)\r\n```Suggestion\r\n        // If we can't calculate a feerate, it's because the cluster size limits were hit, and we may want to try package RBF.\r\n```",
      "created_at": "2025-10-15T21:31:40Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434013019",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434013019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1023,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434061477",
      "pull_request_review_id": 3340512731,
      "id": 2434061477,
      "node_id": "PRRC_kwDOABII586RFNSl",
      "diff_hunk": "@@ -514,6 +514,15 @@ class CTxMemPool\n      */\n     void UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main) LOCKS_EXCLUDED(m_epoch);\n \n+    size_t GetUniqueClusterCount(const setEntries& iters_conflicting) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+        std::vector<const TxGraph::Ref *> entries;\n+        entries.reserve(iters_conflicting.size());\n+        for (auto it : iters_conflicting) {\n+            entries.emplace_back(&*it);\n+        }\n+        return m_txgraph->CountDistinctClusters(entries, TxGraph::Level::MAIN);",
      "path": "src/txmempool.h",
      "position": 370,
      "original_position": 10,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "2aad9f01e514b77538eb780138a8e52484eaf5a8\r\n\r\nnit: belt and suspenders\r\n\r\n```Suggestion\r\n        Assume(!m_txgraph->IsOversized(TxGraph::Level::MAIN));\r\n        return m_txgraph->CountDistinctClusters(entries, TxGraph::Level::MAIN);\r\n```",
      "created_at": "2025-10-15T21:46:07Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434061477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434061477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 421,
      "original_line": 421,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434078457",
      "pull_request_review_id": 3340512731,
      "id": 2434078457,
      "node_id": "PRRC_kwDOABII586RFRb5",
      "diff_hunk": "@@ -193,12 +190,12 @@ def test_package_rbf_additional_fees(self):\n \n     def test_package_rbf_max_conflicts(self):\n         node = self.nodes[0]\n-        self.log.info(\"Check Package RBF cannot replace more than MAX_REPLACEMENT_CANDIDATES transactions\")\n-        num_coins = 51\n+        self.log.info(\"Check Package RBF cannot conflict with  more than MAX_REPLACEMENT_CANDIDATES clusters\")\n+        num_coins = 101\n         parent_coins = self.coins[:num_coins]\n         del self.coins[:num_coins]\n \n-        # Original transactions: 51 transactions with 1 descendants each -> 102 total transactions\n+        # Original transactions: 101 transactions with 1 descendants each -> 202 total transactions, 101 clusters",
      "path": "test/functional/mempool_package_rbf.py",
      "position": 1,
      "original_position": 22,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "2aad9f01e514b77538eb780138a8e52484eaf5a8\r\n\r\nDidn't carefully look at this test case, but we should make sure we are testing the case of package RBF conflicting against clusters of up to count 64\r\n\r\nLooks like the test is still only conflicting with size 2",
      "created_at": "2025-10-15T21:55:41Z",
      "updated_at": "2025-10-15T21:58:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434078457",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434078457"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434195677",
      "pull_request_review_id": 3342628801,
      "id": 2434195677,
      "node_id": "PRRC_kwDOABII586RFuDd",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_raises_rpc_error,\n+)\n+\n+MAX_CLUSTER_COUNT = 64\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n+\n+        node = self.nodes[0]\n+        parent_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        ancestors = [parent_tx[\"txid\"]]\n+        while len(node.getrawmempool()) < MAX_CLUSTER_COUNT:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert node.getmempoolcluster(next_tx['txid']) == node.getmempoolcluster(parent_tx['txid'])\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert sorted(mempool_ancestors) == sorted(ancestors)\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in ancestors ])\n+\n+            # Update for next iteration\n+            ancestors.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == MAX_CLUSTER_COUNT\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            assert last_val[0]*x['fee'] >= last_val[1]*x['vsize']\n+            last_val = [x['vsize'], x['fee']]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_spend)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # TODO: verify that the size limits are also enforced.\n+        # TODO: add tests that exercise rbf, package submission, and package\n+        # rbf and verify that cluster limits are enforced.",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 59,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "in_reply_to_id": 2433669609,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Looks good, will include -- thank you for the test coverage!",
      "created_at": "2025-10-15T23:19:02Z",
      "updated_at": "2025-10-15T23:19:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434195677",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434195677"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 57,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434207347",
      "pull_request_review_id": 3342642066,
      "id": 2434207347,
      "node_id": "PRRC_kwDOABII586RFw5z",
      "diff_hunk": "@@ -59,8 +59,8 @@ class LOCKABLE Epoch\n     public:\n         Marker() = default;\n         Marker(const Marker&) = default;\n-        Marker(Marker&&) = delete;\n-        Marker& operator=(Marker&&) = delete;\n+        Marker(Marker&&) = default;",
      "path": "src/util/epochguard.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "51430680ecb722e1d4ee4a26dac5724050f41c9e",
      "in_reply_to_id": 2432642810,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Ok it's been a really long time since I've thought about this, but I believe the issue was that I needed epoch markers to be movable so that I could make CTxMemPoolEntry movable.\r\n\r\nI don't exactly remember why CTxMemPoolEntry needs to be movable but I believe it has something to do with inheriting from TxGraph::Ref.  I guess Ref's can't be copied, but they can be moved?",
      "created_at": "2025-10-15T23:29:55Z",
      "updated_at": "2025-10-15T23:29:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434207347",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434207347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 62,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434211174",
      "pull_request_review_id": 3342646532,
      "id": 2434211174,
      "node_id": "PRRC_kwDOABII586RFx1m",
      "diff_hunk": "@@ -137,12 +137,11 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToU\n         {",
      "path": "src/txmempool.cpp",
      "position": 110,
      "original_position": 1,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "6c73e4744837a7dc138a9177df3a48f30a1ba6c1",
      "in_reply_to_id": 2432836478,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Actually, in fairness I think there might be some platforms where the space usage may be different -- I think I ran into that at some point in the history of this PR with one of our CI jobs, but I don't recall the details now.  (Even still, I think saving the map lookup is likely worth it.)",
      "created_at": "2025-10-15T23:33:47Z",
      "updated_at": "2025-10-15T23:33:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434211174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434211174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434216116",
      "pull_request_review_id": 3342652253,
      "id": 2434216116,
      "node_id": "PRRC_kwDOABII586RFzC0",
      "diff_hunk": "@@ -145,10 +143,11 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock()\n     pblock->nTime = TicksSinceEpoch<std::chrono::seconds>(NodeClock::now());\n     m_lock_time_cutoff = pindexPrev->GetMedianTimePast();\n \n-    int nPackagesSelected = 0;\n-    int nDescendantsUpdated = 0;\n     if (m_mempool) {\n-        addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+        LOCK(m_mempool->cs);\n+        m_mempool->StartBlockBuilding();\n+        addChunks();",
      "path": "src/node/miner.cpp",
      "position": 27,
      "original_position": 19,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433860250,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think the reason I didn't is probably because `addChunks()` has multiple places where it returns, so it seemed a little messy to have to invoke `StopBlockBuilding()` within that function. But if you think it's worth it, I can rework the function and push the calls down into it.",
      "created_at": "2025-10-15T23:38:36Z",
      "updated_at": "2025-10-15T23:38:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434216116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434216116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434220844",
      "pull_request_review_id": 3342657436,
      "id": 2434220844,
      "node_id": "PRRC_kwDOABII586RF0Ms",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);",
      "path": "src/node/miner.cpp",
      "position": 250,
      "original_position": 240,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433884234,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In this commit, `chunk_feerate.fee` is used further down, but this gets cleaned up further in #33591 with the introduction of `CFeeRate::GetFeePerVSize`, at which point this could be inlined.  I'll make that change in #33591.",
      "created_at": "2025-10-15T23:43:14Z",
      "updated_at": "2025-10-15T23:43:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434220844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434220844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434234855",
      "pull_request_review_id": 3342672654,
      "id": 2434234855,
      "node_id": "PRRC_kwDOABII586RF3nn",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 50,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": 2434013019,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Will take this doc change in #33591.",
      "created_at": "2025-10-15T23:56:42Z",
      "updated_at": "2025-10-15T23:56:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434234855",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434234855"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1023,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434241333",
      "pull_request_review_id": 3342680926,
      "id": 2434241333,
      "node_id": "PRRC_kwDOABII586RF5M1",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;",
      "path": "src/node/miner.cpp",
      "position": 232,
      "original_position": 224,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433925096,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good point!  Taking your change.",
      "created_at": "2025-10-16T00:03:00Z",
      "updated_at": "2025-10-16T00:03:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434241333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434241333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434242379",
      "pull_request_review_id": 3342682304,
      "id": 2434242379,
      "node_id": "PRRC_kwDOABII586RF5dL",
      "diff_hunk": "@@ -1604,6 +1611,12 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptMultipleTransactions(const std::\n         return PackageMempoolAcceptResult(package_state, std::move(results));\n     }\n \n+    // Check if the transaction would exceed the cluster size limit.",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 46,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48",
      "in_reply_to_id": 2433318113,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-10-16T00:04:07Z",
      "updated_at": "2025-10-16T00:04:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434242379",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434242379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1614,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434242823",
      "pull_request_review_id": 3342682894,
      "id": 2434242823,
      "node_id": "PRRC_kwDOABII586RF5kH",
      "diff_hunk": "@@ -641,6 +641,8 @@ void SetupServerArgs(ArgsManager& argsman, bool can_listen_ipc)\n     argsman.AddArg(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-test=<option>\", \"Pass a test-only option. Options include : \" + Join(TEST_OPTIONS_DOC, \", \") + \".\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustercount=<n>\", strprintf(\"Do not accept transactions connected to <n> or more existing in-mempool transactions (default: %u, maximum: %u)\", DEFAULT_CLUSTER_LIMIT, MAX_CLUSTER_COUNT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustersize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool connected transactions exceeds <n> kilobytes (default: %u)\", DEFAULT_CLUSTER_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);",
      "path": "src/init.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "in_reply_to_id": 2433686891,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done, thanks.",
      "created_at": "2025-10-16T00:04:37Z",
      "updated_at": "2025-10-16T00:04:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2434242823",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2434242823"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 644,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 645,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435629619",
      "pull_request_review_id": 3344448886,
      "id": 2435629619,
      "node_id": "PRRC_kwDOABII586RLMIz",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_raises_rpc_error,\n+)\n+\n+MAX_CLUSTER_COUNT = 64\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n+\n+        node = self.nodes[0]\n+        parent_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        ancestors = [parent_tx[\"txid\"]]\n+        while len(node.getrawmempool()) < MAX_CLUSTER_COUNT:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert node.getmempoolcluster(next_tx['txid']) == node.getmempoolcluster(parent_tx['txid'])\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert sorted(mempool_ancestors) == sorted(ancestors)\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in ancestors ])\n+\n+            # Update for next iteration\n+            ancestors.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == MAX_CLUSTER_COUNT\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            assert last_val[0]*x['fee'] >= last_val[1]*x['vsize']\n+            last_val = [x['vsize'], x['fee']]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_spend)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # TODO: verify that the size limits are also enforced.\n+        # TODO: add tests that exercise rbf, package submission, and package\n+        # rbf and verify that cluster limits are enforced.",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 59,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "in_reply_to_id": 2433669609,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I did make a few changes (the linter alerted on a few lines) so please take a look again at what is here.",
      "created_at": "2025-10-16T11:57:52Z",
      "updated_at": "2025-10-16T11:57:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435629619",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435629619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 57,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435644194",
      "pull_request_review_id": 3344470492,
      "id": 2435644194,
      "node_id": "PRRC_kwDOABII586RLPsi",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);",
      "path": "src/node/miner.cpp",
      "position": 250,
      "original_position": 240,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433884234,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oh, actually we need the weight further down for the check to see if the chunk will fit in the block, so I'm inclined to leave this as-is?",
      "created_at": "2025-10-16T12:03:05Z",
      "updated_at": "2025-10-16T12:03:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435644194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435644194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435654614",
      "pull_request_review_id": 3344485966,
      "id": 2435654614,
      "node_id": "PRRC_kwDOABII586RLSPW",
      "diff_hunk": "@@ -514,6 +514,15 @@ class CTxMemPool\n      */\n     void UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main) LOCKS_EXCLUDED(m_epoch);\n \n+    size_t GetUniqueClusterCount(const setEntries& iters_conflicting) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+        std::vector<const TxGraph::Ref *> entries;\n+        entries.reserve(iters_conflicting.size());\n+        for (auto it : iters_conflicting) {\n+            entries.emplace_back(&*it);\n+        }\n+        return m_txgraph->CountDistinctClusters(entries, TxGraph::Level::MAIN);",
      "path": "src/txmempool.h",
      "position": 370,
      "original_position": 10,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": 2434061477,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-16T12:06:51Z",
      "updated_at": "2025-10-16T12:06:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435654614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435654614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 421,
      "original_line": 421,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435668780",
      "pull_request_review_id": 3344505191,
      "id": 2435668780,
      "node_id": "PRRC_kwDOABII586RLVss",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;",
      "path": "src/node/miner.cpp",
      "position": 232,
      "original_position": 224,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433925096,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Incorporated in a8be743aeb42ec8ab613f822989a11a2f2ce70ac",
      "created_at": "2025-10-16T12:10:55Z",
      "updated_at": "2025-10-16T12:10:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435668780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435668780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435683806",
      "pull_request_review_id": 3344528789,
      "id": 2435683806,
      "node_id": "PRRC_kwDOABII586RLZXe",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 50,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": 2434013019,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 6881d21c57ce122f0c2f5900e6caab7ba806d279.",
      "created_at": "2025-10-16T12:15:05Z",
      "updated_at": "2025-10-16T12:15:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435683806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435683806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1023,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435843010",
      "pull_request_review_id": 3344751997,
      "id": 2435843010,
      "node_id": "PRRC_kwDOABII586RMAPC",
      "diff_hunk": "@@ -145,10 +143,11 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock()\n     pblock->nTime = TicksSinceEpoch<std::chrono::seconds>(NodeClock::now());\n     m_lock_time_cutoff = pindexPrev->GetMedianTimePast();\n \n-    int nPackagesSelected = 0;\n-    int nDescendantsUpdated = 0;\n     if (m_mempool) {\n-        addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+        LOCK(m_mempool->cs);\n+        m_mempool->StartBlockBuilding();\n+        addChunks();",
      "path": "src/node/miner.cpp",
      "position": 27,
      "original_position": 19,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433860250,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "sounds reasonable, leave as is",
      "created_at": "2025-10-16T13:06:31Z",
      "updated_at": "2025-10-16T13:06:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435843010",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435843010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435845248",
      "pull_request_review_id": 3344755003,
      "id": 2435845248,
      "node_id": "PRRC_kwDOABII586RMAyA",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);",
      "path": "src/node/miner.cpp",
      "position": 250,
      "original_position": 240,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433884234,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "oops you're right",
      "created_at": "2025-10-16T13:07:17Z",
      "updated_at": "2025-10-16T13:07:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435845248",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435845248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 250,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435934233",
      "pull_request_review_id": 3339641710,
      "id": 2435934233,
      "node_id": "PRRC_kwDOABII586RMWgZ",
      "diff_hunk": "@@ -195,29 +100,23 @@ class BlockAssembler\n     /** Clear the block's state and prepare for assembling a new block */\n     void resetBlock();\n     /** Add a tx to the block */\n-    void AddToBlock(CTxMemPool::txiter iter);\n+    void AddToBlock(const CTxMemPoolEntry& entry);\n \n     // Methods for how to add transactions to a block.\n-    /** Add transactions based on feerate including unconfirmed ancestors\n-      * Increments nPackagesSelected / nDescendantsUpdated with corresponding\n-      * statistics from the package selection (for logging statistics).\n+    /** Add transactions based on chunk feerate\n       *\n       * @pre BlockAssembler::m_mempool must not be nullptr\n     */\n-    void addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated) EXCLUSIVE_LOCKS_REQUIRED(!m_mempool->cs);\n+    void addChunks() EXCLUSIVE_LOCKS_REQUIRED(m_mempool->cs);\n \n     // helper functions for addPackageTxs()",
      "path": "src/node/miner.h",
      "position": 1,
      "original_position": 129,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "a8be743aeb42ec8ab613f822989a11a2f2ce70ac",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Select transactions for blocks based on chunk feerate\" a8be743aeb42ec8ab613f822989a11a2f2ce70ac\r\n\r\nnit:  change to helper functions for addChunks since addPackageTxs is now gone.\r\n```suggestion\r\n    // helper functions for addChunks()\r\n\r\n```",
      "created_at": "2025-10-16T13:31:47Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435934233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435934233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435949023",
      "pull_request_review_id": 3339641710,
      "id": 2435949023,
      "node_id": "PRRC_kwDOABII586RMaHf",
      "diff_hunk": "@@ -195,29 +100,23 @@ class BlockAssembler\n     /** Clear the block's state and prepare for assembling a new block */\n     void resetBlock();\n     /** Add a tx to the block */\n-    void AddToBlock(CTxMemPool::txiter iter);\n+    void AddToBlock(const CTxMemPoolEntry& entry);\n \n     // Methods for how to add transactions to a block.\n-    /** Add transactions based on feerate including unconfirmed ancestors\n-      * Increments nPackagesSelected / nDescendantsUpdated with corresponding\n-      * statistics from the package selection (for logging statistics).\n+    /** Add transactions based on chunk feerate\n       *\n       * @pre BlockAssembler::m_mempool must not be nullptr\n     */\n-    void addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated) EXCLUSIVE_LOCKS_REQUIRED(!m_mempool->cs);\n+    void addChunks() EXCLUSIVE_LOCKS_REQUIRED(m_mempool->cs);\n \n     // helper functions for addPackageTxs()\n-    /** Remove confirmed (inBlock) entries from given set */\n-    void onlyUnconfirmed(CTxMemPool::setEntries& testSet);\n     /** Test if a new package would \"fit\" in the block */\n-    bool TestPackage(uint64_t packageSize, int64_t packageSigOpsCost) const;\n+    bool TestPackage(FeePerWeight package_feerate, int64_t packageSigOpsCost) const;",
      "path": "src/node/miner.h",
      "position": 135,
      "original_position": 134,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "a8be743aeb42ec8ab613f822989a11a2f2ce70ac",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Select transactions for blocks based on chunk feerate\" a8be743aeb42ec8ab613f822989a11a2f2ce70ac\r\n\r\n\r\nnit: It will be better for us replace package with chunk here and other places in the miner?\r\n\r\n```diff\r\ndiff --git a/src/node/miner.cpp b/src/node/miner.cpp\r\nindex 1bfe7714440..e80d55c1f31 100644\r\n--- a/src/node/miner.cpp\r\n+++ b/src/node/miner.cpp\r\n@@ -192,12 +192,12 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock()\r\n     return std::move(pblocktemplate);\r\n }\r\n \r\n-bool BlockAssembler::TestPackage(FeePerWeight package_feerate, int64_t packageSigOpsCost) const\r\n+bool BlockAssembler::TestChunk(FeePerWeight chunk_feerate, int64_t chunk_sigops_cost) const\r\n {\r\n-    if (nBlockWeight + package_feerate.size >= m_options.nBlockMaxWeight) {\r\n+    if (nBlockWeight + chunk_feerate.size >= m_options.nBlockMaxWeight) {\r\n         return false;\r\n     }\r\n-    if (nBlockSigOpsCost + packageSigOpsCost >= MAX_BLOCK_SIGOPS_COST) {\r\n+    if (nBlockSigOpsCost + chunk_sigops_cost >= MAX_BLOCK_SIGOPS_COST) {\r\n         return false;\r\n     }\r\n     return true;\r\n@@ -205,7 +205,7 @@ bool BlockAssembler::TestPackage(FeePerWeight package_feerate, int64_t packageSi\r\n \r\n // Perform transaction-level checks before adding to block:\r\n // - transaction finality (locktime)\r\n-bool BlockAssembler::TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const\r\n+bool BlockAssembler::TestChunkTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const\r\n {\r\n     for (const auto tx : txs) {\r\n         if (!IsFinalTx(tx.get().GetTx(), nHeight, m_lock_time_cutoff)) {\r\n@@ -256,13 +256,13 @@ void BlockAssembler::addChunks()\r\n             return;\r\n         }\r\n \r\n-        int64_t package_sig_ops = 0;\r\n+        int64_t chunk_sig_ops = 0;\r\n         for (const auto& tx : selected_transactions) {\r\n-            package_sig_ops += tx.get().GetSigOpCost();\r\n+            chunk_sig_ops += tx.get().GetSigOpCost();\r\n         }\r\n \r\n         // Check to see if this chunk will fit.\r\n-        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(selected_transactions)) {\r\n+        if (!TestChunk(chunk_feerate, chunk_sig_ops) || !TestChunkTransactions(selected_transactions)) {\r\n             m_mempool->SkipBuilderChunk();\r\n             // This chunk won't fit, so we let it be removed from the heap and\r\n             // we'll try the next best.\r\n@@ -281,7 +281,7 @@ void BlockAssembler::addChunks()\r\n             for (const auto& tx : selected_transactions) {\r\n                 AddToBlock(tx);\r\n             }\r\n-            pblocktemplate->m_package_feerates.emplace_back(chunk_feerate_vsize);\r\n+            pblocktemplate->m_chunk_feerates.emplace_back(chunk_feerate_vsize);\r\n         }\r\n \r\n         selected_transactions.clear();\r\ndiff --git a/src/node/miner.h b/src/node/miner.h\r\nindex a42e2e2cb48..5fee028d9cd 100644\r\n--- a/src/node/miner.h\r\n+++ b/src/node/miner.h\r\n@@ -47,9 +47,9 @@ struct CBlockTemplate\r\n     // Sigops per transaction, not including coinbase transaction (unlike CBlock::vtx).\r\n     std::vector<int64_t> vTxSigOpsCost;\r\n     std::vector<unsigned char> vchCoinbaseCommitment;\r\n-    /* A vector of package fee rates, ordered by the sequence in which\r\n-     * packages are selected for inclusion in the block template.*/\r\n-    std::vector<FeePerVSize> m_package_feerates;\r\n+    /* A vector of chunk fee rates, ordered by the sequence in which\r\n+     * chunks are selected for inclusion in the block template.*/\r\n+    std::vector<FeePerVSize> m_chunk_feerates;\r\n };\r\n \r\n /** Generate a new block, without valid proof-of-work */\r\n@@ -109,14 +109,14 @@ private:\r\n     */\r\n     void addChunks() EXCLUSIVE_LOCKS_REQUIRED(m_mempool->cs);\r\n \r\n-    // helper functions for addPackageTxs()\r\n-    /** Test if a new package would \"fit\" in the block */\r\n-    bool TestPackage(FeePerWeight package_feerate, int64_t packageSigOpsCost) const;\r\n-    /** Perform checks on each transaction in a package:\r\n+    // helper functions for addChunkTxs()\r\n+    /** Test if a new chunk would \"fit\" in the block */\r\n+    bool TestChunk(FeePerWeight chunk_feerate, int64_t chunk_sigops_cost) const;\r\n+    /** Perform checks on each transaction in a chunk:\r\n       * locktime, premature-witness, serialized size (if necessary)\r\n       * These checks should always succeed, and they're here\r\n       * only as an extra check in case of suboptimal node configuration */\r\n-    bool TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const;\r\n+    bool TestChunkTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const;\r\n };\r\n \r\n /**\r\n```",
      "created_at": "2025-10-16T13:36:14Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2435949023",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2435949023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 114,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436027616",
      "pull_request_review_id": 3342174984,
      "id": 2436027616,
      "node_id": "PRRC_kwDOABII586RMtTg",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_raises_rpc_error,\n+)\n+\n+MAX_CLUSTER_COUNT = 64\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n+\n+        node = self.nodes[0]\n+        parent_tx = self.wallet.send_self_transfer(from_node=node)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        ancestors = [parent_tx[\"txid\"]]\n+        while len(node.getrawmempool()) < MAX_CLUSTER_COUNT:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend)\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert node.getmempoolcluster(next_tx['txid']) == node.getmempoolcluster(parent_tx['txid'])\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert sorted(mempool_ancestors) == sorted(ancestors)\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in ancestors ])\n+\n+            # Update for next iteration\n+            ancestors.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == MAX_CLUSTER_COUNT\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            assert last_val[0]*x['fee'] >= last_val[1]*x['vsize']\n+            last_val = [x['vsize'], x['fee']]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_spend)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # TODO: verify that the size limits are also enforced.\n+        # TODO: add tests that exercise rbf, package submission, and package\n+        # rbf and verify that cluster limits are enforced.",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 59,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "in_reply_to_id": 2433669609,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "My bad on the linter, lgtm!",
      "created_at": "2025-10-16T13:56:55Z",
      "updated_at": "2025-10-17T17:49:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436027616",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436027616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 57,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436033865",
      "pull_request_review_id": 3339641710,
      "id": 2436033865,
      "node_id": "PRRC_kwDOABII586RMu1J",
      "diff_hunk": "@@ -219,224 +205,88 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (const auto tx : txs) {\n+        if (!IsFinalTx(tx.get().GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    selected_transactions.reserve(MAX_CLUSTER_COUNT_LIMIT);\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    // This fills selected_transactions\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);\n \n-        if (packageFees < m_options.blockMinFeeRate.GetFee(packageSize)) {\n-            // Everything else we might consider has a lower fee rate\n+    while (selected_transactions.size() > 0) {\n+        // Check to see if min fee rate is still respected.\n+        if (chunk_feerate.fee < m_options.blockMinFeeRate.GetFee(chunk_feerate_vsize.size)) {\n+            // Everything else we might consider has a lower feerate\n             return;\n         }\n \n-        if (!TestPackage(packageSize, packageSigOpsCost)) {\n-            if (fUsingModified) {\n-                // Since we always look at the best entry in mapModifiedTx,\n-                // we must erase failed entries so that we can consider the\n-                // next best entry on the next loop iteration\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter->GetSharedTx()->GetHash());\n-            }\n+        int64_t package_sig_ops = 0;\n+        for (const auto& tx : selected_transactions) {\n+            package_sig_ops += tx.get().GetSigOpCost();\n+        }\n \n+        // Check to see if this chunk will fit.\n+        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(selected_transactions)) {\n+            m_mempool->SkipBuilderChunk();\n+            // This chunk won't fit, so we let it be removed from the heap and\n+            // we'll try the next best.\n             ++nConsecutiveFailed;\n \n             if (nConsecutiveFailed > MAX_CONSECUTIVE_FAILURES && nBlockWeight +\n                     BLOCK_FULL_ENOUGH_WEIGHT_DELTA > m_options.nBlockMaxWeight) {\n                 // Give up if we're close to full and haven't succeeded in a while\n-                break;\n+                return;\n             }\n-            continue;\n-        }\n-\n-        auto ancestors{mempool.AssumeCalculateMemPoolAncestors(__func__, *iter, CTxMemPool::Limits::NoLimits(), /*fSearchForParents=*/false)};\n-\n-        onlyUnconfirmed(ancestors);\n-        ancestors.insert(iter);\n+        } else {\n+            m_mempool->IncludeBuilderChunk();\n \n-        // Test if all tx's are Final\n-        if (!TestPackageTransactions(ancestors)) {\n-            if (fUsingModified) {\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter->GetSharedTx()->GetHash());\n+            // This chunk will fit, so add it to the block.\n+            nConsecutiveFailed = 0;\n+            for (const auto& tx : selected_transactions) {\n+                AddToBlock(tx);\n             }\n-            continue;\n+            pblocktemplate->m_package_feerates.emplace_back(chunk_feerate_vsize);\n         }\n \n-        // This transaction will make it in; reset the failed counter.\n-        nConsecutiveFailed = 0;\n-\n-        // Package can be added. Sort the entries in a valid order.\n-        std::vector<CTxMemPool::txiter> sortedEntries;\n-        SortForBlock(ancestors, sortedEntries);\n-\n-        for (size_t i = 0; i < sortedEntries.size(); ++i) {\n-            AddToBlock(sortedEntries[i]);\n-            // Erase from the modified set, if present\n-            mapModifiedTx.erase(sortedEntries[i]);\n-        }\n-\n-        ++nPackagesSelected;\n-        pblocktemplate->m_package_feerates.emplace_back(packageFees, static_cast<int32_t>(packageSize));\n-\n-        // Update transactions that depend on each of these\n-        nDescendantsUpdated += UpdatePackagesForAdded(mempool, ancestors, mapModifiedTx);\n+        selected_transactions.clear();",
      "path": "src/node/miner.cpp",
      "position": 329,
      "original_position": 321,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "a8be743aeb42ec8ab613f822989a11a2f2ce70ac",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Select transactions for blocks based on chunk feerate\" a8be743aeb42ec8ab613f822989a11a2f2ce70ac\r\n\r\nnit: maybe reserve again after clear here?\r\n",
      "created_at": "2025-10-16T13:58:24Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436033865",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436033865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 287,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436048271",
      "pull_request_review_id": 3339641710,
      "id": 2436048271,
      "node_id": "PRRC_kwDOABII586RMyWP",
      "diff_hunk": "@@ -535,49 +535,64 @@ CMutableTransaction TestChain100Setup::CreateValidMempoolTransaction(CTransactio\n std::vector<CTransactionRef> TestChain100Setup::PopulateMempool(FastRandomContext& det_rand, size_t num_transactions, bool submit)\n {\n     std::vector<CTransactionRef> mempool_transactions;\n-    std::deque<std::pair<COutPoint, CAmount>> unspent_prevouts;\n+    std::deque<std::pair<COutPoint, CAmount>> unspent_prevouts, undo_info;",
      "path": "src/test/util/setup_common.cpp",
      "position": 14,
      "original_position": 5,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "afb9003bc602a77ed15bf4e79277d960937a5c28",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"test: rewrite PopulateMempool to not violate mempool policy (cluster size) limits\"  afb9003bc602a77ed15bf4e79277d960937a5c28\r\n\r\nnitty-nit: instead of undo, spent outputs might be better?",
      "created_at": "2025-10-16T14:02:02Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436048271",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436048271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 538,
      "original_line": 538,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436069486",
      "pull_request_review_id": 3345064005,
      "id": 2436069486,
      "node_id": "PRRC_kwDOABII586RM3hu",
      "diff_hunk": "@@ -74,12 +74,11 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\n     // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n     for (const auto& txiter : cluster) {\n         if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n-            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(),\n-                MiniMinerMempoolEntry{/*tx_in=*/txiter->GetSharedTx(),\n-                                      /*vsize_self=*/txiter->GetTxSize(),\n-                                      /*vsize_ancestor=*/txiter->GetSizeWithAncestors(),\n-                                      /*fee_self=*/txiter->GetModifiedFee(),\n-                                      /*fee_ancestor=*/txiter->GetModFeesWithAncestors()});\n+            size_t ancestor_count{0};\n+            size_t ancestor_size{0};\n+            CAmount ancestor_fee{0};\n+            mempool.CalculateAncestorData(*txiter, ancestor_count, ancestor_size, ancestor_fee);\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter->GetSharedTx(), txiter->GetTxSize(), int64_t(ancestor_size), txiter->GetModifiedFee(), ancestor_fee));",
      "path": "src/node/mini_miner.cpp",
      "position": 1,
      "original_position": 14,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "729cec4f6ddb880210b7e0011fff8b0a5f88c933",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "729cec4f6ddb880210b7e0011fff8b0a5f88c933\r\n\r\nmicro-nit: readability of format prior to this commit was better, can it remain a multiline ctor for MiniMinerMempoolEntry with annotations?",
      "created_at": "2025-10-16T14:06:11Z",
      "updated_at": "2025-10-16T15:38:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436069486",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436069486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436127304",
      "pull_request_review_id": 3339641710,
      "id": 2436127304,
      "node_id": "PRRC_kwDOABII586RNFpI",
      "diff_hunk": "@@ -1002,40 +1002,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (auto ancestors{m_subpackage.m_changeset->CalculateMemPoolAncestors(ws.m_tx_handle, maybe_rbf_limits)}) {\n         ws.m_ancestors = std::move(*ancestors);\n     } else {\n-        // If CalculateMemPoolAncestors fails second time, we want the original error string.",
      "path": "src/validation.cpp",
      "position": 165,
      "original_position": 4,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "31a045700ee13a6746c4f4de253e64a0b8a61334",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"policy: Remove CPFP carveout rule\" 31a045700ee13a6746c4f4de253e64a0b8a61334\r\n\r\nIn doc/policy/mempool-limits.md,  Exemptions section CPFP carveout is  now stale and should also be deleted",
      "created_at": "2025-10-16T14:16:02Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436127304",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436127304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1005,
      "original_line": 1005,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436313337",
      "pull_request_review_id": 3339641710,
      "id": 2436313337,
      "node_id": "PRRC_kwDOABII586RNzD5",
      "diff_hunk": "@@ -21,8 +21,8 @@\n class CFeeRate;\n class uint256;\n \n-/** Maximum number of transactions that can be replaced by RBF (Rule #5). This includes all\n- * mempool conflicts and their descendants. */\n+/** Maximum number of unique clusters that can be affected by an RBF (Rule #5);",
      "path": "src/policy/rbf.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Implement new RBF logic for cluster mempool\" e6315c24326016cfaee5bd046e8b2e4e1088ac6b\r\n\r\nDelete the bip125 rule numbers references.\r\n",
      "created_at": "2025-10-16T14:49:03Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436313337",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436313337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436396593",
      "pull_request_review_id": 3339641710,
      "id": 2436396593,
      "node_id": "PRRC_kwDOABII586ROHYx",
      "diff_hunk": "@@ -333,14 +330,9 @@ def test_new_unconfirmed_inputs(self):\n         )[\"tx\"]\n         tx2_hex = tx2.serialize().hex()\n \n-        # This will raise an exception\n-        reject_reason = \"replacement-adds-unconfirmed\"\n-        reject_details = f\"{reject_reason}, replacement {tx2.txid_hex} adds unconfirmed input, idx 1\"\n-        res = self.nodes[0].testmempoolaccept(rawtxs=[tx2_hex])[0]\n-        assert_equal(res[\"reject-reason\"], reject_reason)\n-        assert_equal(res[\"reject-details\"], reject_details)\n-        assert_raises_rpc_error(-26, f\"{reject_details}\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n-\n+        # This will not raise an exception\n+        tx2_id = self.nodes[0].sendrawtransaction(tx2_hex, 0)\n+        assert tx2_id in self.nodes[0].getrawmempool()\n \n     def test_too_many_replacements(self):\n         \"\"\"Replacements that evict too many transactions are rejected\"\"\"",
      "path": "test/functional/feature_rbf.py",
      "position": 1,
      "original_position": 57,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Implement new RBF logic for cluster mempool\" e6315c24326016cfaee5bd046e8b2e4e1088ac6b\r\n\r\nnit: replace transactions with clusters here and other places\r\n```suggestion\r\n        \"\"\"Replacements that evict too many clusters are rejected\"\"\"\r\n\r\n```",
      "created_at": "2025-10-16T15:06:06Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436396593",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436396593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436409780",
      "pull_request_review_id": 3339641710,
      "id": 2436409780,
      "node_id": "PRRC_kwDOABII586ROKm0",
      "diff_hunk": "@@ -39,35 +39,6 @@ static inline CTransactionRef make_tx(const std::vector<CTransactionRef>& inputs\n \n // Make two child transactions from parent (which must have at least 2 outputs).\n // Each tx will have the same outputs, using the amounts specified in output_values.",
      "path": "src/test/rbf_tests.cpp",
      "position": 1,
      "original_position": 3,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Implement new RBF logic for cluster mempool\" e6315c24326016cfaee5bd046e8b2e4e1088ac6b\r\n\r\n```suggestion\r\n```",
      "created_at": "2025-10-16T15:10:01Z",
      "updated_at": "2025-10-16T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436409780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436409780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436500068",
      "pull_request_review_id": 3345064005,
      "id": 2436500068,
      "node_id": "PRRC_kwDOABII586ROgpk",
      "diff_hunk": "@@ -57,28 +57,35 @@ struct ParentInfo {\n \n std::optional<std::string> PackageTRUCChecks(const CTxMemPool& pool, const CTransactionRef& ptx, int64_t vsize,\n                                            const Package& package,\n-                                           const CTxMemPool::setEntries& mempool_ancestors)\n+                                           const std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef>& mempool_parents)\n {\n     // This function is specialized for these limits, and must be reimplemented if they ever change.\n     static_assert(TRUC_ANCESTOR_LIMIT == 2);\n     static_assert(TRUC_DESCENDANT_LIMIT == 2);\n \n     const auto in_package_parents{FindInPackageParents(package, ptx)};\n \n-    // Now we have all ancestors, so we can start checking TRUC rules.\n+    // Now we have all parents, so we can start checking TRUC rules.\n     if (ptx->version == TRUC_VERSION) {\n         // SingleTRUCChecks should have checked this already.\n         if (!Assume(vsize <= TRUC_MAX_VSIZE)) {\n             return strprintf(\"version=3 tx %s (wtxid=%s) is too big: %u > %u virtual bytes\",\n                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(), vsize, TRUC_MAX_VSIZE);\n         }\n \n-        if (mempool_ancestors.size() + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {\n+        if (mempool_parents.size() + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {\n             return strprintf(\"tx %s (wtxid=%s) would have too many ancestors\",\n                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n         }\n \n-        const bool has_parent{mempool_ancestors.size() + in_package_parents.size() > 0};\n+        if (mempool_parents.size()) {\n+            if (pool.GetNumAncestors(mempool_parents[0]) + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {",
      "path": "src/policy/truc_policy.cpp",
      "position": 33,
      "original_position": 30,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "10872f7ec923803f711cd2c3af93a0e17121330e\r\n\r\nYou're still looking up ancestors in TRUC prior to knowing how large the resulting graph would be, but you're only doing it once against a single in-mempool parent, so it should be bounded to 64 results total.\r\n\r\nMaybe leave a comment to that effect or stick that in the commit message?",
      "created_at": "2025-10-16T15:36:55Z",
      "updated_at": "2025-10-16T15:44:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436500068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436500068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 82,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436684815",
      "pull_request_review_id": 3342174984,
      "id": 2436684815,
      "node_id": "PRRC_kwDOABII586RPNwP",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 82,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "8f62e9177b9d35beb27ca9749768b99543d4225b",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This started failing when I added it to other tests, then I realized it's the wrong direction\r\n```suggestion\r\n            assert_greater_than_or_equal(last_val[1] * x['vsize'], last_val[0] * x['fee'])\r\n```",
      "created_at": "2025-10-16T16:38:57Z",
      "updated_at": "2025-10-17T17:49:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2436684815",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2436684815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2437193014",
      "pull_request_review_id": 3342174984,
      "id": 2437193014,
      "node_id": "PRRC_kwDOABII586RRJ02",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 82,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "8f62e9177b9d35beb27ca9749768b99543d4225b",
      "in_reply_to_id": 2436684815,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I ended up writing some feerate diagram tests to check my understanding of how it works. It might be helpful for reviewers and/or if you're interested in taking them:\r\n\r\n<details>\r\n\r\n\r\n\r\n```diff\r\ndiff --git a/test/functional/mempool_cluster.py b/test/functional/mempool_cluster.py\r\nindex ee8005a1cd2..c86e6a1b5c0 100755\r\n--- a/test/functional/mempool_cluster.py\r\n+++ b/test/functional/mempool_cluster.py\r\n@@ -7,6 +7,8 @@\r\n from decimal import Decimal\r\n \r\n from test_framework.mempool_util import (\r\n+    assert_equal_feerate_diagram,\r\n+    check_feerate_diagram_monotonically_decreasing,\r\n     DEFAULT_CLUSTER_LIMIT,\r\n     DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\r\n )\r\n@@ -71,17 +73,6 @@ class MempoolClusterTest(BitcoinTestFramework):\r\n         assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\r\n         return all_results\r\n \r\n-    def check_feerate_diagram(self, node):\r\n-        \"\"\"Sanity check the feerate diagram.\"\"\"\r\n-        feeratediagram = node.getmempoolfeeratediagram()\r\n-        last_val = [0, 0]\r\n-        for x in feeratediagram:\r\n-            # The vsize is always positive, except for the first iteration\r\n-            assert x['vsize'] > 0 or x['fee'] == 0\r\n-            # Monotonically decreasing fee per vsize\r\n-            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])\r\n-            last_val = [x['vsize'], x['fee']]\r\n-\r\n     def test_limit_enforcement(self, cluster_submitted, target_vsize_per_tx=None):\r\n         \"\"\"\r\n         the cluster may change as a result of these transactions, so cluster_submitted is mutated accordingly\r\n@@ -149,7 +140,7 @@ class MempoolClusterTest(BitcoinTestFramework):\r\n     def test_cluster_count_limit(self, max_cluster_count):\r\n         node = self.nodes[0]\r\n         cluster_submitted = self.add_chain_cluster(node, max_cluster_count)\r\n-        self.check_feerate_diagram(node)\r\n+        check_feerate_diagram_monotonically_decreasing(node.getmempoolfeeratediagram())\r\n         for result in cluster_submitted:\r\n             assert_equal(node.getmempoolcluster(result[\"txid\"])['txcount'], max_cluster_count)\r\n \r\n@@ -292,6 +283,151 @@ class MempoolClusterTest(BitcoinTestFramework):\r\n         assert tx_replacer_sponsor[\"txid\"] in node.getrawmempool()\r\n         assert_equal(node.getmempoolcluster(tx_replacer[\"txid\"])['txcount'], 2)\r\n \r\n+    @cleanup\r\n+    def test_feerate_diagram(self):\r\n+        node = self.nodes[0]\r\n+        self.log.info(\"Test that the feerate diagram shows chunks correctly\")\r\n+\r\n+        # 1 sat/vB as Decimal BTC/kvB\r\n+        feerate_1000sat_kvb = Decimal(1000) / COIN\r\n+\r\n+        def sats_to_btc(sats):\r\n+            \"\"\"Convert int sats to Decimal BTC with 8 decimal places\"\"\"\r\n+            return Decimal(sats) / Decimal(1e8)\r\n+\r\n+        # txA (0sat / 500vB) <- txB (1000sat / 500vB)\r\n+        # Use v3 to allow 0 fee\r\n+        txA = self.wallet.create_self_transfer(confirmed_only=True, fee=0, fee_rate=0, version=3, target_vsize=500)\r\n+        txB = self.wallet.create_self_transfer(utxo_to_spend=txA[\"new_utxo\"], fee=sats_to_btc(1000), version=3, target_vsize=500)\r\n+        result_ab = node.submitpackage([txA[\"hex\"], txB[\"hex\"]])\r\n+        assert_equal(result_ab[\"package_msg\"], \"success\")\r\n+\r\n+        # one cluster, one chunk with feerate 1sat/vB\r\n+        assert_equal(result_ab[\"tx-results\"][txA[\"wtxid\"]][\"fees\"][\"effective-feerate\"], feerate_1000sat_kvb)\r\n+        assert_equal(result_ab[\"tx-results\"][txB[\"wtxid\"]][\"fees\"][\"effective-feerate\"], feerate_1000sat_kvb)\r\n+        assert_equal(node.getmempoolcluster(txA[\"txid\"])['txcount'], 2)\r\n+        expected_feerate_diagram_ab = [\r\n+            [0, 0],\r\n+            [1000, 1000], # [txA, txB] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_ab, node.getmempoolfeeratediagram())\r\n+\r\n+        # txC (0sat / 1000vB) <- txD (2000sat / 1000vB)\r\n+        # Use v3 to allow 0 fee\r\n+        txC = self.wallet.create_self_transfer(confirmed_only=True, fee=0, fee_rate=0, version=3, target_vsize=1000)\r\n+        txD = self.wallet.create_self_transfer(utxo_to_spend=txC[\"new_utxo\"], fee=sats_to_btc(2000), version=3, target_vsize=1000)\r\n+        result_cd = node.submitpackage([txC[\"hex\"], txD[\"hex\"]])\r\n+\r\n+        # one cluster, one chunks with feerate 1sat/vB\r\n+        assert_equal(result_cd[\"package_msg\"], \"success\")\r\n+        assert_equal(result_cd[\"tx-results\"][txC[\"wtxid\"]][\"fees\"][\"effective-feerate\"], feerate_1000sat_kvb)\r\n+        assert_equal(result_cd[\"tx-results\"][txD[\"wtxid\"]][\"fees\"][\"effective-feerate\"], feerate_1000sat_kvb)\r\n+        assert_equal(node.getmempoolcluster(txC[\"txid\"])['txcount'], 2)\r\n+        # Same chunk feerate as [txA, txB], but [txC, txD] has larger vsize.\r\n+        expected_feerate_diagram_cd = [\r\n+            [0, 0],\r\n+            [1000, 1000], # [txA, txB] 1sat/vB\r\n+            [3000, 3000], # [txC, txD] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_cd, node.getmempoolfeeratediagram())\r\n+\r\n+        self.log.info(\"Test that the feerate diagram uses modified fees\")\r\n+        # txE (800sat / 400vB)\r\n+        # 799sat of fees will come from prioritisetransaction\r\n+        txE = self.wallet.create_self_transfer(confirmed_only=True, fee=sats_to_btc(1), target_vsize=400)\r\n+        node.prioritisetransaction(txid=txE[\"txid\"], fee_delta=799)\r\n+        node.sendrawtransaction(txE[\"hex\"])\r\n+        assert_equal(node.getmempoolcluster(txE[\"txid\"])['txcount'], 1)\r\n+        expected_feerate_diagram_e = [\r\n+            [0, 0],\r\n+            [800, 400], # [txE] 2sat/vB\r\n+            [1800, 1400], # [txA, txB] 1sat/vB\r\n+            [3800, 3400], # [txC, txD] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_e, node.getmempoolfeeratediagram())\r\n+\r\n+        # txF (750sat / 500vB) <- txG (6250sat / 500vB)\r\n+        txF = self.wallet.create_self_transfer(confirmed_only=True, fee=sats_to_btc(750), target_vsize=500)\r\n+        txG = self.wallet.create_self_transfer(utxo_to_spend=txF[\"new_utxo\"], fee=sats_to_btc(6250), target_vsize=500)\r\n+\r\n+        # Submit them individually to see txF's chunk feerate change.\r\n+        node.sendrawtransaction(txF[\"hex\"])\r\n+        assert_equal(node.getmempoolcluster(txF[\"txid\"])['txcount'], 1)\r\n+        # txF has a feerate of 1.5sat/vB, so it's in the middle\r\n+        expected_feerate_diagram_f = [\r\n+            [0, 0],\r\n+            [800, 400], # [txE] 2sat/vB\r\n+            [1550, 900], # [txF] 1.5sat/vB\r\n+            [2550, 1900], # [txA, txB] 1sat/vB\r\n+            [4550, 3900], # [txC, txD] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_f, node.getmempoolfeeratediagram())\r\n+\r\n+        # txG bumps txF's chunk feerate to 7sat/vB\r\n+        node.sendrawtransaction(txG[\"hex\"])\r\n+        assert_equal(node.getmempoolcluster(txF[\"txid\"])['txcount'], 2)\r\n+        expected_feerate_diagram_g = [\r\n+            [0, 0],\r\n+            [7000, 1000], # [txF, txG] 7sat/vB\r\n+            [7800, 1400], # [txE] 2sat/vB\r\n+            [8800, 2400], # [txA, txB] 1sat/vB\r\n+            [10800, 4400], # [txC, txD] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_g, node.getmempoolfeeratediagram())\r\n+\r\n+        self.log.info(\"Test that prioritisetransaction on a mempool entry affects the feerate diagram\")\r\n+        # Prioritise txD to make its chunk feerate a little more than 8sat/vB\r\n+        node.prioritisetransaction(txid=txD[\"txid\"], fee_delta=14012)\r\n+        expected_feerate_diagram_d_prio = [\r\n+            [0, 0],\r\n+            [16012, 2000], # [txC, txD] 8.006sat/vB\r\n+            [23012, 3000], # [txF, txG] 7sat/vB\r\n+            [23812, 3400], # [txE] 2sat/vB\r\n+            [24812, 4400], # [txA, txB] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_d_prio, node.getmempoolfeeratediagram())\r\n+\r\n+        # De-prioritise txG to split up the chunk, putting txF behind txE and txG at the very end.\r\n+        node.prioritisetransaction(txid=txG[\"txid\"], fee_delta=-6195)\r\n+        expected_feerate_diagram_g_deprio = [\r\n+            [0, 0],\r\n+            [16012, 2000], # [txC, txD] 8.006sat/vB\r\n+            [16812, 2400], # [txE] 2sat/vB\r\n+            [17562, 2900], # [txF] 1.5sat/vB\r\n+            [18562, 3900], # [txA, txB] 1sat/vB\r\n+            [18617, 4400], # [txG] 0.11sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_g_deprio, node.getmempoolfeeratediagram())\r\n+\r\n+        # txH (30sat / 300vB) Spend txE and txG to merge their clusters, but keeping the chunking the same.\r\n+        txH = self.wallet.create_self_transfer_multi(utxos_to_spend=[txE[\"new_utxo\"], txG[\"new_utxo\"]], fee_per_output=30, target_vsize=300)\r\n+        node.sendrawtransaction(txH[\"hex\"])\r\n+        # The cluster is now EFGH\r\n+        assert_equal(node.getmempoolcluster(txE[\"txid\"])['txcount'], 4)\r\n+        expected_feerate_diagram_h = [\r\n+            [0, 0],\r\n+            [16012, 2000], # [txC, txD] 8.006sat/vB\r\n+            [16812, 2400], # [txE] 2sat/vB\r\n+            [17562, 2900], # [txF] 1.5sat/vB\r\n+            [18562, 3900], # [txA, txB] 1sat/vB\r\n+            [18617, 4400], # [txG] 0.11sat/vB\r\n+            [18647, 4700], # [txH] 0.1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_h, node.getmempoolfeeratediagram())\r\n+\r\n+        # txI (2150sat / 200vB) bumps txF, txG, txH to 1.99sat/vB, combining them into a single chunk\r\n+        txI = self.wallet.create_self_transfer(utxo_to_spend=txH[\"new_utxos\"][0], fee=sats_to_btc(2150), target_vsize=200)\r\n+        node.sendrawtransaction(txI[\"hex\"])\r\n+        # The cluster is now EFGHI\r\n+        assert_equal(node.getmempoolcluster(txI[\"txid\"])['txcount'], 5)\r\n+        expected_feerate_diagram_i = [\r\n+            [0, 0],\r\n+            [16012, 2000], # [txC, txD] 8.006sat/vB\r\n+            [16812, 2400], # [txE] 2sat/vB\r\n+            [19797, 3900], # [txF, txG, txH, txI] 1.99sat/vB\r\n+            [20797, 4900], # [txA, txB] 1sat/vB\r\n+        ]\r\n+        assert_equal_feerate_diagram(expected_feerate_diagram_i, node.getmempoolfeeratediagram())\r\n \r\n     def run_test(self):\r\n         node = self.nodes[0]\r\n@@ -299,6 +435,7 @@ class MempoolClusterTest(BitcoinTestFramework):\r\n         self.generate(self.wallet, 400)\r\n \r\n         self.test_cluster_limit_rbf(DEFAULT_CLUSTER_LIMIT)\r\n+        self.test_feerate_diagram()\r\n \r\n         for cluster_size_limit_kvb in [10, 20, 33, 100, DEFAULT_CLUSTER_SIZE_LIMIT_KVB]:\r\n             self.log.info(f\"-> Resetting node with -limitclustersize={cluster_size_limit_kvb}\")\r\ndiff --git a/test/functional/test_framework/mempool_util.py b/test/functional/test_framework/mempool_util.py\r\nindex 89e2558307e..2bce87bda2f 100644\r\n--- a/test/functional/test_framework/mempool_util.py\r\n+++ b/test/functional/test_framework/mempool_util.py\r\n@@ -10,6 +10,7 @@ from .blocktools import (\r\n )\r\n from .messages import (\r\n     COutPoint,\r\n+    COIN,\r\n     CTransaction,\r\n     CTxIn,\r\n     CTxInWitness,\r\n@@ -22,6 +23,7 @@ from .script import (\r\n from .util import (\r\n     assert_equal,\r\n     assert_greater_than,\r\n+    assert_greater_than_or_equal,\r\n     create_lots_of_big_transactions,\r\n     gen_return_txouts,\r\n )\r\n@@ -131,3 +133,28 @@ def create_large_orphan():\r\n     tx.wit.vtxinwit[0].scriptWitness.stack = [CScript(b'X' * 390000)]\r\n     tx.vout = [CTxOut(100, CScript([OP_RETURN, b'a' * 20]))]\r\n     return tx\r\n+\r\n+def check_feerate_diagram_monotonically_decreasing(feerate_diagram):\r\n+    \"\"\"Sanity check the feerate diagram.\"\"\"\r\n+    last_val = [0, 0]\r\n+    for x in feerate_diagram:\r\n+        # The vsize is always positive, except for the first iteration\r\n+        assert x['vsize'] > 0 or x['fee'] == 0\r\n+        # Monotonically decreasing fee per vsize\r\n+        assert_greater_than_or_equal(last_val[0] * x['vsize'], last_val[1] * x['fee'])\r\n+        last_val = [x['vsize'], x['fee']]\r\n+\r\n+def assert_equal_feerate_diagram(expected, actual):\r\n+    \"\"\"Check that expected and actual are equal, handling Decimal values and giving helpful error messages.\r\n+    expected: list of [fee, vsize] pairs where fee is an integer number of satoshis\r\n+    actual: list of { \"fee\": Decimal, \"vsize\": int } from the getmempoolfeeratediagram RPC\r\n+    Also sanity checks that the actual feerates are monotonically decreasing.\r\n+    \"\"\"\r\n+    assert_equal(len(expected), len(actual))\r\n+    for i in range(len(expected)):\r\n+        # We convert the Decimal to an integer number to avoid Decimal comparisons.\r\n+        # For example, Decimal('0') == Decimal('0E-8') and Decimal('0.0001') == Decimal('0.00010000')\r\n+        assert_equal(expected[i][0], int(actual[i][\"fee\"] * COIN))\r\n+        assert_equal(expected[i][1], actual[i][\"vsize\"])\r\n+\r\n+    check_feerate_diagram_monotonically_decreasing(actual)\r\n\r\n```\r\n</details>",
      "created_at": "2025-10-16T19:14:14Z",
      "updated_at": "2025-10-17T17:51:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2437193014",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2437193014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2437862407",
      "pull_request_review_id": 3347518017,
      "id": 2437862407,
      "node_id": "PRRC_kwDOABII586RTtQH",
      "diff_hunk": "@@ -219,224 +205,92 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<const CTxMemPoolEntry *>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (auto tx : txs) {\n+        if (!IsFinalTx(tx->GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);\n \n-        if (packageFees < m_options.blockMinFeeRate.GetFee(packageSize)) {\n-            // Everything else we might consider has a lower fee rate\n+    std::vector<const CTxMemPoolEntry*> chunk_txs;\n+    // We'll add at most one chunk per iteration below, and chunk count is bounded by\n+    // the cluster size limit.\n+    chunk_txs.reserve(MAX_CLUSTER_COUNT_LIMIT);\n+    while (selected_transactions.size() > 0) {\n+        // Check to see if min fee rate is still respected.\n+        if (chunk_feerate.fee < m_options.blockMinFeeRate.GetFee(chunk_feerate_vsize.size)) {\n+            // Everything else we might consider has a lower feerate\n             return;\n         }\n \n-        if (!TestPackage(packageSize, packageSigOpsCost)) {\n-            if (fUsingModified) {\n-                // Since we always look at the best entry in mapModifiedTx,\n-                // we must erase failed entries so that we can consider the\n-                // next best entry on the next loop iteration\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter->GetSharedTx()->GetHash());\n-            }\n+        int64_t package_sig_ops = 0;\n+        chunk_txs.clear();\n+        for (const auto& tx : selected_transactions) {\n+            chunk_txs.emplace_back(&tx.get());\n+            package_sig_ops += tx.get().GetSigOpCost();\n+        }\n \n+        // Check to see if this chunk will fit.\n+        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(chunk_txs)) {",
      "path": "src/node/miner.cpp",
      "position": 1,
      "original_position": 271,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "ae1ac5410383e57ed16867580a5fd355a46953de",
      "in_reply_to_id": 2433939831,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in #33591 (d7109669b54d299e84dfe90d2ebf591ff673f51c)",
      "created_at": "2025-10-17T00:15:31Z",
      "updated_at": "2025-10-17T00:15:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2437862407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2437862407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 269,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2437897737",
      "pull_request_review_id": 3347559162,
      "id": 2437897737,
      "node_id": "PRRC_kwDOABII586RT14J",
      "diff_hunk": "@@ -641,6 +641,8 @@ void SetupServerArgs(ArgsManager& argsman, bool can_listen_ipc)\n     argsman.AddArg(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-test=<option>\", \"Pass a test-only option. Options include : \" + Join(TEST_OPTIONS_DOC, \", \") + \".\", ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustercount=<n>\", strprintf(\"Do not accept transactions connected to <n> or more existing in-mempool transactions (default: %u, maximum: %u)\", DEFAULT_CLUSTER_LIMIT, MAX_CLUSTER_COUNT_LIMIT), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-limitclustersize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool connected transactions exceeds <n> kilobytes (default: %u)\", DEFAULT_CLUSTER_SIZE_LIMIT_KVB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);",
      "path": "src/init.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "2801e80528a3a1c2949a8fda6338882613a673e5",
      "in_reply_to_id": 2432258434,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks -- I'm going to make it \"virtual size with all in-mempool...\" rather than \"virtual kilobytes\", which I think is more legible?  ",
      "created_at": "2025-10-17T00:28:32Z",
      "updated_at": "2025-10-17T00:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2437897737",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2437897737"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 645,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440116718",
      "pull_request_review_id": 3350483416,
      "id": 2440116718,
      "node_id": "PRRC_kwDOABII586RcTnu",
      "diff_hunk": "@@ -5426,7 +5426,7 @@ class CompareInvMempoolOrder\n     {\n         /* As std::make_heap produces a max-heap, we want the entries with the\n          * fewest ancestors/highest fee to sort later. */",
      "path": "src/net_processing.cpp",
      "position": 1,
      "original_position": 3,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "936f04e770eeb4ef8477722cb1f23f29746883a1",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Use cluster linearization for transaction relay sort order\"  936f04e770eeb4ef8477722cb1f23f29746883a1\r\n\r\nnit: This comment is stale?\r\n```suggestion\r\n         * higher mining score to sort later. */\r\n\r\n```",
      "created_at": "2025-10-17T13:55:56Z",
      "updated_at": "2025-10-21T06:58:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440116718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440116718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5428,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440174148",
      "pull_request_review_id": 3350483416,
      "id": 2440174148,
      "node_id": "PRRC_kwDOABII586RchpE",
      "diff_hunk": "@@ -733,7 +734,7 @@ void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendhei\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 setParentCheck.insert(*it2);\n             }\n-            // We are iterating through the mempool entries sorted in order by ancestor count.\n+            // We are iterating through the mempool entries sorted topologically and by score.",
      "path": "src/txmempool.cpp",
      "position": 1,
      "original_position": 20,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "9b31836abfc086e4693ecdb1ceaec0a8e21dbb8f",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Remove CTxMemPool::GetSortedDepthAndScore\"  9b31836abfc086e4693ecdb1ceaec0a8e21dbb8f\r\n\r\nnit\r\n```suggestion\r\n            // We are iterating through the mempool entries sorted topologically and by mining score.\r\n\r\n```",
      "created_at": "2025-10-17T14:11:33Z",
      "updated_at": "2025-10-21T06:58:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440174148",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440174148"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 737,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440224630",
      "pull_request_review_id": 3350483416,
      "id": 2440224630,
      "node_id": "PRRC_kwDOABII586Rct92",
      "diff_hunk": "@@ -74,12 +74,11 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\n     // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n     for (const auto& txiter : cluster) {\n         if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n-            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(),\n-                MiniMinerMempoolEntry{/*tx_in=*/txiter->GetSharedTx(),\n-                                      /*vsize_self=*/txiter->GetTxSize(),\n-                                      /*vsize_ancestor=*/txiter->GetSizeWithAncestors(),\n-                                      /*fee_self=*/txiter->GetModifiedFee(),\n-                                      /*fee_ancestor=*/txiter->GetModFeesWithAncestors()});\n+            size_t ancestor_count{0};\n+            size_t ancestor_size{0};\n+            CAmount ancestor_fee{0};\n+            mempool.CalculateAncestorData(*txiter, ancestor_count, ancestor_size, ancestor_fee);\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter->GetSharedTx(), txiter->GetTxSize(), int64_t(ancestor_size), txiter->GetModifiedFee(), ancestor_fee));",
      "path": "src/node/mini_miner.cpp",
      "position": 1,
      "original_position": 14,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "729cec4f6ddb880210b7e0011fff8b0a5f88c933",
      "in_reply_to_id": 2436069486,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think it will even be better to have a struct for this to avoid the repetition of the declaration of the variables and passing the as out params, according to guidelines we prefer returning values https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#coding-style-c-functions-and-methods",
      "created_at": "2025-10-17T14:28:56Z",
      "updated_at": "2025-10-21T06:58:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440224630",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440224630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440265397",
      "pull_request_review_id": 3350483416,
      "id": 2440265397,
      "node_id": "PRRC_kwDOABII586Rc361",
      "diff_hunk": "@@ -228,6 +228,16 @@ def test_nondefault_package_limits(self):\n         assert_equal(node.getmempoolentry(tx_v3_parent_large1[\"txid\"])[\"descendantcount\"], 1)\n         self.generate(node, 1)\n \n+        self.log.info(\"Test that a decreased limitclustersize also applies to TRUC child\")\n+        self.restart_node(0, extra_args=[\"-limitclustersize=10\", \"-acceptnonstdtxn=1\"])\n+        tx_v3_parent_large2 = self.wallet.send_self_transfer(from_node=node, target_vsize=parent_target_vsize, version=3)\n+        tx_v3_child_large2 = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_parent_large2[\"new_utxo\"], target_vsize=child_target_vsize, version=3)\n+        # Parent and child are within TRUC limits\n+        assert_greater_than_or_equal(TRUC_MAX_VSIZE, tx_v3_parent_large2[\"tx\"].get_vsize())\n+        assert_greater_than_or_equal(TRUC_CHILD_MAX_VSIZE, tx_v3_child_large2[\"tx\"].get_vsize())\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, tx_v3_child_large2[\"hex\"])\n+        self.check_mempool([tx_v3_parent_large2[\"txid\"]])",
      "path": "test/functional/mempool_truc.py",
      "position": 63,
      "original_position": 12,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "cf2f5211a8fab1438feb1cf1ccb86dccedd4b6c8",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Add test case for cluster size limits to TRUC logic\"  cf2f5211a8fab1438feb1cf1ccb86dccedd4b6c8\r\n\r\nalso add a test for cluster count\r\n\r\n```suggestion\r\n        self.log.info(\"Test that a decreased limitclustercount also applies to TRUC cluster\")\r\n        self.restart_node(0, extra_args=[\"-limitclustercount=1\", \"-acceptnonstdtxn=1\"])\r\n        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, tx_v3_child_large2[\"hex\"])\r\n        self.check_mempool([tx_v3_parent_large2[\"txid\"]])\r\n```",
      "created_at": "2025-10-17T14:43:14Z",
      "updated_at": "2025-10-21T06:58:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440265397",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440265397"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 241,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440284422",
      "pull_request_review_id": 3350483416,
      "id": 2440284422,
      "node_id": "PRRC_kwDOABII586Rc8kG",
      "diff_hunk": "@@ -665,10 +665,7 @@ class ChainImpl : public Chain\n     bool hasDescendantsInMempool(const Txid& txid) override\n     {\n         if (!m_node.mempool) return false;\n-        LOCK(m_node.mempool->cs);\n-        const auto entry{m_node.mempool->GetEntry(txid)};\n-        if (entry == nullptr) return false;\n-        return entry->GetCountWithDescendants() > 1;\n+        return m_node.mempool->HasDescendants(txid);",
      "path": "src/node/interfaces.cpp",
      "position": 31,
      "original_position": 8,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "b23b156c7bdf112a4fe64acd71e398cc7c0bd231",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In \"Use mempool/txgraph to determine if a tx has descendants\" b23b156c7bdf112a4fe64acd71e398cc7c0bd231\r\n\r\nnice I like this pattern, not leaking internals, I think it will be better to adopt this pattern also in https://github.com/bitcoin/bitcoin/pull/33629/commits/d2f75c555caf1f6a62b8ab1ef0f2543f0c84cc39#r2432661442",
      "created_at": "2025-10-17T14:49:57Z",
      "updated_at": "2025-10-21T06:58:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440284422",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440284422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 668,
      "original_line": 668,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440825043",
      "pull_request_review_id": 3351431350,
      "id": 2440825043,
      "node_id": "PRRC_kwDOABII586RfAjT",
      "diff_hunk": "@@ -1002,40 +1002,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (auto ancestors{m_subpackage.m_changeset->CalculateMemPoolAncestors(ws.m_tx_handle, maybe_rbf_limits)}) {\n         ws.m_ancestors = std::move(*ancestors);\n     } else {\n-        // If CalculateMemPoolAncestors fails second time, we want the original error string.",
      "path": "src/validation.cpp",
      "position": 165,
      "original_position": 4,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "31a045700ee13a6746c4f4de253e64a0b8a61334",
      "in_reply_to_id": 2436127304,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think the whole file can be deleted, as ancestor/descendant limits are now also obsolete.\r\n\r\nI think we can write a new doc for cluster limits in a followup? And a release note (/me ducks)",
      "created_at": "2025-10-17T18:22:49Z",
      "updated_at": "2025-10-17T20:19:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440825043",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440825043"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1005,
      "original_line": 1005,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440839627",
      "pull_request_review_id": 3351431350,
      "id": 2440839627,
      "node_id": "PRRC_kwDOABII586RfEHL",
      "diff_hunk": "@@ -1274,135 +1274,15 @@ std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txi\n     return clustered_txs;\n }\n \n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n-    }\n-    return std::nullopt;\n-}\n-\n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n \n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};",
      "path": "src/txmempool.cpp",
      "position": 1082,
      "original_position": 52,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "in e6315c24326016cfaee5bd046e8b2e4e1088ac6b\r\n\r\nNice! We should also remove \"All conflicting clusters (connected components of mempool transactions) must be clusters of up to size 2.\" from the package RBF rules in policy/packages.md",
      "created_at": "2025-10-17T18:26:42Z",
      "updated_at": "2025-10-17T20:19:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440839627",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440839627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1305,
      "original_line": 1305,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440892816",
      "pull_request_review_id": 3351431350,
      "id": 2440892816,
      "node_id": "PRRC_kwDOABII586RfRGQ",
      "diff_hunk": "@@ -12,12 +12,7 @@ other consensus and policy rules, each of the following conditions are met:\n \n 1. (Removed)\n \n-2. The replacement transaction only include an unconfirmed input if that input was included in\n-   one of the directly conflicting transactions. An unconfirmed input spends an output from a\n-   currently-unconfirmed transaction.\n-\n-   *Rationale*: When RBF was originally implemented, the mempool did not keep track of\n-   ancestor feerates yet. This rule was suggested as a temporary restriction.\n+2. [REDACTED]",
      "path": "doc/policy/mempool-replacements.md",
      "position": 1,
      "original_position": 10,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "fba5200d59af87db240a1b061f995c63b0ed5ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "fba5200d59af87db240a1b061f995c63b0ed5ee8 nit: Could be \"(Removed)\" to be consistent with the other rules we no longer implement?",
      "created_at": "2025-10-17T18:42:53Z",
      "updated_at": "2025-10-17T20:19:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440892816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440892816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440894335",
      "pull_request_review_id": 3351431350,
      "id": 2440894335,
      "node_id": "PRRC_kwDOABII586RfRd_",
      "diff_hunk": "@@ -79,3 +67,5 @@ This set of rules is similar but distinct from BIP125.\n * Signaling for replace-by-fee is no longer required as of [PR 30592](https://github.com/bitcoin/bitcoin/pull/30592).\n \n * The incremental relay feerate default is 0.1sat/vB ([PR #33106](https://github.com/bitcoin/bitcoin/pull/33106)).\n+\n+* Feerate diagram policy enabled in conjunction with switch to cluster mempool as of **v??.0**.",
      "path": "doc/policy/mempool-replacements.md",
      "position": 1,
      "original_position": 49,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "fba5200d59af87db240a1b061f995c63b0ed5ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n* Feerate diagram policy enabled in conjunction with switch to cluster mempool as of **v31.0**.\r\n```",
      "created_at": "2025-10-17T18:43:20Z",
      "updated_at": "2025-10-17T20:19:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440894335",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440894335"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440904975",
      "pull_request_review_id": 3351431350,
      "id": 2440904975,
      "node_id": "PRRC_kwDOABII586RfUEP",
      "diff_hunk": "@@ -38,23 +33,16 @@ other consensus and policy rules, each of the following conditions are met:\n    *Rationale*: Try to prevent DoS attacks where an attacker causes the network to repeatedly relay\n    transactions each paying a tiny additional amount in fees, e.g. just 1 satoshi.\n \n-5. The number of original transactions does not exceed 100. More precisely, the sum of all\n-   directly conflicting transactions' descendant counts (number of transactions inclusive of itself\n-   and its descendants) must not exceed 100; it is possible that this overestimates the true number\n-   of original transactions.\n+5. The number of distinct clusters corresponding to conflicting transactions does not exceed 100.\n \n-   *Rationale*: Try to prevent DoS attacks where an attacker is able to easily occupy and flush out\n-   significant portions of the node's mempool using replacements with multiple directly conflicting\n-   transactions, each with large descendant sets.\n+   *Rationale*: Limit CPU usage required to update the mempool for so many transactions being\n+   removed at once.\n \n-6. The replacement transaction's feerate is greater than the feerates of all directly conflicting\n-   transactions.\n+6. The feerate diagram of the mempool must be strictly improved by the replacement transaction.",
      "path": "doc/policy/mempool-replacements.md",
      "position": 32,
      "original_position": 32,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "fba5200d59af87db240a1b061f995c63b0ed5ee8",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "fba5200d59af87db240a1b061f995c63b0ed5ee8 \r\n\r\nHappy for this to go into a followup:\r\n\r\nMaybe worth adding a bit more color for people who don't have any context: A singleton replacing a singleton must pay higher total fees and have a higher feerate (covers vast majority of cases). For more complex cases, see this link to more comprehensive explanation.",
      "created_at": "2025-10-17T18:46:44Z",
      "updated_at": "2025-10-17T20:19:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2440904975",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2440904975"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 41,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2441070793",
      "pull_request_review_id": 3351431350,
      "id": 2441070793,
      "node_id": "PRRC_kwDOABII586Rf8jJ",
      "diff_hunk": "@@ -419,8 +419,7 @@ def test_no_minrelay_fee(self):\n \n         res = self.nodes[0].submitpackage([dusty_tx[\"hex\"] for dusty_tx in dusty_txs] + [insufficient_sweep_tx[\"hex\"]])\n         assert_equal(res['package_msg'], \"transaction failed\")\n-        #assert_equal(res['tx-results'][insufficient_sweep_tx[\"wtxid\"]][\"error\"], f\"missing-ephemeral-spends, tx {insufficient_sweep_tx['txid']} (wtxid={insufficient_sweep_tx['wtxid']}) did not spend parent's ephemeral dust\")",
      "path": "test/functional/mempool_ephemeral_dust.py",
      "position": 1,
      "original_position": 4,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "b9cbca76762 Reviewer note, I originally wanted to point out the extra commented line but then read the commit message and saw it changes back later in e6315c24326",
      "created_at": "2025-10-17T19:47:30Z",
      "updated_at": "2025-10-17T20:19:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2441070793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2441070793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 422,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2441096106",
      "pull_request_review_id": 3351431350,
      "id": 2441096106,
      "node_id": "PRRC_kwDOABII586RgCuq",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "e6315c24326: In both single and package settings, `ImprovesFeerateDiagram` is where cluster size limits are checked for the first time if RBF is happening. The check is cached and many RBF checks are cheaper than `CheckMemPoolPolicyLimits`, so that doesn't seem problematic.\r\n\r\nHowever, this is assigning `TX_RECONSIDERABLE` as the error when cluster limits are exceeded, which will cause net_processing to give it some special treatment (we may redownload and revalidate in some circumstances, which may waste resources), which should only be for errors that can be fixed by adding a child (e.g. to pay for fee requirements or sweep dust). I don't think it makes sense to apply that here, or it should at least be consistent with the other too-large-cluster error.\r\n\r\nAlso, I think the error string should be \"too-large-cluster\" (but that's more of a nit).\r\n\r\nPutting `CheckMemPoolPolicyLimits` before replacement checks would automatically fix this. That feels cleaner to me, so `ImprovesFeerateDiagram` doesn't need to do double duty.\r\n\r\nWe could also examine the `err_string` here and assign `TX_RECONSIDERABLE` if it's actually a feerate diagram error, `TX_MEMPOOL_POLICY` if it's a cluster limit error.",
      "created_at": "2025-10-17T20:00:54Z",
      "updated_at": "2025-10-17T23:13:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2441096106",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2441096106"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2441138984",
      "pull_request_review_id": 3351431350,
      "id": 2441138984,
      "node_id": "PRRC_kwDOABII586RgNMo",
      "diff_hunk": "",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe for a followup, but since `CheckTopologyLimits` is being removed, I think the package RBF logic can have one more tweak in e6315c24326016cfaee5bd046e8b2e4e1088ac6b, which I think @sipa brought up a few weeks ago:\r\n\r\nWe currently have the requirement that the package feerate is higher than the parent feerate because \"we don't want the child to be only paying anti-DoS fees\" but that's more restrictive than it needs to be. It's ok if the child has a lower feerate than the parent and only pays anti-DoS fees, as long as it pays for itself to be above the mempool minimum feerate.\r\n\r\nHere's a branch to do this + a few test cases and a doc update: https://github.com/glozow/bitcoin/commits/2025-10-cluster-package-rbf/\r\n\r\n<details>\r\n\r\n```diff\r\ndiff --git a/doc/policy/packages.md b/doc/policy/packages.md\r\nindex 7522a984435..2e8f5cf8e0d 100644\r\n--- a/doc/policy/packages.md\r\n+++ b/doc/policy/packages.md\r\n@@ -38,17 +38,10 @@ The following rules are enforced for all packages:\r\n \r\n    - Packages are 1-parent-1-child, with no in-mempool ancestors of the package.\r\n \r\n-   - All conflicting clusters (connected components of mempool transactions) must be clusters of up to size 2.\r\n+   - The child's individual feerate must meet the mempool minimum feerate.\r\n \r\n-   - No more than MAX_REPLACEMENT_CANDIDATES transactions can be replaced, analogous to\r\n-     regular [replacement rule](./mempool-replacements.md) 5).\r\n-\r\n-   - Replacements must pay more total fees at the incremental relay fee (analogous to\r\n-     regular [replacement rules](./mempool-replacements.md) 3 and 4).\r\n-\r\n-   - Parent feerate must be lower than package feerate.\r\n-\r\n-   - Must improve [feerate diagram](https://delvingbitcoin.org/t/mempool-incentive-compatibility/553). (#29242)\r\n+   - All other [replacement rules](./mempool-replacements.md) are met: no more than 100 distinct clusters, total package\r\n+   fees pay for the package size at the incremental relay feerate, and the feerate diagram improves.\r\n \r\n    - *Rationale*: Basic support for package RBF can be used by wallets\r\n      by making chains of no longer than two, then directly conflicting\r\n@@ -56,18 +49,6 @@ The following rules are enforced for all packages:\r\n      result in more robust fee bumping. More general package RBF may be\r\n      enabled in the future.\r\n \r\n-* When packages are evaluated against ancestor/descendant limits, the union of all transactions'\r\n-  descendants and ancestors is considered. (#21800)\r\n-\r\n-   - *Rationale*: This is essentially a \"worst case\" heuristic intended for packages that are\r\n-     heavily connected, i.e. some transaction in the package is the ancestor or descendant of all\r\n-     the other transactions.\r\n-\r\n-* [CPFP Carve Out](./mempool-limits.md#CPFP-Carve-Out) is disabled in packaged contexts. (#21800)\r\n-\r\n-   - *Rationale*: This carve out cannot be accurately applied when there are multiple transactions'\r\n-     ancestors and descendants being considered at the same time.\r\n-\r\n The following rules are only enforced for packages to be submitted to the mempool (not\r\n enforced for test accepts):\r\n \r\ndiff --git a/src/test/txpackage_tests.cpp b/src/test/txpackage_tests.cpp\r\nindex 1f167586fe9..fbdaa49f70e 100644\r\n--- a/src/test/txpackage_tests.cpp\r\n+++ b/src/test/txpackage_tests.cpp\r\n@@ -1078,6 +1078,7 @@ BOOST_AUTO_TEST_CASE(package_cpfp_tests)\r\n BOOST_AUTO_TEST_CASE(package_rbf_tests)\r\n {\r\n     mineBlocks(5);\r\n+    MockMempoolMinFee(CFeeRate(1000));\r\n     LOCK(::cs_main);\r\n     size_t expected_pool_size = m_node.mempool->size();\r\n     CKey child_key{GenerateRandomKey()};\r\n@@ -1159,16 +1160,19 @@ BOOST_AUTO_TEST_CASE(package_rbf_tests)\r\n             tx_parent_3, /*input_vout=*/0, /*input_height=*/101,\r\n             child_key, child_spk, coinbase_value - 199 - 1300, /*submit=*/false));\r\n \r\n+        CTransactionRef tx_parent_4 = MakeTransactionRef(CreateValidMempoolTransaction(\r\n+            m_coinbase_txns[1], /*input_vout=*/0, /*input_height=*/0,\r\n+            coinbaseKey, parent_spk, coinbase_value - 1763, /*submit=*/false));\r\n+        CTransactionRef tx_child_4 = MakeTransactionRef(CreateValidMempoolTransaction(\r\n+            tx_parent_4, /*input_vout=*/0, /*input_height=*/101,\r\n+            child_key, child_spk, coinbase_value - 1763 - 60, /*submit=*/false));\r\n+\r\n         // In all packages, the parents conflict with each other\r\n         BOOST_CHECK(tx_parent_1->GetHash() != tx_parent_2->GetHash() && tx_parent_2->GetHash() != tx_parent_3->GetHash());\r\n \r\n         // 1 parent paying 200sat, 1 child paying 200sat.\r\n         Package package1{tx_parent_1, tx_child_1};\r\n-        // 1 parent paying 800sat, 1 child paying 200sat.\r\n-        Package package2{tx_parent_2, tx_child_2};\r\n-        // 1 parent paying 199sat, 1 child paying 1300sat.\r\n-        Package package3{tx_parent_3, tx_child_3};\r\n-\r\n+        {\r\n         const auto submit1 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package1, false, std::nullopt);\r\n         if (auto err_1{CheckPackageMempoolAcceptResult(package1, submit1, /*expect_valid=*/true, m_node.mempool.get())}) {\r\n             BOOST_ERROR(err_1.value());\r\n@@ -1177,11 +1181,20 @@ BOOST_AUTO_TEST_CASE(package_rbf_tests)\r\n         auto it_child_1 = submit1.m_tx_results.find(tx_child_1->GetWitnessHash());\r\n         BOOST_CHECK_EQUAL(it_parent_1->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n         BOOST_CHECK_EQUAL(it_child_1->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n+        // Both validated individually.\r\n+        BOOST_CHECK_EQUAL(it_parent_1->second.m_wtxids_fee_calculations.value().size(), 1);\r\n+        BOOST_CHECK_EQUAL(it_parent_1->second.m_wtxids_fee_calculations.value().front(), tx_parent_1->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_child_1->second.m_wtxids_fee_calculations.value().size(), 1);\r\n+        BOOST_CHECK_EQUAL(it_child_1->second.m_wtxids_fee_calculations.value().front(), tx_child_1->GetWitnessHash());\r\n+        }\r\n         expected_pool_size += 2;\r\n         BOOST_CHECK_EQUAL(m_node.mempool->size(), expected_pool_size);\r\n \r\n         // This replacement is actually not package rbf; the parent carries enough fees\r\n         // to replace the entire package on its own.\r\n+        // 1 parent paying 800sat, 1 child paying 200sat.\r\n+        Package package2{tx_parent_2, tx_child_2};\r\n+        {\r\n         const auto submit2 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package2, false, std::nullopt);\r\n         if (auto err_2{CheckPackageMempoolAcceptResult(package2, submit2, /*expect_valid=*/true, m_node.mempool.get())}) {\r\n             BOOST_ERROR(err_2.value());\r\n@@ -1190,8 +1203,17 @@ BOOST_AUTO_TEST_CASE(package_rbf_tests)\r\n         auto it_child_2 = submit2.m_tx_results.find(tx_child_2->GetWitnessHash());\r\n         BOOST_CHECK_EQUAL(it_parent_2->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n         BOOST_CHECK_EQUAL(it_child_2->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n+        // Both validated individually.\r\n+        BOOST_CHECK_EQUAL(it_parent_2->second.m_wtxids_fee_calculations.value().size(), 1);\r\n+        BOOST_CHECK_EQUAL(it_parent_2->second.m_wtxids_fee_calculations.value().front(), tx_parent_2->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_child_2->second.m_wtxids_fee_calculations.value().size(), 1);\r\n+        BOOST_CHECK_EQUAL(it_child_2->second.m_wtxids_fee_calculations.value().front(), tx_child_2->GetWitnessHash());\r\n+        }\r\n         BOOST_CHECK_EQUAL(m_node.mempool->size(), expected_pool_size);\r\n \r\n+        // 1 parent paying 199sat, 1 child paying 1300sat.\r\n+        Package package3{tx_parent_3, tx_child_3};\r\n+        {\r\n         // Package RBF, in which the replacement transaction's child sponsors the fees to meet RBF feerate rules\r\n         const auto submit3 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package3, false, std::nullopt);\r\n         if (auto err_3{CheckPackageMempoolAcceptResult(package3, submit3, /*expect_valid=*/true, m_node.mempool.get())}) {\r\n@@ -1212,27 +1234,91 @@ BOOST_AUTO_TEST_CASE(package_rbf_tests)\r\n         BOOST_CHECK(it_child_3->second.m_wtxids_fee_calculations.value() == expected_package3_wtxids);\r\n         BOOST_CHECK_EQUAL(it_parent_3->second.m_effective_feerate.value().GetFee(package3_total_vsize), 199 + 1300);\r\n         BOOST_CHECK_EQUAL(it_child_3->second.m_effective_feerate.value().GetFee(package3_total_vsize), 199 + 1300);\r\n-\r\n+        }\r\n         BOOST_CHECK_EQUAL(m_node.mempool->size(), expected_pool_size);\r\n \r\n         // Finally, check that we can prioritise tx_child_1 to get package1 into the mempool.\r\n         // It should not be possible to resubmit package1 and get it in without prioritisation.\r\n+        // 1 parent paying 200sat, 1 child paying 200sat.\r\n+        Package package4{package1};\r\n+        {\r\n         const auto submit4 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package1, false, std::nullopt);\r\n-        if (auto err_4{CheckPackageMempoolAcceptResult(package1, submit4, /*expect_valid=*/false, m_node.mempool.get())}) {\r\n+        if (auto err_4{CheckPackageMempoolAcceptResult(package4, submit4, /*expect_valid=*/false, m_node.mempool.get())}) {\r\n             BOOST_ERROR(err_4.value());\r\n         }\r\n+        }\r\n+\r\n+        // 1 parent paying 200sat, 1 child paying 1563sat.\r\n+        Package package5{package1};\r\n         m_node.mempool->PrioritiseTransaction(tx_child_1->GetHash(), 1363);\r\n-        const auto submit5 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package1, false, std::nullopt);\r\n-        if (auto err_5{CheckPackageMempoolAcceptResult(package1, submit5, /*expect_valid=*/true, m_node.mempool.get())}) {\r\n+        {\r\n+        const auto submit5 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package5, false, std::nullopt);\r\n+        if (auto err_5{CheckPackageMempoolAcceptResult(package5, submit5, /*expect_valid=*/true, m_node.mempool.get())}) {\r\n             BOOST_ERROR(err_5.value());\r\n         }\r\n-        it_parent_1 = submit5.m_tx_results.find(tx_parent_1->GetWitnessHash());\r\n-        it_child_1 = submit5.m_tx_results.find(tx_child_1->GetWitnessHash());\r\n-        BOOST_CHECK_EQUAL(it_parent_1->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n-        BOOST_CHECK_EQUAL(it_child_1->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n-        LOCK(m_node.mempool->cs);\r\n-        BOOST_CHECK(m_node.mempool->GetIter(tx_parent_1->GetHash()).has_value());\r\n-        BOOST_CHECK(m_node.mempool->GetIter(tx_child_1->GetHash()).has_value());\r\n+        auto it_parent_5 = submit5.m_tx_results.find(tx_parent_1->GetWitnessHash());\r\n+        auto it_child_5 = submit5.m_tx_results.find(tx_child_1->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_parent_5->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n+        BOOST_CHECK_EQUAL(it_child_5->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n+        // Validated together.\r\n+        const auto expected_wtxids_5 = std::vector<Wtxid>({tx_parent_1->GetWitnessHash(), tx_child_1->GetWitnessHash()});\r\n+        BOOST_CHECK(it_parent_5->second.m_wtxids_fee_calculations.value() == expected_wtxids_5);\r\n+        BOOST_CHECK(it_child_5->second.m_wtxids_fee_calculations.value() == expected_wtxids_5);\r\n+        const CFeeRate feerate_parent_child_5(1363 + 200 + 200, GetVirtualTransactionSize(*tx_parent_1) + GetVirtualTransactionSize(*tx_child_1));\r\n+        BOOST_CHECK(it_parent_5->second.m_effective_feerate.value() == feerate_parent_child_5);\r\n+        BOOST_CHECK(it_child_5->second.m_effective_feerate.value() == feerate_parent_child_5);\r\n+        }\r\n+        BOOST_CHECK_EQUAL(m_node.mempool->size(), expected_pool_size);\r\n+\r\n+        // Check that the grouping for package RBF does not allow a parent to pay for a child below mempool minimum feerate.\r\n+        // This parent cannot pay for its own replacement, and can get assistance from the child, but the child should\r\n+        // not be eligible for submission at all.\r\n+        // 1 parent paying 1763sat, 1 child paying 60sat.\r\n+        Package package6{tx_parent_4, tx_child_4};\r\n+        {\r\n+        const auto submit6 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package6, false, std::nullopt);\r\n+        if (auto err_6{CheckPackageMempoolAcceptResult(package6, submit6, /*expect_valid=*/false, m_node.mempool.get())}) {\r\n+            BOOST_ERROR(err_6.value());\r\n+        }\r\n+        auto it_parent_6 = submit6.m_tx_results.find(tx_parent_4->GetWitnessHash());\r\n+        auto it_child_6 = submit6.m_tx_results.find(tx_child_4->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_parent_6->second.m_result_type, MempoolAcceptResult::ResultType::INVALID);\r\n+        BOOST_CHECK_EQUAL(it_child_6->second.m_result_type, MempoolAcceptResult::ResultType::INVALID);\r\n+        // Parent does not meet rule 4\r\n+        BOOST_CHECK_EQUAL(it_parent_6->second.m_state.GetResult(), TxValidationResult::TX_RECONSIDERABLE);\r\n+        BOOST_CHECK_EQUAL(it_parent_6->second.m_state.GetRejectReason(), \"insufficient fee\");\r\n+        // Child needs parent's output\r\n+        BOOST_CHECK_EQUAL(it_child_6->second.m_state.GetResult(), TxValidationResult::TX_MISSING_INPUTS);\r\n+        BOOST_CHECK_EQUAL(it_child_6->second.m_state.GetRejectReason(), \"bad-txns-inputs-missingorspent\");\r\n+        }\r\n+        BOOST_CHECK_EQUAL(m_node.mempool->size(), expected_pool_size);\r\n+\r\n+        // It is ok if the child pays fewer fees but subsidizes the parent's replacement cost, as long as the child meets the mempool minimum feerate.\r\n+        // 1 parent paying 1763sat, 1 child paying 160sat.\r\n+        // Even though the parent has a higher feerate, this isn't \"parent pays for child\" because the child meets the mempool minimum feerate.\r\n+        Package package7{package6};\r\n+        m_node.mempool->PrioritiseTransaction(tx_child_4->GetHash(), 100);\r\n+        {\r\n+        const auto submit7 = ProcessNewPackage(m_node.chainman->ActiveChainstate(), *m_node.mempool, package7, false, std::nullopt);\r\n+        if (auto err_7{CheckPackageMempoolAcceptResult(package7, submit7, /*expect_valid=*/true, m_node.mempool.get())}) {\r\n+            BOOST_ERROR(err_7.value());\r\n+        }\r\n+        auto it_parent_7 = submit7.m_tx_results.find(tx_parent_4->GetWitnessHash());\r\n+        auto it_child_7 = submit7.m_tx_results.find(tx_child_4->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_parent_7->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n+        BOOST_CHECK_EQUAL(it_child_7->second.m_result_type, MempoolAcceptResult::ResultType::VALID);\r\n+        // The two transactions were validated together.\r\n+        BOOST_CHECK_EQUAL(it_parent_7->second.m_wtxids_fee_calculations.value().size(), 2);\r\n+        BOOST_CHECK_EQUAL(it_parent_7->second.m_wtxids_fee_calculations.value().front(), tx_parent_4->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_parent_7->second.m_wtxids_fee_calculations.value().back(), tx_child_4->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_child_7->second.m_wtxids_fee_calculations.value().size(), 2);\r\n+        BOOST_CHECK_EQUAL(it_child_7->second.m_wtxids_fee_calculations.value().front(), tx_parent_4->GetWitnessHash());\r\n+        BOOST_CHECK_EQUAL(it_child_7->second.m_wtxids_fee_calculations.value().back(), tx_child_4->GetWitnessHash());\r\n+        const CFeeRate feerate_parent_child_7(1763 + 160, GetVirtualTransactionSize(*tx_parent_4) + GetVirtualTransactionSize(*tx_child_4));\r\n+        BOOST_CHECK(it_parent_7->second.m_effective_feerate.value() == feerate_parent_child_7);\r\n+        BOOST_CHECK(it_child_7->second.m_effective_feerate.value() == feerate_parent_child_7);\r\n+        }\r\n+        BOOST_CHECK_EQUAL(m_node.mempool->size(), expected_pool_size);\r\n     }\r\n }\r\n BOOST_AUTO_TEST_SUITE_END()\r\ndiff --git a/src/validation.cpp b/src/validation.cpp\r\nindex 1102f2bb051..508892faea2 100644\r\n--- a/src/validation.cpp\r\n+++ b/src/validation.cpp\r\n@@ -1048,8 +1048,23 @@ bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txn\r\n         return package_state.Invalid(PackageValidationResult::PCKG_POLICY, \"package RBF failed: package must be 1-parent-1-child\");\r\n     }\r\n \r\n-    // If the package has in-mempool parents, we won't consider a package RBF\r\n-    // since it would result in a cluster larger than 2.\r\n+    // Use the child as the transaction for attributing errors because it is presumably sponsoring this package RBF.\r\n+    auto& child_ws = workspaces[1];\r\n+    const Txid& child_hash = child_ws.m_ptx->GetHash();\r\n+\r\n+    // Check if this child is eligible to be a sponsor. We allow a child with a lower feerate than that of its\r\n+    // parents (and thus only helping pay for the replacement). However, the child itself must meet the mempool minimum\r\n+    // feerate, otherwise it would sponsor this replacement, potentially using the parents' fees to pay for its entry,\r\n+    // but be immediately evicted next time we trim the mempool.\r\n+    if (!CheckFeeRate(child_ws.m_vsize, child_ws.m_modified_fees, child_ws.m_state)) {\r\n+        // Add the CheckFeeRate error as the debug string.\r\n+        return package_state.Invalid(PackageValidationResult::PCKG_POLICY,\r\n+                                     \"package RBF failed: child cannot sponsor because it does not meet mempool minimum feerate\",\r\n+                                     child_ws.m_state.ToString());\r\n+    }\r\n+\r\n+\r\n+    // If the package has in-mempool parents, we won't consider a package RBF for now.\r\n     // N.B. To relax this constraint we will need to revisit how CCoinsViewMemPool::PackageAddTransaction\r\n     // is being used inside AcceptMultipleTransactions to track available inputs while processing a package.\r\n     // Specifically we would need to check that the ancestors of the new\r\n@@ -1062,6 +1077,7 @@ bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txn\r\n         }\r\n     }\r\n \r\n+    // The remaining checks are similar to those for a single transaction's replacement(s).\r\n     // Aggregate all conflicts into one set.\r\n     CTxMemPool::setEntries direct_conflict_iters;\r\n     for (Workspace& ws : workspaces) {\r\n@@ -1069,9 +1085,6 @@ bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txn\r\n         direct_conflict_iters.merge(ws.m_iters_conflicting);\r\n     }\r\n \r\n-    const auto& parent_ws = workspaces[0];\r\n-    const auto& child_ws = workspaces[1];\r\n-\r\n     // Don't consider replacements that would cause us to remove a large number of mempool entries.\r\n     // This limit is not increased in a package RBF. Use the aggregate number of transactions.\r\n     CTxMemPool::setEntries all_conflicts;\r\n@@ -1087,8 +1100,6 @@ bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txn\r\n         m_subpackage.m_conflicting_size += it->GetTxSize();\r\n     }\r\n \r\n-    // Use the child as the transaction for attributing errors to.\r\n-    const Txid& child_hash = child_ws.m_ptx->GetHash();\r\n     if (const auto err_string{PaysForRBF(/*original_fees=*/m_subpackage.m_conflicting_fees,\r\n                                          /*replacement_fees=*/m_subpackage.m_total_modified_fees,\r\n                                          /*replacement_vsize=*/m_subpackage.m_total_vsize,\r\n@@ -1097,16 +1108,6 @@ bool MemPoolAccept::PackageMempoolChecks(const std::vector<CTransactionRef>& txn\r\n                                      \"package RBF failed: insufficient anti-DoS fees\", *err_string);\r\n     }\r\n \r\n-    // Ensure this two transaction package is a \"chunk\" on its own; we don't want the child\r\n-    // to be only paying anti-DoS fees\r\n-    const CFeeRate parent_feerate(parent_ws.m_modified_fees, parent_ws.m_vsize);\r\n-    const CFeeRate package_feerate(m_subpackage.m_total_modified_fees, m_subpackage.m_total_vsize);\r\n-    if (package_feerate <= parent_feerate) {\r\n-        return package_state.Invalid(PackageValidationResult::PCKG_POLICY,\r\n-                                     \"package RBF failed: package feerate is less than or equal to parent feerate\",\r\n-                                     strprintf(\"package feerate %s <= parent feerate is %s\", package_feerate.ToString(), parent_feerate.ToString()));\r\n-    }\r\n-\r\n     // Check if it's economically rational to mine this package rather than the ones it replaces.\r\n     // This takes the place of ReplacementChecks()'s PaysMoreThanConflicts() in the package RBF setting.\r\n     if (const auto err_tup{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\r\ndiff --git a/test/functional/mempool_package_rbf.py b/test/functional/mempool_package_rbf.py\r\nindex 759e3cb07d3..c1983cab57b 100755\r\n--- a/test/functional/mempool_package_rbf.py\r\n+++ b/test/functional/mempool_package_rbf.py\r\n@@ -178,14 +178,10 @@ class PackageRBFTest(BitcoinTestFramework):\r\n         package_hex4, package_txns4 = self.create_simple_package(coin, parent_fee=DEFAULT_FEE, child_fee=DEFAULT_CHILD_FEE)\r\n         node.submitpackage(package_hex4)\r\n         self.assert_mempool_contents(expected=package_txns4)\r\n-        package_hex5, _package_txns5 = self.create_simple_package(coin, parent_fee=DEFAULT_CHILD_FEE, child_fee=DEFAULT_CHILD_FEE)\r\n-        pkg_results5 = node.submitpackage(package_hex5)\r\n-        assert 'package RBF failed: package feerate is less than or equal to parent feerate' in pkg_results5[\"package_msg\"]\r\n-        self.assert_mempool_contents(expected=package_txns4)\r\n+        package_hex5, package_txns5 = self.create_simple_package(coin, parent_fee=DEFAULT_CHILD_FEE + DEFAULT_FEE, child_fee=DEFAULT_CHILD_FEE)\r\n+        node.submitpackage(package_hex5)\r\n+        self.assert_mempool_contents(expected=package_txns5)\r\n \r\n-        package_hex5_1, package_txns5_1 = self.create_simple_package(coin, parent_fee=DEFAULT_CHILD_FEE, child_fee=DEFAULT_CHILD_FEE + Decimal(\"0.00000001\"))\r\n-        node.submitpackage(package_hex5_1)\r\n-        self.assert_mempool_contents(expected=package_txns5_1)\r\n         self.generate(node, 1)\r\n \r\n     def test_package_rbf_max_conflicts(self):\r\n\r\n```\r\n</details>",
      "created_at": "2025-10-17T20:17:57Z",
      "updated_at": "2025-10-17T23:14:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2441138984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2441138984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443315198",
      "pull_request_review_id": 3354528508,
      "id": 2443315198,
      "node_id": "PRRC_kwDOABII586Rogf-",
      "diff_hunk": "@@ -547,7 +547,7 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n         AddToMempool(pool, entry.Fee(100LL).FromTx(tx5));\n     AddToMempool(pool, entry.Fee(900LL).FromTx(tx7));\n \n-    pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7\n+    pool.TrimToSize(pool.DynamicMemoryUsage() * 0.75); // should maximize mempool size by only removing 5/7",
      "path": "src/test/mempool_tests.cpp",
      "position": 1,
      "original_position": 5,
      "commit_id": "d3f8b6380f165e44fa0aa5e2f2b7b75a28087b38",
      "original_commit_id": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48",
      "in_reply_to_id": 2432516613,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This test is further updated in a later commit in this PR -- please let me know what you think of the state it ends up in and if it could use further improvements.",
      "created_at": "2025-10-19T13:31:21Z",
      "updated_at": "2025-10-19T13:31:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2443315198",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443315198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 550,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443316513",
      "pull_request_review_id": 3354529645,
      "id": 2443316513,
      "node_id": "PRRC_kwDOABII586Rog0h",
      "diff_hunk": "@@ -719,10 +719,16 @@ class ChainImpl : public Chain\n     util::Result<void> checkChainLimits(const CTransactionRef& tx) override\n     {\n         if (!m_node.mempool) return {};\n-        LockPoints lp;\n-        CTxMemPoolEntry entry(TxGraph::Ref(), tx, 0, 0, 0, 0, false, 0, lp);\n         LOCK(m_node.mempool->cs);\n-        return m_node.mempool->CheckPackageLimits({tx}, entry.GetTxSize());\n+        // Use CTxMemPool's ChangeSet interface to check whether the chain\n+        // limits would be violated. Note that the changeset will be destroyed\n+        // when it goes out of scope.\n+        auto changeset = m_node.mempool->GetChangeSet();",
      "path": "src/node/interfaces.cpp",
      "position": 68,
      "original_position": 11,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1102ac7f74ac2f48760b46be58c7deb70fa727cf",
      "in_reply_to_id": 2432661442,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Seems redundant, given that we have an `EXCLUSIVE_LOCKS_REQUIRED` annotation on `GetChangeSet()` already? Will leave this as-is.",
      "created_at": "2025-10-19T13:34:43Z",
      "updated_at": "2025-10-19T13:34:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2443316513",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443316513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 723,
      "original_line": 723,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443318588",
      "pull_request_review_id": 3354531518,
      "id": 2443318588,
      "node_id": "PRRC_kwDOABII586RohU8",
      "diff_hunk": "@@ -219,224 +205,88 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (const auto tx : txs) {\n+        if (!IsFinalTx(tx.get().GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    selected_transactions.reserve(MAX_CLUSTER_COUNT_LIMIT);\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    // This fills selected_transactions\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);\n \n-        if (packageFees < m_options.blockMinFeeRate.GetFee(packageSize)) {\n-            // Everything else we might consider has a lower fee rate\n+    while (selected_transactions.size() > 0) {\n+        // Check to see if min fee rate is still respected.\n+        if (chunk_feerate.fee < m_options.blockMinFeeRate.GetFee(chunk_feerate_vsize.size)) {\n+            // Everything else we might consider has a lower feerate\n             return;\n         }\n \n-        if (!TestPackage(packageSize, packageSigOpsCost)) {\n-            if (fUsingModified) {\n-                // Since we always look at the best entry in mapModifiedTx,\n-                // we must erase failed entries so that we can consider the\n-                // next best entry on the next loop iteration\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter->GetSharedTx()->GetHash());\n-            }\n+        int64_t package_sig_ops = 0;\n+        for (const auto& tx : selected_transactions) {\n+            package_sig_ops += tx.get().GetSigOpCost();\n+        }\n \n+        // Check to see if this chunk will fit.\n+        if (!TestPackage(chunk_feerate, package_sig_ops) || !TestPackageTransactions(selected_transactions)) {\n+            m_mempool->SkipBuilderChunk();\n+            // This chunk won't fit, so we let it be removed from the heap and\n+            // we'll try the next best.\n             ++nConsecutiveFailed;\n \n             if (nConsecutiveFailed > MAX_CONSECUTIVE_FAILURES && nBlockWeight +\n                     BLOCK_FULL_ENOUGH_WEIGHT_DELTA > m_options.nBlockMaxWeight) {\n                 // Give up if we're close to full and haven't succeeded in a while\n-                break;\n+                return;\n             }\n-            continue;\n-        }\n-\n-        auto ancestors{mempool.AssumeCalculateMemPoolAncestors(__func__, *iter, CTxMemPool::Limits::NoLimits(), /*fSearchForParents=*/false)};\n-\n-        onlyUnconfirmed(ancestors);\n-        ancestors.insert(iter);\n+        } else {\n+            m_mempool->IncludeBuilderChunk();\n \n-        // Test if all tx's are Final\n-        if (!TestPackageTransactions(ancestors)) {\n-            if (fUsingModified) {\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter->GetSharedTx()->GetHash());\n+            // This chunk will fit, so add it to the block.\n+            nConsecutiveFailed = 0;\n+            for (const auto& tx : selected_transactions) {\n+                AddToBlock(tx);\n             }\n-            continue;\n+            pblocktemplate->m_package_feerates.emplace_back(chunk_feerate_vsize);\n         }\n \n-        // This transaction will make it in; reset the failed counter.\n-        nConsecutiveFailed = 0;\n-\n-        // Package can be added. Sort the entries in a valid order.\n-        std::vector<CTxMemPool::txiter> sortedEntries;\n-        SortForBlock(ancestors, sortedEntries);\n-\n-        for (size_t i = 0; i < sortedEntries.size(); ++i) {\n-            AddToBlock(sortedEntries[i]);\n-            // Erase from the modified set, if present\n-            mapModifiedTx.erase(sortedEntries[i]);\n-        }\n-\n-        ++nPackagesSelected;\n-        pblocktemplate->m_package_feerates.emplace_back(packageFees, static_cast<int32_t>(packageSize));\n-\n-        // Update transactions that depend on each of these\n-        nDescendantsUpdated += UpdatePackagesForAdded(mempool, ancestors, mapModifiedTx);\n+        selected_transactions.clear();",
      "path": "src/node/miner.cpp",
      "position": 329,
      "original_position": 321,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "a8be743aeb42ec8ab613f822989a11a2f2ce70ac",
      "in_reply_to_id": 2436033865,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`clear()` doesn't change the capacity of the vector, so there's no need to `reserve()` again.",
      "created_at": "2025-10-19T13:40:25Z",
      "updated_at": "2025-10-19T13:40:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2443318588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443318588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 287,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443321045",
      "pull_request_review_id": 3354533440,
      "id": 2443321045,
      "node_id": "PRRC_kwDOABII586Roh7V",
      "diff_hunk": "@@ -21,8 +21,8 @@\n class CFeeRate;\n class uint256;\n \n-/** Maximum number of transactions that can be replaced by RBF (Rule #5). This includes all\n- * mempool conflicts and their descendants. */\n+/** Maximum number of unique clusters that can be affected by an RBF (Rule #5);",
      "path": "src/policy/rbf.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2436313337,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is a reference to Rule #5 in `doc/policy/mempool-replacements.md`.",
      "created_at": "2025-10-19T13:45:50Z",
      "updated_at": "2025-10-19T13:45:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2443321045",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443321045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 24,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443329464",
      "pull_request_review_id": 3354540350,
      "id": 2443329464,
      "node_id": "PRRC_kwDOABII586Roj-4",
      "diff_hunk": "@@ -535,49 +535,64 @@ CMutableTransaction TestChain100Setup::CreateValidMempoolTransaction(CTransactio\n std::vector<CTransactionRef> TestChain100Setup::PopulateMempool(FastRandomContext& det_rand, size_t num_transactions, bool submit)\n {\n     std::vector<CTransactionRef> mempool_transactions;\n-    std::deque<std::pair<COutPoint, CAmount>> unspent_prevouts;\n+    std::deque<std::pair<COutPoint, CAmount>> unspent_prevouts, undo_info;",
      "path": "src/test/util/setup_common.cpp",
      "position": 14,
      "original_position": 5,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "afb9003bc602a77ed15bf4e79277d960937a5c28",
      "in_reply_to_id": 2436048271,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think \"spent\" would be confusing, as the purpose of this object is to store the data needed to undo the removal of a utxo from the unspent_prevouts list, in the event that a transaction spending the prevout fails to get into the mempool.",
      "created_at": "2025-10-19T14:05:39Z",
      "updated_at": "2025-10-19T14:05:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2443329464",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443329464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 538,
      "original_line": 538,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443345859",
      "pull_request_review_id": 3354554984,
      "id": 2443345859,
      "node_id": "PRRC_kwDOABII586Ron_D",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Not sure I follow the reasoning here -- an RBF that fails due to cluster size limits might succeed if a child is added that adds additional conflicts, thereby making space in the affected cluster.\r\n\r\nEDIT: Oh -- I guess your point is that a transaction which is NOT an RBF might fail due to cluster size limits, and not be treated as RECONSIDERABLE even though a child might be able to free up cluster space as well by introducing new conflicts...  That seems like a reasonable objection, but it's not clear to me the best way to address.",
      "created_at": "2025-10-19T14:44:43Z",
      "updated_at": "2025-10-19T14:46:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2443345859",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2443345859"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2445023085",
      "pull_request_review_id": 3356474129,
      "id": 2445023085,
      "node_id": "PRRC_kwDOABII586RvBdt",
      "diff_hunk": "@@ -59,8 +59,8 @@ class LOCKABLE Epoch\n     public:\n         Marker() = default;\n         Marker(const Marker&) = default;\n-        Marker(Marker&&) = delete;\n-        Marker& operator=(Marker&&) = delete;\n+        Marker(Marker&&) = default;",
      "path": "src/util/epochguard.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "51430680ecb722e1d4ee4a26dac5724050f41c9e",
      "in_reply_to_id": 2432642810,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "CTxMemPoolEntry seems to only need to be movable for `mempool_entries.emplace_back(ConsumeTxMempoolEntry(...))` in test/fuzz/policy_estimator.cpp.\r\n\r\nI'm a bit surprised `Ref::operator=(Ref&&)` isn't virtual -- moving a Ref that might actually a mempool entry seems dangerous; but otoh, moving by operator= only seems to be used in fuzz/txgraph.cpp, which means we don't actually move anything that's not just a Ref.",
      "created_at": "2025-10-20T13:27:38Z",
      "updated_at": "2025-10-20T13:27:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2445023085",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2445023085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 62,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2445998747",
      "pull_request_review_id": 3357768810,
      "id": 2445998747,
      "node_id": "PRRC_kwDOABII586Ryvqb",
      "diff_hunk": "",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441138984,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Agreed, though I think this type of behavior change regarding what packages we accept can happen in a separate PR after cluster mempool. (In particular I think it's worth a separate discussion around what use cases we would be trying to enable with such a change.)",
      "created_at": "2025-10-20T20:07:48Z",
      "updated_at": "2025-10-20T20:08:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2445998747",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2445998747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2446016715",
      "pull_request_review_id": 3357793891,
      "id": 2446016715,
      "node_id": "PRRC_kwDOABII586Ry0DL",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm inclined to implement your suggestion, so that any cluster size limit failures are treated as non-RECONSIDERABLE for now.  TRUC transactions would never hit these cluster limits, so users who would be concerned about cluster size limits as a potential pinning vector for CPFP packages already have a mechanism to avoid it.\r\n\r\n(I also considered having all cluster size limits being treated as RECONSIDERABLE, but decided that is also not great, partly because we certainly shouldn't let a transaction whose cluster size just with its own unconfirmed ancestors be treated as RECONSIDERABLE, and I didn't want to spend a lot of time trying to figure out if there might be some DoS vector that opened up as a result.)\r\n\r\nWe can try to improve on this behavior in the future if there are use cases that would need smarter behavior here; but for now this would be consistent with how the mempool's ancestor/descendant limits have always worked anyway.",
      "created_at": "2025-10-20T20:15:29Z",
      "updated_at": "2025-10-20T20:15:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2446016715",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2446016715"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2446843163",
      "pull_request_review_id": 3358902693,
      "id": 2446843163,
      "node_id": "PRRC_kwDOABII586R190b",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> we certainly shouldn't let a transaction whose cluster size just with its own unconfirmed ancestors be treated as RECONSIDERABLE,\r\n\r\ncertainly seems like Future Kindred Eviction Work, agreed on distinguishing error types and not attempting a package RBF in this case.",
      "created_at": "2025-10-21T06:26:01Z",
      "updated_at": "2025-10-21T06:26:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2446843163",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2446843163"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447496922",
      "pull_request_review_id": 3359709468,
      "id": 2447496922,
      "node_id": "PRRC_kwDOABII586R4dba",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> I also considered having all cluster size limits being treated as RECONSIDERABLE, but decided that is also not great, partly because we certainly shouldn't let a transaction whose cluster size just with its own unconfirmed ancestors be treated as RECONSIDERABLE\r\n\r\n definitely think we should not allow reconsideration in that case\r\n\r\nSounds good to me to make it non-reconsiderable for now, and maybe change it in the future in a consistent way. I agree it's possible for a child to make a tx no longer break cluster limits, but it's not clear to me how important it is to support that case.",
      "created_at": "2025-10-21T09:35:22Z",
      "updated_at": "2025-10-21T09:35:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2447496922",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447496922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447498384",
      "pull_request_review_id": 3359711267,
      "id": 2447498384,
      "node_id": "PRRC_kwDOABII586R4dyQ",
      "diff_hunk": "",
      "path": "src/validation.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441138984,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Great, marking resolved and will refer to this in a followup!",
      "created_at": "2025-10-21T09:35:55Z",
      "updated_at": "2025-10-21T09:35:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2447498384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447498384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447930605",
      "pull_request_review_id": 3360272954,
      "id": 2447930605,
      "node_id": "PRRC_kwDOABII586R6HTt",
      "diff_hunk": "@@ -74,12 +74,11 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\n     // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n     for (const auto& txiter : cluster) {\n         if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n-            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(),\n-                MiniMinerMempoolEntry{/*tx_in=*/txiter->GetSharedTx(),\n-                                      /*vsize_self=*/txiter->GetTxSize(),\n-                                      /*vsize_ancestor=*/txiter->GetSizeWithAncestors(),\n-                                      /*fee_self=*/txiter->GetModifiedFee(),\n-                                      /*fee_ancestor=*/txiter->GetModFeesWithAncestors()});\n+            size_t ancestor_count{0};\n+            size_t ancestor_size{0};\n+            CAmount ancestor_fee{0};\n+            mempool.CalculateAncestorData(*txiter, ancestor_count, ancestor_size, ancestor_fee);\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter->GetSharedTx(), txiter->GetTxSize(), int64_t(ancestor_size), txiter->GetModifiedFee(), ancestor_fee));",
      "path": "src/node/mini_miner.cpp",
      "position": 1,
      "original_position": 14,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "729cec4f6ddb880210b7e0011fff8b0a5f88c933",
      "in_reply_to_id": 2436069486,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "After cluster mempool, mini_miner should be modified anyway (and I think this whole MiniMinerMempoolEntry object will disappear, see for example my draft [here](https://github.com/bitcoin/bitcoin/commit/d24f02699ec4af215a4ffae3a2ae2457f71bf93f#diff-5dfb364874cfa42dd98492c3c3c1b07aafbe73ef7ecd895246d2fea00499fd6c)).  So I don't think it's worth re-implementing a new interface in this PR.",
      "created_at": "2025-10-21T12:09:56Z",
      "updated_at": "2025-10-21T12:10:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2447930605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447930605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447949351",
      "pull_request_review_id": 3360297451,
      "id": 2447949351,
      "node_id": "PRRC_kwDOABII586R6L4n",
      "diff_hunk": "@@ -665,10 +665,7 @@ class ChainImpl : public Chain\n     bool hasDescendantsInMempool(const Txid& txid) override\n     {\n         if (!m_node.mempool) return false;\n-        LOCK(m_node.mempool->cs);\n-        const auto entry{m_node.mempool->GetEntry(txid)};\n-        if (entry == nullptr) return false;\n-        return entry->GetCountWithDescendants() > 1;\n+        return m_node.mempool->HasDescendants(txid);",
      "path": "src/node/interfaces.cpp",
      "position": 31,
      "original_position": 8,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "b23b156c7bdf112a4fe64acd71e398cc7c0bd231",
      "in_reply_to_id": 2440284422,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can you clarify what you have in mind here?",
      "created_at": "2025-10-21T12:14:24Z",
      "updated_at": "2025-10-21T12:14:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2447949351",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2447949351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 668,
      "original_line": 668,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448512960",
      "pull_request_review_id": 3361044413,
      "id": 2448512960,
      "node_id": "PRRC_kwDOABII586R8VfA",
      "diff_hunk": "@@ -21,6 +21,8 @@\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n \n MAX_REPLACEMENT_LIMIT = 100\n+MAX_CLUSTER_LIMIT = 64",
      "path": "test/functional/feature_rbf.py",
      "position": 1,
      "original_position": 4,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "429bdbecfde93c54374fb3098e357e18556e7e21",
      "in_reply_to_id": 2432321152,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-21T14:14:02Z",
      "updated_at": "2025-10-21T14:14:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448512960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448512960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448515450",
      "pull_request_review_id": 3361048475,
      "id": 2448515450,
      "node_id": "PRRC_kwDOABII586R8WF6",
      "diff_hunk": "@@ -220,7 +220,7 @@ def test_chainlimits_exceeded(self):\n \n     def run_test(self):\n         # Mine in batches of 25 to test multi-block reorg under chain limits\n-        self.transaction_graph_test(size=CUSTOM_ANCESTOR_COUNT, n_tx_to_mine=[25, 50, 75])\n+        self.transaction_graph_test(size=64, n_tx_to_mine=[25, 50, 75])",
      "path": "test/functional/mempool_updatefromblock.py",
      "position": 1,
      "original_position": 28,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "5a388c0d595b2318fea4b1dce977e2d5ff1abc48",
      "in_reply_to_id": 2432430377,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-21T14:14:27Z",
      "updated_at": "2025-10-21T14:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448515450",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448515450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448518145",
      "pull_request_review_id": 3361052630,
      "id": 2448518145,
      "node_id": "PRRC_kwDOABII586R8WwB",
      "diff_hunk": "@@ -195,29 +100,23 @@ class BlockAssembler\n     /** Clear the block's state and prepare for assembling a new block */\n     void resetBlock();\n     /** Add a tx to the block */\n-    void AddToBlock(CTxMemPool::txiter iter);\n+    void AddToBlock(const CTxMemPoolEntry& entry);\n \n     // Methods for how to add transactions to a block.\n-    /** Add transactions based on feerate including unconfirmed ancestors\n-      * Increments nPackagesSelected / nDescendantsUpdated with corresponding\n-      * statistics from the package selection (for logging statistics).\n+    /** Add transactions based on chunk feerate\n       *\n       * @pre BlockAssembler::m_mempool must not be nullptr\n     */\n-    void addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated) EXCLUSIVE_LOCKS_REQUIRED(!m_mempool->cs);\n+    void addChunks() EXCLUSIVE_LOCKS_REQUIRED(m_mempool->cs);\n \n     // helper functions for addPackageTxs()",
      "path": "src/node/miner.h",
      "position": 1,
      "original_position": 129,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "a8be743aeb42ec8ab613f822989a11a2f2ce70ac",
      "in_reply_to_id": 2435934233,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-21T14:14:59Z",
      "updated_at": "2025-10-21T14:14:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448518145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448518145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448551580",
      "pull_request_review_id": 3361100658,
      "id": 2448551580,
      "node_id": "PRRC_kwDOABII586R8e6c",
      "diff_hunk": "@@ -333,14 +330,9 @@ def test_new_unconfirmed_inputs(self):\n         )[\"tx\"]\n         tx2_hex = tx2.serialize().hex()\n \n-        # This will raise an exception\n-        reject_reason = \"replacement-adds-unconfirmed\"\n-        reject_details = f\"{reject_reason}, replacement {tx2.txid_hex} adds unconfirmed input, idx 1\"\n-        res = self.nodes[0].testmempoolaccept(rawtxs=[tx2_hex])[0]\n-        assert_equal(res[\"reject-reason\"], reject_reason)\n-        assert_equal(res[\"reject-details\"], reject_details)\n-        assert_raises_rpc_error(-26, f\"{reject_details}\", self.nodes[0].sendrawtransaction, tx2_hex, 0)\n-\n+        # This will not raise an exception\n+        tx2_id = self.nodes[0].sendrawtransaction(tx2_hex, 0)\n+        assert tx2_id in self.nodes[0].getrawmempool()\n \n     def test_too_many_replacements(self):\n         \"\"\"Replacements that evict too many transactions are rejected\"\"\"",
      "path": "test/functional/feature_rbf.py",
      "position": 1,
      "original_position": 57,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2436396593,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed this in a couple of places, should be good now I think.",
      "created_at": "2025-10-21T14:22:41Z",
      "updated_at": "2025-10-21T14:22:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448551580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448551580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448553286",
      "pull_request_review_id": 3361103076,
      "id": 2448553286,
      "node_id": "PRRC_kwDOABII586R8fVG",
      "diff_hunk": "@@ -57,28 +57,35 @@ struct ParentInfo {\n \n std::optional<std::string> PackageTRUCChecks(const CTxMemPool& pool, const CTransactionRef& ptx, int64_t vsize,\n                                            const Package& package,\n-                                           const CTxMemPool::setEntries& mempool_ancestors)\n+                                           const std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef>& mempool_parents)\n {\n     // This function is specialized for these limits, and must be reimplemented if they ever change.\n     static_assert(TRUC_ANCESTOR_LIMIT == 2);\n     static_assert(TRUC_DESCENDANT_LIMIT == 2);\n \n     const auto in_package_parents{FindInPackageParents(package, ptx)};\n \n-    // Now we have all ancestors, so we can start checking TRUC rules.\n+    // Now we have all parents, so we can start checking TRUC rules.\n     if (ptx->version == TRUC_VERSION) {\n         // SingleTRUCChecks should have checked this already.\n         if (!Assume(vsize <= TRUC_MAX_VSIZE)) {\n             return strprintf(\"version=3 tx %s (wtxid=%s) is too big: %u > %u virtual bytes\",\n                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString(), vsize, TRUC_MAX_VSIZE);\n         }\n \n-        if (mempool_ancestors.size() + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {\n+        if (mempool_parents.size() + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {\n             return strprintf(\"tx %s (wtxid=%s) would have too many ancestors\",\n                              ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString());\n         }\n \n-        const bool has_parent{mempool_ancestors.size() + in_package_parents.size() > 0};\n+        if (mempool_parents.size()) {\n+            if (pool.GetNumAncestors(mempool_parents[0]) + in_package_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {",
      "path": "src/policy/truc_policy.cpp",
      "position": 33,
      "original_position": 30,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "in_reply_to_id": 2436500068,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Updated the commit message.",
      "created_at": "2025-10-21T14:23:06Z",
      "updated_at": "2025-10-21T14:23:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448553286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448553286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 82,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448557208",
      "pull_request_review_id": 3361108361,
      "id": 2448557208,
      "node_id": "PRRC_kwDOABII586R8gSY",
      "diff_hunk": "@@ -1274,135 +1274,15 @@ std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txi\n     return clustered_txs;\n }\n \n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n-    }\n-    return std::nullopt;\n-}\n-\n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n \n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};",
      "path": "src/txmempool.cpp",
      "position": 1082,
      "original_position": 52,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2440839627,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 845ec3a3f806dee6c9ad053655fb466bd599a73d",
      "created_at": "2025-10-21T14:24:12Z",
      "updated_at": "2025-10-21T14:24:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448557208",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448557208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1305,
      "original_line": 1305,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448557622",
      "pull_request_review_id": 3361108970,
      "id": 2448557622,
      "node_id": "PRRC_kwDOABII586R8gY2",
      "diff_hunk": "@@ -12,12 +12,7 @@ other consensus and policy rules, each of the following conditions are met:\n \n 1. (Removed)\n \n-2. The replacement transaction only include an unconfirmed input if that input was included in\n-   one of the directly conflicting transactions. An unconfirmed input spends an output from a\n-   currently-unconfirmed transaction.\n-\n-   *Rationale*: When RBF was originally implemented, the mempool did not keep track of\n-   ancestor feerates yet. This rule was suggested as a temporary restriction.\n+2. [REDACTED]",
      "path": "doc/policy/mempool-replacements.md",
      "position": 1,
      "original_position": 10,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "fba5200d59af87db240a1b061f995c63b0ed5ee8",
      "in_reply_to_id": 2440892816,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-21T14:24:22Z",
      "updated_at": "2025-10-21T14:24:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448557622",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448557622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448561421",
      "pull_request_review_id": 3361114673,
      "id": 2448561421,
      "node_id": "PRRC_kwDOABII586R8hUN",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Implemented this change in 1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a. Should I try to squash this into place or is this fine as its own commit?",
      "created_at": "2025-10-21T14:25:37Z",
      "updated_at": "2025-10-21T14:25:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448561421",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448561421"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448565249",
      "pull_request_review_id": 3361119993,
      "id": 2448565249,
      "node_id": "PRRC_kwDOABII586R8iQB",
      "diff_hunk": "@@ -5426,7 +5426,7 @@ class CompareInvMempoolOrder\n     {\n         /* As std::make_heap produces a max-heap, we want the entries with the\n          * fewest ancestors/highest fee to sort later. */",
      "path": "src/net_processing.cpp",
      "position": 1,
      "original_position": 3,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "936f04e770eeb4ef8477722cb1f23f29746883a1",
      "in_reply_to_id": 2440116718,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-21T14:26:46Z",
      "updated_at": "2025-10-21T14:26:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448565249",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448565249"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5428,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448566519",
      "pull_request_review_id": 3361121447,
      "id": 2448566519,
      "node_id": "PRRC_kwDOABII586R8ij3",
      "diff_hunk": "@@ -733,7 +734,7 @@ void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendhei\n                 assert(tx2.vout.size() > txin.prevout.n && !tx2.vout[txin.prevout.n].IsNull());\n                 setParentCheck.insert(*it2);\n             }\n-            // We are iterating through the mempool entries sorted in order by ancestor count.\n+            // We are iterating through the mempool entries sorted topologically and by score.",
      "path": "src/txmempool.cpp",
      "position": 1,
      "original_position": 20,
      "commit_id": "10872f7ec923803f711cd2c3af93a0e17121330e",
      "original_commit_id": "9b31836abfc086e4693ecdb1ceaec0a8e21dbb8f",
      "in_reply_to_id": 2440174148,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-10-21T14:27:06Z",
      "updated_at": "2025-10-21T14:27:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448566519",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448566519"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 737,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448573573",
      "pull_request_review_id": 3361131824,
      "id": 2448573573,
      "node_id": "PRRC_kwDOABII586R8kSF",
      "diff_hunk": "@@ -228,6 +228,16 @@ def test_nondefault_package_limits(self):\n         assert_equal(node.getmempoolentry(tx_v3_parent_large1[\"txid\"])[\"descendantcount\"], 1)\n         self.generate(node, 1)\n \n+        self.log.info(\"Test that a decreased limitclustersize also applies to TRUC child\")\n+        self.restart_node(0, extra_args=[\"-limitclustersize=10\", \"-acceptnonstdtxn=1\"])\n+        tx_v3_parent_large2 = self.wallet.send_self_transfer(from_node=node, target_vsize=parent_target_vsize, version=3)\n+        tx_v3_child_large2 = self.wallet.create_self_transfer(utxo_to_spend=tx_v3_parent_large2[\"new_utxo\"], target_vsize=child_target_vsize, version=3)\n+        # Parent and child are within TRUC limits\n+        assert_greater_than_or_equal(TRUC_MAX_VSIZE, tx_v3_parent_large2[\"tx\"].get_vsize())\n+        assert_greater_than_or_equal(TRUC_CHILD_MAX_VSIZE, tx_v3_child_large2[\"tx\"].get_vsize())\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, tx_v3_child_large2[\"hex\"])\n+        self.check_mempool([tx_v3_parent_large2[\"txid\"]])",
      "path": "test/functional/mempool_truc.py",
      "position": 63,
      "original_position": 12,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "cf2f5211a8fab1438feb1cf1ccb86dccedd4b6c8",
      "in_reply_to_id": 2440265397,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I took this change but I just realized that this is redundant with the first test that appears earlier in this function, right?  ",
      "created_at": "2025-10-21T14:29:08Z",
      "updated_at": "2025-10-21T14:29:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448573573",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448573573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 241,
      "original_line": 241,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448612169",
      "pull_request_review_id": 3361185279,
      "id": 2448612169,
      "node_id": "PRRC_kwDOABII586R8ttJ",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I prefer a squash but up to you.",
      "created_at": "2025-10-21T14:40:27Z",
      "updated_at": "2025-10-21T14:40:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2448612169",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2448612169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450631707",
      "pull_request_review_id": 3363955723,
      "id": 2450631707,
      "node_id": "PRRC_kwDOABII586SEawb",
      "diff_hunk": "@@ -1230,180 +902,131 @@ void CTxMemPool::SetLoadTried(bool load_tried)\n std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txid>& txids) const\n {\n     AssertLockHeld(cs);\n-    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n-    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n-    // necessarily mean the entry has been processed.\n-    WITH_FRESH_EPOCH(m_epoch);\n-    for (const auto& it : clustered_txs) {\n-        visited(it);\n-    }\n-    // i = index of where the list of entries to process starts\n-    for (size_t i{0}; i < clustered_txs.size(); ++i) {\n-        // DoS protection: if there are 500 or more entries to process, just quit.\n-        if (clustered_txs.size() > 500) return {};\n-        const txiter& tx_iter = clustered_txs.at(i);\n-        for (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\n-            for (const CTxMemPoolEntry& entry : entries) {\n-                const auto entry_it = mapTx.iterator_to(entry);\n-                if (!visited(entry_it)) {\n-                    clustered_txs.push_back(entry_it);\n+\n+    std::vector<CTxMemPool::txiter> ret;\n+    std::set<const CTxMemPoolEntry*> unique_cluster_representatives;\n+    for (auto txid : txids) {\n+        auto it = mapTx.find(txid);\n+        if (it != mapTx.end()) {\n+            auto cluster = m_txgraph->GetCluster(*it, TxGraph::Level::MAIN);\n+            if (unique_cluster_representatives.insert(static_cast<const CTxMemPoolEntry*>(&(**cluster.begin()))).second) {\n+                for (auto tx : cluster) {\n+                    ret.emplace_back(mapTx.iterator_to(static_cast<const CTxMemPoolEntry&>(*tx)));\n                 }\n             }\n         }\n     }\n-    return clustered_txs;\n-}\n-\n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n+    if (ret.size() > 500) {\n+        return {};\n     }\n-    return std::nullopt;\n+    return ret;\n }\n \n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n-\n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};\n-    if (err_string.has_value()) {\n-        // Unsupported topology for calculating a feerate diagram\n-        return util::Error{Untranslated(err_string.value())};\n-    }\n-\n-    // new diagram will have chunks that consist of each ancestor of\n-    // direct_conflicts that is at its own fee/size, along with the replacement\n-    // tx/package at its own fee/size\n-\n-    // old diagram will consist of the ancestors and descendants of each element of\n-    // all_conflicts.  every such transaction will either be at its own feerate (followed\n-    // by any descendant at its own feerate), or as a single chunk at the descendant's\n-    // ancestor feerate.\n-\n-    std::vector<FeeFrac> old_chunks;\n-    // Step 1: build the old diagram.\n \n-    // The above clusters are all trivially linearized;\n-    // they have a strict topology of 1 or two connected transactions.\n-\n-    // OLD: Compute existing chunks from all affected clusters\n-    for (auto txiter : m_to_remove) {\n-        // Does this transaction have descendants?\n-        if (txiter->GetCountWithDescendants() > 1) {\n-            // Consider this tx when we consider the descendant.\n-            continue;\n-        }\n-        // Does this transaction have ancestors?\n-        FeeFrac individual{txiter->GetModifiedFee(), txiter->GetTxSize()};\n-        if (txiter->GetCountWithAncestors() > 1) {\n-            // We'll add chunks for either the ancestor by itself and this tx\n-            // by itself, or for a combined package.\n-            FeeFrac package{txiter->GetModFeesWithAncestors(), static_cast<int32_t>(txiter->GetSizeWithAncestors())};\n-            if (individual >> package) {\n-                // The individual feerate is higher than the package, and\n-                // therefore higher than the parent's fee. Chunk these\n-                // together.\n-                old_chunks.emplace_back(package);\n-            } else {\n-                // Add two points, one for the parent and one for this child.\n-                old_chunks.emplace_back(package - individual);\n-                old_chunks.emplace_back(individual);\n-            }\n-        } else {\n-            old_chunks.emplace_back(individual);\n-        }\n-    }\n-\n-    // No topology restrictions post-chunking; sort\n-    std::sort(old_chunks.begin(), old_chunks.end(), std::greater());\n-\n-    std::vector<FeeFrac> new_chunks;\n-\n-    /* Step 2: build the NEW diagram\n-     * CON = Conflicts of proposed chunk\n-     * CNK = Proposed chunk\n-     * NEW = OLD - CON + CNK: New diagram includes all chunks in OLD, minus\n-     * the conflicts, plus the proposed chunk\n-     */\n-\n-    // OLD - CON: Add any parents of direct conflicts that are not conflicted themselves\n-    for (auto direct_conflict : m_to_remove) {\n-        // If a direct conflict has an ancestor that is not in all_conflicts,\n-        // it can be affected by the replacement of the child.\n-        if (direct_conflict->GetMemPoolParentsConst().size() > 0) {\n-            // Grab the parent.\n-            const CTxMemPoolEntry& parent = direct_conflict->GetMemPoolParentsConst().begin()->get();\n-            if (!m_to_remove.contains(m_pool->mapTx.iterator_to(parent))) {\n-                // This transaction would be left over, so add to the NEW\n-                // diagram.\n-                new_chunks.emplace_back(parent.GetModifiedFee(), parent.GetTxSize());\n-            }\n-        }\n+    if (!CheckMemPoolPolicyLimits()) {\n+        return util::Error{Untranslated(\"cluster size limit exceeded\")};\n     }\n-    // + CNK: Add the proposed chunk itself\n-    new_chunks.emplace_back(replacement_feerate);\n \n-    // No topology restrictions post-chunking; sort\n-    std::sort(new_chunks.begin(), new_chunks.end(), std::greater());\n-    return std::make_pair(old_chunks, new_chunks);\n+    return m_pool->m_txgraph->GetMainStagingDiagrams();\n }\n \n CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTransactionRef& tx, const CAmount fee, int64_t time, unsigned int entry_height, uint64_t entry_sequence, bool spends_coinbase, int64_t sigops_cost, LockPoints lp)\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n-    auto newit = m_to_add.emplace(tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    Assume(!m_dependencies_processed);\n+\n+    // We need to reprocess dependencies after adding a new transaction.\n+    m_dependencies_processed = false;\n+\n     CAmount delta{0};\n     m_pool->ApplyDelta(tx->GetHash(), delta);\n-    if (delta) m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+\n+    TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\n+    auto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    if (delta) {\n+        m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+    }\n \n     m_entry_vec.push_back(newit);\n+\n     return newit;\n }\n \n+void CTxMemPool::ChangeSet::StageRemoval(CTxMemPool::txiter it)\n+{\n+    LOCK(m_pool->cs);\n+    m_pool->m_txgraph->RemoveTransaction(*it);\n+    m_to_remove.insert(it);\n+}\n+\n void CTxMemPool::ChangeSet::Apply()\n {\n     LOCK(m_pool->cs);\n+    if (!m_dependencies_processed) {\n+        ProcessDependencies();\n+    }\n     m_pool->Apply(this);\n     m_to_add.clear();\n     m_to_remove.clear();\n     m_entry_vec.clear();\n     m_ancestors.clear();\n }\n+\n+void CTxMemPool::ChangeSet::ProcessDependencies()\n+{\n+    LOCK(m_pool->cs);\n+    Assume(!m_dependencies_processed); // should only call this once.\n+    for (const auto& entryptr : m_entry_vec) {\n+        for (const auto &txin : entryptr->GetSharedTx()->vin) {\n+            std::optional<txiter> piter = m_pool->GetIter(txin.prevout.hash);\n+            if (!piter) {\n+                auto it = m_to_add.find(txin.prevout.hash);\n+                if (it != m_to_add.end()) {\n+                    piter = std::make_optional(it);\n+                }\n+            }\n+            if (piter) {\n+                m_pool->m_txgraph->AddDependency(**piter, *entryptr);\n+            }\n+        }\n+    }\n+    m_dependencies_processed = true;",
      "path": "src/txmempool.cpp",
      "position": 1231,
      "original_position": 1223,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Unkilled mutant:\r\n\r\n```diff\r\ndiff --git a/src/txmempool.cpp b/src/txmempool.cpp\r\nindex b0c9ab043c..8d7e4d2bb9 100644\r\n--- a/src/txmempool.cpp\r\n+++ b/src/txmempool.cpp\r\n@@ -994,7 +994,7 @@ void CTxMemPool::ChangeSet::ProcessDependencies()\r\n             }\r\n         }\r\n     }\r\n-    m_dependencies_processed = true;\r\n+    m_dependencies_processed = false;\r\n     return;\r\n  }\r\n```",
      "created_at": "2025-10-22T06:58:52Z",
      "updated_at": "2025-10-22T10:00:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450631707",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450631707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1005,
      "original_line": 1005,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450642965",
      "pull_request_review_id": 3363955723,
      "id": 2450642965,
      "node_id": "PRRC_kwDOABII586SEdgV",
      "diff_hunk": "@@ -54,353 +54,113 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints& lp)\n     return true;\n }\n \n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendants,\n-                                      const std::set<Txid>& setExclude, std::set<Txid>& descendants_to_remove)\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetChildren(const CTxMemPoolEntry& entry) const\n {\n-    CTxMemPoolEntry::Children stageEntries, descendants;\n-    stageEntries = updateIt->GetMemPoolChildrenConst();\n-\n-    while (!stageEntries.empty()) {\n-        const CTxMemPoolEntry& descendant = *stageEntries.begin();\n-        descendants.insert(descendant);\n-        stageEntries.erase(descendant);\n-        const CTxMemPoolEntry::Children& children = descendant.GetMemPoolChildrenConst();\n-        for (const CTxMemPoolEntry& childEntry : children) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(mapTx.iterator_to(childEntry));\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    descendants.insert(*cacheEntry);\n-                }\n-            } else if (!descendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n-            }\n-        }\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    setEntries children;\n+    auto iter = mapNextTx.lower_bound(COutPoint(entry.GetTx().GetHash(), 0));\n+    for (; iter != mapNextTx.end() && iter->first->hash == entry.GetTx().GetHash(); ++iter) {\n+        children.insert(iter->second);\n     }\n-    // descendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int32_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (const CTxMemPoolEntry& descendant : descendants) {\n-        if (!setExclude.count(descendant.GetTx().GetHash())) {\n-            modifySize += descendant.GetTxSize();\n-            modifyFee += descendant.GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(mapTx.iterator_to(descendant));\n-            // Update ancestor state for each descendant\n-            mapTx.modify(mapTx.iterator_to(descendant), [=](CTxMemPoolEntry& e) {\n-              e.UpdateAncestorState(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost());\n-            });\n-            // Don't directly remove the transaction here -- doing so would\n-            // invalidate iterators in cachedDescendants. Mark it for removal\n-            // by inserting into descendants_to_remove.\n-            if (descendant.GetCountWithAncestors() > uint64_t(m_opts.limits.ancestor_count) || descendant.GetSizeWithAncestors() > m_opts.limits.ancestor_size_vbytes) {\n-                descendants_to_remove.insert(descendant.GetTx().GetHash());\n-            }\n+    for (const auto& child : children) {\n+        ret.emplace_back(*child);\n+    }\n+    return ret;\n+}\n+\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetParents(const CTxMemPoolEntry& entry) const\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    std::set<Txid> inputs;\n+    for (const auto& txin : entry.GetTx().vin) {\n+        inputs.insert(txin.prevout.hash);\n+    }\n+    for (const auto& hash : inputs) {\n+        std::optional<txiter> piter = GetIter(hash);\n+        if (piter) {\n+            ret.emplace_back(**piter);\n         }\n     }\n-    mapTx.modify(updateIt, [=](CTxMemPoolEntry& e) { e.UpdateDescendantState(modifySize, modifyFee, modifyCount); });\n+    return ret;\n }\n \n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate)\n {\n     AssertLockHeld(cs);\n-    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n-    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n-    // descendants when we come across a previously seen entry.\n-    cacheMap mapMemPoolDescendantsToUpdate;\n-\n-    // Use a set for lookups into vHashesToUpdate (these entries are already\n-    // accounted for in the state of their ancestors)\n-    std::set<Txid> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n-\n-    std::set<Txid> descendants_to_remove;\n \n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n-    // This maximizes the benefit of the descendant cache and guarantees that\n-    // CTxMemPoolEntry::m_children will be updated, an assumption made in\n-    // UpdateForDescendants.\n     for (const Txid& hash : vHashesToUpdate | std::views::reverse) {\n         // calculate children from mapNextTx\n         txiter it = mapTx.find(hash);\n         if (it == mapTx.end()) {\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update CTxMemPoolEntry::m_children to\n-        // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n-        // we cache the in-mempool children to avoid duplicate updates\n         {\n-            WITH_FRESH_EPOCH(m_epoch);\n             for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n-                const Txid &childHash = iter->second->GetHash();\n-                txiter childIter = mapTx.find(childHash);\n+                txiter childIter = iter->second;\n                 assert(childIter != mapTx.end());\n-                // We can skip updating entries we've encountered before or that\n-                // are in the block (which are already accounted for).\n-                if (!visited(childIter) && !setAlreadyIncluded.count(childHash)) {\n-                    UpdateChild(it, childIter, true);\n-                    UpdateParent(childIter, it, true);\n-                }\n+                // Add dependencies that are discovered between transactions in the\n+                // block and transactions that were in the mempool to txgraph.\n+                m_txgraph->AddDependency(*it, *childIter);\n             }\n-        } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded, descendants_to_remove);\n+        }\n     }\n \n-    for (const auto& txid : descendants_to_remove) {\n-        // This txid may have been removed already in a prior call to removeRecursive.\n-        // Therefore we ensure it is not yet removed already.\n-        if (const std::optional<txiter> txiter = GetIter(txid)) {\n-            removeRecursive((*txiter)->GetTx(), MemPoolRemovalReason::SIZELIMIT);\n-        }\n+    auto txs_to_remove = m_txgraph->Trim(); // Enforce cluster size limits.\n+    for (auto txptr : txs_to_remove) {\n+        const CTxMemPoolEntry& entry = *(static_cast<const CTxMemPoolEntry*>(txptr));\n+        removeUnchecked(mapTx.iterator_to(entry), MemPoolRemovalReason::SIZELIMIT);\n     }\n }\n \n-util::Result<CTxMemPool::setEntries> CTxMemPool::CalculateAncestorsAndCheckLimits(\n-    int64_t entry_size,\n-    size_t entry_count,\n-    CTxMemPoolEntry::Parents& staged_ancestors,\n-    const Limits& limits) const\n+bool CTxMemPool::HasDescendants(const Txid& txid) const\n {\n-    int64_t totalSizeWithAncestors = entry_size;\n-    setEntries ancestors;\n-\n-    while (!staged_ancestors.empty()) {\n-        const CTxMemPoolEntry& stage = staged_ancestors.begin()->get();\n-        txiter stageit = mapTx.iterator_to(stage);\n-\n-        ancestors.insert(stageit);\n-        staged_ancestors.erase(stage);\n-        totalSizeWithAncestors += stageit->GetTxSize();\n-\n-        if (stageit->GetSizeWithDescendants() + entry_size > limits.descendant_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_size_vbytes))};\n-        } else if (stageit->GetCountWithDescendants() + entry_count > static_cast<uint64_t>(limits.descendant_count)) {\n-            return util::Error{Untranslated(strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_count))};\n-        } else if (totalSizeWithAncestors > limits.ancestor_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds ancestor size limit [limit: %u]\", limits.ancestor_size_vbytes))};\n-        }\n-\n-        const CTxMemPoolEntry::Parents& parents = stageit->GetMemPoolParentsConst();\n-        for (const CTxMemPoolEntry& parent : parents) {\n-            txiter parent_it = mapTx.iterator_to(parent);\n-\n-            // If this is a new ancestor, add it.\n-            if (ancestors.count(parent_it) == 0) {\n-                staged_ancestors.insert(parent);\n-            }\n-            if (staged_ancestors.size() + ancestors.size() + entry_count > static_cast<uint64_t>(limits.ancestor_count)) {\n-                return util::Error{Untranslated(strprintf(\"too many unconfirmed ancestors [limit: %u]\", limits.ancestor_count))};\n-            }\n-        }\n-    }\n-\n-    return ancestors;\n+    LOCK(cs);\n+    auto entry = GetEntry(txid);\n+    if (!entry) return false;\n+    return m_txgraph->GetDescendants(*entry, TxGraph::Level::MAIN).size() > 1;\n }\n \n-util::Result<void> CTxMemPool::CheckPackageLimits(const Package& package,\n-                                                  const int64_t total_vsize) const\n+CTxMemPool::setEntries CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry) const\n {\n-    size_t pack_count = package.size();\n-\n-    // Package itself is busting mempool limits; should be rejected even if no staged_ancestors exist\n-    if (pack_count > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds ancestor count limit [limit: %u]\", pack_count, m_opts.limits.ancestor_count))};\n-    } else if (pack_count > static_cast<uint64_t>(m_opts.limits.descendant_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds descendant count limit [limit: %u]\", pack_count, m_opts.limits.descendant_count))};\n-    } else if (total_vsize > m_opts.limits.ancestor_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds ancestor size limit [limit: %u]\", total_vsize, m_opts.limits.ancestor_size_vbytes))};\n-    } else if (total_vsize > m_opts.limits.descendant_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds descendant size limit [limit: %u]\", total_vsize, m_opts.limits.descendant_size_vbytes))};\n-    }\n-\n-    CTxMemPoolEntry::Parents staged_ancestors;\n-    for (const auto& tx : package) {\n-        for (const auto& input : tx->vin) {\n-            std::optional<txiter> piter = GetIter(input.prevout.hash);\n-            if (piter) {\n-                staged_ancestors.insert(**piter);\n-                if (staged_ancestors.size() + package.size() > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-                    return util::Error{Untranslated(strprintf(\"too many unconfirmed parents [limit: %u]\", m_opts.limits.ancestor_count))};\n-                }\n+    auto ancestors = m_txgraph->GetAncestors(entry, TxGraph::Level::MAIN);\n+    setEntries ret;\n+    if (ancestors.size() > 0) {",
      "path": "src/txmempool.cpp",
      "position": 220,
      "original_position": 220,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Unkilled mutant:\r\n\r\n```diff\r\ndiff --git a/src/txmempool.cpp b/src/txmempool.cpp\r\nindex b0c9ab043c..aef4fdde8d 100644\r\n--- a/src/txmempool.cpp\r\n+++ b/src/txmempool.cpp\r\n@@ -129,7 +129,7 @@ CTxMemPool::setEntries CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEnt\r\n {\r\n     auto ancestors = m_txgraph->GetAncestors(entry, TxGraph::Level::MAIN);\r\n     setEntries ret;\r\n-    if (ancestors.size() > 0) {\r\n+    if (ancestors.size() < 0) {\r\n         for (auto ancestor : ancestors) {\r\n             if (ancestor != &entry) {\r\n                 ret.insert(mapTx.iterator_to(static_cast<const CTxMemPoolEntry&>(*ancestor)));\r\n```",
      "created_at": "2025-10-22T07:04:11Z",
      "updated_at": "2025-10-22T10:00:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450642965",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450642965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450650949",
      "pull_request_review_id": 3363955723,
      "id": 2450650949,
      "node_id": "PRRC_kwDOABII586SEfdF",
      "diff_hunk": "@@ -54,353 +54,113 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints& lp)\n     return true;\n }\n \n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendants,\n-                                      const std::set<Txid>& setExclude, std::set<Txid>& descendants_to_remove)\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetChildren(const CTxMemPoolEntry& entry) const\n {\n-    CTxMemPoolEntry::Children stageEntries, descendants;\n-    stageEntries = updateIt->GetMemPoolChildrenConst();\n-\n-    while (!stageEntries.empty()) {\n-        const CTxMemPoolEntry& descendant = *stageEntries.begin();\n-        descendants.insert(descendant);\n-        stageEntries.erase(descendant);\n-        const CTxMemPoolEntry::Children& children = descendant.GetMemPoolChildrenConst();\n-        for (const CTxMemPoolEntry& childEntry : children) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(mapTx.iterator_to(childEntry));\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    descendants.insert(*cacheEntry);\n-                }\n-            } else if (!descendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n-            }\n-        }\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    setEntries children;\n+    auto iter = mapNextTx.lower_bound(COutPoint(entry.GetTx().GetHash(), 0));\n+    for (; iter != mapNextTx.end() && iter->first->hash == entry.GetTx().GetHash(); ++iter) {\n+        children.insert(iter->second);\n     }\n-    // descendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int32_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (const CTxMemPoolEntry& descendant : descendants) {\n-        if (!setExclude.count(descendant.GetTx().GetHash())) {\n-            modifySize += descendant.GetTxSize();\n-            modifyFee += descendant.GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(mapTx.iterator_to(descendant));\n-            // Update ancestor state for each descendant\n-            mapTx.modify(mapTx.iterator_to(descendant), [=](CTxMemPoolEntry& e) {\n-              e.UpdateAncestorState(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost());\n-            });\n-            // Don't directly remove the transaction here -- doing so would\n-            // invalidate iterators in cachedDescendants. Mark it for removal\n-            // by inserting into descendants_to_remove.\n-            if (descendant.GetCountWithAncestors() > uint64_t(m_opts.limits.ancestor_count) || descendant.GetSizeWithAncestors() > m_opts.limits.ancestor_size_vbytes) {\n-                descendants_to_remove.insert(descendant.GetTx().GetHash());\n-            }\n+    for (const auto& child : children) {\n+        ret.emplace_back(*child);\n+    }\n+    return ret;\n+}\n+\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetParents(const CTxMemPoolEntry& entry) const\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    std::set<Txid> inputs;\n+    for (const auto& txin : entry.GetTx().vin) {\n+        inputs.insert(txin.prevout.hash);\n+    }\n+    for (const auto& hash : inputs) {\n+        std::optional<txiter> piter = GetIter(hash);\n+        if (piter) {\n+            ret.emplace_back(**piter);\n         }\n     }\n-    mapTx.modify(updateIt, [=](CTxMemPoolEntry& e) { e.UpdateDescendantState(modifySize, modifyFee, modifyCount); });\n+    return ret;\n }\n \n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate)\n {\n     AssertLockHeld(cs);\n-    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n-    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n-    // descendants when we come across a previously seen entry.\n-    cacheMap mapMemPoolDescendantsToUpdate;\n-\n-    // Use a set for lookups into vHashesToUpdate (these entries are already\n-    // accounted for in the state of their ancestors)\n-    std::set<Txid> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n-\n-    std::set<Txid> descendants_to_remove;\n \n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n-    // This maximizes the benefit of the descendant cache and guarantees that\n-    // CTxMemPoolEntry::m_children will be updated, an assumption made in\n-    // UpdateForDescendants.\n     for (const Txid& hash : vHashesToUpdate | std::views::reverse) {\n         // calculate children from mapNextTx\n         txiter it = mapTx.find(hash);\n         if (it == mapTx.end()) {\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update CTxMemPoolEntry::m_children to\n-        // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n-        // we cache the in-mempool children to avoid duplicate updates\n         {\n-            WITH_FRESH_EPOCH(m_epoch);\n             for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n-                const Txid &childHash = iter->second->GetHash();\n-                txiter childIter = mapTx.find(childHash);\n+                txiter childIter = iter->second;\n                 assert(childIter != mapTx.end());\n-                // We can skip updating entries we've encountered before or that\n-                // are in the block (which are already accounted for).\n-                if (!visited(childIter) && !setAlreadyIncluded.count(childHash)) {\n-                    UpdateChild(it, childIter, true);\n-                    UpdateParent(childIter, it, true);\n-                }\n+                // Add dependencies that are discovered between transactions in the\n+                // block and transactions that were in the mempool to txgraph.\n+                m_txgraph->AddDependency(*it, *childIter);\n             }\n-        } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded, descendants_to_remove);\n+        }\n     }\n \n-    for (const auto& txid : descendants_to_remove) {\n-        // This txid may have been removed already in a prior call to removeRecursive.\n-        // Therefore we ensure it is not yet removed already.\n-        if (const std::optional<txiter> txiter = GetIter(txid)) {\n-            removeRecursive((*txiter)->GetTx(), MemPoolRemovalReason::SIZELIMIT);\n-        }\n+    auto txs_to_remove = m_txgraph->Trim(); // Enforce cluster size limits.\n+    for (auto txptr : txs_to_remove) {\n+        const CTxMemPoolEntry& entry = *(static_cast<const CTxMemPoolEntry*>(txptr));\n+        removeUnchecked(mapTx.iterator_to(entry), MemPoolRemovalReason::SIZELIMIT);\n     }\n }\n \n-util::Result<CTxMemPool::setEntries> CTxMemPool::CalculateAncestorsAndCheckLimits(\n-    int64_t entry_size,\n-    size_t entry_count,\n-    CTxMemPoolEntry::Parents& staged_ancestors,\n-    const Limits& limits) const\n+bool CTxMemPool::HasDescendants(const Txid& txid) const\n {\n-    int64_t totalSizeWithAncestors = entry_size;\n-    setEntries ancestors;\n-\n-    while (!staged_ancestors.empty()) {\n-        const CTxMemPoolEntry& stage = staged_ancestors.begin()->get();\n-        txiter stageit = mapTx.iterator_to(stage);\n-\n-        ancestors.insert(stageit);\n-        staged_ancestors.erase(stage);\n-        totalSizeWithAncestors += stageit->GetTxSize();\n-\n-        if (stageit->GetSizeWithDescendants() + entry_size > limits.descendant_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_size_vbytes))};\n-        } else if (stageit->GetCountWithDescendants() + entry_count > static_cast<uint64_t>(limits.descendant_count)) {\n-            return util::Error{Untranslated(strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_count))};\n-        } else if (totalSizeWithAncestors > limits.ancestor_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds ancestor size limit [limit: %u]\", limits.ancestor_size_vbytes))};\n-        }\n-\n-        const CTxMemPoolEntry::Parents& parents = stageit->GetMemPoolParentsConst();\n-        for (const CTxMemPoolEntry& parent : parents) {\n-            txiter parent_it = mapTx.iterator_to(parent);\n-\n-            // If this is a new ancestor, add it.\n-            if (ancestors.count(parent_it) == 0) {\n-                staged_ancestors.insert(parent);\n-            }\n-            if (staged_ancestors.size() + ancestors.size() + entry_count > static_cast<uint64_t>(limits.ancestor_count)) {\n-                return util::Error{Untranslated(strprintf(\"too many unconfirmed ancestors [limit: %u]\", limits.ancestor_count))};\n-            }\n-        }\n-    }\n-\n-    return ancestors;\n+    LOCK(cs);\n+    auto entry = GetEntry(txid);\n+    if (!entry) return false;",
      "path": "src/txmempool.cpp",
      "position": 188,
      "original_position": 188,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Unkilled mutant:\r\n\r\n```diff\r\ndiff --git a/src/txmempool.cpp b/src/txmempool.cpp\r\nindex b0c9ab043c..bdbbc8325d 100644\r\n--- a/src/txmempool.cpp\r\n+++ b/src/txmempool.cpp\r\n@@ -121,7 +121,7 @@ bool CTxMemPool::HasDescendants(const Txid& txid) const\r\n {\r\n     LOCK(cs);\r\n     auto entry = GetEntry(txid);\r\n-    if (!entry) return false;\r\n+    if (1==0) return false;\r\n     return m_txgraph->GetDescendants(*entry, TxGraph::Level::MAIN).size() > 1;\r\n }\r\n```",
      "created_at": "2025-10-22T07:07:55Z",
      "updated_at": "2025-10-22T10:00:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450650949",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450650949"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 124,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450652757",
      "pull_request_review_id": 3363982025,
      "id": 2450652757,
      "node_id": "PRRC_kwDOABII586SEf5V",
      "diff_hunk": "@@ -26,7 +26,7 @@ def func_wrapper(self, *args, **kwargs):\n         testres_error_expected = node.testmempoolaccept(rawtxs=package_hex)\n         assert_equal(len(testres_error_expected), len(package_hex))\n         for txres in testres_error_expected:\n-            assert \"package-mempool-limits\" in txres[\"package-error\"]\n+            assert \"too-large-cluster\" in txres[\"package-error\"]",
      "path": "test/functional/mempool_package_limits.py",
      "position": 14,
      "original_position": 5,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "there's a single lasting reference to \"package-mempool-limits\" in the comment in this file",
      "created_at": "2025-10-22T07:08:52Z",
      "updated_at": "2025-10-28T20:41:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450652757",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450652757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450694460",
      "pull_request_review_id": 3363955723,
      "id": 2450694460,
      "node_id": "PRRC_kwDOABII586SEqE8",
      "diff_hunk": "@@ -508,67 +392,55 @@ class CTxMemPool\n      */\n     void UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs, cs_main) LOCKS_EXCLUDED(m_epoch);\n \n+    std::vector<FeePerVSize> GetFeerateDiagram() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    FeePerVSize GetMainChunkFeerate(const CTxMemPoolEntry& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+        return ToFeePerVSize(m_txgraph->GetMainChunkFeerate(tx));\n+    }\n+    std::vector<const CTxMemPoolEntry*> GetCluster(Txid txid) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\n+        auto tx = GetIter(txid);\n+        if (!tx) return {};",
      "path": "src/txmempool.h",
      "position": 352,
      "original_position": 350,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Unkilled mutant:\r\n\r\n```diff\r\ndiff --git a/src/txmempool.h b/src/txmempool.h\r\nindex 4aeae00f69..c4332f3344 100644\r\n--- a/src/txmempool.h\r\n+++ b/src/txmempool.h\r\n@@ -398,7 +398,7 @@ public:\r\n     }\r\n     std::vector<const CTxMemPoolEntry*> GetCluster(Txid txid) const EXCLUSIVE_LOCKS_REQUIRED(cs) {\r\n         auto tx = GetIter(txid);\r\n-        if (!tx) return {};\r\n+        if (1==0) return {};\r\n         auto cluster = m_txgraph->GetCluster(**tx, TxGraph::Level::MAIN);\r\n         std::vector<const CTxMemPoolEntry*> ret;\r\n         ret.reserve(cluster.size());\r\n```",
      "created_at": "2025-10-22T07:27:49Z",
      "updated_at": "2025-10-22T10:00:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450694460",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450694460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 403,
      "original_line": 403,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450722652",
      "pull_request_review_id": 3363955723,
      "id": 2450722652,
      "node_id": "PRRC_kwDOABII586SEw9c",
      "diff_hunk": "@@ -1230,180 +902,131 @@ void CTxMemPool::SetLoadTried(bool load_tried)\n std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txid>& txids) const\n {\n     AssertLockHeld(cs);\n-    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n-    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n-    // necessarily mean the entry has been processed.\n-    WITH_FRESH_EPOCH(m_epoch);\n-    for (const auto& it : clustered_txs) {\n-        visited(it);\n-    }\n-    // i = index of where the list of entries to process starts\n-    for (size_t i{0}; i < clustered_txs.size(); ++i) {\n-        // DoS protection: if there are 500 or more entries to process, just quit.\n-        if (clustered_txs.size() > 500) return {};\n-        const txiter& tx_iter = clustered_txs.at(i);\n-        for (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\n-            for (const CTxMemPoolEntry& entry : entries) {\n-                const auto entry_it = mapTx.iterator_to(entry);\n-                if (!visited(entry_it)) {\n-                    clustered_txs.push_back(entry_it);\n+\n+    std::vector<CTxMemPool::txiter> ret;\n+    std::set<const CTxMemPoolEntry*> unique_cluster_representatives;\n+    for (auto txid : txids) {\n+        auto it = mapTx.find(txid);\n+        if (it != mapTx.end()) {\n+            auto cluster = m_txgraph->GetCluster(*it, TxGraph::Level::MAIN);\n+            if (unique_cluster_representatives.insert(static_cast<const CTxMemPoolEntry*>(&(**cluster.begin()))).second) {\n+                for (auto tx : cluster) {\n+                    ret.emplace_back(mapTx.iterator_to(static_cast<const CTxMemPoolEntry&>(*tx)));\n                 }\n             }\n         }\n     }\n-    return clustered_txs;\n-}\n-\n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n+    if (ret.size() > 500) {\n+        return {};\n     }\n-    return std::nullopt;\n+    return ret;\n }\n \n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n-\n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};\n-    if (err_string.has_value()) {\n-        // Unsupported topology for calculating a feerate diagram\n-        return util::Error{Untranslated(err_string.value())};\n-    }\n-\n-    // new diagram will have chunks that consist of each ancestor of\n-    // direct_conflicts that is at its own fee/size, along with the replacement\n-    // tx/package at its own fee/size\n-\n-    // old diagram will consist of the ancestors and descendants of each element of\n-    // all_conflicts.  every such transaction will either be at its own feerate (followed\n-    // by any descendant at its own feerate), or as a single chunk at the descendant's\n-    // ancestor feerate.\n-\n-    std::vector<FeeFrac> old_chunks;\n-    // Step 1: build the old diagram.\n \n-    // The above clusters are all trivially linearized;\n-    // they have a strict topology of 1 or two connected transactions.\n-\n-    // OLD: Compute existing chunks from all affected clusters\n-    for (auto txiter : m_to_remove) {\n-        // Does this transaction have descendants?\n-        if (txiter->GetCountWithDescendants() > 1) {\n-            // Consider this tx when we consider the descendant.\n-            continue;\n-        }\n-        // Does this transaction have ancestors?\n-        FeeFrac individual{txiter->GetModifiedFee(), txiter->GetTxSize()};\n-        if (txiter->GetCountWithAncestors() > 1) {\n-            // We'll add chunks for either the ancestor by itself and this tx\n-            // by itself, or for a combined package.\n-            FeeFrac package{txiter->GetModFeesWithAncestors(), static_cast<int32_t>(txiter->GetSizeWithAncestors())};\n-            if (individual >> package) {\n-                // The individual feerate is higher than the package, and\n-                // therefore higher than the parent's fee. Chunk these\n-                // together.\n-                old_chunks.emplace_back(package);\n-            } else {\n-                // Add two points, one for the parent and one for this child.\n-                old_chunks.emplace_back(package - individual);\n-                old_chunks.emplace_back(individual);\n-            }\n-        } else {\n-            old_chunks.emplace_back(individual);\n-        }\n-    }\n-\n-    // No topology restrictions post-chunking; sort\n-    std::sort(old_chunks.begin(), old_chunks.end(), std::greater());\n-\n-    std::vector<FeeFrac> new_chunks;\n-\n-    /* Step 2: build the NEW diagram\n-     * CON = Conflicts of proposed chunk\n-     * CNK = Proposed chunk\n-     * NEW = OLD - CON + CNK: New diagram includes all chunks in OLD, minus\n-     * the conflicts, plus the proposed chunk\n-     */\n-\n-    // OLD - CON: Add any parents of direct conflicts that are not conflicted themselves\n-    for (auto direct_conflict : m_to_remove) {\n-        // If a direct conflict has an ancestor that is not in all_conflicts,\n-        // it can be affected by the replacement of the child.\n-        if (direct_conflict->GetMemPoolParentsConst().size() > 0) {\n-            // Grab the parent.\n-            const CTxMemPoolEntry& parent = direct_conflict->GetMemPoolParentsConst().begin()->get();\n-            if (!m_to_remove.contains(m_pool->mapTx.iterator_to(parent))) {\n-                // This transaction would be left over, so add to the NEW\n-                // diagram.\n-                new_chunks.emplace_back(parent.GetModifiedFee(), parent.GetTxSize());\n-            }\n-        }\n+    if (!CheckMemPoolPolicyLimits()) {\n+        return util::Error{Untranslated(\"cluster size limit exceeded\")};\n     }\n-    // + CNK: Add the proposed chunk itself\n-    new_chunks.emplace_back(replacement_feerate);\n \n-    // No topology restrictions post-chunking; sort\n-    std::sort(new_chunks.begin(), new_chunks.end(), std::greater());\n-    return std::make_pair(old_chunks, new_chunks);\n+    return m_pool->m_txgraph->GetMainStagingDiagrams();\n }\n \n CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTransactionRef& tx, const CAmount fee, int64_t time, unsigned int entry_height, uint64_t entry_sequence, bool spends_coinbase, int64_t sigops_cost, LockPoints lp)\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n-    auto newit = m_to_add.emplace(tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    Assume(!m_dependencies_processed);\n+\n+    // We need to reprocess dependencies after adding a new transaction.\n+    m_dependencies_processed = false;\n+\n     CAmount delta{0};\n     m_pool->ApplyDelta(tx->GetHash(), delta);\n-    if (delta) m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+\n+    TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\n+    auto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    if (delta) {",
      "path": "src/txmempool.cpp",
      "position": 1184,
      "original_position": 1176,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Unkilled mutant:\r\n\r\n```diff\r\ndiff --git a/src/txmempool.cpp b/src/txmempool.cpp\r\nindex b0c9ab043c..9142d8d2c6 100644\r\n--- a/src/txmempool.cpp\r\n+++ b/src/txmempool.cpp\r\n@@ -947,7 +947,7 @@ CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTran\r\n\r\n     TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\r\n     auto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\r\n-    if (delta) {\r\n+    if (1==1) {\r\n         m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\r\n     }\r\n```",
      "created_at": "2025-10-22T07:39:50Z",
      "updated_at": "2025-10-22T10:00:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450722652",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450722652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 958,
      "original_line": 958,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450756366",
      "pull_request_review_id": 3363955723,
      "id": 2450756366,
      "node_id": "PRRC_kwDOABII586SE5MO",
      "diff_hunk": "@@ -244,112 +159,91 @@ BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n     BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 20, higher_relay_feerate, unused_txid) == std::nullopt);\n     BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n     BOOST_CHECK(PaysForRBF(low_fee, high_fee + 99999999, 99999999, incremental_relay_feerate, unused_txid) == std::nullopt);\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_conflicts_calculator, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount normal_fee{CENT/10};\n+\n+    // Create two parent transactions with 51 outputs each\n+    const int NUM_OUTPUTS = 51;\n+    std::vector<CAmount> output_values;\n+    output_values.reserve(NUM_OUTPUTS);\n+    for (int i = 0; i < NUM_OUTPUTS; ++i) {\n+        output_values.push_back(1 * COIN);\n+    }\n \n-    // Tests for GetEntriesForConflicts\n-    CTxMemPool::setEntries all_parents{entry1_normal, entry3_low, entry5_low, entry7_high, entry8_high};\n-    CTxMemPool::setEntries all_children{entry2_normal, entry4_high, entry6_low_prioritised};\n-    const std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n-                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n-    const auto conflicts_with_parents = make_tx(parent_inputs, {50 * CENT});\n-    CTxMemPool::setEntries all_conflicts;\n-    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+    const auto parent_tx_1 = make_tx(/*inputs=*/ {m_coinbase_txns[0]}, /*output_values=*/ output_values);\n+    const auto parent_tx_2 = make_tx(/*inputs=*/ {m_coinbase_txns[1]}, /*output_values=*/ output_values);\n+    AddToMempool(pool, entry.Fee(normal_fee).FromTx(parent_tx_1));\n+    AddToMempool(pool, entry.Fee(normal_fee).FromTx(parent_tx_2));\n+\n+    std::vector<CTransactionRef> direct_children;\n+\n+    // Create individual spends of these outputs\n+    for (const auto& parent_tx : {parent_tx_1, parent_tx_2}) {\n+        for (auto i = 0; i < NUM_OUTPUTS; ++i) {\n+            auto pretx = make_tx(/*inputs=*/ {parent_tx}, /*output_values=*/ {995 * CENT});\n+            CMutableTransaction tx(*pretx);\n+            tx.vin[0].prevout.n = i;\n+            AddToMempool(pool, entry.Fee(normal_fee).FromTx(tx));\n+            BOOST_CHECK(pool.GetIter(tx.GetHash()).has_value());\n+            direct_children.push_back(MakeTransactionRef(tx));\n+        }\n+    }\n+\n+    // At this point, we should have 2 clusters in the mempool, each with 52\n+    // transactions.\n+\n+    // parent_tx and all children are in one cluster, so we can have as many\n+    // conflicts within this cluster as we want without violating the RBF conflicts\n+    // limit.\n+    const auto parent_entry_1 = pool.GetIter(parent_tx_1->GetHash()).value();\n+    const auto parent_entry_2 = pool.GetIter(parent_tx_2->GetHash()).value();\n+    const auto conflicting_transaction = make_tx({parent_tx_1, parent_tx_2}, {50 * CENT});\n+    CTxMemPool::setEntries all_conflicts, dummy;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicting_transaction.get(),\n                                        /*pool=*/ pool,\n-                                       /*iters_conflicting=*/ all_parents,\n+                                       /*iters_conflicting=*/ {parent_entry_1, parent_entry_2},\n                                        /*all_conflicts=*/ all_conflicts) == std::nullopt);\n-    BOOST_CHECK(all_conflicts == all_entries);\n-    auto conflicts_size = all_conflicts.size();\n-    all_conflicts.clear();\n-\n-    add_descendants(tx2, 23, pool);\n-    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n-    conflicts_size += 23;\n-    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n-    all_conflicts.clear();\n-\n-    add_descendants(tx4, 23, pool);\n-    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n-    conflicts_size += 23;\n-    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n-    all_conflicts.clear();\n-\n-    add_descendants(tx6, 23, pool);\n-    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n-    conflicts_size += 23;\n-    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n-    all_conflicts.clear();\n-\n-    add_descendants(tx7, 23, pool);\n-    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n-    conflicts_size += 23;\n-    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n-    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n-    all_conflicts.clear();\n-\n-    // Exceeds maximum number of conflicts.\n-    add_descendants(tx8, 1, pool);\n-    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n-\n-    // Tests for HasNoNewUnconfirmed\n-    const auto spends_unconfirmed = make_tx({tx1}, {36 * CENT});\n-    for (const auto& input : spends_unconfirmed->vin) {\n-        // Spends unconfirmed inputs.\n-        BOOST_CHECK(pool.exists(input.prevout.hash));\n+\n+    dummy.clear();\n+    // Conflicting directly with all those conflicts doesn't change anything.\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicting_transaction.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_conflicts,\n+                                       /*all_conflicts=*/ dummy) == std::nullopt);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), dummy.size());\n+    dummy.clear();\n+\n+    // If we mine the parent_tx's, then the clusters split (102 clusters).\n+    pool.removeForBlock({parent_tx_1, parent_tx_2}, /* dummy */ 1);\n+\n+    // Add some descendants now to each of the direct children (we can do this now that the clusters have split).\n+    for (const auto& child : direct_children) {\n+        add_descendants(child, 10, pool);",
      "path": "src/test/rbf_tests.cpp",
      "position": 245,
      "original_position": 245,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Removing this doesn't make the test to fail:\r\n\r\n```diff\r\ndiff --git a/src/test/rbf_tests.cpp b/src/test/rbf_tests.cpp\r\nindex 45dd8bcb12..8ef8f0618c 100644\r\n--- a/src/test/rbf_tests.cpp\r\n+++ b/src/test/rbf_tests.cpp\r\n@@ -225,7 +225,7 @@ BOOST_FIXTURE_TEST_CASE(rbf_conflicts_calculator, TestChain100Setup)\r\n\r\n     // Add some descendants now to each of the direct children (we can do this now that the clusters have split).\r\n     for (const auto& child : direct_children) {\r\n-        add_descendants(child, 10, pool);\r\n+\r\n     }\r\n```",
      "created_at": "2025-10-22T07:53:03Z",
      "updated_at": "2025-10-22T10:00:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2450756366",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2450756366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 228,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2451080297",
      "pull_request_review_id": 3363955723,
      "id": 2451080297,
      "node_id": "PRRC_kwDOABII586SGIRp",
      "diff_hunk": "@@ -195,48 +204,57 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT\n     }\n \n     // Check that TRUC_ANCESTOR_LIMIT would not be violated.\n-    if (mempool_ancestors.size() + 1 > TRUC_ANCESTOR_LIMIT) {\n+    if (mempool_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {",
      "path": "src/policy/truc_policy.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Unkilled mutant:\r\n\r\n```diff\r\ndiff --git a/src/policy/truc_policy.cpp b/src/policy/truc_policy.cpp\r\nindex dd16eccb7c..c60dff899f 100644\r\n--- a/src/policy/truc_policy.cpp\r\n+++ b/src/policy/truc_policy.cpp\r\n@@ -204,7 +204,7 @@ std::optional<std::pair<std::string, CTransactionRef>> SingleTRUCChecks(const CT\r\n     }\r\n\r\n     // Check that TRUC_ANCESTOR_LIMIT would not be violated.\r\n-    if (mempool_parents.size() + 1 > TRUC_ANCESTOR_LIMIT) {\r\n+    if (mempool_parents.size() / 1 > TRUC_ANCESTOR_LIMIT) {\r\n         return std::make_pair(strprintf(\"tx %s (wtxid=%s) would have too many ancestors\",\r\n                          ptx->GetHash().ToString(), ptx->GetWitnessHash().ToString()),\r\n             nullptr);\r\n```",
      "created_at": "2025-10-22T09:07:33Z",
      "updated_at": "2025-10-22T10:00:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2451080297",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2451080297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 207,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469541272",
      "pull_request_review_id": 3388723571,
      "id": 2469541272,
      "node_id": "PRRC_kwDOABII586TMjWY",
      "diff_hunk": "@@ -152,5 +208,65 @@ static void MempoolCheck(benchmark::Bench& bench)\n     });\n }\n \n+#if 0\n+static void MemPoolMiningScoreCheck(benchmark::Bench& bench)\n+{\n+    // Default test: each cluster is of size 20, and we'll try to RBF with a\n+    // transaction that merges 10 clusters, evicting 10 transactions from each.\n+\n+    FastRandomContext det_rand{true};\n+    int childTxs = 10;\n+    if (bench.complexityN() > 1) {\n+        childTxs = static_cast<int>(bench.complexityN());\n+    }\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(ChainType::MAIN);\n+    CTxMemPool& pool = *testing_setup.get()->m_node.mempool;\n+\n+    LOCK2(cs_main, pool.cs);\n+\n+    std::vector<CTransactionRef> parent_txs_for_rbf;\n+    std::set<uint256> child_txs_to_conflict_with;\n+\n+    for (int i=0; i<10; i++) {\n+        std::vector<CTransactionRef> transactions = CreateCoinCluster(det_rand, childTxs, /*min_ancestors=*/1);\n+        parent_txs_for_rbf.push_back(transactions[0]);\n+        // Conflict with everything after the first 10 transactions\n+        for (size_t j=10; j<transactions.size(); ++j) {\n+            child_txs_to_conflict_with.insert(transactions[j]->GetHash());\n+        }\n+\n+        // Add all transactions to the mempool.\n+        for (auto& tx : transactions) {\n+            AddTx(tx, pool, det_rand);\n+        }\n+    }\n+\n+    // Construct a transaction that spends from each of the parent transactions\n+    // selected.\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(10);\n+    for (size_t i=0; i<parent_txs_for_rbf.size(); ++i) {\n+        tx.vin[i].prevout = COutPoint(parent_txs_for_rbf[i]->GetHash(), 0);\n+        tx.vin[i].scriptSig = CScript() << i;\n+    }\n+    tx.vout.resize(1);\n+    for (auto& out : tx.vout) {\n+        out.scriptPubKey = CScript() << CScriptNum(det_rand.randrange(19)+1) << OP_EQUAL;\n+        out.nValue = 10 * COIN;\n+    }\n+\n+    CTxMemPool::setEntries all_conflicts = pool.GetIterSet(child_txs_to_conflict_with);\n+    CTxMemPoolEntry entry(MakeTransactionRef(tx), det_rand.randrange(10000)+1000, 0, 1, 0, false, 4, LockPoints());\n+\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n+        CTxMemPool::Limits limits(pool.m_limits);\n+        pool.CalculateMiningScoreOfReplacementTx(entry, det_rand.randrange(30000)+1000, all_conflicts, limits);\n+    });\n+}\n+#endif\n+\n+BENCHMARK(MemPoolAncestorsDescendants, benchmark::PriorityLevel::HIGH);\n+BENCHMARK(MemPoolAddTransactions, benchmark::PriorityLevel::HIGH);\n BENCHMARK(ComplexMemPool, benchmark::PriorityLevel::HIGH);\n BENCHMARK(MempoolCheck, benchmark::PriorityLevel::HIGH);\n+//BENCHMARK(MemPoolMiningScoreCheck, benchmark::PriorityLevel::HIGH);",
      "path": "src/bench/mempool_stress.cpp",
      "position": 1,
      "original_position": 169,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "4c359dabd2a7ca5a5d7469070f55e66a88196291",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In 4c359dabd2a7ca5a5d7469070f55e66a88196291\r\n\r\nIs this benchmark supposed to be deleted? It seems like it was written a long time ago.",
      "created_at": "2025-10-28T13:17:36Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469541272",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469541272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469577973",
      "pull_request_review_id": 3388723571,
      "id": 2469577973,
      "node_id": "PRRC_kwDOABII586TMsT1",
      "diff_hunk": "@@ -50,6 +50,9 @@ struct bilingual_str;\n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+/** How many linearization iterations required for TxGraph clusters */",
      "path": "src/txmempool.h",
      "position": 1,
      "original_position": 4,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "83c8753abf9c2af75cfbacd5488605332da588a4",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "in 83c8753abf9c2af75cfbacd5488605332da588a4, I think this is missing a few words?\r\n\r\n```suggestion\r\n/** How many linearization iterations required for TxGraph clusters to have \"acceptable\" quality, if they cannot be optimally linearized with fewer iterations. */\r\n```",
      "created_at": "2025-10-28T13:28:17Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469577973",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469577973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469604073",
      "pull_request_review_id": 3388723571,
      "id": 2469604073,
      "node_id": "PRRC_kwDOABII586TMyrp",
      "diff_hunk": "@@ -1230,180 +902,131 @@ void CTxMemPool::SetLoadTried(bool load_tried)\n std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txid>& txids) const\n {\n     AssertLockHeld(cs);\n-    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n-    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n-    // necessarily mean the entry has been processed.\n-    WITH_FRESH_EPOCH(m_epoch);\n-    for (const auto& it : clustered_txs) {\n-        visited(it);\n-    }\n-    // i = index of where the list of entries to process starts\n-    for (size_t i{0}; i < clustered_txs.size(); ++i) {\n-        // DoS protection: if there are 500 or more entries to process, just quit.\n-        if (clustered_txs.size() > 500) return {};\n-        const txiter& tx_iter = clustered_txs.at(i);\n-        for (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\n-            for (const CTxMemPoolEntry& entry : entries) {\n-                const auto entry_it = mapTx.iterator_to(entry);\n-                if (!visited(entry_it)) {\n-                    clustered_txs.push_back(entry_it);\n+\n+    std::vector<CTxMemPool::txiter> ret;\n+    std::set<const CTxMemPoolEntry*> unique_cluster_representatives;\n+    for (auto txid : txids) {\n+        auto it = mapTx.find(txid);\n+        if (it != mapTx.end()) {\n+            auto cluster = m_txgraph->GetCluster(*it, TxGraph::Level::MAIN);\n+            if (unique_cluster_representatives.insert(static_cast<const CTxMemPoolEntry*>(&(**cluster.begin()))).second) {\n+                for (auto tx : cluster) {\n+                    ret.emplace_back(mapTx.iterator_to(static_cast<const CTxMemPoolEntry&>(*tx)));\n                 }\n             }\n         }\n     }\n-    return clustered_txs;\n-}\n-\n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n+    if (ret.size() > 500) {\n+        return {};\n     }\n-    return std::nullopt;\n+    return ret;\n }\n \n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n-\n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};\n-    if (err_string.has_value()) {\n-        // Unsupported topology for calculating a feerate diagram\n-        return util::Error{Untranslated(err_string.value())};\n-    }\n-\n-    // new diagram will have chunks that consist of each ancestor of\n-    // direct_conflicts that is at its own fee/size, along with the replacement\n-    // tx/package at its own fee/size\n-\n-    // old diagram will consist of the ancestors and descendants of each element of\n-    // all_conflicts.  every such transaction will either be at its own feerate (followed\n-    // by any descendant at its own feerate), or as a single chunk at the descendant's\n-    // ancestor feerate.\n-\n-    std::vector<FeeFrac> old_chunks;\n-    // Step 1: build the old diagram.\n \n-    // The above clusters are all trivially linearized;\n-    // they have a strict topology of 1 or two connected transactions.\n-\n-    // OLD: Compute existing chunks from all affected clusters\n-    for (auto txiter : m_to_remove) {\n-        // Does this transaction have descendants?\n-        if (txiter->GetCountWithDescendants() > 1) {\n-            // Consider this tx when we consider the descendant.\n-            continue;\n-        }\n-        // Does this transaction have ancestors?\n-        FeeFrac individual{txiter->GetModifiedFee(), txiter->GetTxSize()};\n-        if (txiter->GetCountWithAncestors() > 1) {\n-            // We'll add chunks for either the ancestor by itself and this tx\n-            // by itself, or for a combined package.\n-            FeeFrac package{txiter->GetModFeesWithAncestors(), static_cast<int32_t>(txiter->GetSizeWithAncestors())};\n-            if (individual >> package) {\n-                // The individual feerate is higher than the package, and\n-                // therefore higher than the parent's fee. Chunk these\n-                // together.\n-                old_chunks.emplace_back(package);\n-            } else {\n-                // Add two points, one for the parent and one for this child.\n-                old_chunks.emplace_back(package - individual);\n-                old_chunks.emplace_back(individual);\n-            }\n-        } else {\n-            old_chunks.emplace_back(individual);\n-        }\n-    }\n-\n-    // No topology restrictions post-chunking; sort\n-    std::sort(old_chunks.begin(), old_chunks.end(), std::greater());\n-\n-    std::vector<FeeFrac> new_chunks;\n-\n-    /* Step 2: build the NEW diagram\n-     * CON = Conflicts of proposed chunk\n-     * CNK = Proposed chunk\n-     * NEW = OLD - CON + CNK: New diagram includes all chunks in OLD, minus\n-     * the conflicts, plus the proposed chunk\n-     */\n-\n-    // OLD - CON: Add any parents of direct conflicts that are not conflicted themselves\n-    for (auto direct_conflict : m_to_remove) {\n-        // If a direct conflict has an ancestor that is not in all_conflicts,\n-        // it can be affected by the replacement of the child.\n-        if (direct_conflict->GetMemPoolParentsConst().size() > 0) {\n-            // Grab the parent.\n-            const CTxMemPoolEntry& parent = direct_conflict->GetMemPoolParentsConst().begin()->get();\n-            if (!m_to_remove.contains(m_pool->mapTx.iterator_to(parent))) {\n-                // This transaction would be left over, so add to the NEW\n-                // diagram.\n-                new_chunks.emplace_back(parent.GetModifiedFee(), parent.GetTxSize());\n-            }\n-        }\n+    if (!CheckMemPoolPolicyLimits()) {\n+        return util::Error{Untranslated(\"cluster size limit exceeded\")};\n     }\n-    // + CNK: Add the proposed chunk itself\n-    new_chunks.emplace_back(replacement_feerate);\n \n-    // No topology restrictions post-chunking; sort\n-    std::sort(new_chunks.begin(), new_chunks.end(), std::greater());\n-    return std::make_pair(old_chunks, new_chunks);\n+    return m_pool->m_txgraph->GetMainStagingDiagrams();\n }\n \n CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTransactionRef& tx, const CAmount fee, int64_t time, unsigned int entry_height, uint64_t entry_sequence, bool spends_coinbase, int64_t sigops_cost, LockPoints lp)\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n-    auto newit = m_to_add.emplace(tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    Assume(!m_dependencies_processed);\n+\n+    // We need to reprocess dependencies after adding a new transaction.\n+    m_dependencies_processed = false;\n+\n     CAmount delta{0};\n     m_pool->ApplyDelta(tx->GetHash(), delta);\n-    if (delta) m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+\n+    TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\n+    auto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    if (delta) {",
      "path": "src/txmempool.cpp",
      "position": 1184,
      "original_position": 1176,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450722652,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes, calling `UpdateModifiedFee(0)` does nothing. I think it's fine to keep this :shrug:",
      "created_at": "2025-10-28T13:35:42Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469604073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469604073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 958,
      "original_line": 958,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469612014",
      "pull_request_review_id": 3388723571,
      "id": 2469612014,
      "node_id": "PRRC_kwDOABII586TM0nu",
      "diff_hunk": "@@ -413,6 +413,7 @@ static CTxMemPool::Options&& Flatten(CTxMemPool::Options&& opts, bilingual_str&\n CTxMemPool::CTxMemPool(Options opts, bilingual_str& error)\n     : m_opts{Flatten(std::move(opts), error)}\n {\n+    m_txgraph = MakeTxGraph(64, 101'000, 10'000);",
      "path": "src/txmempool.cpp",
      "position": 1,
      "original_position": 4,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "91d9bfcca62bd6c168476f6af442bd7049ff872e",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit 91d9bfcca62bd6c168476f6af442bd7049ff872e\r\n\r\nI was going to complain about this magic number, maybe squash 83c8753abf9c2af75cfbacd5488605332da588a4 into its parent?",
      "created_at": "2025-10-28T13:37:45Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469612014",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469612014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 416,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469628917",
      "pull_request_review_id": 3388723571,
      "id": 2469628917,
      "node_id": "PRRC_kwDOABII586TM4v1",
      "diff_hunk": "@@ -891,6 +893,7 @@ void CTxMemPool::PrioritiseTransaction(const Txid& hash, const CAmount& nFeeDelt\n         delta = SaturatingAdd(delta, nFeeDelta);\n         txiter it = mapTx.find(hash);\n         if (it != mapTx.end()) {\n+            m_txgraph->SetTransactionFee(*it, it->GetModifiedFee() + nFeeDelta);",
      "path": "src/txmempool.cpp",
      "position": 801,
      "original_position": 13,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "2812471c2bfce6215d6d58c1defd39c7a050edbd",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "2812471c2bfce6215d6d58c1defd39c7a050edbd: Maybe deserves a comment\r\n\r\n```suggestion\r\n            // PrioritiseTransaction calls stack on previous ones. Set the new transaction fee to be current modified fee + feedelta.\r\n            m_txgraph->SetTransactionFee(*it, it->GetModifiedFee() + nFeeDelta);\r\n```",
      "created_at": "2025-10-28T13:42:22Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469628917",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469628917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 594,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469865825",
      "pull_request_review_id": 3388723571,
      "id": 2469865825,
      "node_id": "PRRC_kwDOABII586TNylh",
      "diff_hunk": "@@ -112,6 +125,19 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         assert(tx_pool.size() < info_all.size());\n         WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n     }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // Try eviction\n+        LOCK2(::cs_main, tx_pool.cs);\n+        tx_pool.TrimToSize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0U, tx_pool.DynamicMemoryUsage()));\n+        tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1);",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 1,
      "original_position": 52,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "0e25736d6e07b411beacc51f89c62c8efdb83fde",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "in 0e25736d6e0\r\n\r\nIt would help the fuzzer run faster to just call `check` once at the end, instead of after each round of potential removals.",
      "created_at": "2025-10-28T14:46:12Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469865825",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469865825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469945254",
      "pull_request_review_id": 3388723571,
      "id": 2469945254,
      "node_id": "PRRC_kwDOABII586TOF-m",
      "diff_hunk": "@@ -1354,6 +1335,32 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef\n         return MempoolAcceptResult::Failure(ws.m_state);\n     }\n \n+    // Now that we've verified the cluster limit is respected, we can perform\n+    // calculations involving the full ancestors of the tx.",
      "path": "src/validation.cpp",
      "position": 393,
      "original_position": 98,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "675fa79bb280129fb87e5d1884e670a35a03f5cd",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It seems a bit unfortunate that, prior to 675fa79bb280129fb87e5d1884e670a35a03f5cd, there isn't a cap on ancestor count when we call `CalculateMemPoolAncestors`. Could the rework be done earlier?",
      "created_at": "2025-10-28T15:07:56Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469945254",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469945254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": 1362,
      "original_start_line": 1338,
      "start_side": "RIGHT",
      "line": 1363,
      "original_line": 1363,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469950583",
      "pull_request_review_id": 3388723571,
      "id": 2469950583,
      "node_id": "PRRC_kwDOABII586TOHR3",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "If not squashed, perhaps move it earlier so that the test can have the correct string when introduced?",
      "created_at": "2025-10-28T15:09:03Z",
      "updated_at": "2025-10-28T15:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2469950583",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469950583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470293205",
      "pull_request_review_id": 3389790663,
      "id": 2470293205,
      "node_id": "PRRC_kwDOABII586TPa7V",
      "diff_hunk": "@@ -1230,180 +902,131 @@ void CTxMemPool::SetLoadTried(bool load_tried)\n std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txid>& txids) const\n {\n     AssertLockHeld(cs);\n-    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n-    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n-    // necessarily mean the entry has been processed.\n-    WITH_FRESH_EPOCH(m_epoch);\n-    for (const auto& it : clustered_txs) {\n-        visited(it);\n-    }\n-    // i = index of where the list of entries to process starts\n-    for (size_t i{0}; i < clustered_txs.size(); ++i) {\n-        // DoS protection: if there are 500 or more entries to process, just quit.\n-        if (clustered_txs.size() > 500) return {};\n-        const txiter& tx_iter = clustered_txs.at(i);\n-        for (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\n-            for (const CTxMemPoolEntry& entry : entries) {\n-                const auto entry_it = mapTx.iterator_to(entry);\n-                if (!visited(entry_it)) {\n-                    clustered_txs.push_back(entry_it);\n+\n+    std::vector<CTxMemPool::txiter> ret;\n+    std::set<const CTxMemPoolEntry*> unique_cluster_representatives;\n+    for (auto txid : txids) {\n+        auto it = mapTx.find(txid);\n+        if (it != mapTx.end()) {\n+            auto cluster = m_txgraph->GetCluster(*it, TxGraph::Level::MAIN);\n+            if (unique_cluster_representatives.insert(static_cast<const CTxMemPoolEntry*>(&(**cluster.begin()))).second) {\n+                for (auto tx : cluster) {\n+                    ret.emplace_back(mapTx.iterator_to(static_cast<const CTxMemPoolEntry&>(*tx)));\n                 }\n             }\n         }\n     }\n-    return clustered_txs;\n-}\n-\n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n+    if (ret.size() > 500) {\n+        return {};\n     }\n-    return std::nullopt;\n+    return ret;\n }\n \n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n-\n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};\n-    if (err_string.has_value()) {\n-        // Unsupported topology for calculating a feerate diagram\n-        return util::Error{Untranslated(err_string.value())};\n-    }\n-\n-    // new diagram will have chunks that consist of each ancestor of\n-    // direct_conflicts that is at its own fee/size, along with the replacement\n-    // tx/package at its own fee/size\n-\n-    // old diagram will consist of the ancestors and descendants of each element of\n-    // all_conflicts.  every such transaction will either be at its own feerate (followed\n-    // by any descendant at its own feerate), or as a single chunk at the descendant's\n-    // ancestor feerate.\n-\n-    std::vector<FeeFrac> old_chunks;\n-    // Step 1: build the old diagram.\n \n-    // The above clusters are all trivially linearized;\n-    // they have a strict topology of 1 or two connected transactions.\n-\n-    // OLD: Compute existing chunks from all affected clusters\n-    for (auto txiter : m_to_remove) {\n-        // Does this transaction have descendants?\n-        if (txiter->GetCountWithDescendants() > 1) {\n-            // Consider this tx when we consider the descendant.\n-            continue;\n-        }\n-        // Does this transaction have ancestors?\n-        FeeFrac individual{txiter->GetModifiedFee(), txiter->GetTxSize()};\n-        if (txiter->GetCountWithAncestors() > 1) {\n-            // We'll add chunks for either the ancestor by itself and this tx\n-            // by itself, or for a combined package.\n-            FeeFrac package{txiter->GetModFeesWithAncestors(), static_cast<int32_t>(txiter->GetSizeWithAncestors())};\n-            if (individual >> package) {\n-                // The individual feerate is higher than the package, and\n-                // therefore higher than the parent's fee. Chunk these\n-                // together.\n-                old_chunks.emplace_back(package);\n-            } else {\n-                // Add two points, one for the parent and one for this child.\n-                old_chunks.emplace_back(package - individual);\n-                old_chunks.emplace_back(individual);\n-            }\n-        } else {\n-            old_chunks.emplace_back(individual);\n-        }\n-    }\n-\n-    // No topology restrictions post-chunking; sort\n-    std::sort(old_chunks.begin(), old_chunks.end(), std::greater());\n-\n-    std::vector<FeeFrac> new_chunks;\n-\n-    /* Step 2: build the NEW diagram\n-     * CON = Conflicts of proposed chunk\n-     * CNK = Proposed chunk\n-     * NEW = OLD - CON + CNK: New diagram includes all chunks in OLD, minus\n-     * the conflicts, plus the proposed chunk\n-     */\n-\n-    // OLD - CON: Add any parents of direct conflicts that are not conflicted themselves\n-    for (auto direct_conflict : m_to_remove) {\n-        // If a direct conflict has an ancestor that is not in all_conflicts,\n-        // it can be affected by the replacement of the child.\n-        if (direct_conflict->GetMemPoolParentsConst().size() > 0) {\n-            // Grab the parent.\n-            const CTxMemPoolEntry& parent = direct_conflict->GetMemPoolParentsConst().begin()->get();\n-            if (!m_to_remove.contains(m_pool->mapTx.iterator_to(parent))) {\n-                // This transaction would be left over, so add to the NEW\n-                // diagram.\n-                new_chunks.emplace_back(parent.GetModifiedFee(), parent.GetTxSize());\n-            }\n-        }\n+    if (!CheckMemPoolPolicyLimits()) {\n+        return util::Error{Untranslated(\"cluster size limit exceeded\")};\n     }\n-    // + CNK: Add the proposed chunk itself\n-    new_chunks.emplace_back(replacement_feerate);\n \n-    // No topology restrictions post-chunking; sort\n-    std::sort(new_chunks.begin(), new_chunks.end(), std::greater());\n-    return std::make_pair(old_chunks, new_chunks);\n+    return m_pool->m_txgraph->GetMainStagingDiagrams();\n }\n \n CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTransactionRef& tx, const CAmount fee, int64_t time, unsigned int entry_height, uint64_t entry_sequence, bool spends_coinbase, int64_t sigops_cost, LockPoints lp)\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n-    auto newit = m_to_add.emplace(tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    Assume(!m_dependencies_processed);\n+\n+    // We need to reprocess dependencies after adding a new transaction.\n+    m_dependencies_processed = false;\n+\n     CAmount delta{0};\n     m_pool->ApplyDelta(tx->GetHash(), delta);\n-    if (delta) m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+\n+    TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\n+    auto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    if (delta) {",
      "path": "src/txmempool.cpp",
      "position": 1184,
      "original_position": 1176,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450722652,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Perfect, I wasn't aware of `UpdateModifiedFee`, I just took a look and this is a saturated addition, so it won't have any effect. This can be ignored.",
      "created_at": "2025-10-28T16:42:53Z",
      "updated_at": "2025-10-28T16:42:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2470293205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470293205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 958,
      "original_line": 958,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474270872",
      "pull_request_review_id": 3394857863,
      "id": 2474270872,
      "node_id": "PRRC_kwDOABII586TemCY",
      "diff_hunk": "@@ -702,17 +419,28 @@ void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendhei\n     uint64_t checkTotal = 0;\n     CAmount check_total_fee{0};\n     uint64_t innerUsage = 0;\n-    uint64_t prev_ancestor_count{0};\n+\n+    assert(!m_txgraph->IsOversized(TxGraph::Level::MAIN));\n+    m_txgraph->SanityCheck();\n \n     CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(&active_coins_tip));\n \n-    for (const auto& it : GetSortedDepthAndScore()) {\n+    std::optional<Wtxid> last_wtxid = std::nullopt;\n+\n+    for (const auto& it : GetSortedScoreWithTopology()) {",
      "path": "src/txmempool.cpp",
      "position": 1,
      "original_position": 599,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Adds some GetFeerateDiagram coverage that will get hit in various contexts including fuzz\r\n\r\n```\r\ndiff --git a/src/txmempool.cpp b/src/txmempool.cpp\r\nindex b0c9ab043c..3dcc0dd3e4 100644\r\n--- a/src/txmempool.cpp\r\n+++ b/src/txmempool.cpp\r\n@@ -426,7 +426,13 @@ void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendhei\r\n     CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(&active_coins_tip));\r\n \r\n+    const auto score_with_topo{GetSortedScoreWithTopology()};\r\n+\r\n+    // Number of chunks bounded by number of txs\r\n+    const auto diagram{GetFeerateDiagram()};\r\n+    assert(diagram.size() <= score_with_topo.size());\r\n+\r\n     std::optional<Wtxid> last_wtxid = std::nullopt;\r\n \r\n-    for (const auto& it : GetSortedScoreWithTopology()) {\r\n+    for (const auto& it : score_with_topo) {\r\n         checkTotal += it->GetTxSize();\r\n         check_total_fee += it->GetFee();\r\n```",
      "created_at": "2025-10-29T16:59:23Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474270872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474270872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474280989",
      "pull_request_review_id": 3394857863,
      "id": 2474280989,
      "node_id": "PRRC_kwDOABII586Teogd",
      "diff_hunk": "@@ -104,6 +100,23 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n         auto block_template = assembler.CreateNewBlock();\n         Assert(block_template->block.vtx.size() >= 1);\n+\n+        // Try updating the mempool for this block, as though it were mined.\n+        LOCK2(::cs_main, tx_pool.cs);\n+        tx_pool.removeForBlock(block_template->block.vtx, chainstate.m_chain.Height() + 1);\n+\n+        // Now try to add those transactions back, as though a reorg happened.\n+        std::vector<Txid> hashes_to_update;\n+        for (const auto& tx : block_template->block.vtx) {\n+            const auto res = AcceptToMemoryPool(chainstate, tx, GetTime(), true, /*test_accept=*/false);\n+            if (res.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n+                hashes_to_update.push_back(tx->GetHash());\n+            } else {\n+                tx_pool.removeRecursive(*tx, MemPoolRemovalReason::REORG /* dummy */);",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 1,
      "original_position": 35,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "what does dummy mean here?",
      "created_at": "2025-10-29T17:03:20Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474280989",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474280989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474283513",
      "pull_request_review_id": 3394857863,
      "id": 2474283513,
      "node_id": "PRRC_kwDOABII586TepH5",
      "diff_hunk": "@@ -112,6 +125,19 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         assert(tx_pool.size() < info_all.size());\n         WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n     }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // Try eviction\n+        LOCK2(::cs_main, tx_pool.cs);\n+        tx_pool.TrimToSize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0U, tx_pool.DynamicMemoryUsage()));",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 1,
      "original_position": 51,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "no-op trimming makes sense too (probably a smarter of way of having this hit than I suggest here)\r\n\r\n```suggestion\r\n        tx_pool.TrimToSize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0U, tx_pool.DynamicMemoryUsage() * 2));\r\n```",
      "created_at": "2025-10-29T17:04:20Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474283513",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474283513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474299026",
      "pull_request_review_id": 3394857863,
      "id": 2474299026,
      "node_id": "PRRC_kwDOABII586Tes6S",
      "diff_hunk": "@@ -56,7 +56,9 @@ struct MinerTestingSetup : public TestingSetup {\n         // instead.\n         m_node.mempool.reset();\n         bilingual_str error;\n-        m_node.mempool = std::make_unique<CTxMemPool>(MemPoolOptionsForTest(m_node), error);\n+        auto opts = MemPoolOptionsForTest(m_node);\n+        opts.limits.cluster_size_vbytes = 1'250'000;",
      "path": "src/test/miner_tests.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "could we get this magic number explained?",
      "created_at": "2025-10-29T17:10:32Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474299026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474299026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474321911",
      "pull_request_review_id": 3394857863,
      "id": 2474321911,
      "node_id": "PRRC_kwDOABII586Teyf3",
      "diff_hunk": "@@ -281,40 +325,42 @@ void MinerTestingSetup::TestBasicMining(const CScript& scriptPubKey, const std::\n         BOOST_REQUIRE(block_template);\n         CBlock block{block_template->getBlock()};\n \n-        // block sigops > limit: 1000 CHECKMULTISIG + 1\n-        tx.vin.resize(1);\n-        // NOTE: OP_NOP is used to force 20 SigOps for the CHECKMULTISIG\n-        tx.vin[0].scriptSig = CScript() << OP_0 << OP_0 << OP_0 << OP_NOP << OP_CHECKMULTISIG << OP_1;\n-        tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n-        tx.vin[0].prevout.n = 0;\n-        tx.vout.resize(1);\n-        tx.vout[0].nValue = BLOCKSUBSIDY;\n-        for (unsigned int i = 0; i < 1001; ++i) {\n-            tx.vout[0].nValue -= LOWFEE;\n-            hash = tx.GetHash();\n-            bool spendsCoinbase = i == 0; // only first tx spends coinbase\n-            // If we don't set the # of sig ops in the CTxMemPoolEntry, template creation fails\n-            AddToMempool(tx_mempool, entry.Fee(LOWFEE).Time(Now<NodeSeconds>()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n-            tx.vin[0].prevout.hash = hash;\n-        }\n+        auto txs = CreateBigSigOpsCluster(txFirst[0]);\n \n+        int64_t legacy_sigops = 0;\n+        for (auto& t : txs) {\n+            AddToMempool(tx_mempool, entry.Fee(LOWFEE).Time(Now<NodeSeconds>()).SpendsCoinbase(true).FromTx(t));",
      "path": "src/test/miner_tests.cpp",
      "position": 133,
      "original_position": 84,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "without comment I found this hard to understand\r\n```suggestion\r\n            // If we don't set the # of sig ops in the CTxMemPoolEntry, template creation fails during sanity checks\r\n            AddToMempool(tx_mempool, entry.Fee(LOWFEE).Time(Now<NodeSeconds>()).SpendsCoinbase(true).FromTx(t));\r\n```",
      "created_at": "2025-10-29T17:19:30Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474321911",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474321911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": 337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474910301",
      "pull_request_review_id": 3394857863,
      "id": 2474910301,
      "node_id": "PRRC_kwDOABII586ThCJd",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])\n+            last_val = [x['vsize'], x['fee']]\n+\n+    def test_limit_enforcement(self, cluster_submitted, target_vsize_per_tx=None):\n+        \"\"\"\n+        the cluster may change as a result of these transactions, so cluster_submitted is mutated accordingly\n+        \"\"\"\n+        # Cluster has already been submitted and has at least 3 transactions, otherwise this test won't work.\n+        assert_greater_than_or_equal(len(cluster_submitted), 3)\n+        node = self.nodes[0]\n+        last_result = cluster_submitted[-1]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=last_result[\"new_utxo\"], target_vsize=target_vsize_per_tx)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # It should also work during replacement",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 98,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n        # It should also limit cluster sizes during replacement\r\n```",
      "created_at": "2025-10-29T19:04:25Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474910301",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474910301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474913651",
      "pull_request_review_id": 3394857863,
      "id": 2474913651,
      "node_id": "PRRC_kwDOABII586ThC9z",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])\n+            last_val = [x['vsize'], x['fee']]\n+\n+    def test_limit_enforcement(self, cluster_submitted, target_vsize_per_tx=None):\n+        \"\"\"\n+        the cluster may change as a result of these transactions, so cluster_submitted is mutated accordingly\n+        \"\"\"\n+        # Cluster has already been submitted and has at least 3 transactions, otherwise this test won't work.\n+        assert_greater_than_or_equal(len(cluster_submitted), 3)\n+        node = self.nodes[0]\n+        last_result = cluster_submitted[-1]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=last_result[\"new_utxo\"], target_vsize=target_vsize_per_tx)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # It should also work during replacement\n+        utxo_to_double_spend = self.wallet.get_utxo(confirmed_only=True)\n+        fee = Decimal(\"0.000001\")\n+        tx_to_replace = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_double_spend, fee=fee)\n+        node.sendrawtransaction(tx_to_replace[\"hex\"])\n+\n+        # Multiply fee by 5, which should easily cover the cost to replace. Otherwise, use the target vsize at 10sat/vB",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 104,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n        # Multiply fee by 5, which should easily cover the cost to replace (but is still too large a cluster). Otherwise, use the target vsize at 10sat/vB\r\n```",
      "created_at": "2025-10-29T19:04:48Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2474913651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474913651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475016196",
      "pull_request_review_id": 3394857863,
      "id": 2475016196,
      "node_id": "PRRC_kwDOABII586ThcAE",
      "diff_hunk": "@@ -193,12 +190,12 @@ def test_package_rbf_additional_fees(self):\n \n     def test_package_rbf_max_conflicts(self):\n         node = self.nodes[0]\n-        self.log.info(\"Check Package RBF cannot replace more than MAX_REPLACEMENT_CANDIDATES transactions\")\n-        num_coins = 51\n+        self.log.info(\"Check Package RBF cannot conflict with  more than MAX_REPLACEMENT_CANDIDATES clusters\")\n+        num_coins = 101\n         parent_coins = self.coins[:num_coins]\n         del self.coins[:num_coins]\n \n-        # Original transactions: 51 transactions with 1 descendants each -> 102 total transactions\n+        # Original transactions: 101 transactions with 1 descendants each -> 202 total transactions, 101 clusters",
      "path": "test/functional/mempool_package_rbf.py",
      "position": 1,
      "original_position": 22,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": 2434078457,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "just extended it to clusters of size three and made log more sensible\r\n```\r\ndiff --git a/test/functional/mempool_package_rbf.py b/test/functional/mempool_package_rbf.py\r\nindex 759e3cb07d..c54534f6f8 100755\r\n--- a/test/functional/mempool_package_rbf.py\r\n+++ b/test/functional/mempool_package_rbf.py\r\n@@ -94,5 +94,5 @@ class PackageRBFTest(BitcoinTestFramework):\r\n \r\n     def test_package_rbf_basic(self):\r\n-        self.log.info(\"Test that a child can pay to replace its parents' conflicts of cluster size 2\")\r\n+        self.log.info(\"Test that a child can pay to replace its parents' conflicts\")\r\n         node = self.nodes[0]\r\n         # Reuse the same coins so that the transactions conflict with one another.\r\n@@ -196,10 +196,10 @@ class PackageRBFTest(BitcoinTestFramework):\r\n         del self.coins[:num_coins]\r\n \r\n-        # Original transactions: 101 transactions with 1 descendants each -> 202 total transactions, 101 clusters\r\n-        size_two_clusters = []\r\n+        # Original transactions: 101 transactions with 2 descendants each -> 303 total transactions, 101 clusters\r\n+        size_three_clusters = []\r\n         for coin in parent_coins:\r\n-            size_two_clusters.append(self.wallet.send_self_transfer_chain(from_node=node, chain_length=2, utxo_to_spend=coin))\r\n-        expected_txns = [txn[\"tx\"] for parent_child_txns in size_two_clusters for txn in parent_child_txns]\r\n-        assert_equal(len(expected_txns), num_coins * 2)\r\n+            size_three_clusters.append(self.wallet.send_self_transfer_chain(from_node=node, chain_length=3, utxo_to_spend=coin))\r\n+        expected_txns = [txn[\"tx\"] for parent_child_txns in size_three_clusters for txn in parent_child_txns]\r\n+        assert_equal(len(expected_txns), num_coins * 3)\r\n         self.assert_mempool_contents(expected=expected_txns)\r\n \r\n@@ -241,5 +241,5 @@ class PackageRBFTest(BitcoinTestFramework):\r\n         pkg_results = node.submitpackage([package_parent[\"hex\"], package_child[\"hex\"]], maxfeerate=0)\r\n         assert_equal(pkg_results[\"package_msg\"], \"success\")\r\n-        self.assert_mempool_contents(expected=[singleton_tx[\"tx\"], size_two_clusters[-1][0][\"tx\"], size_two_clusters[-1][1][\"tx\"], package_parent[\"tx\"], package_child[\"tx\"]] )\r\n+        self.assert_mempool_contents(expected=[singleton_tx[\"tx\"], size_three_clusters[-1][0][\"tx\"], size_three_clusters[-1][1][\"tx\"], size_three_clusters[-1][2][\"tx\"], package_parent[\"tx\"], package_child[\"tx\"]] )\r\n \r\n         self.generate(node, 1)\r\n```",
      "created_at": "2025-10-29T19:18:00Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2475016196",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475016196"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475071643",
      "pull_request_review_id": 3394857863,
      "id": 2475071643,
      "node_id": "PRRC_kwDOABII586Thpib",
      "diff_hunk": "@@ -104,6 +100,23 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n         auto block_template = assembler.CreateNewBlock();\n         Assert(block_template->block.vtx.size() >= 1);\n+\n+        // Try updating the mempool for this block, as though it were mined.\n+        LOCK2(::cs_main, tx_pool.cs);",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 25,
      "original_position": 25,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Since this harness is making blocks, I think it'd be good to have sigops naturally appearing in the constructed blocks. Ran this for a bit, seemed to work?\r\n\r\n```\r\ndiff --git a/src/test/fuzz/tx_pool.cpp b/src/test/fuzz/tx_pool.cpp\r\nindex 8a5863c5d5..413ab0db4c 100644\r\n--- a/src/test/fuzz/tx_pool.cpp\r\n+++ b/src/test/fuzz/tx_pool.cpp\r\n@@ -291,9 +291,18 @@ FUZZ_TARGET(tx_pool_standard, .init = initialize_tx_pool)\r\n                 tx_mut.vin.push_back(in);\r\n             }\r\n+\r\n+            // Check sigops in mempool + block template creation\r\n+            bool add_sigops{fuzzed_data_provider.ConsumeBool()};\r\n+\r\n             const auto amount_fee = fuzzed_data_provider.ConsumeIntegralInRange<CAmount>(-1000, amount_in);\r\n             const auto amount_out = (amount_in - amount_fee) / num_out;\r\n             for (int i = 0; i < num_out; ++i) {\r\n-                tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\r\n+                if (i == 0 && add_sigops) {\r\n+                    tx_mut.vout.emplace_back(amount_out, CScript() << std::vector<unsigned char>(33, 0x02) << OP_CHECKSIG);\r\n+                } else {\r\n+                    tx_mut.vout.emplace_back(amount_out, P2WSH_OP_TRUE);\r\n+                }\r\n             }\r\n+\r\n             auto tx = MakeTransactionRef(tx_mut);\r\n             // Restore previously removed outpoints\r\n```",
      "created_at": "2025-10-29T19:30:18Z",
      "updated_at": "2025-10-29T19:36:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2475071643",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475071643"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 105,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477858904",
      "pull_request_review_id": 3399284521,
      "id": 2477858904,
      "node_id": "PRRC_kwDOABII586TsSBY",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 82,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "8f62e9177b9d35beb27ca9749768b99543d4225b",
      "in_reply_to_id": 2436684815,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "My hesitation to include stricter tests on the chunks is that we currently have no guarantee that our linearizations will be anything more than topological, so it feels brittle to add tests that put an expectation on linearization quality. EDIT: actually we can say more, specifically about the properties of chunking, which this code does test -- but if I'm understanding some of the test cases right I think there are also assumptions about linearization quality being mixed in too.\r\n\r\nPerhaps something like this would make more sense in the context of implementing SFL?",
      "created_at": "2025-10-30T12:06:12Z",
      "updated_at": "2025-10-30T12:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2477858904",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477858904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477948499",
      "pull_request_review_id": 3399402759,
      "id": 2477948499,
      "node_id": "PRRC_kwDOABII586Tsn5T",
      "diff_hunk": "@@ -152,5 +208,65 @@ static void MempoolCheck(benchmark::Bench& bench)\n     });\n }\n \n+#if 0\n+static void MemPoolMiningScoreCheck(benchmark::Bench& bench)\n+{\n+    // Default test: each cluster is of size 20, and we'll try to RBF with a\n+    // transaction that merges 10 clusters, evicting 10 transactions from each.\n+\n+    FastRandomContext det_rand{true};\n+    int childTxs = 10;\n+    if (bench.complexityN() > 1) {\n+        childTxs = static_cast<int>(bench.complexityN());\n+    }\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(ChainType::MAIN);\n+    CTxMemPool& pool = *testing_setup.get()->m_node.mempool;\n+\n+    LOCK2(cs_main, pool.cs);\n+\n+    std::vector<CTransactionRef> parent_txs_for_rbf;\n+    std::set<uint256> child_txs_to_conflict_with;\n+\n+    for (int i=0; i<10; i++) {\n+        std::vector<CTransactionRef> transactions = CreateCoinCluster(det_rand, childTxs, /*min_ancestors=*/1);\n+        parent_txs_for_rbf.push_back(transactions[0]);\n+        // Conflict with everything after the first 10 transactions\n+        for (size_t j=10; j<transactions.size(); ++j) {\n+            child_txs_to_conflict_with.insert(transactions[j]->GetHash());\n+        }\n+\n+        // Add all transactions to the mempool.\n+        for (auto& tx : transactions) {\n+            AddTx(tx, pool, det_rand);\n+        }\n+    }\n+\n+    // Construct a transaction that spends from each of the parent transactions\n+    // selected.\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(10);\n+    for (size_t i=0; i<parent_txs_for_rbf.size(); ++i) {\n+        tx.vin[i].prevout = COutPoint(parent_txs_for_rbf[i]->GetHash(), 0);\n+        tx.vin[i].scriptSig = CScript() << i;\n+    }\n+    tx.vout.resize(1);\n+    for (auto& out : tx.vout) {\n+        out.scriptPubKey = CScript() << CScriptNum(det_rand.randrange(19)+1) << OP_EQUAL;\n+        out.nValue = 10 * COIN;\n+    }\n+\n+    CTxMemPool::setEntries all_conflicts = pool.GetIterSet(child_txs_to_conflict_with);\n+    CTxMemPoolEntry entry(MakeTransactionRef(tx), det_rand.randrange(10000)+1000, 0, 1, 0, false, 4, LockPoints());\n+\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n+        CTxMemPool::Limits limits(pool.m_limits);\n+        pool.CalculateMiningScoreOfReplacementTx(entry, det_rand.randrange(30000)+1000, all_conflicts, limits);\n+    });\n+}\n+#endif\n+\n+BENCHMARK(MemPoolAncestorsDescendants, benchmark::PriorityLevel::HIGH);\n+BENCHMARK(MemPoolAddTransactions, benchmark::PriorityLevel::HIGH);\n BENCHMARK(ComplexMemPool, benchmark::PriorityLevel::HIGH);\n BENCHMARK(MempoolCheck, benchmark::PriorityLevel::HIGH);\n+//BENCHMARK(MemPoolMiningScoreCheck, benchmark::PriorityLevel::HIGH);",
      "path": "src/bench/mempool_stress.cpp",
      "position": 1,
      "original_position": 169,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "4c359dabd2a7ca5a5d7469070f55e66a88196291",
      "in_reply_to_id": 2469541272,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Oops, yes I think this must be a holdover from a very early draft of this PR, prior to txgraph.  I'll remove.",
      "created_at": "2025-10-30T12:40:54Z",
      "updated_at": "2025-10-30T12:40:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2477948499",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477948499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478967921",
      "pull_request_review_id": 3400848592,
      "id": 2478967921,
      "node_id": "PRRC_kwDOABII586Twgxx",
      "diff_hunk": "@@ -1354,6 +1335,32 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef\n         return MempoolAcceptResult::Failure(ws.m_state);\n     }\n \n+    // Now that we've verified the cluster limit is respected, we can perform\n+    // calculations involving the full ancestors of the tx.",
      "path": "src/validation.cpp",
      "position": 393,
      "original_position": 98,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "675fa79bb280129fb87e5d1884e670a35a03f5cd",
      "in_reply_to_id": 2469945254,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I took a stab at it and it's a bit tedious (I managed to move it up earlier in the commit history, but stopped when I got to a conflict with a commit that also touches truc_policy in different ways).  \r\n\r\nMy overall take is it's not such a big deal, as the concern is not around correctness of the code but a potential CPU DoS if exposed over the network, which doesn't strike me as all that concerning for an intermediate commit. ",
      "created_at": "2025-10-30T17:36:40Z",
      "updated_at": "2025-10-30T17:36:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2478967921",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478967921"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": 1362,
      "original_start_line": 1338,
      "start_side": "RIGHT",
      "line": 1363,
      "original_line": 1363,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479711613",
      "pull_request_review_id": 3401947552,
      "id": 2479711613,
      "node_id": "PRRC_kwDOABII586TzWV9",
      "diff_hunk": "@@ -193,12 +190,12 @@ def test_package_rbf_additional_fees(self):\n \n     def test_package_rbf_max_conflicts(self):\n         node = self.nodes[0]\n-        self.log.info(\"Check Package RBF cannot replace more than MAX_REPLACEMENT_CANDIDATES transactions\")\n-        num_coins = 51\n+        self.log.info(\"Check Package RBF cannot conflict with  more than MAX_REPLACEMENT_CANDIDATES clusters\")\n+        num_coins = 101\n         parent_coins = self.coins[:num_coins]\n         del self.coins[:num_coins]\n \n-        # Original transactions: 51 transactions with 1 descendants each -> 102 total transactions\n+        # Original transactions: 101 transactions with 1 descendants each -> 202 total transactions, 101 clusters",
      "path": "test/functional/mempool_package_rbf.py",
      "position": 1,
      "original_position": 22,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "2aad9f01e514b77538eb780138a8e52484eaf5a8",
      "in_reply_to_id": 2434078457,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in c00612c15592faa094d60c7bba8eb9966f5910d6",
      "created_at": "2025-10-30T22:53:02Z",
      "updated_at": "2025-10-30T22:53:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479711613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479711613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479713548",
      "pull_request_review_id": 3401952585,
      "id": 2479713548,
      "node_id": "PRRC_kwDOABII586TzW0M",
      "diff_hunk": "@@ -1002,40 +1002,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (auto ancestors{m_subpackage.m_changeset->CalculateMemPoolAncestors(ws.m_tx_handle, maybe_rbf_limits)}) {\n         ws.m_ancestors = std::move(*ancestors);\n     } else {\n-        // If CalculateMemPoolAncestors fails second time, we want the original error string.",
      "path": "src/validation.cpp",
      "position": 165,
      "original_position": 4,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "31a045700ee13a6746c4f4de253e64a0b8a61334",
      "in_reply_to_id": 2436127304,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Agreed -- I was thinking I'd tackle this in #33591, if that seems reasonable?",
      "created_at": "2025-10-30T22:54:10Z",
      "updated_at": "2025-10-30T22:54:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479713548",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479713548"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1005,
      "original_line": 1005,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479721696",
      "pull_request_review_id": 3401967869,
      "id": 2479721696,
      "node_id": "PRRC_kwDOABII586TzYzg",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think I managed to squash this into 9d0c8d4d5ec2a50ba4756b9882d8801f24542a2e; hopefully the changes all look sane...",
      "created_at": "2025-10-30T22:57:35Z",
      "updated_at": "2025-10-30T22:57:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479721696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479721696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479724535",
      "pull_request_review_id": 3401974057,
      "id": 2479724535,
      "node_id": "PRRC_kwDOABII586TzZf3",
      "diff_hunk": "@@ -152,5 +208,65 @@ static void MempoolCheck(benchmark::Bench& bench)\n     });\n }\n \n+#if 0\n+static void MemPoolMiningScoreCheck(benchmark::Bench& bench)\n+{\n+    // Default test: each cluster is of size 20, and we'll try to RBF with a\n+    // transaction that merges 10 clusters, evicting 10 transactions from each.\n+\n+    FastRandomContext det_rand{true};\n+    int childTxs = 10;\n+    if (bench.complexityN() > 1) {\n+        childTxs = static_cast<int>(bench.complexityN());\n+    }\n+    const auto testing_setup = MakeNoLogFileContext<const TestingSetup>(ChainType::MAIN);\n+    CTxMemPool& pool = *testing_setup.get()->m_node.mempool;\n+\n+    LOCK2(cs_main, pool.cs);\n+\n+    std::vector<CTransactionRef> parent_txs_for_rbf;\n+    std::set<uint256> child_txs_to_conflict_with;\n+\n+    for (int i=0; i<10; i++) {\n+        std::vector<CTransactionRef> transactions = CreateCoinCluster(det_rand, childTxs, /*min_ancestors=*/1);\n+        parent_txs_for_rbf.push_back(transactions[0]);\n+        // Conflict with everything after the first 10 transactions\n+        for (size_t j=10; j<transactions.size(); ++j) {\n+            child_txs_to_conflict_with.insert(transactions[j]->GetHash());\n+        }\n+\n+        // Add all transactions to the mempool.\n+        for (auto& tx : transactions) {\n+            AddTx(tx, pool, det_rand);\n+        }\n+    }\n+\n+    // Construct a transaction that spends from each of the parent transactions\n+    // selected.\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(10);\n+    for (size_t i=0; i<parent_txs_for_rbf.size(); ++i) {\n+        tx.vin[i].prevout = COutPoint(parent_txs_for_rbf[i]->GetHash(), 0);\n+        tx.vin[i].scriptSig = CScript() << i;\n+    }\n+    tx.vout.resize(1);\n+    for (auto& out : tx.vout) {\n+        out.scriptPubKey = CScript() << CScriptNum(det_rand.randrange(19)+1) << OP_EQUAL;\n+        out.nValue = 10 * COIN;\n+    }\n+\n+    CTxMemPool::setEntries all_conflicts = pool.GetIterSet(child_txs_to_conflict_with);\n+    CTxMemPoolEntry entry(MakeTransactionRef(tx), det_rand.randrange(10000)+1000, 0, 1, 0, false, 4, LockPoints());\n+\n+    bench.run([&]() NO_THREAD_SAFETY_ANALYSIS {\n+        CTxMemPool::Limits limits(pool.m_limits);\n+        pool.CalculateMiningScoreOfReplacementTx(entry, det_rand.randrange(30000)+1000, all_conflicts, limits);\n+    });\n+}\n+#endif\n+\n+BENCHMARK(MemPoolAncestorsDescendants, benchmark::PriorityLevel::HIGH);\n+BENCHMARK(MemPoolAddTransactions, benchmark::PriorityLevel::HIGH);\n BENCHMARK(ComplexMemPool, benchmark::PriorityLevel::HIGH);\n BENCHMARK(MempoolCheck, benchmark::PriorityLevel::HIGH);\n+//BENCHMARK(MemPoolMiningScoreCheck, benchmark::PriorityLevel::HIGH);",
      "path": "src/bench/mempool_stress.cpp",
      "position": 1,
      "original_position": 169,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "4c359dabd2a7ca5a5d7469070f55e66a88196291",
      "in_reply_to_id": 2469541272,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Gone now in 110e62ce76f029e32eeed44238db8d3c09ddb2f7.",
      "created_at": "2025-10-30T22:58:52Z",
      "updated_at": "2025-10-30T22:58:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479724535",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479724535"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479726030",
      "pull_request_review_id": 3401977487,
      "id": 2479726030,
      "node_id": "PRRC_kwDOABII586TzZ3O",
      "diff_hunk": "@@ -50,6 +50,9 @@ struct bilingual_str;\n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+/** How many linearization iterations required for TxGraph clusters */",
      "path": "src/txmempool.h",
      "position": 1,
      "original_position": 4,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "83c8753abf9c2af75cfbacd5488605332da588a4",
      "in_reply_to_id": 2469577973,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in a6649dffe92319a17790bf2add5206a84726f34d.",
      "created_at": "2025-10-30T22:59:39Z",
      "updated_at": "2025-10-30T22:59:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479726030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479726030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479727735",
      "pull_request_review_id": 3401979699,
      "id": 2479727735,
      "node_id": "PRRC_kwDOABII586TzaR3",
      "diff_hunk": "@@ -413,6 +413,7 @@ static CTxMemPool::Options&& Flatten(CTxMemPool::Options&& opts, bilingual_str&\n CTxMemPool::CTxMemPool(Options opts, bilingual_str& error)\n     : m_opts{Flatten(std::move(opts), error)}\n {\n+    m_txgraph = MakeTxGraph(64, 101'000, 10'000);",
      "path": "src/txmempool.cpp",
      "position": 1,
      "original_position": 4,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "91d9bfcca62bd6c168476f6af442bd7049ff872e",
      "in_reply_to_id": 2469612014,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This was squashed.",
      "created_at": "2025-10-30T23:00:15Z",
      "updated_at": "2025-10-30T23:00:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479727735",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479727735"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 416,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479729062",
      "pull_request_review_id": 3401981440,
      "id": 2479729062,
      "node_id": "PRRC_kwDOABII586Tzamm",
      "diff_hunk": "@@ -891,6 +893,7 @@ void CTxMemPool::PrioritiseTransaction(const Txid& hash, const CAmount& nFeeDelt\n         delta = SaturatingAdd(delta, nFeeDelta);\n         txiter it = mapTx.find(hash);\n         if (it != mapTx.end()) {\n+            m_txgraph->SetTransactionFee(*it, it->GetModifiedFee() + nFeeDelta);",
      "path": "src/txmempool.cpp",
      "position": 801,
      "original_position": 13,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "2812471c2bfce6215d6d58c1defd39c7a050edbd",
      "in_reply_to_id": 2469628917,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in b0c8081258fc37816e4675e17fa9ea8d308921f3",
      "created_at": "2025-10-30T23:00:42Z",
      "updated_at": "2025-10-30T23:00:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479729062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479729062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 594,
      "original_line": 594,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479731017",
      "pull_request_review_id": 3401984012,
      "id": 2479731017,
      "node_id": "PRRC_kwDOABII586TzbFJ",
      "diff_hunk": "@@ -112,6 +125,19 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         assert(tx_pool.size() < info_all.size());\n         WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n     }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // Try eviction\n+        LOCK2(::cs_main, tx_pool.cs);\n+        tx_pool.TrimToSize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0U, tx_pool.DynamicMemoryUsage()));\n+        tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1);",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 1,
      "original_position": 52,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "0e25736d6e07b411beacc51f89c62c8efdb83fde",
      "in_reply_to_id": 2469865825,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 0097138011b6e502bfbae528304a6a7e6b6462ad.",
      "created_at": "2025-10-30T23:01:25Z",
      "updated_at": "2025-10-30T23:01:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479731017",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479731017"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479732658",
      "pull_request_review_id": 3401986047,
      "id": 2479732658,
      "node_id": "PRRC_kwDOABII586Tzbey",
      "diff_hunk": "@@ -26,7 +26,7 @@ def func_wrapper(self, *args, **kwargs):\n         testres_error_expected = node.testmempoolaccept(rawtxs=package_hex)\n         assert_equal(len(testres_error_expected), len(package_hex))\n         for txres in testres_error_expected:\n-            assert \"package-mempool-limits\" in txres[\"package-error\"]\n+            assert \"too-large-cluster\" in txres[\"package-error\"]",
      "path": "test/functional/mempool_package_limits.py",
      "position": 14,
      "original_position": 5,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450652757,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Fixed in f784ae88327c61b08684e1e073b010a244e2b52e.",
      "created_at": "2025-10-30T23:02:02Z",
      "updated_at": "2025-10-30T23:02:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479732658",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479732658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479735309",
      "pull_request_review_id": 3401989159,
      "id": 2479735309,
      "node_id": "PRRC_kwDOABII586TzcIN",
      "diff_hunk": "@@ -702,17 +419,28 @@ void CTxMemPool::check(const CCoinsViewCache& active_coins_tip, int64_t spendhei\n     uint64_t checkTotal = 0;\n     CAmount check_total_fee{0};\n     uint64_t innerUsage = 0;\n-    uint64_t prev_ancestor_count{0};\n+\n+    assert(!m_txgraph->IsOversized(TxGraph::Level::MAIN));\n+    m_txgraph->SanityCheck();\n \n     CCoinsViewCache mempoolDuplicate(const_cast<CCoinsViewCache*>(&active_coins_tip));\n \n-    for (const auto& it : GetSortedDepthAndScore()) {\n+    std::optional<Wtxid> last_wtxid = std::nullopt;\n+\n+    for (const auto& it : GetSortedScoreWithTopology()) {",
      "path": "src/txmempool.cpp",
      "position": 1,
      "original_position": 599,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474270872,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "There was an off-by-one here (feerate diagrams start with a [0, 0]), but otherwise I incorporated this into ed23b4537ae8a8a814738909fe9a84c548f2855d.",
      "created_at": "2025-10-30T23:03:24Z",
      "updated_at": "2025-10-30T23:03:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2479735309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479735309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480717926",
      "pull_request_review_id": 3403297879,
      "id": 2480717926,
      "node_id": "PRRC_kwDOABII586T3MBm",
      "diff_hunk": "@@ -104,6 +100,23 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n         auto block_template = assembler.CreateNewBlock();\n         Assert(block_template->block.vtx.size() >= 1);\n+\n+        // Try updating the mempool for this block, as though it were mined.\n+        LOCK2(::cs_main, tx_pool.cs);\n+        tx_pool.removeForBlock(block_template->block.vtx, chainstate.m_chain.Height() + 1);\n+\n+        // Now try to add those transactions back, as though a reorg happened.\n+        std::vector<Txid> hashes_to_update;\n+        for (const auto& tx : block_template->block.vtx) {\n+            const auto res = AcceptToMemoryPool(chainstate, tx, GetTime(), true, /*test_accept=*/false);\n+            if (res.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n+                hashes_to_update.push_back(tx->GetHash());\n+            } else {\n+                tx_pool.removeRecursive(*tx, MemPoolRemovalReason::REORG /* dummy */);",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 1,
      "original_position": 35,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474280989,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think this was a copy-paste thing from elsewhere in the code (this \"dummy\" comment appears at line 123 as well, and seems to have been introduced when this fuzz test was first created) -- I presume the origin is just that the MemPoolRemovalReason doesn't matter for how `removeRecursive()` behaves, it's just passed on to callbacks.\r\n\r\nAnyway I've removed it from this line.",
      "created_at": "2025-10-31T09:32:02Z",
      "updated_at": "2025-10-31T09:33:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480717926",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480717926"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480723944",
      "pull_request_review_id": 3403305742,
      "id": 2480723944,
      "node_id": "PRRC_kwDOABII586T3Nfo",
      "diff_hunk": "@@ -112,6 +125,19 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         assert(tx_pool.size() < info_all.size());\n         WITH_LOCK(::cs_main, tx_pool.check(chainstate.CoinsTip(), chainstate.m_chain.Height() + 1));\n     }\n+\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        // Try eviction\n+        LOCK2(::cs_main, tx_pool.cs);\n+        tx_pool.TrimToSize(fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0U, tx_pool.DynamicMemoryUsage()));",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 1,
      "original_position": 51,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474283513,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Incorporated in 0097138011b6",
      "created_at": "2025-10-31T09:33:44Z",
      "updated_at": "2025-10-31T09:33:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480723944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480723944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480726400",
      "pull_request_review_id": 3403308948,
      "id": 2480726400,
      "node_id": "PRRC_kwDOABII586T3OGA",
      "diff_hunk": "@@ -56,7 +56,9 @@ struct MinerTestingSetup : public TestingSetup {\n         // instead.\n         m_node.mempool.reset();\n         bilingual_str error;\n-        m_node.mempool = std::make_unique<CTxMemPool>(MemPoolOptionsForTest(m_node), error);\n+        auto opts = MemPoolOptionsForTest(m_node);\n+        opts.limits.cluster_size_vbytes = 1'250'000;",
      "path": "src/test/miner_tests.cpp",
      "position": 1,
      "original_position": 6,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474299026,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in d00d8a8a84e43cb79e81482a2a85532209dd9ab2",
      "created_at": "2025-10-31T09:34:26Z",
      "updated_at": "2025-10-31T09:34:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480726400",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480726400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480727366",
      "pull_request_review_id": 3403310161,
      "id": 2480727366,
      "node_id": "PRRC_kwDOABII586T3OVG",
      "diff_hunk": "@@ -281,40 +325,42 @@ void MinerTestingSetup::TestBasicMining(const CScript& scriptPubKey, const std::\n         BOOST_REQUIRE(block_template);\n         CBlock block{block_template->getBlock()};\n \n-        // block sigops > limit: 1000 CHECKMULTISIG + 1\n-        tx.vin.resize(1);\n-        // NOTE: OP_NOP is used to force 20 SigOps for the CHECKMULTISIG\n-        tx.vin[0].scriptSig = CScript() << OP_0 << OP_0 << OP_0 << OP_NOP << OP_CHECKMULTISIG << OP_1;\n-        tx.vin[0].prevout.hash = txFirst[0]->GetHash();\n-        tx.vin[0].prevout.n = 0;\n-        tx.vout.resize(1);\n-        tx.vout[0].nValue = BLOCKSUBSIDY;\n-        for (unsigned int i = 0; i < 1001; ++i) {\n-            tx.vout[0].nValue -= LOWFEE;\n-            hash = tx.GetHash();\n-            bool spendsCoinbase = i == 0; // only first tx spends coinbase\n-            // If we don't set the # of sig ops in the CTxMemPoolEntry, template creation fails\n-            AddToMempool(tx_mempool, entry.Fee(LOWFEE).Time(Now<NodeSeconds>()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n-            tx.vin[0].prevout.hash = hash;\n-        }\n+        auto txs = CreateBigSigOpsCluster(txFirst[0]);\n \n+        int64_t legacy_sigops = 0;\n+        for (auto& t : txs) {\n+            AddToMempool(tx_mempool, entry.Fee(LOWFEE).Time(Now<NodeSeconds>()).SpendsCoinbase(true).FromTx(t));",
      "path": "src/test/miner_tests.cpp",
      "position": 133,
      "original_position": 84,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474321911,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in d00d8a8a84e43cb79e81482a2a85532209dd9ab2",
      "created_at": "2025-10-31T09:34:42Z",
      "updated_at": "2025-10-31T09:34:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480727366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480727366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 337,
      "original_line": 337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480729561",
      "pull_request_review_id": 3403312883,
      "id": 2480729561,
      "node_id": "PRRC_kwDOABII586T3O3Z",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])\n+            last_val = [x['vsize'], x['fee']]\n+\n+    def test_limit_enforcement(self, cluster_submitted, target_vsize_per_tx=None):\n+        \"\"\"\n+        the cluster may change as a result of these transactions, so cluster_submitted is mutated accordingly\n+        \"\"\"\n+        # Cluster has already been submitted and has at least 3 transactions, otherwise this test won't work.\n+        assert_greater_than_or_equal(len(cluster_submitted), 3)\n+        node = self.nodes[0]\n+        last_result = cluster_submitted[-1]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=last_result[\"new_utxo\"], target_vsize=target_vsize_per_tx)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # It should also work during replacement",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 98,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474910301,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 74654eaf1bef5b578b97111af20b3de39c39cec6",
      "created_at": "2025-10-31T09:35:18Z",
      "updated_at": "2025-10-31T09:35:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480729561",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480729561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480730805",
      "pull_request_review_id": 3403314647,
      "id": 2480730805,
      "node_id": "PRRC_kwDOABII586T3PK1",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test cluster mempool accessors and limits\"\"\"\n+\n+from decimal import Decimal\n+\n+from test_framework.mempool_util import (\n+    DEFAULT_CLUSTER_LIMIT,\n+    DEFAULT_CLUSTER_SIZE_LIMIT_KVB,\n+)\n+from test_framework.messages import (\n+    COIN,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    assert_greater_than_or_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            # Mine blocks to clear the mempool and replenish the wallet's confirmed UTXOs.\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.generate(self.nodes[0], 1)\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class MempoolClusterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def add_chain_cluster(self, node, cluster_count, target_vsize=None):\n+        \"\"\"Create a cluster of transactions, with the count specified.\n+        The topology is a chain: the i'th transaction depends on the (i-1)'th transaction.\n+        Optionally provide a target_vsize for each transaction.\n+        \"\"\"\n+        parent_tx = self.wallet.send_self_transfer(from_node=node, confirmed_only=True, target_vsize=target_vsize)\n+        utxo_to_spend = parent_tx[\"new_utxo\"]\n+        all_txids = [parent_tx[\"txid\"]]\n+        all_results = [parent_tx]\n+\n+        while len(all_results) < cluster_count:\n+            next_tx = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=utxo_to_spend, target_vsize=target_vsize)\n+            assert next_tx[\"txid\"] in node.getrawmempool()\n+\n+            # Confirm that each transaction is in the same cluster as the first.\n+            assert_equal(node.getmempoolcluster(next_tx['txid']), node.getmempoolcluster(parent_tx['txid']))\n+\n+            # Confirm that the ancestors are what we expect\n+            mempool_ancestors = node.getmempoolancestors(next_tx['txid'])\n+            assert_equal(sorted(mempool_ancestors), sorted(all_txids))\n+\n+            # Confirm that each successive transaction is added as a descendant.\n+            assert all([ next_tx[\"txid\"] in node.getmempooldescendants(x) for x in all_txids ])\n+\n+            # Update for next iteration\n+            all_results.append(next_tx)\n+            all_txids.append(next_tx[\"txid\"])\n+            utxo_to_spend = next_tx[\"new_utxo\"]\n+\n+        assert node.getmempoolcluster(parent_tx['txid'])['txcount'] == cluster_count\n+        return all_results\n+\n+    def check_feerate_diagram(self, node):\n+        \"\"\"Sanity check the feerate diagram.\"\"\"\n+        feeratediagram = node.getmempoolfeeratediagram()\n+        last_val = [0, 0]\n+        for x in feeratediagram:\n+            # The vsize is always positive, except for the first iteration\n+            assert x['vsize'] > 0 or x['fee'] == 0\n+            # Monotonically decreasing fee per vsize\n+            assert_greater_than_or_equal(last_val[0] * x['fee'], last_val[1] * x['vsize'])\n+            last_val = [x['vsize'], x['fee']]\n+\n+    def test_limit_enforcement(self, cluster_submitted, target_vsize_per_tx=None):\n+        \"\"\"\n+        the cluster may change as a result of these transactions, so cluster_submitted is mutated accordingly\n+        \"\"\"\n+        # Cluster has already been submitted and has at least 3 transactions, otherwise this test won't work.\n+        assert_greater_than_or_equal(len(cluster_submitted), 3)\n+        node = self.nodes[0]\n+        last_result = cluster_submitted[-1]\n+\n+        # Test that adding one more transaction to the cluster will fail.\n+        bad_tx = self.wallet.create_self_transfer(utxo_to_spend=last_result[\"new_utxo\"], target_vsize=target_vsize_per_tx)\n+        assert_raises_rpc_error(-26, \"too-large-cluster\", node.sendrawtransaction, bad_tx[\"hex\"])\n+\n+        # It should also work during replacement\n+        utxo_to_double_spend = self.wallet.get_utxo(confirmed_only=True)\n+        fee = Decimal(\"0.000001\")\n+        tx_to_replace = self.wallet.create_self_transfer(utxo_to_spend=utxo_to_double_spend, fee=fee)\n+        node.sendrawtransaction(tx_to_replace[\"hex\"])\n+\n+        # Multiply fee by 5, which should easily cover the cost to replace. Otherwise, use the target vsize at 10sat/vB",
      "path": "test/functional/mempool_cluster.py",
      "position": 1,
      "original_position": 104,
      "commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2474913651,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 74654eaf1bef5b578b97111af20b3de39c39cec6",
      "created_at": "2025-10-31T09:35:39Z",
      "updated_at": "2025-10-31T09:35:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480730805",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480730805"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480733194",
      "pull_request_review_id": 3403317911,
      "id": 2480733194,
      "node_id": "PRRC_kwDOABII586T3PwK",
      "diff_hunk": "@@ -104,6 +100,23 @@ void Finish(FuzzedDataProvider& fuzzed_data_provider, MockedTxPool& tx_pool, Cha\n         auto assembler = BlockAssembler{chainstate, &tx_pool, options};\n         auto block_template = assembler.CreateNewBlock();\n         Assert(block_template->block.vtx.size() >= 1);\n+\n+        // Try updating the mempool for this block, as though it were mined.\n+        LOCK2(::cs_main, tx_pool.cs);",
      "path": "src/test/fuzz/tx_pool.cpp",
      "position": 25,
      "original_position": 25,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2475071643,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done in 0097138011b6e502bfbae528304a6a7e6b6462ad",
      "created_at": "2025-10-31T09:36:26Z",
      "updated_at": "2025-10-31T09:36:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2480733194",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2480733194"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 105,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2510907674",
      "pull_request_review_id": 3443711685,
      "id": 2510907674,
      "node_id": "PRRC_kwDOABII586VqWka",
      "diff_hunk": "@@ -59,8 +59,8 @@ class LOCKABLE Epoch\n     public:\n         Marker() = default;\n         Marker(const Marker&) = default;\n-        Marker(Marker&&) = delete;\n-        Marker& operator=(Marker&&) = delete;\n+        Marker(Marker&&) = default;",
      "path": "src/util/epochguard.h",
      "position": 6,
      "original_position": 6,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "51430680ecb722e1d4ee4a26dac5724050f41c9e",
      "in_reply_to_id": 2432642810,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "@ajtowns I don't think a virtual move assignment would actually help. It's true that there are risks when performing (move) assignments across types, but it doesn't seem like making it virtual affects those much.\r\n\r\nWith the code, as it exists in this PR, the risk is something like:\r\n```c++\r\nTxGraph::Ref ref = ...;\r\nTxMempoolEntry entry = ...;\r\n...\r\nref = std::move(entry);\r\n// or\r\nentry = std::move(ref);\r\n```\r\n\r\nThe first of which will \"excise\" the ref from the entry, leaving the entry ref-less. The second will move a ref into place inside an entry. These are posssibly undesirable operations, but not necessarily dangerous (e.g., they won't result in an inconsistent state or UB on their own).\r\n\r\nWe could instead have a \r\n```c++\r\nvirtual TxGraph::Ref& TxGraph::Ref::operator=(TxGraph::Ref&& other);\r\n```\r\nbut this would only allow overriding as\r\n```c++\r\nTxGraph::Ref& TxMempoolEntry::operator=(TxGraph::Ref&& other);\r\n```\r\nwhich can't really do anything better than the excising effect offered by the current non-virtual move. Note that this would be independent from a\r\n```c++\r\nTxMempoolEntry& TxMempoolEntry::operator=(TxMempoolEntry&& other);\r\n```\r\noperator for moving between entries.",
      "created_at": "2025-11-10T15:02:35Z",
      "updated_at": "2025-11-10T15:03:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2510907674",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2510907674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 62,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2510927772",
      "pull_request_review_id": 3443737782,
      "id": 2510927772,
      "node_id": "PRRC_kwDOABII586Vqbec",
      "diff_hunk": "@@ -1107,6 +1085,12 @@ bool MemPoolAccept::ReplacementChecks(Workspace& ws)\n     for (auto it : all_conflicts) {\n         m_subpackage.m_changeset->StageRemoval(it);\n     }\n+\n+    if (const auto err_string{ImprovesFeerateDiagram(*m_subpackage.m_changeset)}) {\n+        // If we can't calculate a feerate, it's because the cluster size limits were hit.\n+        return state.Invalid(TxValidationResult::TX_RECONSIDERABLE, \"replacement-failed\", err_string->second);",
      "path": "src/validation.cpp",
      "position": 292,
      "original_position": 51,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e6315c24326016cfaee5bd046e8b2e4e1088ac6b",
      "in_reply_to_id": 2441096106,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Looks good to me",
      "created_at": "2025-11-10T15:06:49Z",
      "updated_at": "2025-11-10T15:06:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2510927772",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2510927772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1043,
      "original_line": 1043,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511014559",
      "pull_request_review_id": 3443855926,
      "id": 2511014559,
      "node_id": "PRRC_kwDOABII586Vqwqf",
      "diff_hunk": "@@ -74,7 +74,7 @@ FUZZ_TARGET(policy_estimator, .init = initialize_policy_estimator)\n                         break;\n                     }\n                     const CTransaction tx{*mtx};\n-                    mempool_entries.emplace_back(CTxMemPoolEntry::ExplicitCopy, ConsumeTxMemPoolEntry(fuzzed_data_provider, tx, current_height));\n+                    mempool_entries.emplace_back(ConsumeTxMemPoolEntry(fuzzed_data_provider, tx, current_height));",
      "path": "src/test/fuzz/policy_estimator.cpp",
      "position": 5,
      "original_position": 5,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "cd0bea2197d8e1ca97af5586327c1c80dba2e36a",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Allow moving CTxMemPoolEntry objects, disallow copying\"\r\n\r\nUltranit: `push_back` instead of `emplace_back` (no real downside to using emplace_back, but push_back makes it more clear that nothing is really being constructed in-place).",
      "created_at": "2025-11-10T15:28:30Z",
      "updated_at": "2025-11-10T19:41:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511014559",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511014559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511123334",
      "pull_request_review_id": 3443855926,
      "id": 2511123334,
      "node_id": "PRRC_kwDOABII586VrLOG",
      "diff_hunk": "@@ -49,6 +50,11 @@ struct bilingual_str;\n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n+/** How many linearization iterations required for TxGraph clusters to have\n+ * \"acceptable\" quality, if they cannot be optimally linearized with fewer\n+ * iterations. */\n+static constexpr uint64_t ACCEPTABLE_ITERS = 10'000;",
      "path": "src/txmempool.h",
      "position": 15,
      "original_position": 15,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "a6649dffe92319a17790bf2add5206a84726f34d",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Create a txgraph inside CTxMemPool\"\r\n\r\nBased on the `Linearize64TxWorstCase15000Iters` and `Linearize64TxWorstCase5000Iters` benchmarks, it seems one iteration costs around:\r\n* Ryzen 5950X: ~41 ns\r\n* Ryzen 9980X: ~30 ns\r\n\r\nSo 1200-1700 is probably a more reasonable range here to get to the \"~50 s per cluster\" number.\r\n\r\nIn #32545 the cost metric is changed, and aims for ~2 ns per \"iteration\", so after that PR, a number like 25000 should be more in line with what we want.",
      "created_at": "2025-11-10T15:58:45Z",
      "updated_at": "2025-11-10T20:14:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511123334",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511123334"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 56,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511137437",
      "pull_request_review_id": 3443855926,
      "id": 2511137437,
      "node_id": "PRRC_kwDOABII586VrOqd",
      "diff_hunk": "@@ -188,4 +189,8 @@ static inline int64_t GetVirtualTransactionInputSize(const CTxIn& tx)\n     return GetVirtualTransactionInputSize(tx, 0, 0);\n }\n \n+int64_t GetSigOpsAdjustedWeight(int64_t weight, int64_t sigop_cost, unsigned int bytes_per_sigop);\n+\n+static inline FeePerVSize ToFeePerVSize(FeePerWeight feerate) { return {feerate.fee, (feerate.size + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR}; }",
      "path": "src/policy/policy.h",
      "position": 25,
      "original_position": 14,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "43ba20ff997a9a02739d05d6bc768be711fc58f7",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Add sigops adjusted weight calculator\"\r\n\r\nThis can be done more accurately (avoiding the rounding):\r\n```c++\r\nreturn {feerate.fee * WITNESS_SCALE_FACTOR, feerate.size};\r\n```\r\n\r\nWould that be desirable? It's used inside `BlockAssembler::addChunks` where it would be useful I think, but also in `TxMempool` where it's less clear to me if sticking to the old rounding-up behavior may be necessary.\r\n\r\nOne potential pitfall is that the resulting `size` member variable of the returned `FeePerVSize` will be misleading, so if it's used directly (not as a fraction) it could lead to wrong results.",
      "created_at": "2025-11-10T16:03:31Z",
      "updated_at": "2025-11-10T19:41:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511137437",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511137437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 198,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511144640",
      "pull_request_review_id": 3443855926,
      "id": 2511144640,
      "node_id": "PRRC_kwDOABII586VrQbA",
      "diff_hunk": "@@ -891,6 +893,9 @@ void CTxMemPool::PrioritiseTransaction(const Txid& hash, const CAmount& nFeeDelt\n         delta = SaturatingAdd(delta, nFeeDelta);\n         txiter it = mapTx.find(hash);\n         if (it != mapTx.end()) {\n+            // PrioritiseTransaction calls stack on previous ones. Set the new\n+            // transaction fee to be current modified fee + feedelta.\n+            m_txgraph->SetTransactionFee(*it, it->GetModifiedFee() + nFeeDelta);",
      "path": "src/txmempool.cpp",
      "position": 801,
      "original_position": 15,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "b0c8081258fc37816e4675e17fa9ea8d308921f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Add transactions to txgraph, but without cluster dependencies\"\r\n\r\nCould this repeat of the adjustment be avoided by swapping? I.e.,\r\n```c++\r\nmapTx.modify(it, [&nFeeDelta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(nFeeDelta); });\r\nm_txgraph->SetTransactionFee(*it, it->GetModifiedFee());\r\n```\r\n\r\nIf so, that would seem more natural.",
      "created_at": "2025-11-10T16:05:45Z",
      "updated_at": "2025-11-10T19:41:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511144640",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511144640"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 594,
      "original_line": 898,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511155021",
      "pull_request_review_id": 3443855926,
      "id": 2511155021,
      "node_id": "PRRC_kwDOABII586VrS9N",
      "diff_hunk": "@@ -1387,15 +1392,27 @@ CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTran\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n-    auto newit = m_to_add.emplace(TxGraph::Ref(), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+\n     CAmount delta{0};\n     m_pool->ApplyDelta(tx->GetHash(), delta);\n-    if (delta) m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+\n+    TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));",
      "path": "src/txmempool.cpp",
      "position": 1182,
      "original_position": 29,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "b0c8081258fc37816e4675e17fa9ea8d308921f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Add transactions to txgraph, but without cluster dependencies\"\r\n\r\nPossibly the same can be done here as I suggested above, but with a separate call:\r\n```c++\r\nTxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\r\nauto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\r\nif (delta) {\r\n    m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\r\n    m_txgraph->SetTransactionFee(*newit, newit->GetModifiedFee());\r\n}\r\n```\r\n\r\nmoving all responsibility for deciding the modified fee inside `UpdateModifiedFee`.",
      "created_at": "2025-11-10T16:09:09Z",
      "updated_at": "2025-11-10T19:41:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511155021",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511155021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 956,
      "original_line": 1399,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511170420",
      "pull_request_review_id": 3443855926,
      "id": 2511170420,
      "node_id": "PRRC_kwDOABII586VrWt0",
      "diff_hunk": "@@ -822,16 +822,22 @@ class CTxMemPool\n      */\n     class ChangeSet {\n     public:\n-        explicit ChangeSet(CTxMemPool* pool) : m_pool(pool) {}\n-        ~ChangeSet() EXCLUSIVE_LOCKS_REQUIRED(m_pool->cs) { m_pool->m_have_changeset = false; }\n+        explicit ChangeSet(CTxMemPool* pool) : m_pool(pool) { m_pool->m_txgraph->StartStaging(); }\n+        ~ChangeSet() EXCLUSIVE_LOCKS_REQUIRED(m_pool->cs) {\n+            if (m_pool->m_txgraph->HaveStaging()) {",
      "path": "src/txmempool.h",
      "position": 527,
      "original_position": 24,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "b0c8081258fc37816e4675e17fa9ea8d308921f3",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Add transactions to txgraph, but without cluster dependencies\"\r\n\r\nThere should always exist a txgraph staging when a `ChangeSet` is destroyed, right?\r\n\r\n```c++\r\nAssume(m_pool->m_txgraph->HaveStaging());\r\nAssume(m_pool->m_have_changeset);\r\nm_pool->m_txgraph->AbortStaging();\r\nm_pool->m_have_changeset = false;\r\n```\r\n",
      "created_at": "2025-11-10T16:14:18Z",
      "updated_at": "2025-11-10T19:41:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511170420",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511170420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 649,
      "original_line": 827,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511204657",
      "pull_request_review_id": 3443855926,
      "id": 2511204657,
      "node_id": "PRRC_kwDOABII586VrfEx",
      "diff_hunk": "@@ -1681,11 +1691,11 @@ PackageMempoolAcceptResult MemPoolAccept::AcceptSubPackage(const std::vector<CTr\n     AssertLockHeld(m_pool.cs);\n     auto result = [&]() EXCLUSIVE_LOCKS_REQUIRED(::cs_main, m_pool.cs) {\n         if (subpackage.size() > 1) {\n-            return AcceptMultipleTransactions(subpackage, args);\n+            return AcceptMultipleTransactionsAndCleanup(subpackage, args);",
      "path": "src/validation.cpp",
      "position": 481,
      "original_position": 65,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "51d213d1449b61665628ce9b4e0209cff3c4f818",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"squashme: fix locking so that mempool lock is held through subpackage destruction\"\r\n\r\nIt seems strange to use the `AndCleanup` version here (both for `MultipleTransactions` here and `SingleTransaction` below), for two reasons:\r\n* The `AndCleanup` version grabs its own `m_pool.cs` lock, but is called here in a place that already holds that lock.\r\n* The call here in `AcceptSubPackage` is followed by a `ClearSubPackageState();` below, which is already invoked inside the `AndCleanup` versions.\r\n\r\nI can't say I fully understand the intended semantics here, so I may be off, but it's a red flag for me so want to point it out.",
      "created_at": "2025-11-10T16:25:41Z",
      "updated_at": "2025-11-10T19:41:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511204657",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511204657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1616,
      "original_line": 1694,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511237219",
      "pull_request_review_id": 3443855926,
      "id": 2511237219,
      "node_id": "PRRC_kwDOABII586VrnBj",
      "diff_hunk": "@@ -1230,180 +902,131 @@ void CTxMemPool::SetLoadTried(bool load_tried)\n std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<Txid>& txids) const\n {\n     AssertLockHeld(cs);\n-    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n-    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n-    // necessarily mean the entry has been processed.\n-    WITH_FRESH_EPOCH(m_epoch);\n-    for (const auto& it : clustered_txs) {\n-        visited(it);\n-    }\n-    // i = index of where the list of entries to process starts\n-    for (size_t i{0}; i < clustered_txs.size(); ++i) {\n-        // DoS protection: if there are 500 or more entries to process, just quit.\n-        if (clustered_txs.size() > 500) return {};\n-        const txiter& tx_iter = clustered_txs.at(i);\n-        for (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\n-            for (const CTxMemPoolEntry& entry : entries) {\n-                const auto entry_it = mapTx.iterator_to(entry);\n-                if (!visited(entry_it)) {\n-                    clustered_txs.push_back(entry_it);\n+\n+    std::vector<CTxMemPool::txiter> ret;\n+    std::set<const CTxMemPoolEntry*> unique_cluster_representatives;\n+    for (auto txid : txids) {\n+        auto it = mapTx.find(txid);\n+        if (it != mapTx.end()) {\n+            auto cluster = m_txgraph->GetCluster(*it, TxGraph::Level::MAIN);\n+            if (unique_cluster_representatives.insert(static_cast<const CTxMemPoolEntry*>(&(**cluster.begin()))).second) {\n+                for (auto tx : cluster) {\n+                    ret.emplace_back(mapTx.iterator_to(static_cast<const CTxMemPoolEntry&>(*tx)));\n                 }\n             }\n         }\n     }\n-    return clustered_txs;\n-}\n-\n-std::optional<std::string> CTxMemPool::CheckConflictTopology(const setEntries& direct_conflicts)\n-{\n-    for (const auto& direct_conflict : direct_conflicts) {\n-        // Ancestor and descendant counts are inclusive of the tx itself.\n-        const auto ancestor_count{direct_conflict->GetCountWithAncestors()};\n-        const auto descendant_count{direct_conflict->GetCountWithDescendants()};\n-        const bool has_ancestor{ancestor_count > 1};\n-        const bool has_descendant{descendant_count > 1};\n-        const auto& txid_string{direct_conflict->GetSharedTx()->GetHash().ToString()};\n-        // The only allowed configurations are:\n-        // 1 ancestor and 0 descendant\n-        // 0 ancestor and 1 descendant\n-        // 0 ancestor and 0 descendant\n-        if (ancestor_count > 2) {\n-            return strprintf(\"%s has %u ancestors, max 1 allowed\", txid_string, ancestor_count - 1);\n-        } else if (descendant_count > 2) {\n-            return strprintf(\"%s has %u descendants, max 1 allowed\", txid_string, descendant_count - 1);\n-        } else if (has_ancestor && has_descendant) {\n-            return strprintf(\"%s has both ancestor and descendant, exceeding cluster limit of 2\", txid_string);\n-        }\n-        // Additionally enforce that:\n-        // If we have a child,  we are its only parent.\n-        // If we have a parent, we are its only child.\n-        if (has_descendant) {\n-            const auto& our_child = direct_conflict->GetMemPoolChildrenConst().begin();\n-            if (our_child->get().GetCountWithAncestors() > 2) {\n-                return strprintf(\"%s is not the only parent of child %s\",\n-                                 txid_string, our_child->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        } else if (has_ancestor) {\n-            const auto& our_parent = direct_conflict->GetMemPoolParentsConst().begin();\n-            if (our_parent->get().GetCountWithDescendants() > 2) {\n-                return strprintf(\"%s is not the only child of parent %s\",\n-                                 txid_string, our_parent->get().GetSharedTx()->GetHash().ToString());\n-            }\n-        }\n+    if (ret.size() > 500) {\n+        return {};\n     }\n-    return std::nullopt;\n+    return ret;\n }\n \n util::Result<std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>>> CTxMemPool::ChangeSet::CalculateChunksForRBF()\n {\n     LOCK(m_pool->cs);\n-    FeeFrac replacement_feerate{0, 0};\n-    for (auto it : m_entry_vec) {\n-        replacement_feerate += {it->GetModifiedFee(), it->GetTxSize()};\n-    }\n-\n-    auto err_string{m_pool->CheckConflictTopology(m_to_remove)};\n-    if (err_string.has_value()) {\n-        // Unsupported topology for calculating a feerate diagram\n-        return util::Error{Untranslated(err_string.value())};\n-    }\n-\n-    // new diagram will have chunks that consist of each ancestor of\n-    // direct_conflicts that is at its own fee/size, along with the replacement\n-    // tx/package at its own fee/size\n-\n-    // old diagram will consist of the ancestors and descendants of each element of\n-    // all_conflicts.  every such transaction will either be at its own feerate (followed\n-    // by any descendant at its own feerate), or as a single chunk at the descendant's\n-    // ancestor feerate.\n-\n-    std::vector<FeeFrac> old_chunks;\n-    // Step 1: build the old diagram.\n \n-    // The above clusters are all trivially linearized;\n-    // they have a strict topology of 1 or two connected transactions.\n-\n-    // OLD: Compute existing chunks from all affected clusters\n-    for (auto txiter : m_to_remove) {\n-        // Does this transaction have descendants?\n-        if (txiter->GetCountWithDescendants() > 1) {\n-            // Consider this tx when we consider the descendant.\n-            continue;\n-        }\n-        // Does this transaction have ancestors?\n-        FeeFrac individual{txiter->GetModifiedFee(), txiter->GetTxSize()};\n-        if (txiter->GetCountWithAncestors() > 1) {\n-            // We'll add chunks for either the ancestor by itself and this tx\n-            // by itself, or for a combined package.\n-            FeeFrac package{txiter->GetModFeesWithAncestors(), static_cast<int32_t>(txiter->GetSizeWithAncestors())};\n-            if (individual >> package) {\n-                // The individual feerate is higher than the package, and\n-                // therefore higher than the parent's fee. Chunk these\n-                // together.\n-                old_chunks.emplace_back(package);\n-            } else {\n-                // Add two points, one for the parent and one for this child.\n-                old_chunks.emplace_back(package - individual);\n-                old_chunks.emplace_back(individual);\n-            }\n-        } else {\n-            old_chunks.emplace_back(individual);\n-        }\n-    }\n-\n-    // No topology restrictions post-chunking; sort\n-    std::sort(old_chunks.begin(), old_chunks.end(), std::greater());\n-\n-    std::vector<FeeFrac> new_chunks;\n-\n-    /* Step 2: build the NEW diagram\n-     * CON = Conflicts of proposed chunk\n-     * CNK = Proposed chunk\n-     * NEW = OLD - CON + CNK: New diagram includes all chunks in OLD, minus\n-     * the conflicts, plus the proposed chunk\n-     */\n-\n-    // OLD - CON: Add any parents of direct conflicts that are not conflicted themselves\n-    for (auto direct_conflict : m_to_remove) {\n-        // If a direct conflict has an ancestor that is not in all_conflicts,\n-        // it can be affected by the replacement of the child.\n-        if (direct_conflict->GetMemPoolParentsConst().size() > 0) {\n-            // Grab the parent.\n-            const CTxMemPoolEntry& parent = direct_conflict->GetMemPoolParentsConst().begin()->get();\n-            if (!m_to_remove.contains(m_pool->mapTx.iterator_to(parent))) {\n-                // This transaction would be left over, so add to the NEW\n-                // diagram.\n-                new_chunks.emplace_back(parent.GetModifiedFee(), parent.GetTxSize());\n-            }\n-        }\n+    if (!CheckMemPoolPolicyLimits()) {\n+        return util::Error{Untranslated(\"cluster size limit exceeded\")};\n     }\n-    // + CNK: Add the proposed chunk itself\n-    new_chunks.emplace_back(replacement_feerate);\n \n-    // No topology restrictions post-chunking; sort\n-    std::sort(new_chunks.begin(), new_chunks.end(), std::greater());\n-    return std::make_pair(old_chunks, new_chunks);\n+    return m_pool->m_txgraph->GetMainStagingDiagrams();\n }\n \n CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTransactionRef& tx, const CAmount fee, int64_t time, unsigned int entry_height, uint64_t entry_sequence, bool spends_coinbase, int64_t sigops_cost, LockPoints lp)\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n-    auto newit = m_to_add.emplace(tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    Assume(!m_dependencies_processed);\n+\n+    // We need to reprocess dependencies after adding a new transaction.\n+    m_dependencies_processed = false;\n+\n     CAmount delta{0};\n     m_pool->ApplyDelta(tx->GetHash(), delta);\n-    if (delta) m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+\n+    TxGraph::Ref ref(m_pool->m_txgraph->AddTransaction(FeePerWeight(fee+delta, GetSigOpsAdjustedWeight(GetTransactionWeight(*tx), sigops_cost, ::nBytesPerSigOp))));\n+    auto newit = m_to_add.emplace(std::move(ref), tx, fee, time, entry_height, entry_sequence, spends_coinbase, sigops_cost, lp).first;\n+    if (delta) {\n+        m_to_add.modify(newit, [&delta](CTxMemPoolEntry& e) { e.UpdateModifiedFee(delta); });\n+    }\n \n     m_entry_vec.push_back(newit);\n+\n     return newit;\n }\n \n+void CTxMemPool::ChangeSet::StageRemoval(CTxMemPool::txiter it)\n+{\n+    LOCK(m_pool->cs);\n+    m_pool->m_txgraph->RemoveTransaction(*it);\n+    m_to_remove.insert(it);\n+}\n+\n void CTxMemPool::ChangeSet::Apply()\n {\n     LOCK(m_pool->cs);\n+    if (!m_dependencies_processed) {\n+        ProcessDependencies();\n+    }\n     m_pool->Apply(this);\n     m_to_add.clear();\n     m_to_remove.clear();\n     m_entry_vec.clear();\n     m_ancestors.clear();\n }\n+\n+void CTxMemPool::ChangeSet::ProcessDependencies()\n+{\n+    LOCK(m_pool->cs);\n+    Assume(!m_dependencies_processed); // should only call this once.\n+    for (const auto& entryptr : m_entry_vec) {\n+        for (const auto &txin : entryptr->GetSharedTx()->vin) {\n+            std::optional<txiter> piter = m_pool->GetIter(txin.prevout.hash);\n+            if (!piter) {\n+                auto it = m_to_add.find(txin.prevout.hash);\n+                if (it != m_to_add.end()) {\n+                    piter = std::make_optional(it);\n+                }\n+            }\n+            if (piter) {\n+                m_pool->m_txgraph->AddDependency(**piter, *entryptr);\n+            }\n+        }\n+    }\n+    m_dependencies_processed = true;",
      "path": "src/txmempool.cpp",
      "position": 1231,
      "original_position": 1223,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450631707,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "@brunoerg This mutant seems expected, as it just avoids redoing work by remembering it's already done. Is there any suggested/best practice for avoiding things like that?",
      "created_at": "2025-11-10T16:35:47Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511237219",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511237219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1005,
      "original_line": 1005,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511253385",
      "pull_request_review_id": 3443855926,
      "id": 2511253385,
      "node_id": "PRRC_kwDOABII586Vrq-J",
      "diff_hunk": "@@ -1392,6 +1402,10 @@ CTxMemPool::ChangeSet::TxHandle CTxMemPool::ChangeSet::StageAddition(const CTran\n {\n     LOCK(m_pool->cs);\n     Assume(m_to_add.find(tx->GetHash()) == m_to_add.end());\n+    Assume(!m_dependencies_processed);\n+\n+    // We need to reprocess dependencies after adding a new transaction.",
      "path": "src/txmempool.cpp",
      "position": 1175,
      "original_position": 44,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "6b791cc4ee9eda5cccc310e3efb869af36057935",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Do not allow mempool clusters to exceed configured limits\"\r\n\r\nGiven the `Assume(!m_dependencies_process);` above, is the **re**process comment correct here? It seems they're expected to not have been processed at all here.",
      "created_at": "2025-11-10T16:41:09Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511253385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511253385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 950,
      "original_line": 1407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511307703",
      "pull_request_review_id": 3443855926,
      "id": 2511307703,
      "node_id": "PRRC_kwDOABII586Vr4O3",
      "diff_hunk": "@@ -219,224 +205,88 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n \n // Perform transaction-level checks before adding to block:\n // - transaction finality (locktime)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package) const\n+bool BlockAssembler::TestPackageTransactions(const std::vector<CTxMemPoolEntryRef>& txs) const\n {\n-    for (CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, m_lock_time_cutoff)) {\n+    for (const auto tx : txs) {\n+        if (!IsFinalTx(tx.get().GetTx(), nHeight, m_lock_time_cutoff)) {\n             return false;\n         }\n     }\n     return true;\n }\n \n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n+void BlockAssembler::AddToBlock(const CTxMemPoolEntry& entry)\n {\n-    pblocktemplate->block.vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n+    pblocktemplate->block.vtx.emplace_back(entry.GetSharedTx());\n+    pblocktemplate->vTxFees.push_back(entry.GetFee());\n+    pblocktemplate->vTxSigOpsCost.push_back(entry.GetSigOpCost());\n+    nBlockWeight += entry.GetTxWeight();\n     ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter->GetSharedTx()->GetHash());\n+    nBlockSigOpsCost += entry.GetSigOpCost();\n+    nFees += entry.GetFee();\n \n     if (m_options.print_modified_fee) {\n         LogPrintf(\"fee rate %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-/** Add descendants of given transactions to mapModifiedTx with ancestor\n- * state updated assuming given transactions are inBlock. Returns number\n- * of updated descendants. */\n-static int UpdatePackagesForAdded(const CTxMemPool& mempool,\n-                                  const CTxMemPool::setEntries& alreadyAdded,\n-                                  indexed_modified_transaction_set& mapModifiedTx) EXCLUSIVE_LOCKS_REQUIRED(mempool.cs)\n-{\n-    AssertLockHeld(mempool.cs);\n-\n-    int nDescendantsUpdated = 0;\n-    for (CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc)) {\n-                continue;\n-            }\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                mit = mapModifiedTx.insert(modEntry).first;\n-            }\n-            mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-        }\n+                  CFeeRate(entry.GetModifiedFee(), entry.GetTxSize()).ToString(),\n+                  entry.GetTx().GetHash().ToString());\n     }\n-    return nDescendantsUpdated;\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n }\n \n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int& nPackagesSelected, int& nDescendantsUpdated)\n+void BlockAssembler::addChunks()\n {\n-    const auto& mempool{*Assert(m_mempool)};\n-    LOCK(mempool.cs);\n-\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    std::set<Txid> failedTx;\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n     // Limit the number of attempts to add transactions to the block when it is\n     // close to full; this is just a simple heuristic to finish quickly if the\n     // mempool has a lot of entries.\n     const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n     constexpr int32_t BLOCK_FULL_ENOUGH_WEIGHT_DELTA = 4000;\n     int64_t nConsecutiveFailed = 0;\n \n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty()) {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        //\n-        // Skip entries in mapTx that are already in a block or are present\n-        // in mapModifiedTx (which implies that the mapTx ancestor state is\n-        // stale due to ancestor inclusion in the block)\n-        // Also skip transactions that we've already failed to add. This can happen if\n-        // we consider a transaction in mapModifiedTx and it fails: we can then\n-        // potentially consider it again while walking mapTx.  It's currently\n-        // guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-        // failedTx and avoid re-evaluation, since the re-evaluation would be using\n-        // cached size/sigops/fee values that are not actually correct.\n-        /** Return true if given transaction from mapTx has already been evaluated,\n-         * or if the transaction's cached data in mapTx is incorrect. */\n-        if (mi != mempool.mapTx.get<ancestor_score>().end()) {\n-            auto it = mempool.mapTx.project<0>(mi);\n-            assert(it != mempool.mapTx.end());\n-            if (mapModifiedTx.count(it) || inBlock.count(it->GetSharedTx()->GetHash()) || failedTx.count(it->GetSharedTx()->GetHash())) {\n-                ++mi;\n-                continue;\n-            }\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareTxMemPoolEntryByAncestorFee()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> selected_transactions;\n+    selected_transactions.reserve(MAX_CLUSTER_COUNT_LIMIT);\n+    FeePerWeight chunk_feerate;\n \n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter->GetSharedTx()->GetHash()));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n+    // This fills selected_transactions\n+    chunk_feerate = m_mempool->GetBlockBuilderChunk(selected_transactions);\n+    FeePerVSize chunk_feerate_vsize = ToFeePerVSize(chunk_feerate);\n \n-        if (packageFees < m_options.blockMinFeeRate.GetFee(packageSize)) {\n-            // Everything else we might consider has a lower fee rate\n+    while (selected_transactions.size() > 0) {\n+        // Check to see if min fee rate is still respected.\n+        if (chunk_feerate.fee < m_options.blockMinFeeRate.GetFee(chunk_feerate_vsize.size)) {",
      "path": "src/node/miner.cpp",
      "position": 248,
      "original_position": 248,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "35679dbe04d2c998325ae6500c7d0ac19f659feb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Select transactions for blocks based on chunk feerate\"\r\n\r\nThis ought to be possible without a conversion to sats, something like:\r\n```c++\r\nif (chunk_feerate << m_options.blockMinFeeRate.GetFeePerVSize()) {\r\n```\r\n(where `FeePerVSize CFeeRate::GetFeePerVSize()` is a new member function to get the underlying fraction object)",
      "created_at": "2025-11-10T16:59:28Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511307703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511307703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 254,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511560296",
      "pull_request_review_id": 3443855926,
      "id": 2511560296,
      "node_id": "PRRC_kwDOABII586Vs15o",
      "diff_hunk": "@@ -285,6 +285,9 @@ class CTxMemPool\n     using Limits = kernel::MemPoolLimits;\n \n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    void CalculateAncestorData(const CTxMemPoolEntry& entry, size_t& ancestor_count, size_t& ancestor_size, CAmount& ancestor_fees) const EXCLUSIVE_LOCKS_REQUIRED(cs);",
      "path": "src/txmempool.h",
      "position": 266,
      "original_position": 5,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "e7a1cf82bd7b55f46ad51f0d81b0ad4a7d4910af",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Reimplement GetTransactionAncestry() to not rely on cached data\"\r\n\r\nNit, it seems cleaner to make these outputs rather than pass-by-reference inputs:\r\n```c++\r\nstd::tuple<size_t, size_t, CAmount> CalculateAncestorData(const CTxMemPoolEntry& entry) const\r\n```\r\n\r\nwhich can then by used with structured bindings like (next commit):\r\n```c++\r\nauto [ancestor_count, ancestor_size, ancestor_fees] = CalculateAncestorData(e);\r\n```\r\n",
      "created_at": "2025-11-10T18:30:07Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511560296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511560296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 275,
      "original_line": 289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511585987",
      "pull_request_review_id": 3443855926,
      "id": 2511585987,
      "node_id": "PRRC_kwDOABII586Vs8LD",
      "diff_hunk": "@@ -94,12 +94,6 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendan\n             mapTx.modify(mapTx.iterator_to(descendant), [=](CTxMemPoolEntry& e) {\n               e.UpdateAncestorState(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost());\n             });\n-            // Don't directly remove the transaction here -- doing so would\n-            // invalidate iterators in cachedDescendants. Mark it for removal\n-            // by inserting into descendants_to_remove.\n-            if (descendant.GetCountWithAncestors() > uint64_t(m_opts.limits.ancestor_count) || descendant.GetSizeWithAncestors() > m_opts.limits.ancestor_size_vbytes) {\n-                descendants_to_remove.insert(descendant.GetTx().GetHash());",
      "path": "src/txmempool.cpp",
      "position": 55,
      "original_position": 8,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "df783fd2f7905e10c10b99998c920c2d28b7d482",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Stop enforcing ancestor size/count limits\"\r\n\r\nI see this is addressed in a later commit already, but it was a bit confusing that this commit leaves `descendants_to_remove` in place, but doesn't use it anymore.",
      "created_at": "2025-11-10T18:39:12Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511585987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511585987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511595563",
      "pull_request_review_id": 3443855926,
      "id": 2511595563,
      "node_id": "PRRC_kwDOABII586Vs-gr",
      "diff_hunk": "@@ -287,6 +287,7 @@ class CTxMemPool\n     uint64_t CalculateDescendantMaximum(txiter entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void CalculateAncestorData(const CTxMemPoolEntry& entry, size_t& ancestor_count, size_t& ancestor_size, CAmount& ancestor_fees) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void CalculateDescendantData(const CTxMemPoolEntry& entry, size_t& descendant_count, size_t& descendant_size, CAmount& descendant_fees) const EXCLUSIVE_LOCKS_REQUIRED(cs);",
      "path": "src/txmempool.h",
      "position": 267,
      "original_position": 4,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "279ee6fdefe8cb2ab38eb55169a5359edfad19a9",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Calculate descendant information for mempool RPC output on-the-fly\"\r\n\r\nNit, seems cleaner to make these return values:\r\n```c++\r\nstd::tuple<size_t, size_t, CAmount> CalculateDescendantData(const CTxMemPoolEntry& entry) const EXCLUSIVE_LOCKS_REQUIRED(cs);\r\n```\r\n",
      "created_at": "2025-11-10T18:42:21Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511595563",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511595563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 276,
      "original_line": 290,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511603538",
      "pull_request_review_id": 3443855926,
      "id": 2511603538,
      "node_id": "PRRC_kwDOABII586VtAdS",
      "diff_hunk": "@@ -516,12 +516,12 @@ class CTxMemPool\n     int Expire(std::chrono::seconds time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /**\n-     * Calculate the ancestor and descendant count for the given transaction.\n+     * Calculate the ancestor and cluster count for the given transaction.\n      * The counts include the transaction itself.\n      * When ancestors is non-zero (ie, the transaction itself is in the mempool),\n      * ancestorsize and ancestorfees will also be set to the appropriate values.\n      */\n-    void GetTransactionAncestry(const Txid& txid, size_t& ancestors, size_t& descendants, size_t* ancestorsize = nullptr, CAmount* ancestorfees = nullptr) const;\n+    void GetTransactionAncestry(const Txid& txid, size_t& ancestors, size_t& clustersize, size_t* ancestorsize = nullptr, CAmount* ancestorfees = nullptr) const;",
      "path": "src/txmempool.h",
      "position": 454,
      "original_position": 11,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "cf1bcbbb8e1a4cb72cd37a44dcd8811db8a1958b",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"wallet: Replace max descendantsize with clustersize\"\r\n\r\nNit: maybe call the new variable `cluster_count` (so it isn't confused with total vsize/weight of a cluster).",
      "created_at": "2025-11-10T18:45:18Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511603538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511603538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 472,
      "original_line": 524,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511617302",
      "pull_request_review_id": 3443855926,
      "id": 2511617302,
      "node_id": "PRRC_kwDOABII586VtD0W",
      "diff_hunk": "@@ -54,353 +54,113 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints& lp)\n     return true;\n }\n \n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendants,\n-                                      const std::set<Txid>& setExclude, std::set<Txid>& descendants_to_remove)\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetChildren(const CTxMemPoolEntry& entry) const\n {\n-    CTxMemPoolEntry::Children stageEntries, descendants;\n-    stageEntries = updateIt->GetMemPoolChildrenConst();\n-\n-    while (!stageEntries.empty()) {\n-        const CTxMemPoolEntry& descendant = *stageEntries.begin();\n-        descendants.insert(descendant);\n-        stageEntries.erase(descendant);\n-        const CTxMemPoolEntry::Children& children = descendant.GetMemPoolChildrenConst();\n-        for (const CTxMemPoolEntry& childEntry : children) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(mapTx.iterator_to(childEntry));\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    descendants.insert(*cacheEntry);\n-                }\n-            } else if (!descendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n-            }\n-        }\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    setEntries children;\n+    auto iter = mapNextTx.lower_bound(COutPoint(entry.GetTx().GetHash(), 0));\n+    for (; iter != mapNextTx.end() && iter->first->hash == entry.GetTx().GetHash(); ++iter) {\n+        children.insert(iter->second);\n     }\n-    // descendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int32_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (const CTxMemPoolEntry& descendant : descendants) {\n-        if (!setExclude.count(descendant.GetTx().GetHash())) {\n-            modifySize += descendant.GetTxSize();\n-            modifyFee += descendant.GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(mapTx.iterator_to(descendant));\n-            // Update ancestor state for each descendant\n-            mapTx.modify(mapTx.iterator_to(descendant), [=](CTxMemPoolEntry& e) {\n-              e.UpdateAncestorState(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost());\n-            });\n-            // Don't directly remove the transaction here -- doing so would\n-            // invalidate iterators in cachedDescendants. Mark it for removal\n-            // by inserting into descendants_to_remove.\n-            if (descendant.GetCountWithAncestors() > uint64_t(m_opts.limits.ancestor_count) || descendant.GetSizeWithAncestors() > m_opts.limits.ancestor_size_vbytes) {\n-                descendants_to_remove.insert(descendant.GetTx().GetHash());\n-            }\n+    for (const auto& child : children) {\n+        ret.emplace_back(*child);\n+    }\n+    return ret;\n+}\n+\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetParents(const CTxMemPoolEntry& entry) const\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    std::set<Txid> inputs;\n+    for (const auto& txin : entry.GetTx().vin) {\n+        inputs.insert(txin.prevout.hash);\n+    }\n+    for (const auto& hash : inputs) {\n+        std::optional<txiter> piter = GetIter(hash);\n+        if (piter) {\n+            ret.emplace_back(**piter);\n         }\n     }\n-    mapTx.modify(updateIt, [=](CTxMemPoolEntry& e) { e.UpdateDescendantState(modifySize, modifyFee, modifyCount); });\n+    return ret;\n }\n \n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate)\n {\n     AssertLockHeld(cs);\n-    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n-    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n-    // descendants when we come across a previously seen entry.\n-    cacheMap mapMemPoolDescendantsToUpdate;\n-\n-    // Use a set for lookups into vHashesToUpdate (these entries are already\n-    // accounted for in the state of their ancestors)\n-    std::set<Txid> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n-\n-    std::set<Txid> descendants_to_remove;\n \n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n-    // This maximizes the benefit of the descendant cache and guarantees that\n-    // CTxMemPoolEntry::m_children will be updated, an assumption made in\n-    // UpdateForDescendants.\n     for (const Txid& hash : vHashesToUpdate | std::views::reverse) {\n         // calculate children from mapNextTx\n         txiter it = mapTx.find(hash);\n         if (it == mapTx.end()) {\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update CTxMemPoolEntry::m_children to\n-        // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n-        // we cache the in-mempool children to avoid duplicate updates\n         {\n-            WITH_FRESH_EPOCH(m_epoch);\n             for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n-                const Txid &childHash = iter->second->GetHash();\n-                txiter childIter = mapTx.find(childHash);\n+                txiter childIter = iter->second;\n                 assert(childIter != mapTx.end());\n-                // We can skip updating entries we've encountered before or that\n-                // are in the block (which are already accounted for).\n-                if (!visited(childIter) && !setAlreadyIncluded.count(childHash)) {\n-                    UpdateChild(it, childIter, true);\n-                    UpdateParent(childIter, it, true);\n-                }\n+                // Add dependencies that are discovered between transactions in the\n+                // block and transactions that were in the mempool to txgraph.\n+                m_txgraph->AddDependency(*it, *childIter);\n             }\n-        } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded, descendants_to_remove);\n+        }\n     }\n \n-    for (const auto& txid : descendants_to_remove) {\n-        // This txid may have been removed already in a prior call to removeRecursive.\n-        // Therefore we ensure it is not yet removed already.\n-        if (const std::optional<txiter> txiter = GetIter(txid)) {\n-            removeRecursive((*txiter)->GetTx(), MemPoolRemovalReason::SIZELIMIT);\n-        }\n+    auto txs_to_remove = m_txgraph->Trim(); // Enforce cluster size limits.\n+    for (auto txptr : txs_to_remove) {\n+        const CTxMemPoolEntry& entry = *(static_cast<const CTxMemPoolEntry*>(txptr));\n+        removeUnchecked(mapTx.iterator_to(entry), MemPoolRemovalReason::SIZELIMIT);\n     }\n }\n \n-util::Result<CTxMemPool::setEntries> CTxMemPool::CalculateAncestorsAndCheckLimits(\n-    int64_t entry_size,\n-    size_t entry_count,\n-    CTxMemPoolEntry::Parents& staged_ancestors,\n-    const Limits& limits) const\n+bool CTxMemPool::HasDescendants(const Txid& txid) const\n {\n-    int64_t totalSizeWithAncestors = entry_size;\n-    setEntries ancestors;\n-\n-    while (!staged_ancestors.empty()) {\n-        const CTxMemPoolEntry& stage = staged_ancestors.begin()->get();\n-        txiter stageit = mapTx.iterator_to(stage);\n-\n-        ancestors.insert(stageit);\n-        staged_ancestors.erase(stage);\n-        totalSizeWithAncestors += stageit->GetTxSize();\n-\n-        if (stageit->GetSizeWithDescendants() + entry_size > limits.descendant_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_size_vbytes))};\n-        } else if (stageit->GetCountWithDescendants() + entry_count > static_cast<uint64_t>(limits.descendant_count)) {\n-            return util::Error{Untranslated(strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_count))};\n-        } else if (totalSizeWithAncestors > limits.ancestor_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds ancestor size limit [limit: %u]\", limits.ancestor_size_vbytes))};\n-        }\n-\n-        const CTxMemPoolEntry::Parents& parents = stageit->GetMemPoolParentsConst();\n-        for (const CTxMemPoolEntry& parent : parents) {\n-            txiter parent_it = mapTx.iterator_to(parent);\n-\n-            // If this is a new ancestor, add it.\n-            if (ancestors.count(parent_it) == 0) {\n-                staged_ancestors.insert(parent);\n-            }\n-            if (staged_ancestors.size() + ancestors.size() + entry_count > static_cast<uint64_t>(limits.ancestor_count)) {\n-                return util::Error{Untranslated(strprintf(\"too many unconfirmed ancestors [limit: %u]\", limits.ancestor_count))};\n-            }\n-        }\n-    }\n-\n-    return ancestors;\n+    LOCK(cs);\n+    auto entry = GetEntry(txid);\n+    if (!entry) return false;\n+    return m_txgraph->GetDescendants(*entry, TxGraph::Level::MAIN).size() > 1;\n }\n \n-util::Result<void> CTxMemPool::CheckPackageLimits(const Package& package,\n-                                                  const int64_t total_vsize) const\n+CTxMemPool::setEntries CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry) const\n {\n-    size_t pack_count = package.size();\n-\n-    // Package itself is busting mempool limits; should be rejected even if no staged_ancestors exist\n-    if (pack_count > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds ancestor count limit [limit: %u]\", pack_count, m_opts.limits.ancestor_count))};\n-    } else if (pack_count > static_cast<uint64_t>(m_opts.limits.descendant_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds descendant count limit [limit: %u]\", pack_count, m_opts.limits.descendant_count))};\n-    } else if (total_vsize > m_opts.limits.ancestor_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds ancestor size limit [limit: %u]\", total_vsize, m_opts.limits.ancestor_size_vbytes))};\n-    } else if (total_vsize > m_opts.limits.descendant_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds descendant size limit [limit: %u]\", total_vsize, m_opts.limits.descendant_size_vbytes))};\n-    }\n-\n-    CTxMemPoolEntry::Parents staged_ancestors;\n-    for (const auto& tx : package) {\n-        for (const auto& input : tx->vin) {\n-            std::optional<txiter> piter = GetIter(input.prevout.hash);\n-            if (piter) {\n-                staged_ancestors.insert(**piter);\n-                if (staged_ancestors.size() + package.size() > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-                    return util::Error{Untranslated(strprintf(\"too many unconfirmed parents [limit: %u]\", m_opts.limits.ancestor_count))};\n-                }\n+    auto ancestors = m_txgraph->GetAncestors(entry, TxGraph::Level::MAIN);\n+    setEntries ret;\n+    if (ancestors.size() > 0) {",
      "path": "src/txmempool.cpp",
      "position": 220,
      "original_position": 220,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450642965,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Use txgraph to calculate ancestors\"\r\n\r\n[This](https://github.com/bitcoin/bitcoin/pull/33629/commits/fa428af0bc670d6e2d520fe910909fbc4b4c1cb8#r2450642965) unkilled mutant looks concerning, as it means we have no testing in place that relies on correctly computing a non-empty set of ancestors?",
      "created_at": "2025-11-10T18:51:11Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511617302",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511617302"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511736121",
      "pull_request_review_id": 3443855926,
      "id": 2511736121,
      "node_id": "PRRC_kwDOABII586Vtg05",
      "diff_hunk": "@@ -286,6 +305,27 @@ static std::vector<RPCResult> MempoolEntryDescription()\n     };\n }\n \n+static void clusterToJSON(const CTxMemPool& pool, UniValue& info, std::vector<const CTxMemPoolEntry *> cluster) EXCLUSIVE_LOCKS_REQUIRED(pool.cs)\n+{\n+    AssertLockHeld(pool.cs);\n+    int total_vsize{0};\n+    for (const auto& tx : cluster) {\n+        total_vsize += tx->GetTxSize();\n+    }\n+    info.pushKV(\"vsize\", total_vsize);\n+    info.pushKV(\"txcount\", (int)cluster.size());\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& tx : cluster) {\n+        UniValue txentry(UniValue::VOBJ);\n+        auto feerate = pool.GetMainChunkFeerate(*tx);\n+        txentry.pushKV(\"txid\", tx->GetTx().GetHash().ToString());\n+        txentry.pushKV(\"chunk_fee\", ValueFromAmount((int)feerate.fee));\n+        txentry.pushKV(\"chunk_vsize\", feerate.size);",
      "path": "src/rpc/mempool.cpp",
      "position": 59,
      "original_position": 59,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "32f01e75c6d83891722b1c9972b9d29d188fb286",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "In commit \"Expose cluster information via rpc\"\r\n\r\nThis is one place where the `size` member of the output of `ToFeePerVSize()` matters (see earlier suggestion in this review to use `(fee*4, size)` for that function). However, perhaps it's worth using weights instead of vsizes in these RPCs anyway?",
      "created_at": "2025-11-10T19:36:35Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511736121",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511736121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 323,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511746477",
      "pull_request_review_id": 3443855926,
      "id": 2511746477,
      "node_id": "PRRC_kwDOABII586VtjWt",
      "diff_hunk": "@@ -116,95 +116,4 @@ FUZZ_TARGET(mini_miner, .init = initialize_miner)\n     // Overlapping ancestry across multiple outpoints can only reduce the total bump fee.\n     assert (sum_fees >= *total_bumpfee);\n }\n-",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": 4,
      "original_position": 4,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "97e03bec4641b137dc45c754eade95070bb47187",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "General comment on commit \"fuzz: remove comparison between mini_miner block construction and miner\"\r\n\r\nThis says this is preparation for a change to mini_miner, but it doesn't look like that change itself is part of this PR, or of #33591)?",
      "created_at": "2025-11-10T19:41:11Z",
      "updated_at": "2025-11-10T19:41:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511746477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511746477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 119,
      "original_line": 119,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511867396",
      "pull_request_review_id": 3445011636,
      "id": 2511867396,
      "node_id": "PRRC_kwDOABII586VuA4E",
      "diff_hunk": "@@ -54,353 +54,113 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints& lp)\n     return true;\n }\n \n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendants,\n-                                      const std::set<Txid>& setExclude, std::set<Txid>& descendants_to_remove)\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetChildren(const CTxMemPoolEntry& entry) const\n {\n-    CTxMemPoolEntry::Children stageEntries, descendants;\n-    stageEntries = updateIt->GetMemPoolChildrenConst();\n-\n-    while (!stageEntries.empty()) {\n-        const CTxMemPoolEntry& descendant = *stageEntries.begin();\n-        descendants.insert(descendant);\n-        stageEntries.erase(descendant);\n-        const CTxMemPoolEntry::Children& children = descendant.GetMemPoolChildrenConst();\n-        for (const CTxMemPoolEntry& childEntry : children) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(mapTx.iterator_to(childEntry));\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    descendants.insert(*cacheEntry);\n-                }\n-            } else if (!descendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n-            }\n-        }\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    setEntries children;\n+    auto iter = mapNextTx.lower_bound(COutPoint(entry.GetTx().GetHash(), 0));\n+    for (; iter != mapNextTx.end() && iter->first->hash == entry.GetTx().GetHash(); ++iter) {\n+        children.insert(iter->second);\n     }\n-    // descendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int32_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (const CTxMemPoolEntry& descendant : descendants) {\n-        if (!setExclude.count(descendant.GetTx().GetHash())) {\n-            modifySize += descendant.GetTxSize();\n-            modifyFee += descendant.GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(mapTx.iterator_to(descendant));\n-            // Update ancestor state for each descendant\n-            mapTx.modify(mapTx.iterator_to(descendant), [=](CTxMemPoolEntry& e) {\n-              e.UpdateAncestorState(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost());\n-            });\n-            // Don't directly remove the transaction here -- doing so would\n-            // invalidate iterators in cachedDescendants. Mark it for removal\n-            // by inserting into descendants_to_remove.\n-            if (descendant.GetCountWithAncestors() > uint64_t(m_opts.limits.ancestor_count) || descendant.GetSizeWithAncestors() > m_opts.limits.ancestor_size_vbytes) {\n-                descendants_to_remove.insert(descendant.GetTx().GetHash());\n-            }\n+    for (const auto& child : children) {\n+        ret.emplace_back(*child);\n+    }\n+    return ret;\n+}\n+\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetParents(const CTxMemPoolEntry& entry) const\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    std::set<Txid> inputs;\n+    for (const auto& txin : entry.GetTx().vin) {\n+        inputs.insert(txin.prevout.hash);\n+    }\n+    for (const auto& hash : inputs) {\n+        std::optional<txiter> piter = GetIter(hash);\n+        if (piter) {\n+            ret.emplace_back(**piter);\n         }\n     }\n-    mapTx.modify(updateIt, [=](CTxMemPoolEntry& e) { e.UpdateDescendantState(modifySize, modifyFee, modifyCount); });\n+    return ret;\n }\n \n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate)\n {\n     AssertLockHeld(cs);\n-    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n-    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n-    // descendants when we come across a previously seen entry.\n-    cacheMap mapMemPoolDescendantsToUpdate;\n-\n-    // Use a set for lookups into vHashesToUpdate (these entries are already\n-    // accounted for in the state of their ancestors)\n-    std::set<Txid> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n-\n-    std::set<Txid> descendants_to_remove;\n \n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n-    // This maximizes the benefit of the descendant cache and guarantees that\n-    // CTxMemPoolEntry::m_children will be updated, an assumption made in\n-    // UpdateForDescendants.\n     for (const Txid& hash : vHashesToUpdate | std::views::reverse) {\n         // calculate children from mapNextTx\n         txiter it = mapTx.find(hash);\n         if (it == mapTx.end()) {\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update CTxMemPoolEntry::m_children to\n-        // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n-        // we cache the in-mempool children to avoid duplicate updates\n         {\n-            WITH_FRESH_EPOCH(m_epoch);\n             for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n-                const Txid &childHash = iter->second->GetHash();\n-                txiter childIter = mapTx.find(childHash);\n+                txiter childIter = iter->second;\n                 assert(childIter != mapTx.end());\n-                // We can skip updating entries we've encountered before or that\n-                // are in the block (which are already accounted for).\n-                if (!visited(childIter) && !setAlreadyIncluded.count(childHash)) {\n-                    UpdateChild(it, childIter, true);\n-                    UpdateParent(childIter, it, true);\n-                }\n+                // Add dependencies that are discovered between transactions in the\n+                // block and transactions that were in the mempool to txgraph.\n+                m_txgraph->AddDependency(*it, *childIter);\n             }\n-        } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded, descendants_to_remove);\n+        }\n     }\n \n-    for (const auto& txid : descendants_to_remove) {\n-        // This txid may have been removed already in a prior call to removeRecursive.\n-        // Therefore we ensure it is not yet removed already.\n-        if (const std::optional<txiter> txiter = GetIter(txid)) {\n-            removeRecursive((*txiter)->GetTx(), MemPoolRemovalReason::SIZELIMIT);\n-        }\n+    auto txs_to_remove = m_txgraph->Trim(); // Enforce cluster size limits.\n+    for (auto txptr : txs_to_remove) {\n+        const CTxMemPoolEntry& entry = *(static_cast<const CTxMemPoolEntry*>(txptr));\n+        removeUnchecked(mapTx.iterator_to(entry), MemPoolRemovalReason::SIZELIMIT);\n     }\n }\n \n-util::Result<CTxMemPool::setEntries> CTxMemPool::CalculateAncestorsAndCheckLimits(\n-    int64_t entry_size,\n-    size_t entry_count,\n-    CTxMemPoolEntry::Parents& staged_ancestors,\n-    const Limits& limits) const\n+bool CTxMemPool::HasDescendants(const Txid& txid) const\n {\n-    int64_t totalSizeWithAncestors = entry_size;\n-    setEntries ancestors;\n-\n-    while (!staged_ancestors.empty()) {\n-        const CTxMemPoolEntry& stage = staged_ancestors.begin()->get();\n-        txiter stageit = mapTx.iterator_to(stage);\n-\n-        ancestors.insert(stageit);\n-        staged_ancestors.erase(stage);\n-        totalSizeWithAncestors += stageit->GetTxSize();\n-\n-        if (stageit->GetSizeWithDescendants() + entry_size > limits.descendant_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_size_vbytes))};\n-        } else if (stageit->GetCountWithDescendants() + entry_count > static_cast<uint64_t>(limits.descendant_count)) {\n-            return util::Error{Untranslated(strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_count))};\n-        } else if (totalSizeWithAncestors > limits.ancestor_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds ancestor size limit [limit: %u]\", limits.ancestor_size_vbytes))};\n-        }\n-\n-        const CTxMemPoolEntry::Parents& parents = stageit->GetMemPoolParentsConst();\n-        for (const CTxMemPoolEntry& parent : parents) {\n-            txiter parent_it = mapTx.iterator_to(parent);\n-\n-            // If this is a new ancestor, add it.\n-            if (ancestors.count(parent_it) == 0) {\n-                staged_ancestors.insert(parent);\n-            }\n-            if (staged_ancestors.size() + ancestors.size() + entry_count > static_cast<uint64_t>(limits.ancestor_count)) {\n-                return util::Error{Untranslated(strprintf(\"too many unconfirmed ancestors [limit: %u]\", limits.ancestor_count))};\n-            }\n-        }\n-    }\n-\n-    return ancestors;\n+    LOCK(cs);\n+    auto entry = GetEntry(txid);\n+    if (!entry) return false;\n+    return m_txgraph->GetDescendants(*entry, TxGraph::Level::MAIN).size() > 1;\n }\n \n-util::Result<void> CTxMemPool::CheckPackageLimits(const Package& package,\n-                                                  const int64_t total_vsize) const\n+CTxMemPool::setEntries CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry) const\n {\n-    size_t pack_count = package.size();\n-\n-    // Package itself is busting mempool limits; should be rejected even if no staged_ancestors exist\n-    if (pack_count > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds ancestor count limit [limit: %u]\", pack_count, m_opts.limits.ancestor_count))};\n-    } else if (pack_count > static_cast<uint64_t>(m_opts.limits.descendant_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds descendant count limit [limit: %u]\", pack_count, m_opts.limits.descendant_count))};\n-    } else if (total_vsize > m_opts.limits.ancestor_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds ancestor size limit [limit: %u]\", total_vsize, m_opts.limits.ancestor_size_vbytes))};\n-    } else if (total_vsize > m_opts.limits.descendant_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds descendant size limit [limit: %u]\", total_vsize, m_opts.limits.descendant_size_vbytes))};\n-    }\n-\n-    CTxMemPoolEntry::Parents staged_ancestors;\n-    for (const auto& tx : package) {\n-        for (const auto& input : tx->vin) {\n-            std::optional<txiter> piter = GetIter(input.prevout.hash);\n-            if (piter) {\n-                staged_ancestors.insert(**piter);\n-                if (staged_ancestors.size() + package.size() > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-                    return util::Error{Untranslated(strprintf(\"too many unconfirmed parents [limit: %u]\", m_opts.limits.ancestor_count))};\n-                }\n+    auto ancestors = m_txgraph->GetAncestors(entry, TxGraph::Level::MAIN);\n+    setEntries ret;\n+    if (ancestors.size() > 0) {",
      "path": "src/txmempool.cpp",
      "position": 220,
      "original_position": 220,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450642965,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe misunderstanding, but this just means it's purely an optimzation?\r\n\r\nIf it's not in the main graph, it still is able to gather ancestors via more expensive mempool queries.",
      "created_at": "2025-11-10T20:23:49Z",
      "updated_at": "2025-11-10T20:23:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511867396",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511867396"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511906918",
      "pull_request_review_id": 3445066408,
      "id": 2511906918,
      "node_id": "PRRC_kwDOABII586VuKhm",
      "diff_hunk": "@@ -54,353 +54,113 @@ bool TestLockPointValidity(CChain& active_chain, const LockPoints& lp)\n     return true;\n }\n \n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap& cachedDescendants,\n-                                      const std::set<Txid>& setExclude, std::set<Txid>& descendants_to_remove)\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetChildren(const CTxMemPoolEntry& entry) const\n {\n-    CTxMemPoolEntry::Children stageEntries, descendants;\n-    stageEntries = updateIt->GetMemPoolChildrenConst();\n-\n-    while (!stageEntries.empty()) {\n-        const CTxMemPoolEntry& descendant = *stageEntries.begin();\n-        descendants.insert(descendant);\n-        stageEntries.erase(descendant);\n-        const CTxMemPoolEntry::Children& children = descendant.GetMemPoolChildrenConst();\n-        for (const CTxMemPoolEntry& childEntry : children) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(mapTx.iterator_to(childEntry));\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    descendants.insert(*cacheEntry);\n-                }\n-            } else if (!descendants.count(childEntry)) {\n-                // Schedule for later processing\n-                stageEntries.insert(childEntry);\n-            }\n-        }\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    setEntries children;\n+    auto iter = mapNextTx.lower_bound(COutPoint(entry.GetTx().GetHash(), 0));\n+    for (; iter != mapNextTx.end() && iter->first->hash == entry.GetTx().GetHash(); ++iter) {\n+        children.insert(iter->second);\n     }\n-    // descendants now contains all in-mempool descendants of updateIt.\n-    // Update and add to cached descendant map\n-    int32_t modifySize = 0;\n-    CAmount modifyFee = 0;\n-    int64_t modifyCount = 0;\n-    for (const CTxMemPoolEntry& descendant : descendants) {\n-        if (!setExclude.count(descendant.GetTx().GetHash())) {\n-            modifySize += descendant.GetTxSize();\n-            modifyFee += descendant.GetModifiedFee();\n-            modifyCount++;\n-            cachedDescendants[updateIt].insert(mapTx.iterator_to(descendant));\n-            // Update ancestor state for each descendant\n-            mapTx.modify(mapTx.iterator_to(descendant), [=](CTxMemPoolEntry& e) {\n-              e.UpdateAncestorState(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost());\n-            });\n-            // Don't directly remove the transaction here -- doing so would\n-            // invalidate iterators in cachedDescendants. Mark it for removal\n-            // by inserting into descendants_to_remove.\n-            if (descendant.GetCountWithAncestors() > uint64_t(m_opts.limits.ancestor_count) || descendant.GetSizeWithAncestors() > m_opts.limits.ancestor_size_vbytes) {\n-                descendants_to_remove.insert(descendant.GetTx().GetHash());\n-            }\n+    for (const auto& child : children) {\n+        ret.emplace_back(*child);\n+    }\n+    return ret;\n+}\n+\n+std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> CTxMemPool::GetParents(const CTxMemPoolEntry& entry) const\n+{\n+    LOCK(cs);\n+    std::vector<CTxMemPoolEntry::CTxMemPoolEntryRef> ret;\n+    std::set<Txid> inputs;\n+    for (const auto& txin : entry.GetTx().vin) {\n+        inputs.insert(txin.prevout.hash);\n+    }\n+    for (const auto& hash : inputs) {\n+        std::optional<txiter> piter = GetIter(hash);\n+        if (piter) {\n+            ret.emplace_back(**piter);\n         }\n     }\n-    mapTx.modify(updateIt, [=](CTxMemPoolEntry& e) { e.UpdateDescendantState(modifySize, modifyFee, modifyCount); });\n+    return ret;\n }\n \n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<Txid>& vHashesToUpdate)\n {\n     AssertLockHeld(cs);\n-    // For each entry in vHashesToUpdate, store the set of in-mempool, but not\n-    // in-vHashesToUpdate transactions, so that we don't have to recalculate\n-    // descendants when we come across a previously seen entry.\n-    cacheMap mapMemPoolDescendantsToUpdate;\n-\n-    // Use a set for lookups into vHashesToUpdate (these entries are already\n-    // accounted for in the state of their ancestors)\n-    std::set<Txid> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n-\n-    std::set<Txid> descendants_to_remove;\n \n     // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n-    // This maximizes the benefit of the descendant cache and guarantees that\n-    // CTxMemPoolEntry::m_children will be updated, an assumption made in\n-    // UpdateForDescendants.\n     for (const Txid& hash : vHashesToUpdate | std::views::reverse) {\n         // calculate children from mapNextTx\n         txiter it = mapTx.find(hash);\n         if (it == mapTx.end()) {\n             continue;\n         }\n         auto iter = mapNextTx.lower_bound(COutPoint(hash, 0));\n-        // First calculate the children, and update CTxMemPoolEntry::m_children to\n-        // include them, and update their CTxMemPoolEntry::m_parents to include this tx.\n-        // we cache the in-mempool children to avoid duplicate updates\n         {\n-            WITH_FRESH_EPOCH(m_epoch);\n             for (; iter != mapNextTx.end() && iter->first->hash == hash; ++iter) {\n-                const Txid &childHash = iter->second->GetHash();\n-                txiter childIter = mapTx.find(childHash);\n+                txiter childIter = iter->second;\n                 assert(childIter != mapTx.end());\n-                // We can skip updating entries we've encountered before or that\n-                // are in the block (which are already accounted for).\n-                if (!visited(childIter) && !setAlreadyIncluded.count(childHash)) {\n-                    UpdateChild(it, childIter, true);\n-                    UpdateParent(childIter, it, true);\n-                }\n+                // Add dependencies that are discovered between transactions in the\n+                // block and transactions that were in the mempool to txgraph.\n+                m_txgraph->AddDependency(*it, *childIter);\n             }\n-        } // release epoch guard for UpdateForDescendants\n-        UpdateForDescendants(it, mapMemPoolDescendantsToUpdate, setAlreadyIncluded, descendants_to_remove);\n+        }\n     }\n \n-    for (const auto& txid : descendants_to_remove) {\n-        // This txid may have been removed already in a prior call to removeRecursive.\n-        // Therefore we ensure it is not yet removed already.\n-        if (const std::optional<txiter> txiter = GetIter(txid)) {\n-            removeRecursive((*txiter)->GetTx(), MemPoolRemovalReason::SIZELIMIT);\n-        }\n+    auto txs_to_remove = m_txgraph->Trim(); // Enforce cluster size limits.\n+    for (auto txptr : txs_to_remove) {\n+        const CTxMemPoolEntry& entry = *(static_cast<const CTxMemPoolEntry*>(txptr));\n+        removeUnchecked(mapTx.iterator_to(entry), MemPoolRemovalReason::SIZELIMIT);\n     }\n }\n \n-util::Result<CTxMemPool::setEntries> CTxMemPool::CalculateAncestorsAndCheckLimits(\n-    int64_t entry_size,\n-    size_t entry_count,\n-    CTxMemPoolEntry::Parents& staged_ancestors,\n-    const Limits& limits) const\n+bool CTxMemPool::HasDescendants(const Txid& txid) const\n {\n-    int64_t totalSizeWithAncestors = entry_size;\n-    setEntries ancestors;\n-\n-    while (!staged_ancestors.empty()) {\n-        const CTxMemPoolEntry& stage = staged_ancestors.begin()->get();\n-        txiter stageit = mapTx.iterator_to(stage);\n-\n-        ancestors.insert(stageit);\n-        staged_ancestors.erase(stage);\n-        totalSizeWithAncestors += stageit->GetTxSize();\n-\n-        if (stageit->GetSizeWithDescendants() + entry_size > limits.descendant_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds descendant size limit for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_size_vbytes))};\n-        } else if (stageit->GetCountWithDescendants() + entry_count > static_cast<uint64_t>(limits.descendant_count)) {\n-            return util::Error{Untranslated(strprintf(\"too many descendants for tx %s [limit: %u]\", stageit->GetTx().GetHash().ToString(), limits.descendant_count))};\n-        } else if (totalSizeWithAncestors > limits.ancestor_size_vbytes) {\n-            return util::Error{Untranslated(strprintf(\"exceeds ancestor size limit [limit: %u]\", limits.ancestor_size_vbytes))};\n-        }\n-\n-        const CTxMemPoolEntry::Parents& parents = stageit->GetMemPoolParentsConst();\n-        for (const CTxMemPoolEntry& parent : parents) {\n-            txiter parent_it = mapTx.iterator_to(parent);\n-\n-            // If this is a new ancestor, add it.\n-            if (ancestors.count(parent_it) == 0) {\n-                staged_ancestors.insert(parent);\n-            }\n-            if (staged_ancestors.size() + ancestors.size() + entry_count > static_cast<uint64_t>(limits.ancestor_count)) {\n-                return util::Error{Untranslated(strprintf(\"too many unconfirmed ancestors [limit: %u]\", limits.ancestor_count))};\n-            }\n-        }\n-    }\n-\n-    return ancestors;\n+    LOCK(cs);\n+    auto entry = GetEntry(txid);\n+    if (!entry) return false;\n+    return m_txgraph->GetDescendants(*entry, TxGraph::Level::MAIN).size() > 1;\n }\n \n-util::Result<void> CTxMemPool::CheckPackageLimits(const Package& package,\n-                                                  const int64_t total_vsize) const\n+CTxMemPool::setEntries CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry) const\n {\n-    size_t pack_count = package.size();\n-\n-    // Package itself is busting mempool limits; should be rejected even if no staged_ancestors exist\n-    if (pack_count > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds ancestor count limit [limit: %u]\", pack_count, m_opts.limits.ancestor_count))};\n-    } else if (pack_count > static_cast<uint64_t>(m_opts.limits.descendant_count)) {\n-        return util::Error{Untranslated(strprintf(\"package count %u exceeds descendant count limit [limit: %u]\", pack_count, m_opts.limits.descendant_count))};\n-    } else if (total_vsize > m_opts.limits.ancestor_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds ancestor size limit [limit: %u]\", total_vsize, m_opts.limits.ancestor_size_vbytes))};\n-    } else if (total_vsize > m_opts.limits.descendant_size_vbytes) {\n-        return util::Error{Untranslated(strprintf(\"package size %u exceeds descendant size limit [limit: %u]\", total_vsize, m_opts.limits.descendant_size_vbytes))};\n-    }\n-\n-    CTxMemPoolEntry::Parents staged_ancestors;\n-    for (const auto& tx : package) {\n-        for (const auto& input : tx->vin) {\n-            std::optional<txiter> piter = GetIter(input.prevout.hash);\n-            if (piter) {\n-                staged_ancestors.insert(**piter);\n-                if (staged_ancestors.size() + package.size() > static_cast<uint64_t>(m_opts.limits.ancestor_count)) {\n-                    return util::Error{Untranslated(strprintf(\"too many unconfirmed parents [limit: %u]\", m_opts.limits.ancestor_count))};\n-                }\n+    auto ancestors = m_txgraph->GetAncestors(entry, TxGraph::Level::MAIN);\n+    setEntries ret;\n+    if (ancestors.size() > 0) {",
      "path": "src/txmempool.cpp",
      "position": 220,
      "original_position": 220,
      "commit_id": "02ac4a1e7c30e8cf1a862ec1e2ddab55273c2d65",
      "original_commit_id": "1ae9fd3f7a4fddc786e9921e7fc2af41ab96bf9a",
      "in_reply_to_id": 2450642965,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "@instagibbs Oh, you're right - the mutation just causes the code to always use the fallback path, which needs to exist for non-mempool transactions anyway.",
      "created_at": "2025-11-10T20:38:21Z",
      "updated_at": "2025-11-10T20:38:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33629#discussion_r2511906918",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2511906918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33629"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 132,
      "original_line": 132,
      "side": "RIGHT"
    }
  ]
}