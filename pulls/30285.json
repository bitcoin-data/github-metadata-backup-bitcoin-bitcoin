{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285",
    "id": 1919777919,
    "node_id": "PR_kwDOABII585ybXx_",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30285",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30285.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30285.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30285",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30285/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/bbcee5a0d67db46526ba29a1a4a7c590d303de03",
    "number": 30285,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: merging & postprocessing of linearizations",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Part of cluster mempool: #30289 \r\n\r\nDepends on #30126, and was split off from it. #28676 depends on this.\r\n\r\nThis adds the algorithms for merging & postprocessing linearizations.\r\n\r\nThe `PostLinearize(depgraph, linearization)` function performs an in-place improvement of `linearization`, using two iterations of the [Linearization post-processing](https://delvingbitcoin.org/t/linearization-post-processing-o-n-2-fancy-chunking/201/8) algorithm. The first running from back to front, the second from front to back.\r\n\r\nThe `MergeLinearizations(depgraph, linearization1, linearization2)` function computes a new linearization for the provided cluster, given two existing linearizations for that cluster, which is at least as good as both inputs. The algorithm is described at a high level in [merging incomparable linearizations](https://delvingbitcoin.org/t/merging-incomparable-linearizations/209).\r\n\r\nFor background and references, see [Introduction to cluster linearization](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032).",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2024-06-14T02:12:38Z",
    "updated_at": "2024-08-02T12:10:35Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "b566dba1bf330813929b9c344a359fcd2f76cd98",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202406_clusterlin_meta",
      "ref": "202406_clusterlin_meta",
      "sha": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 22,
        "stargazers_count": 86,
        "watchers_count": 86,
        "size": 244310,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-08-01T20:13:04Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2024-06-02T01:19:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "9774a958b501a6d439a734e18b29e04f59f973f6",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35817,
        "stargazers_count": 77567,
        "watchers_count": 77567,
        "size": 264551,
        "default_branch": "master",
        "open_issues_count": 675,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-08-02T12:51:33Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-08-02T12:26:28Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 653,
    "deletions": 16,
    "changed_files": 3,
    "commits": 5,
    "review_comments": 54,
    "comments": 4
  },
  "events": [
    {
      "event": "commented",
      "id": 2167083725,
      "node_id": "IC_kwDOABII586BKxLN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2167083725",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T02:12:41Z",
      "updated_at": "2024-08-02T11:14:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30285).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [glozow](https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2215276451) |\n| Stale ACK | [sdaftuar](https://github.com/bitcoin/bitcoin/pull/30285#issuecomment-2261388754), [instagibbs](https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2210653746) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30286](https://github.com/bitcoin/bitcoin/pull/30286) (cluster mempool: optimized candidate search by sipa)\n* [#28676](https://github.com/bitcoin/bitcoin/pull/28676) ([WIP] Cluster mempool implementation by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#issuecomment-2167083725",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30285"
    },
    {
      "event": "renamed",
      "id": 13160834191,
      "node_id": "RTE_lADOABII586MNeZQzwAAAAMQcmSP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13160834191",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:13:10Z",
      "rename": {
        "from": "Low-level cluster linearization code: merging & postprocessing",
        "to": "cluster mempool: merging and postprocessing for linearizations"
      }
    },
    {
      "event": "renamed",
      "id": 13160836966,
      "node_id": "RTE_lADOABII586MNeZQzwAAAAMQcm9m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13160836966",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:13:24Z",
      "rename": {
        "from": "cluster mempool: merging and postprocessing for linearizations",
        "to": "cluster mempool: merging & postprocessing of linearizations"
      }
    },
    {
      "event": "labeled",
      "id": 13160842418,
      "node_id": "LE_lADOABII586MNeZQzwAAAAMQcoSy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13160842418",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-14T13:13:47Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13371687480,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMdA8I4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13371687480",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-02T20:51:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13462026606,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMiZjlu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13462026606",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T20:38:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13462204247,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMiaO9X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13462204247",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T20:49:51Z"
    },
    {
      "event": "labeled",
      "id": 13463242988,
      "node_id": "LE_lADOABII586MNeZQzwAAAAMieMjs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13463242988",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T22:20:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2221624602,
      "node_id": "IC_kwDOABII586Ea00a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2221624602",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T22:20:14Z",
      "updated_at": "2024-07-10T22:20:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\nðŸš§ At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/27291659212</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#issuecomment-2221624602",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30285"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13471007664,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMi70Ow",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13471007664",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T12:27:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13471132242,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMi8SpS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13471132242",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T12:37:07Z"
    },
    {
      "event": "unlabeled",
      "id": 13472768574,
      "node_id": "UNLE_lADOABII586MNeZQzwAAAAMjCiI-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13472768574",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-11T14:29:17Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13579307432,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMpY8mo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13579307432",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-19T18:00:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13580419081,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMpdMAJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13580419081",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-19T19:38:49Z"
    },
    {
      "event": "labeled",
      "id": 13659858097,
      "node_id": "LE_lADOABII586MNeZQzwAAAAMuMOSx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13659858097",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T11:17:37Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13660693615,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMuPaRv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13660693615",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T12:39:30Z"
    },
    {
      "event": "unlabeled",
      "id": 13661348737,
      "node_id": "UNLE_lADOABII586MNeZQzwAAAAMuR6OB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13661348737",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-26T13:36:12Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2205483629,
      "node_id": "PRR_kwDOABII586DdQJt",
      "url": null,
      "actor": null,
      "commit_id": "f4a183cd17c7c770fd6b9d32b9d6c6f791bceb4e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "f4a183cd17c7c770fd6b9d32b9d6c6f791bceb4e \r\n\r\ndid not yet review implementation of PostLinearize, didn't verify benchmarks with optimizations",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2205483629",
      "submitted_at": "2024-07-30T15:21:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13701877587,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMwsg9T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13701877587",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-30T22:08:30Z"
    },
    {
      "event": "labeled",
      "id": 13702433406,
      "node_id": "LE_lADOABII586MNeZQzwAAAAMwuop-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13702433406",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-30T23:47:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13702542545,
      "node_id": "UNLE_lADOABII586MNeZQzwAAAAMwvDTR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13702542545",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-31T00:08:24Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2208370543,
      "node_id": "PRR_kwDOABII586DoQ9v",
      "url": null,
      "actor": null,
      "commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "code review ACK 157464f3a9444ac9b2337227a2fee2f3adbd0918, will fuzz",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2208370543",
      "submitted_at": "2024-07-31T16:21:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
    },
    {
      "event": "commented",
      "id": 2261388754,
      "node_id": "IC_kwDOABII586Gyg3S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2261388754",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-31T20:24:53Z",
      "updated_at": "2024-07-31T20:24:53Z",
      "author_association": "MEMBER",
      "body": "ACK 157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#issuecomment-2261388754",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30285"
    },
    {
      "event": "reviewed",
      "id": 2210653746,
      "node_id": "PRR_kwDOABII586Dw-Yy",
      "url": null,
      "actor": null,
      "commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK 157464f3a9444ac9b2337227a2fee2f3adbd0918\r\n\r\nI didn't verify benchmark timings but opts seemed ok\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2210653746",
      "submitted_at": "2024-07-31T20:37:41Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
    },
    {
      "event": "commented",
      "id": 2263377566,
      "node_id": "IC_kwDOABII586G6Gae",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2263377566",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T15:37:36Z",
      "updated_at": "2024-08-01T15:37:36Z",
      "author_association": "MEMBER",
      "body": "Here are my linearization benchmarks (ryzen 7995wx) after this PR (compare with https://github.com/bitcoin/bitcoin/pull/30126#issuecomment-2248546746):\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              973.43 |        1,027,297.78 |    0.5% |      0.01 | `LinearizeNoIters16TxWorstCaseAnc`\r\n|            1,464.85 |          682,664.84 |    0.2% |      0.01 | `LinearizeNoIters16TxWorstCaseLIMO`\r\n|            2,503.93 |          399,372.47 |    0.3% |      0.01 | `LinearizeNoIters32TxWorstCaseAnc`\r\n|            5,091.86 |          196,392.05 |    0.2% |      0.01 | `LinearizeNoIters32TxWorstCaseLIMO`\r\n|            4,881.34 |          204,861.99 |    0.1% |      0.01 | `LinearizeNoIters48TxWorstCaseAnc`\r\n|           10,880.48 |           91,907.74 |    0.0% |      0.01 | `LinearizeNoIters48TxWorstCaseLIMO`\r\n|            7,843.67 |          127,491.30 |    0.0% |      0.01 | `LinearizeNoIters64TxWorstCaseAnc`\r\n|           18,803.07 |           53,182.80 |    0.1% |      0.01 | `LinearizeNoIters64TxWorstCaseLIMO`\r\n|           11,747.48 |           85,124.62 |    0.1% |      0.01 | `LinearizeNoIters75TxWorstCaseAnc`\r\n|           28,902.79 |           34,598.74 |    0.0% |      0.01 | `LinearizeNoIters75TxWorstCaseLIMO`\r\n|           19,030.02 |           52,548.55 |    0.1% |      0.01 | `LinearizeNoIters99TxWorstCaseAnc`\r\n|           49,663.43 |           20,135.54 |    0.1% |      0.01 | `LinearizeNoIters99TxWorstCaseLIMO`\r\n\r\n|            ns/iters |             iters/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|               13.66 |       73,231,349.71 |    0.1% |      0.01 | `LinearizePerIter16TxWorstCase`\r\n|                9.63 |      103,869,988.01 |    0.3% |      0.01 | `LinearizePerIter32TxWorstCase`\r\n|                9.38 |      106,626,518.23 |    0.3% |      0.01 | `LinearizePerIter48TxWorstCase`\r\n|                9.44 |      105,920,646.37 |    0.3% |      0.01 | `LinearizePerIter64TxWorstCase`\r\n|               10.38 |       96,365,108.12 |    0.3% |      0.01 | `LinearizePerIter75TxWorstCase`\r\n|               10.38 |       96,374,023.73 |    0.2% |      0.01 | `LinearizePerIter99TxWorstCase`\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              690.49 |        1,448,239.70 |    0.4% |      0.01 | `MergeLinearizations16TxWorstCase`\r\n|            2,703.90 |          369,835.96 |    0.1% |      0.01 | `MergeLinearizations32TxWorstCase`\r\n|            6,143.66 |          162,769.31 |    0.0% |      0.01 | `MergeLinearizations48TxWorstCase`\r\n|           11,300.76 |           88,489.66 |    0.1% |      0.01 | `MergeLinearizations64TxWorstCase`\r\n|           17,576.48 |           56,894.21 |    0.0% |      0.01 | `MergeLinearizations75TxWorstCase`\r\n|           31,100.42 |           32,153.91 |    0.0% |      0.01 | `MergeLinearizations99TxWorstCase`\r\n|              278.14 |        3,595,258.27 |    0.0% |      0.01 | `PostLinearize16TxWorstCase`\r\n|              863.81 |        1,157,659.26 |    0.0% |      0.01 | `PostLinearize32TxWorstCase`\r\n|            2,657.66 |          376,271.23 |    0.2% |      0.01 | `PostLinearize48TxWorstCase`\r\n|            4,652.11 |          214,956.22 |    0.0% |      0.01 | `PostLinearize64TxWorstCase`\r\n|            5,392.31 |          185,449.25 |    0.2% |      0.01 | `PostLinearize75TxWorstCase`\r\n|            9,431.09 |          106,032.27 |    0.1% |      0.01 | `PostLinearize99TxWorstCase`",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#issuecomment-2263377566",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30285"
    },
    {
      "event": "reviewed",
      "id": 2212460568,
      "node_id": "PRR_kwDOABII586D33gY",
      "url": null,
      "actor": null,
      "commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2212460568",
      "submitted_at": "2024-08-01T17:13:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBlNTI3MjhhMmQ2Y2NhZmNmZWNmZWZiYjVhMDQzMmE5ODgxZDhlMGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e52728a2d6ccafcfecfefbb5a0432a9881d8e0d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0e52728a2d6ccafcfecfefbb5a0432a9881d8e0d",
      "tree": {
        "sha": "7e5db7de4ba1d6232df2cf764a051c81bd4af13d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e5db7de4ba1d6232df2cf764a051c81bd4af13d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9774a958b501a6d439a734e18b29e04f59f973f6",
          "sha": "9774a958b501a6d439a734e18b29e04f59f973f6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9774a958b501a6d439a734e18b29e04f59f973f6"
        }
      ],
      "message": "clusterlin: rename Intersect -> IntersectPrefixes\n\nThis makes it clearer what the function does.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-01T18:07:54Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-30T20:21:51Z"
      },
      "sha": "0e52728a2d6ccafcfecfefbb5a0432a9881d8e0d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBlMjgxMmQyOTM4YjkzM2RlYmZmYmE1Yjg3MzYzN2ZhMWQzNDhiODE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e2812d2938b933debffba5b873637fa1d348b81",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0e2812d2938b933debffba5b873637fa1d348b81",
      "tree": {
        "sha": "c4dc0374193aba87cf04776f8c94657b7b592501",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c4dc0374193aba87cf04776f8c94657b7b592501"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e52728a2d6ccafcfecfefbb5a0432a9881d8e0d",
          "sha": "0e52728a2d6ccafcfecfefbb5a0432a9881d8e0d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0e52728a2d6ccafcfecfefbb5a0432a9881d8e0d"
        }
      ],
      "message": "clusterlin: add algorithms for connectedness/connected components\n\nAdd utility functions to DepGraph for finding connected components.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-01T19:43:59Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-15T12:37:12Z"
      },
      "sha": "0e2812d2938b933debffba5b873637fa1d348b81"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRmODk1OGQ3NTYzYWUyZDBkMzU5ZWMxZTY4ODVmOGNiNWU0MGE1ZTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f8958d7563ae2d0d359ec1e6885f8cb5e40a5e0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4f8958d7563ae2d0d359ec1e6885f8cb5e40a5e0",
      "tree": {
        "sha": "02cc27137b85e1b8afd47448515296096bdf6288",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02cc27137b85e1b8afd47448515296096bdf6288"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e2812d2938b933debffba5b873637fa1d348b81",
          "sha": "0e2812d2938b933debffba5b873637fa1d348b81",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0e2812d2938b933debffba5b873637fa1d348b81"
        }
      ],
      "message": "clusterlin: add PostLinearize + benchmarks + fuzz tests",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-01T20:02:09Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-19T12:03:57Z"
      },
      "sha": "4f8958d7563ae2d0d359ec1e6885f8cb5e40a5e0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA0ZDdhMDRlYTQyNmRkMGE2OWI2MWUzYjg4Nzg2N2IwMjc3ZDg0ZDE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04d7a04ea426dd0a69b61e3b887867b0277d84d1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/04d7a04ea426dd0a69b61e3b887867b0277d84d1",
      "tree": {
        "sha": "20eaceab7294f40bf2dc69b50129a63057d17c4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20eaceab7294f40bf2dc69b50129a63057d17c4b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f8958d7563ae2d0d359ec1e6885f8cb5e40a5e0",
          "sha": "4f8958d7563ae2d0d359ec1e6885f8cb5e40a5e0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4f8958d7563ae2d0d359ec1e6885f8cb5e40a5e0"
        }
      ],
      "message": "clusterlin: add MergeLinearizations function + fuzz test + benchmark",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-01T20:03:34Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-29T01:18:52Z"
      },
      "sha": "04d7a04ea426dd0a69b61e3b887867b0277d84d1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJiY2VlNWEwZDY3ZGI0NjUyNmJhMjlhMWE0YTdjNTkwZDMwM2RlMDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "tree": {
        "sha": "c4cfdbc724fe7a6d29d0361a187882a1113fd8a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c4cfdbc724fe7a6d29d0361a187882a1113fd8a2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04d7a04ea426dd0a69b61e3b887867b0277d84d1",
          "sha": "04d7a04ea426dd0a69b61e3b887867b0277d84d1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/04d7a04ea426dd0a69b61e3b887867b0277d84d1"
        }
      ],
      "message": "clusterlin: improve rechunking in LinearizationChunking (optimization)\n\nWhen the transactions being marked done exactly match the first chunk of\nwhat remains of the linearization, we can just remember to skip that\nchunk instead of computing a full rechunking.\n\nFurther, chop off prefixes of the input linearization that are already done,\nso they don't need to be reconsidered for further rechunkings.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-01T20:03:38Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-07-10T19:56:17Z"
      },
      "sha": "bbcee5a0d67db46526ba29a1a4a7c590d303de03"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13731597416,
      "node_id": "HRFPE_lADOABII586MNeZQzwAAAAMyd4xo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13731597416",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-01T20:13:06Z"
    },
    {
      "event": "reviewed",
      "id": 2215276451,
      "node_id": "PRR_kwDOABII586ECm-j",
      "url": null,
      "actor": null,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "code review ACK bbcee5a0d67",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#pullrequestreview-2215276451",
      "submitted_at": "2024-08-02T11:14:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
    },
    {
      "event": "review_requested",
      "id": 13740476337,
      "node_id": "RRE_lADOABII586MNeZQzwAAAAMy_wex",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13740476337",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-02T11:14:50Z",
      "requested_reviewer": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 13740476463,
      "node_id": "RRE_lADOABII586MNeZQzwAAAAMy_wgv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13740476463",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-02T11:14:51Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1696993400",
      "pull_request_review_id": 2205483629,
      "id": 1696993400,
      "node_id": "PRRC_kwDOABII585lJhB4",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While there is a group P in L immediately preceding C, which has lower feerate than C:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 38,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n    //   - While there is a group P in L immediately preceding C which has lower feerate than C:\r\n```",
      "created_at": "2024-07-30T13:44:40Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1696993400",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1696993400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 807,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697036508",
      "pull_request_review_id": 2205483629,
      "id": 1697036508,
      "node_id": "PRRC_kwDOABII585lJrjc",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all",
      "path": "src/cluster_linearize.h",
      "position": 172,
      "original_position": 21,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "intuitively, and from attempting to fuzz this, each pass corresponds to one type of tree shape. Might be good to note this, and if state if there are other motivations as well to do two passes and under what topologies.",
      "created_at": "2024-07-30T14:10:03Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697036508",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697036508"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 815,
      "original_line": 815,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697063661",
      "pull_request_review_id": 2205483629,
      "id": 1697063661,
      "node_id": "PRRC_kwDOABII585lJyLt",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While there is a group P in L immediately preceding C, which has lower feerate than C:\n+    //     - If C depends on P:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // appending is kept, but instead the meaning of parent/child and high/low fee are swapped,\n+    // and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // Fields that are only used for transactions that are the last one in a group:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 65,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "next field is `first_tx`, not last",
      "created_at": "2024-07-30T14:23:47Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697063661",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697063661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697069771",
      "pull_request_review_id": 2205483629,
      "id": 1697069771,
      "node_id": "PRRC_kwDOABII585lJzrL",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 24,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sanity checking wrong linearization?",
      "created_at": "2024-07-30T14:27:16Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697069771",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697069771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697077786",
      "pull_request_review_id": 2205483629,
      "id": 1697077786,
      "node_id": "PRRC_kwDOABII585lJ1oa",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 153,
      "original_position": 31,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```Suggestion\r\n\r\n    // Run again, things can keep improving (and never get worse)\r\n    PostLinearize(depgraph, post_linearization);\r\n    SanityCheck(depgraph, post_linearization);\r\n    auto newest_chunking = ChunkLinearization(depgraph, post_linearization);\r\n    cmp = CompareChunks(newest_chunking, new_chunking);\r\n    assert(cmp >= 0);\r\n    \r\n```",
      "created_at": "2024-07-30T14:31:59Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697077786",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697077786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 804,
      "original_line": 804,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697081214",
      "pull_request_review_id": 2205483629,
      "id": 1697081214,
      "node_id": "PRRC_kwDOABII585lJ2d-",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 220,
      "original_position": 98,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could test that running PostLinearization again doesn't do anything",
      "created_at": "2024-07-30T14:34:05Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697081214",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697081214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 871,
      "original_line": 871,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697082277",
      "pull_request_review_id": 2205483629,
      "id": 1697082277,
      "node_id": "PRRC_kwDOABII585lJ2ul",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // Try to find an even better linearization; the result must be identical as post_linearization\n+    // ought to be optimal already with a tree-structured graph.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, new_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 241,
      "original_position": 110,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "is this specifically for prioritisetransaction or something?",
      "created_at": "2024-07-30T14:34:45Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697082277",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697082277"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 892,
      "original_line": 892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697084073",
      "pull_request_review_id": 2205483629,
      "id": 1697084073,
      "node_id": "PRRC_kwDOABII585lJ3Kp",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sanity checking wrong linearization? ",
      "created_at": "2024-07-30T14:35:48Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697084073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697084073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697135017",
      "pull_request_review_id": 2205483629,
      "id": 1697135017,
      "node_id": "PRRC_kwDOABII585lKDmp",
      "diff_hunk": "@@ -962,6 +962,47 @@ void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> lineari\n     }\n }\n \n+/** Merge two linearizations for the same cluster into one that is as good as both.\n+ *\n+ * Complexity: O(N^2) where N=depgraph.TxCount(); O(N) if both inputs are identical.\n+ */\n+template<typename SetType>\n+std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin1, Span<const ClusterIndex> lin2)\n+{\n+    Assume(lin1.size() == depgraph.TxCount());\n+    Assume(lin2.size() == depgraph.TxCount());\n+\n+    /** Chunkings of what remains of both input linearizations. */\n+    LinearizationChunking chunking1(depgraph, lin1), chunking2(depgraph, lin2);\n+    /** Output linearization. */\n+    std::vector<ClusterIndex> ret;\n+    if (depgraph.TxCount() == 0) return ret;\n+    ret.reserve(depgraph.TxCount());\n+\n+    while (true) {\n+        // As long as we are not done, both linearizations must have chunks left.\n+        Assume(chunking1.NumChunksLeft() > 0);\n+        Assume(chunking2.NumChunksLeft() > 0);\n+        // Find the set to output by taking the best remaining chunk, and then intersecting it with\n+        // prefixes of remaining chunks of the other linearization.\n+        SetInfo<SetType> best;\n+        const auto& lin1_firstchunk = chunking1.GetChunk(0);\n+        const auto& lin2_firstchunk = chunking2.GetChunk(0);\n+        if (lin2_firstchunk.feerate >> lin1_firstchunk.feerate) {\n+            best = chunking1.Intersect(lin2_firstchunk);",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 31,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "c17480e1447d9650f71a4749b2d92374278e7f63",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "hm, `Intersect` had me quite confused in this context, consider renaming this as something like `PrefixIntersect`?",
      "created_at": "2024-07-30T15:06:50Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697135017",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697135017"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 992,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697144521",
      "pull_request_review_id": 2205483629,
      "id": 1697144521,
      "node_id": "PRRC_kwDOABII585lKF7J",
      "diff_hunk": "@@ -962,6 +962,47 @@ void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> lineari\n     }\n }\n \n+/** Merge two linearizations for the same cluster into one that is as good as both.\n+ *\n+ * Complexity: O(N^2) where N=depgraph.TxCount(); O(N) if both inputs are identical.\n+ */\n+template<typename SetType>\n+std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin1, Span<const ClusterIndex> lin2)\n+{\n+    Assume(lin1.size() == depgraph.TxCount());\n+    Assume(lin2.size() == depgraph.TxCount());\n+\n+    /** Chunkings of what remains of both input linearizations. */\n+    LinearizationChunking chunking1(depgraph, lin1), chunking2(depgraph, lin2);\n+    /** Output linearization. */\n+    std::vector<ClusterIndex> ret;\n+    if (depgraph.TxCount() == 0) return ret;\n+    ret.reserve(depgraph.TxCount());\n+\n+    while (true) {\n+        // As long as we are not done, both linearizations must have chunks left.\n+        Assume(chunking1.NumChunksLeft() > 0);\n+        Assume(chunking2.NumChunksLeft() > 0);\n+        // Find the set to output by taking the best remaining chunk, and then intersecting it with\n+        // prefixes of remaining chunks of the other linearization.\n+        SetInfo<SetType> best;\n+        const auto& lin1_firstchunk = chunking1.GetChunk(0);\n+        const auto& lin2_firstchunk = chunking2.GetChunk(0);\n+        if (lin2_firstchunk.feerate >> lin1_firstchunk.feerate) {\n+            best = chunking1.Intersect(lin2_firstchunk);\n+        } else {\n+            best = chunking2.Intersect(lin1_firstchunk);\n+        }\n+        // Append the result to the output and mark it as done.\n+        depgraph.AppendTopo(ret, best.transactions);\n+        chunking1.MarkDone(best.transactions);\n+        if (chunking1.NumChunksLeft() == 0) break;",
      "path": "src/cluster_linearize.h",
      "position": 399,
      "original_position": 38,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "c17480e1447d9650f71a4749b2d92374278e7f63",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "breaking here allows you to skip one last `MarkDone` on completion vs putting the count in the while loop, yes?",
      "created_at": "2024-07-30T15:12:59Z",
      "updated_at": "2024-07-30T15:21:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697144521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697144521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1042,
      "original_line": 1042,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697413622",
      "pull_request_review_id": 2208416977,
      "id": 1697413622,
      "node_id": "PRRC_kwDOABII585lLHn2",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While there is a group P in L immediately preceding C, which has lower feerate than C:\n+    //     - If C depends on P:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // appending is kept, but instead the meaning of parent/child and high/low fee are swapped,\n+    // and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // Fields that are only used for transactions that are the last one in a group:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 65,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697063661,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `first_tx` field (just like the `prev_group`, `group`, `deps`, `feerate` fields) are only used for transactions which are the last one in a group.",
      "created_at": "2024-07-30T18:40:33Z",
      "updated_at": "2024-07-30T18:40:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697413622",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697413622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697654309",
      "pull_request_review_id": 2208790350,
      "id": 1697654309,
      "node_id": "PRRC_kwDOABII585lMCYl",
      "diff_hunk": "@@ -962,6 +962,47 @@ void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> lineari\n     }\n }\n \n+/** Merge two linearizations for the same cluster into one that is as good as both.\n+ *\n+ * Complexity: O(N^2) where N=depgraph.TxCount(); O(N) if both inputs are identical.\n+ */\n+template<typename SetType>\n+std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin1, Span<const ClusterIndex> lin2)\n+{\n+    Assume(lin1.size() == depgraph.TxCount());\n+    Assume(lin2.size() == depgraph.TxCount());\n+\n+    /** Chunkings of what remains of both input linearizations. */\n+    LinearizationChunking chunking1(depgraph, lin1), chunking2(depgraph, lin2);\n+    /** Output linearization. */\n+    std::vector<ClusterIndex> ret;\n+    if (depgraph.TxCount() == 0) return ret;\n+    ret.reserve(depgraph.TxCount());\n+\n+    while (true) {\n+        // As long as we are not done, both linearizations must have chunks left.\n+        Assume(chunking1.NumChunksLeft() > 0);\n+        Assume(chunking2.NumChunksLeft() > 0);\n+        // Find the set to output by taking the best remaining chunk, and then intersecting it with\n+        // prefixes of remaining chunks of the other linearization.\n+        SetInfo<SetType> best;\n+        const auto& lin1_firstchunk = chunking1.GetChunk(0);\n+        const auto& lin2_firstchunk = chunking2.GetChunk(0);\n+        if (lin2_firstchunk.feerate >> lin1_firstchunk.feerate) {\n+            best = chunking1.Intersect(lin2_firstchunk);\n+        } else {\n+            best = chunking2.Intersect(lin1_firstchunk);\n+        }\n+        // Append the result to the output and mark it as done.\n+        depgraph.AppendTopo(ret, best.transactions);\n+        chunking1.MarkDone(best.transactions);\n+        if (chunking1.NumChunksLeft() == 0) break;",
      "path": "src/cluster_linearize.h",
      "position": 399,
      "original_position": 38,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "c17480e1447d9650f71a4749b2d92374278e7f63",
      "in_reply_to_id": 1697144521,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Exactly.",
      "created_at": "2024-07-30T22:03:44Z",
      "updated_at": "2024-07-30T22:03:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697654309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697654309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1042,
      "original_line": 1042,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659039",
      "pull_request_review_id": 2208797841,
      "id": 1697659039,
      "node_id": "PRRC_kwDOABII585lMDif",
      "diff_hunk": "@@ -962,6 +962,47 @@ void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> lineari\n     }\n }\n \n+/** Merge two linearizations for the same cluster into one that is as good as both.\n+ *\n+ * Complexity: O(N^2) where N=depgraph.TxCount(); O(N) if both inputs are identical.\n+ */\n+template<typename SetType>\n+std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin1, Span<const ClusterIndex> lin2)\n+{\n+    Assume(lin1.size() == depgraph.TxCount());\n+    Assume(lin2.size() == depgraph.TxCount());\n+\n+    /** Chunkings of what remains of both input linearizations. */\n+    LinearizationChunking chunking1(depgraph, lin1), chunking2(depgraph, lin2);\n+    /** Output linearization. */\n+    std::vector<ClusterIndex> ret;\n+    if (depgraph.TxCount() == 0) return ret;\n+    ret.reserve(depgraph.TxCount());\n+\n+    while (true) {\n+        // As long as we are not done, both linearizations must have chunks left.\n+        Assume(chunking1.NumChunksLeft() > 0);\n+        Assume(chunking2.NumChunksLeft() > 0);\n+        // Find the set to output by taking the best remaining chunk, and then intersecting it with\n+        // prefixes of remaining chunks of the other linearization.\n+        SetInfo<SetType> best;\n+        const auto& lin1_firstchunk = chunking1.GetChunk(0);\n+        const auto& lin2_firstchunk = chunking2.GetChunk(0);\n+        if (lin2_firstchunk.feerate >> lin1_firstchunk.feerate) {\n+            best = chunking1.Intersect(lin2_firstchunk);",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 31,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "c17480e1447d9650f71a4749b2d92374278e7f63",
      "in_reply_to_id": 1697135017,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a commit that renames it.",
      "created_at": "2024-07-30T22:10:30Z",
      "updated_at": "2024-07-30T22:10:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697659039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 992,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659247",
      "pull_request_review_id": 2208798114,
      "id": 1697659247,
      "node_id": "PRRC_kwDOABII585lMDlv",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 24,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697069771,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, fixed (here and below).",
      "created_at": "2024-07-30T22:10:44Z",
      "updated_at": "2024-07-30T22:10:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697659247",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659247"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659525",
      "pull_request_review_id": 2208798473,
      "id": 1697659525,
      "node_id": "PRRC_kwDOABII585lMDqF",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 153,
      "original_position": 31,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697077786,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added.",
      "created_at": "2024-07-30T22:11:07Z",
      "updated_at": "2024-07-30T22:11:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697659525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 804,
      "original_line": 804,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659658",
      "pull_request_review_id": 2208798669,
      "id": 1697659658,
      "node_id": "PRRC_kwDOABII585lMDsK",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697084073,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, fixed.",
      "created_at": "2024-07-30T22:11:17Z",
      "updated_at": "2024-07-30T22:11:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697659658",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659791",
      "pull_request_review_id": 2208798925,
      "id": 1697659791,
      "node_id": "PRRC_kwDOABII585lMDuP",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 220,
      "original_position": 98,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697081214,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-07-30T22:11:26Z",
      "updated_at": "2024-07-30T22:11:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697659791",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697659791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 871,
      "original_line": 871,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697661024",
      "pull_request_review_id": 2208800471,
      "id": 1697661024,
      "node_id": "PRRC_kwDOABII585lMEBg",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // Try to find an even better linearization; the result must be identical as post_linearization\n+    // ought to be optimal already with a tree-structured graph.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, new_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 241,
      "original_position": 110,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697082277,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No, it means that a particular approach for RBF will never worsen single-transaction leaf replacements that do not change the size of a transaction. I've added a comment to clarify.",
      "created_at": "2024-07-30T22:12:53Z",
      "updated_at": "2024-07-30T22:12:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697661024",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697661024"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 892,
      "original_line": 892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697664341",
      "pull_request_review_id": 2208805397,
      "id": 1697664341,
      "node_id": "PRRC_kwDOABII585lME1V",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // Try to find an even better linearization; the result must be identical as post_linearization\n+    // ought to be optimal already with a tree-structured graph.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, new_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 241,
      "original_position": 110,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697082277,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That was my initial thought but the size isn't changing so I'm unsure how it would map to an RBF?",
      "created_at": "2024-07-30T22:16:46Z",
      "updated_at": "2024-07-30T22:16:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697664341",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697664341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 892,
      "original_line": 892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697666103",
      "pull_request_review_id": 2208808034,
      "id": 1697666103,
      "node_id": "PRRC_kwDOABII585lMFQ3",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // Try to find an even better linearization; the result must be identical as post_linearization\n+    // ought to be optimal already with a tree-structured graph.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, new_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 241,
      "original_position": 110,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697082277,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"laboratory conditions\" I guess. It's just a nice property that holds; even if the conditions for it don't exactly hold often in reality, it probably means they're not far off. I'll look into whether I can generalize it a bit to support changing size.",
      "created_at": "2024-07-30T22:19:22Z",
      "updated_at": "2024-07-30T22:19:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1697666103",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1697666103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 892,
      "original_line": 892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698510482",
      "pull_request_review_id": 2210171875,
      "id": 1698510482,
      "node_id": "PRRC_kwDOABII585lPTaS",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While there is a group P in L immediately preceding C, which has lower feerate than C:\n+    //     - If C depends on P:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // appending is kept, but instead the meaning of parent/child and high/low fee are swapped,\n+    // and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // Fields that are only used for transactions that are the last one in a group:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 65,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697063661,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have tried to make the comments here a bit clearer.",
      "created_at": "2024-07-31T13:27:13Z",
      "updated_at": "2024-07-31T13:27:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698510482",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698510482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 834,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698566537",
      "pull_request_review_id": 2208370543,
      "id": 1698566537,
      "node_id": "PRRC_kwDOABII585lPhGJ",
      "diff_hunk": "@@ -782,6 +784,192 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.",
      "path": "src/cluster_linearize.h",
      "position": 199,
      "original_position": 42,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think in your update to this comment, you dropped the condition that C depends on P.  (But thanks for redrafting -- this is easier for me to read.)",
      "created_at": "2024-07-31T14:01:26Z",
      "updated_at": "2024-07-31T16:21:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698566537",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698566537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 842,
      "original_line": 842,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698681760",
      "pull_request_review_id": 2208370543,
      "id": 1698681760,
      "node_id": "PRRC_kwDOABII585lP9Og",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 204,
      "original_position": 90,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just to test my understanding: at this point, the graph we've constructed may not be connected, right?",
      "created_at": "2024-07-31T15:06:55Z",
      "updated_at": "2024-07-31T16:21:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698681760",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698681760"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 855,
      "original_line": 855,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698689296",
      "pull_request_review_id": 2208370543,
      "id": 1698689296,
      "node_id": "PRRC_kwDOABII585lP_EQ",
      "diff_hunk": "@@ -766,3 +766,145 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto old_chunking = ChunkLinearization(depgraph, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking chunking(depgraph, post_linearization);\n+    while (chunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(chunking.GetChunk(0).transactions));\n+        chunking.MarkDone(chunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Compare diagrams.\n+    auto old_chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto new_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);\n+\n+    // Try to find an even better linearization; the result must be identical as post_linearization\n+    // ought to be optimal already with a tree-structured graph.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, new_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 241,
      "original_position": 110,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697082277,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To add on to that -- at one point in an earlier draft of #28676, we were seeing examples of RBFs where a single transaction was being replaced with one that had identical size, identical parents, but higher fee, yet due to quirks in how linearization worked the replacement was being rejected because the diagram wasn't improving.\r\n\r\nWe've since generalized this concern around accidentally discovering a better linearization for a cluster while processing a potential replacement, and I think we will be addressing this in a more robust way, but it's nice that PostLinearization solves the specific problem we observed in the wild.",
      "created_at": "2024-07-31T15:11:54Z",
      "updated_at": "2024-07-31T16:21:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698689296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698689296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 892,
      "original_line": 892,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698691557",
      "pull_request_review_id": 2208370543,
      "id": 1698691557,
      "node_id": "PRRC_kwDOABII585lP_nl",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a postlinearized version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+\n+    // Compare diagrams.\n+    auto chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Verify that post-linearizing again does not change the diagram. The result must be identical\n+    // as post_linearization ought to be optimal already with a tree-structured graph.\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph_tree, post_post_linearization);\n+    auto cmp_post = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp_post == 0);\n+\n+    // Try to find an even better linearization directly. This must not change the diagram for the\n+    // same reason.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, post_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially\n+    // increasing its fee, and then post-linearizing, results in something as good as the\n+    // original. This guarantees that in an RBF that replaces a transaction with one of the same\n+    // size but higher fee, applying the \"remove conflicts, append new transaction, postlinearize\"\n+    // process to an optimalized linearization will retain optimality.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 131,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "optimalized --> optimal",
      "created_at": "2024-07-31T15:13:26Z",
      "updated_at": "2024-07-31T16:21:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698691557",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698691557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 896,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698805660",
      "pull_request_review_id": 2210653746,
      "id": 1698805660,
      "node_id": "PRRC_kwDOABII585lQbec",
      "diff_hunk": "@@ -171,6 +173,50 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"todo\" of this graph.\n+     *\n+     * Specifically, this finds the connected component which contains the first transaction of\n+     * todo (if any).\n+     *\n+     * Two transactions are considered connected if there is a path from one to the other inside\n+     * todo, where each is an ancestor or descendant of the next one in the entire graph (not just\n+     * within todo). Thus, if if todo contains a transaction and a grandparent, but misses the",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 20,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * within todo). Thus, if todo contains a transaction and a grandparent, but misses the\r\n```",
      "created_at": "2024-07-31T16:37:00Z",
      "updated_at": "2024-07-31T20:37:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698805660",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698805660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698811254",
      "pull_request_review_id": 2210653746,
      "id": 1698811254,
      "node_id": "PRRC_kwDOABII585lQc12",
      "diff_hunk": "@@ -687,3 +766,192 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 155,
      "original_position": 155,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sounds like a tasty cantonese restaurant",
      "created_at": "2024-07-31T16:41:37Z",
      "updated_at": "2024-07-31T20:37:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698811254",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698811254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 806,
      "original_line": 806,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698823693",
      "pull_request_review_id": 2210653746,
      "id": 1698823693,
      "node_id": "PRRC_kwDOABII585lQf4N",
      "diff_hunk": "@@ -171,6 +173,50 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"todo\" of this graph.\n+     *\n+     * Specifically, this finds the connected component which contains the first transaction of\n+     * todo (if any).\n+     *\n+     * Two transactions are considered connected if there is a path from one to the other inside",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 18,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n     * Two transactions are considered connected if there is a path from one to the other and both are inside\r\n```\r\n?\r\n\r\nin general this description and rewrite was very helpful",
      "created_at": "2024-07-31T16:51:29Z",
      "updated_at": "2024-07-31T20:37:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698823693",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698823693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698864505",
      "pull_request_review_id": 2210653746,
      "id": 1698864505,
      "node_id": "PRRC_kwDOABII585lQp15",
      "diff_hunk": "@@ -738,6 +804,233 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // both passes append groups, but during even passes the meanings of parent/child, and of\n+    // high/low feerate are reversed, and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 218,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        // The fields below are only used for transactions that are the last one in a group, also known as a tail transaction:\r\n```",
      "created_at": "2024-07-31T17:27:47Z",
      "updated_at": "2024-07-31T20:37:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1698864505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1698864505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699055206",
      "pull_request_review_id": 2210653746,
      "id": 1699055206,
      "node_id": "PRRC_kwDOABII585lRYZm",
      "diff_hunk": "@@ -738,6 +804,233 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // both passes append groups, but during even passes the meanings of parent/child, and of\n+    // high/low feerate are reversed, and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group:\n+\n+        /** Index of the first transaction in this group, possibly itself. */\n+        ClusterIndex first_tx;\n+        /** Index of the last transaction in the previous group. The first group (the sentinel)\n+         *  points back to the last group here, making it a singly-linked circular list. */\n+        ClusterIndex prev_group;\n+        /** All transactions in the group. Empty for the sentinel. */\n+        SetType group;\n+        /** All dependencies of the group (descendants in even passes; ancestors in odd ones). */\n+        SetType deps;\n+        /** The combined fee/size of transactions in the group. Fee is negated in even passes. */\n+        FeeFrac feerate;\n+    };\n+\n+    // As an example, consider the state corresponding to the linearization [1,0,3,2], with\n+    // groups [1,0,3] and [2], in an odd pass. The linked lists would be:\n+    //\n+    //                                        +-----+\n+    //                                 0<-P-- | 0 S | ---\\     Legend:\n+    //                                        +-----+    |\n+    //                                           ^       |     - digit in box: entries index\n+    //             /--------------F---------+    G       |       (note: one more than tx value)\n+    //             v                         \\   |       |     - S: sentinel group\n+    //          +-----+        +-----+        +-----+    |          (empty feerate)\n+    //   0<-P-- | 2   | <--P-- | 1   | <--P-- | 4 T |    |     - T: tail transaction, contains\n+    //          +-----+        +-----+        +-----+    |          fields beyond prev_tv.\n+    //                                           ^       |     - P: prev_tx reference\n+    //                                           G       G     - F: first_tx reference\n+    //                                           |       |     - G: prev_group reference\n+    //                                        +-----+    |\n+    //                                 0<-P-- | 3 T | <--/\n+    //                                        +-----+\n+    //                                         ^   |\n+    //                                         \\-F-/\n+    //\n+    // During an even pass, the diagram above would correspond to linearization [2,3,0,1], with\n+    // groups [2] and [3,0,1].\n+\n+    std::vector<TxEntry> entries(linearization.size() + 1);\n+\n+    // Perform two passes over the linearization.\n+    for (int pass = 0; pass < 2; ++pass) {\n+        int rev = !(pass & 1);\n+        // Construct a sentinel group, identifying the start of the list.\n+        entries[0].prev_group = 0;\n+        Assume(entries[0].feerate.IsEmpty());\n+\n+        // Iterate over all elements in the existing linearization.\n+        for (ClusterIndex i = 0; i < linearization.size(); ++i) {\n+            // Even passes are from back to front; odd passes from front to back.\n+            ClusterIndex idx = linearization[rev ? linearization.size() - 1 - i : i];\n+            // Construct a new group containing just idx. In even passes, the meaning of\n+            // parent/child and high/low feerate are swapped.\n+            ClusterIndex cur_group = idx + 1;\n+            entries[cur_group].group = SetType::Singleton(idx);\n+            entries[cur_group].deps = rev ? depgraph.Descendants(idx): depgraph.Ancestors(idx);\n+            entries[cur_group].feerate = depgraph.FeeRate(idx);\n+            if (rev) entries[cur_group].feerate.fee = -entries[cur_group].feerate.fee;\n+            entries[cur_group].prev_tx = 0; // No previous transaction in group.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 277,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "except for here, I think all uses of 0 are sentinel references, could add a constant to denote that meaning?",
      "created_at": "2024-07-31T20:15:11Z",
      "updated_at": "2024-07-31T20:37:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1699055206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699055206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 920,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699058909",
      "pull_request_review_id": 2210653746,
      "id": 1699058909,
      "node_id": "PRRC_kwDOABII585lRZTd",
      "diff_hunk": "@@ -738,6 +804,233 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // both passes append groups, but during even passes the meanings of parent/child, and of\n+    // high/low feerate are reversed, and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group:\n+\n+        /** Index of the first transaction in this group, possibly itself. */\n+        ClusterIndex first_tx;\n+        /** Index of the last transaction in the previous group. The first group (the sentinel)\n+         *  points back to the last group here, making it a singly-linked circular list. */\n+        ClusterIndex prev_group;\n+        /** All transactions in the group. Empty for the sentinel. */\n+        SetType group;\n+        /** All dependencies of the group (descendants in even passes; ancestors in odd ones). */\n+        SetType deps;\n+        /** The combined fee/size of transactions in the group. Fee is negated in even passes. */\n+        FeeFrac feerate;\n+    };\n+\n+    // As an example, consider the state corresponding to the linearization [1,0,3,2], with\n+    // groups [1,0,3] and [2], in an odd pass. The linked lists would be:\n+    //\n+    //                                        +-----+\n+    //                                 0<-P-- | 0 S | ---\\     Legend:\n+    //                                        +-----+    |\n+    //                                           ^       |     - digit in box: entries index\n+    //             /--------------F---------+    G       |       (note: one more than tx value)\n+    //             v                         \\   |       |     - S: sentinel group\n+    //          +-----+        +-----+        +-----+    |          (empty feerate)\n+    //   0<-P-- | 2   | <--P-- | 1   | <--P-- | 4 T |    |     - T: tail transaction, contains\n+    //          +-----+        +-----+        +-----+    |          fields beyond prev_tv.\n+    //                                           ^       |     - P: prev_tx reference\n+    //                                           G       G     - F: first_tx reference\n+    //                                           |       |     - G: prev_group reference\n+    //                                        +-----+    |\n+    //                                 0<-P-- | 3 T | <--/\n+    //                                        +-----+\n+    //                                         ^   |\n+    //                                         \\-F-/\n+    //\n+    // During an even pass, the diagram above would correspond to linearization [2,3,0,1], with\n+    // groups [2] and [3,0,1].\n+\n+    std::vector<TxEntry> entries(linearization.size() + 1);\n+\n+    // Perform two passes over the linearization.\n+    for (int pass = 0; pass < 2; ++pass) {\n+        int rev = !(pass & 1);\n+        // Construct a sentinel group, identifying the start of the list.\n+        entries[0].prev_group = 0;\n+        Assume(entries[0].feerate.IsEmpty());\n+\n+        // Iterate over all elements in the existing linearization.\n+        for (ClusterIndex i = 0; i < linearization.size(); ++i) {\n+            // Even passes are from back to front; odd passes from front to back.\n+            ClusterIndex idx = linearization[rev ? linearization.size() - 1 - i : i];\n+            // Construct a new group containing just idx. In even passes, the meaning of\n+            // parent/child and high/low feerate are swapped.\n+            ClusterIndex cur_group = idx + 1;\n+            entries[cur_group].group = SetType::Singleton(idx);\n+            entries[cur_group].deps = rev ? depgraph.Descendants(idx): depgraph.Ancestors(idx);\n+            entries[cur_group].feerate = depgraph.FeeRate(idx);\n+            if (rev) entries[cur_group].feerate.fee = -entries[cur_group].feerate.fee;\n+            entries[cur_group].prev_tx = 0; // No previous transaction in group.\n+            entries[cur_group].first_tx = cur_group; // Transaction itself is first of group.\n+            // Insert the new group at the back of the groups linked list.\n+            entries[cur_group].prev_group = entries[0].prev_group;\n+            entries[0].prev_group = cur_group;\n+\n+            // Start merge/swap cycle.\n+            ClusterIndex next_group = 0; // We inserted at the end, so next group is sentinel.\n+            ClusterIndex prev_group = entries[cur_group].prev_group;\n+            // Continue as long as the current group has higher feerate than the previous one.\n+            while (entries[cur_group].feerate >> entries[prev_group].feerate) {\n+                // prev_group/cur_group/next_group refer to (the last transactions of) 3\n+                // consecutive entries in groups list.\n+                Assume(cur_group == entries[next_group].prev_group);\n+                Assume(prev_group == entries[cur_group].prev_group);\n+                // The sentinel has empty feerate, which is neither higher or lower than other\n+                // feerates. Thus, the while loop we are in here guarantees that cur_group and\n+                // prev_group are not the sentinel.\n+                Assume(cur_group != 0);\n+                Assume(prev_group != 0);\n+                if (entries[cur_group].deps.Overlaps(entries[prev_group].group)) {\n+                    // There is a dependency between cur_group and prev_group; merge prev_group\n+                    // into cur_group.\n+                    entries[cur_group].group |= entries[prev_group].group;",
      "path": "src/cluster_linearize.h",
      "position": 315,
      "original_position": 300,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could note that after these lines, `entries[prev_group]`'s group + deps + feerate fields are still set but no longer used\r\n\r\n",
      "created_at": "2024-07-31T20:18:43Z",
      "updated_at": "2024-07-31T20:37:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1699058909",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699058909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 958,
      "original_line": 958,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699072130",
      "pull_request_review_id": 2210653746,
      "id": 1699072130,
      "node_id": "PRRC_kwDOABII585lRciC",
      "diff_hunk": "@@ -687,3 +766,192 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a postlinearized version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+\n+    // Compare diagrams.\n+    auto chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Verify that post-linearizing again does not change the diagram. The result must be identical\n+    // as post_linearization ought to be optimal already with a tree-structured graph.\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph_tree, post_post_linearization);\n+    auto cmp_post = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp_post == 0);\n+\n+    // Try to find an even better linearization directly. This must not change the diagram for the\n+    // same reason.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, post_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially\n+    // increasing its fee, and then post-linearizing, results in something as good as the\n+    // original. This guarantees that in an RBF that replaces a transaction with one of the same\n+    // size but higher fee, applying the \"remove conflicts, append new transaction, postlinearize\"\n+    // process to an optimalized linearization will retain optimality.\n+\n+    // Construct an arbitrary graph and a fee from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    int32_t fee_inc{0};\n+    try {\n+        uint64_t fee_inc_code;\n+        reader >> Using<DepGraphFormatter>(depgraph) >> VARINT(fee_inc_code);\n+        fee_inc = fee_inc_code & 0x3ffff;\n+    } catch (const std::ios_base::failure&) {}\n+    if (depgraph.TxCount() == 0) return;\n+\n+    // Retrieve two linearizations from the fuzz input.\n+    auto lin = ReadLinearization(depgraph, reader);\n+    auto lin_leaf = ReadLinearization(depgraph, reader);\n+\n+    // Construct a linearization identical to lin, but with the tail end of lin_leaf moved to the\n+    // back.\n+    std::vector<ClusterIndex> lin_moved;\n+    for (auto i : lin) {\n+        if (i != lin_leaf.back()) lin_moved.push_back(i);\n+    }\n+    lin_moved.push_back(lin_leaf.back());\n+\n+    // Postlinearize lin_moved.\n+    PostLinearize(depgraph, lin_moved);\n+    SanityCheck(depgraph, lin_moved);\n+\n+    // Compare diagrams (applying the fee delta after computing the old one).\n+    auto old_chunking = ChunkLinearization(depgraph, lin);\n+    depgraph.FeeRate(lin_leaf.back()).fee += fee_inc;\n+    auto new_chunking = ChunkLinearization(depgraph, lin_moved);\n+    auto cmp = CompareChunks(new_chunking, old_chunking);\n+    assert(cmp >= 0);",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 279,
      "original_position": 279,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nice to have a non-tree example of things *strictly* improving, also interesting to see that improvements still happen even if no fees are added\r\nedit: hm, still not quite showing strict improvement since fees are after the fact; it's a different \"cluster\". Oh well.\r\n```suggestion\r\n    if (fee_inc > 0) {\r\n        // It's more fees; should be superior\r\n        assert(cmp > 0);\r\n    } else {\r\n        assert(cmp >= 0);\r\n    }\r\n```",
      "created_at": "2024-07-31T20:32:17Z",
      "updated_at": "2024-07-31T20:40:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1699072130",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699072130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 930,
      "original_line": 930,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699981247",
      "pull_request_review_id": 2212460568,
      "id": 1699981247,
      "node_id": "PRRC_kwDOABII585lU6e_",
      "diff_hunk": "@@ -970,6 +970,47 @@ void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> lineari\n     }\n }\n \n+/** Merge two linearizations for the same cluster into one that is as good as both.\n+ *\n+ * Complexity: O(N^2) where N=depgraph.TxCount(); O(N) if both inputs are identical.\n+ */\n+template<typename SetType>\n+std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin1, Span<const ClusterIndex> lin2)\n+{\n+    Assume(lin1.size() == depgraph.TxCount());\n+    Assume(lin2.size() == depgraph.TxCount());\n+\n+    /** Chunkings of what remains of both input linearizations. */\n+    LinearizationChunking chunking1(depgraph, lin1), chunking2(depgraph, lin2);\n+    /** Output linearization. */\n+    std::vector<ClusterIndex> ret;\n+    if (depgraph.TxCount() == 0) return ret;\n+    ret.reserve(depgraph.TxCount());\n+\n+    while (true) {\n+        // As long as we are not done, both linearizations must have chunks left.\n+        Assume(chunking1.NumChunksLeft() > 0);\n+        Assume(chunking2.NumChunksLeft() > 0);\n+        // Find the set to output by taking the best remaining chunk, and then intersecting it with\n+        // prefixes of remaining chunks of the other linearization.\n+        SetInfo<SetType> best;\n+        const auto& lin1_firstchunk = chunking1.GetChunk(0);\n+        const auto& lin2_firstchunk = chunking2.GetChunk(0);\n+        if (lin2_firstchunk.feerate >> lin1_firstchunk.feerate) {\n+            best = chunking1.IntersectPrefixes(lin2_firstchunk);\n+        } else {\n+            best = chunking2.IntersectPrefixes(lin1_firstchunk);\n+        }\n+        // Append the result to the output and mark it as done.\n+        depgraph.AppendTopo(ret, best.transactions);\n+        chunking1.MarkDone(best.transactions);\n+        if (chunking1.NumChunksLeft() == 0) break;\n+        chunking2.MarkDone(best.transactions);\n+    }\n+",
      "path": "src/cluster_linearize.h",
      "position": 402,
      "original_position": 41,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "17b29eae7cd71c2cc37ae413b3180eec77db3423",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "could do an `Assume(ret.size() == depgraph.TxCount());` before returning here, or in the fuzz test",
      "created_at": "2024-08-01T11:24:09Z",
      "updated_at": "2024-08-01T17:13:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1699981247",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1699981247"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1045,
      "original_line": 1045,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700503698",
      "pull_request_review_id": 2212460568,
      "id": 1700503698,
      "node_id": "PRRC_kwDOABII585lW6CS",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a postlinearized version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+\n+    // Compare diagrams.\n+    auto chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Verify that post-linearizing again does not change the diagram. The result must be identical\n+    // as post_linearization ought to be optimal already with a tree-structured graph.\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph_tree, post_post_linearization);\n+    auto cmp_post = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp_post == 0);\n+\n+    // Try to find an even better linearization directly. This must not change the diagram for the\n+    // same reason.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, post_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially\n+    // increasing its fee, and then post-linearizing, results in something as good as the\n+    // original. This guarantees that in an RBF that replaces a transaction with one of the same\n+    // size but higher fee, applying the \"remove conflicts, append new transaction, postlinearize\"\n+    // process to an optimalized linearization will retain optimality.\n+\n+    // Construct an arbitrary graph and a fee from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    int32_t fee_inc{0};\n+    try {\n+        uint64_t fee_inc_code;\n+        reader >> Using<DepGraphFormatter>(depgraph) >> VARINT(fee_inc_code);\n+        fee_inc = fee_inc_code & 0x3ffff;\n+    } catch (const std::ios_base::failure&) {}\n+    if (depgraph.TxCount() == 0) return;\n+\n+    // Retrieve two linearizations from the fuzz input.\n+    auto lin = ReadLinearization(depgraph, reader);\n+    auto lin_leaf = ReadLinearization(depgraph, reader);\n+\n+    // Construct a linearization identical to lin, but with the tail end of lin_leaf moved to the\n+    // back.\n+    std::vector<ClusterIndex> lin_moved;\n+    for (auto i : lin) {\n+        if (i != lin_leaf.back()) lin_moved.push_back(i);\n+    }\n+    lin_moved.push_back(lin_leaf.back());\n+\n+    // Postlinearize lin_moved.\n+    PostLinearize(depgraph, lin_moved);\n+    SanityCheck(depgraph, lin_moved);\n+\n+    // Compare diagrams (applying the fee delta after computing the old one).\n+    auto old_chunking = ChunkLinearization(depgraph, lin);\n+    depgraph.FeeRate(lin_leaf.back()).fee += fee_inc;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 276,
      "original_position": 162,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm a bit confused trying to understand the \"remove conflicts, append new tx to the end, postlinearize\" RBF idea. I kind of expected this fee increment to happen before `PostLinearize()` is called, if it's similar to appending the replacement with higher fees to the end.",
      "created_at": "2024-08-01T16:45:14Z",
      "updated_at": "2024-08-01T17:13:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700503698",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700503698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 927,
      "original_line": 927,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700608822",
      "pull_request_review_id": 2213539497,
      "id": 1700608822,
      "node_id": "PRRC_kwDOABII585lXTs2",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While there is a group P in L immediately preceding C, which has lower feerate than C:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 38,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1696993400,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This was rewritten.",
      "created_at": "2024-08-01T18:11:57Z",
      "updated_at": "2024-08-01T18:11:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700608822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700608822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 807,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700692538",
      "pull_request_review_id": 2213686285,
      "id": 1700692538,
      "node_id": "PRRC_kwDOABII585lXoI6",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 204,
      "original_position": 90,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": 1698681760,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Certainly, for two reasons:\r\n* `depgraph_gen` may not be connected to begin with (there is no `MakeConnected(depgraph_gen)`; perhaps there should be?)\r\n* Even if `depgraph_gen` is connected (imagine it being a trellis for example), removing all but the first parent, or all but the first child, may split it up.",
      "created_at": "2024-08-01T19:08:33Z",
      "updated_at": "2024-08-01T19:08:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700692538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700692538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 855,
      "original_line": 855,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700721033",
      "pull_request_review_id": 2213735029,
      "id": 1700721033,
      "node_id": "PRRC_kwDOABII585lXvGJ",
      "diff_hunk": "@@ -171,6 +173,50 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"todo\" of this graph.\n+     *\n+     * Specifically, this finds the connected component which contains the first transaction of\n+     * todo (if any).\n+     *\n+     * Two transactions are considered connected if there is a path from one to the other inside",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 18,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1698823693,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not just the two transactions, but all transactions in the path need to be in todo.",
      "created_at": "2024-08-01T19:33:03Z",
      "updated_at": "2024-08-01T19:33:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700721033",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700721033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700782980",
      "pull_request_review_id": 2213825444,
      "id": 1700782980,
      "node_id": "PRRC_kwDOABII585lX-OE",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a postlinearized version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+\n+    // Compare diagrams.\n+    auto chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Verify that post-linearizing again does not change the diagram. The result must be identical\n+    // as post_linearization ought to be optimal already with a tree-structured graph.\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph_tree, post_post_linearization);\n+    auto cmp_post = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp_post == 0);\n+\n+    // Try to find an even better linearization directly. This must not change the diagram for the\n+    // same reason.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, post_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially\n+    // increasing its fee, and then post-linearizing, results in something as good as the\n+    // original. This guarantees that in an RBF that replaces a transaction with one of the same\n+    // size but higher fee, applying the \"remove conflicts, append new transaction, postlinearize\"\n+    // process to an optimalized linearization will retain optimality.\n+\n+    // Construct an arbitrary graph and a fee from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    int32_t fee_inc{0};\n+    try {\n+        uint64_t fee_inc_code;\n+        reader >> Using<DepGraphFormatter>(depgraph) >> VARINT(fee_inc_code);\n+        fee_inc = fee_inc_code & 0x3ffff;\n+    } catch (const std::ios_base::failure&) {}\n+    if (depgraph.TxCount() == 0) return;\n+\n+    // Retrieve two linearizations from the fuzz input.\n+    auto lin = ReadLinearization(depgraph, reader);\n+    auto lin_leaf = ReadLinearization(depgraph, reader);\n+\n+    // Construct a linearization identical to lin, but with the tail end of lin_leaf moved to the\n+    // back.\n+    std::vector<ClusterIndex> lin_moved;\n+    for (auto i : lin) {\n+        if (i != lin_leaf.back()) lin_moved.push_back(i);\n+    }\n+    lin_moved.push_back(lin_leaf.back());\n+\n+    // Postlinearize lin_moved.\n+    PostLinearize(depgraph, lin_moved);\n+    SanityCheck(depgraph, lin_moved);\n+\n+    // Compare diagrams (applying the fee delta after computing the old one).\n+    auto old_chunking = ChunkLinearization(depgraph, lin);\n+    depgraph.FeeRate(lin_leaf.back()).fee += fee_inc;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 276,
      "original_position": 162,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": 1700503698,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So imagine your have an existing cluster *C* with an existing linearization *L*. It contains a leaf transaction *R* (which has no descendants) somewhere, but not at the very end of *L*.\r\n\r\nA new transaction *A* comes in which has the same size as *R*, same ancestors as *R*, and the same or higher fee as *R*.\r\n\r\nImagine that in such a scenario the RBF code starts by taking *L*, removing all conflicts (in this case just *R*) from it, and appending the new transaction *A* at the end, and runs PostLinearize(), before invoking LIMO and whatnot.\r\n\r\nThe test here guarantees that the result of that PostLinearize() will already be as good as the old linearization was, despite having \"forgotten\" where inside *L* *R* was placed. In other words, PostLinearize is - in this very limited scenario - able to \"restore\" the quality the linearization had.",
      "created_at": "2024-08-01T20:08:48Z",
      "updated_at": "2024-08-01T20:08:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700782980",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700782980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 927,
      "original_line": 927,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700789505",
      "pull_request_review_id": 2213837665,
      "id": 1700789505,
      "node_id": "PRRC_kwDOABII585lX_0B",
      "diff_hunk": "@@ -777,6 +779,189 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all",
      "path": "src/cluster_linearize.h",
      "position": 172,
      "original_position": 21,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "8eaca20d60bd3c921f7dda9c0430740b2775fc1f",
      "in_reply_to_id": 1697036508,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've explained this in more detail (in the comment below, inside the function body).",
      "created_at": "2024-08-01T20:13:42Z",
      "updated_at": "2024-08-01T20:13:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700789505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700789505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 815,
      "original_line": 815,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700789944",
      "pull_request_review_id": 2213838560,
      "id": 1700789944,
      "node_id": "PRRC_kwDOABII585lX_64",
      "diff_hunk": "@@ -782,6 +784,192 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.",
      "path": "src/cluster_linearize.h",
      "position": 199,
      "original_position": 42,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": 1698566537,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, fixed.",
      "created_at": "2024-08-01T20:14:09Z",
      "updated_at": "2024-08-01T20:14:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700789944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700789944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 842,
      "original_line": 842,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700790533",
      "pull_request_review_id": 2213839708,
      "id": 1700790533,
      "node_id": "PRRC_kwDOABII585lYAEF",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a postlinearized version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+\n+    // Compare diagrams.\n+    auto chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Verify that post-linearizing again does not change the diagram. The result must be identical\n+    // as post_linearization ought to be optimal already with a tree-structured graph.\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph_tree, post_post_linearization);\n+    auto cmp_post = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp_post == 0);\n+\n+    // Try to find an even better linearization directly. This must not change the diagram for the\n+    // same reason.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, post_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially\n+    // increasing its fee, and then post-linearizing, results in something as good as the\n+    // original. This guarantees that in an RBF that replaces a transaction with one of the same\n+    // size but higher fee, applying the \"remove conflicts, append new transaction, postlinearize\"\n+    // process to an optimalized linearization will retain optimality.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 131,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": 1698691557,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Rewritten (the claim wasn't just grammatically bad, it was also just wrong).",
      "created_at": "2024-08-01T20:14:44Z",
      "updated_at": "2024-08-01T20:14:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700790533",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700790533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 896,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700790650",
      "pull_request_review_id": 2213839959,
      "id": 1700790650,
      "node_id": "PRRC_kwDOABII585lYAF6",
      "diff_hunk": "@@ -171,6 +173,50 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"todo\" of this graph.\n+     *\n+     * Specifically, this finds the connected component which contains the first transaction of\n+     * todo (if any).\n+     *\n+     * Two transactions are considered connected if there is a path from one to the other inside\n+     * todo, where each is an ancestor or descendant of the next one in the entire graph (not just\n+     * within todo). Thus, if if todo contains a transaction and a grandparent, but misses the",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 20,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1698805660,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-08-01T20:14:52Z",
      "updated_at": "2024-08-01T20:14:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700790650",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700790650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700790916",
      "pull_request_review_id": 2213840497,
      "id": 1700790916,
      "node_id": "PRRC_kwDOABII585lYAKE",
      "diff_hunk": "@@ -171,6 +173,50 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"todo\" of this graph.\n+     *\n+     * Specifically, this finds the connected component which contains the first transaction of\n+     * todo (if any).\n+     *\n+     * Two transactions are considered connected if there is a path from one to the other inside",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 18,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1698823693,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I have rewritten this. Please have a look if it's better.",
      "created_at": "2024-08-01T20:15:07Z",
      "updated_at": "2024-08-01T20:15:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700790916",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700790916"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791035",
      "pull_request_review_id": 2213840778,
      "id": 1700791035,
      "node_id": "PRRC_kwDOABII585lYAL7",
      "diff_hunk": "@@ -738,6 +804,233 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // both passes append groups, but during even passes the meanings of parent/child, and of\n+    // high/low feerate are reversed, and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group:",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 218,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1698864505,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done-ish.",
      "created_at": "2024-08-01T20:15:15Z",
      "updated_at": "2024-08-01T20:15:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700791035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791549",
      "pull_request_review_id": 2213841907,
      "id": 1700791549,
      "node_id": "PRRC_kwDOABII585lYAT9",
      "diff_hunk": "@@ -738,6 +804,233 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // both passes append groups, but during even passes the meanings of parent/child, and of\n+    // high/low feerate are reversed, and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group:\n+\n+        /** Index of the first transaction in this group, possibly itself. */\n+        ClusterIndex first_tx;\n+        /** Index of the last transaction in the previous group. The first group (the sentinel)\n+         *  points back to the last group here, making it a singly-linked circular list. */\n+        ClusterIndex prev_group;\n+        /** All transactions in the group. Empty for the sentinel. */\n+        SetType group;\n+        /** All dependencies of the group (descendants in even passes; ancestors in odd ones). */\n+        SetType deps;\n+        /** The combined fee/size of transactions in the group. Fee is negated in even passes. */\n+        FeeFrac feerate;\n+    };\n+\n+    // As an example, consider the state corresponding to the linearization [1,0,3,2], with\n+    // groups [1,0,3] and [2], in an odd pass. The linked lists would be:\n+    //\n+    //                                        +-----+\n+    //                                 0<-P-- | 0 S | ---\\     Legend:\n+    //                                        +-----+    |\n+    //                                           ^       |     - digit in box: entries index\n+    //             /--------------F---------+    G       |       (note: one more than tx value)\n+    //             v                         \\   |       |     - S: sentinel group\n+    //          +-----+        +-----+        +-----+    |          (empty feerate)\n+    //   0<-P-- | 2   | <--P-- | 1   | <--P-- | 4 T |    |     - T: tail transaction, contains\n+    //          +-----+        +-----+        +-----+    |          fields beyond prev_tv.\n+    //                                           ^       |     - P: prev_tx reference\n+    //                                           G       G     - F: first_tx reference\n+    //                                           |       |     - G: prev_group reference\n+    //                                        +-----+    |\n+    //                                 0<-P-- | 3 T | <--/\n+    //                                        +-----+\n+    //                                         ^   |\n+    //                                         \\-F-/\n+    //\n+    // During an even pass, the diagram above would correspond to linearization [2,3,0,1], with\n+    // groups [2] and [3,0,1].\n+\n+    std::vector<TxEntry> entries(linearization.size() + 1);\n+\n+    // Perform two passes over the linearization.\n+    for (int pass = 0; pass < 2; ++pass) {\n+        int rev = !(pass & 1);\n+        // Construct a sentinel group, identifying the start of the list.\n+        entries[0].prev_group = 0;\n+        Assume(entries[0].feerate.IsEmpty());\n+\n+        // Iterate over all elements in the existing linearization.\n+        for (ClusterIndex i = 0; i < linearization.size(); ++i) {\n+            // Even passes are from back to front; odd passes from front to back.\n+            ClusterIndex idx = linearization[rev ? linearization.size() - 1 - i : i];\n+            // Construct a new group containing just idx. In even passes, the meaning of\n+            // parent/child and high/low feerate are swapped.\n+            ClusterIndex cur_group = idx + 1;\n+            entries[cur_group].group = SetType::Singleton(idx);\n+            entries[cur_group].deps = rev ? depgraph.Descendants(idx): depgraph.Ancestors(idx);\n+            entries[cur_group].feerate = depgraph.FeeRate(idx);\n+            if (rev) entries[cur_group].feerate.fee = -entries[cur_group].feerate.fee;\n+            entries[cur_group].prev_tx = 0; // No previous transaction in group.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 277,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1699055206,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done. I have introduced two constants `SENTINEL` and `NO_PREV_TX` (both with value 0) and used them instead of the literal 0s here.",
      "created_at": "2024-08-01T20:15:47Z",
      "updated_at": "2024-08-01T20:15:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700791549",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791549"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 920,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791702",
      "pull_request_review_id": 2213842285,
      "id": 1700791702,
      "node_id": "PRRC_kwDOABII585lYAWW",
      "diff_hunk": "@@ -738,6 +804,233 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   in optimally-linearized clusters will retain optimality through a \"drop conflicts, append new\n+ *   transactions, postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones from back to front,\n+    // the odd ones from front to back. Starting with an even (back to front) pass guarantees the\n+    // moved-leaf property listed above.\n+    //\n+    // During an odd pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even passes, i iterates from the back to the front of the existing linearization,\n+    // and new groups are prepended instead of appended to the list L. To enable more code reuse,\n+    // both passes append groups, but during even passes the meanings of parent/child, and of\n+    // high/low feerate are reversed, and the final concatenation is reversed on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; 0 if this is the first entry of\n+         *  a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group:\n+\n+        /** Index of the first transaction in this group, possibly itself. */\n+        ClusterIndex first_tx;\n+        /** Index of the last transaction in the previous group. The first group (the sentinel)\n+         *  points back to the last group here, making it a singly-linked circular list. */\n+        ClusterIndex prev_group;\n+        /** All transactions in the group. Empty for the sentinel. */\n+        SetType group;\n+        /** All dependencies of the group (descendants in even passes; ancestors in odd ones). */\n+        SetType deps;\n+        /** The combined fee/size of transactions in the group. Fee is negated in even passes. */\n+        FeeFrac feerate;\n+    };\n+\n+    // As an example, consider the state corresponding to the linearization [1,0,3,2], with\n+    // groups [1,0,3] and [2], in an odd pass. The linked lists would be:\n+    //\n+    //                                        +-----+\n+    //                                 0<-P-- | 0 S | ---\\     Legend:\n+    //                                        +-----+    |\n+    //                                           ^       |     - digit in box: entries index\n+    //             /--------------F---------+    G       |       (note: one more than tx value)\n+    //             v                         \\   |       |     - S: sentinel group\n+    //          +-----+        +-----+        +-----+    |          (empty feerate)\n+    //   0<-P-- | 2   | <--P-- | 1   | <--P-- | 4 T |    |     - T: tail transaction, contains\n+    //          +-----+        +-----+        +-----+    |          fields beyond prev_tv.\n+    //                                           ^       |     - P: prev_tx reference\n+    //                                           G       G     - F: first_tx reference\n+    //                                           |       |     - G: prev_group reference\n+    //                                        +-----+    |\n+    //                                 0<-P-- | 3 T | <--/\n+    //                                        +-----+\n+    //                                         ^   |\n+    //                                         \\-F-/\n+    //\n+    // During an even pass, the diagram above would correspond to linearization [2,3,0,1], with\n+    // groups [2] and [3,0,1].\n+\n+    std::vector<TxEntry> entries(linearization.size() + 1);\n+\n+    // Perform two passes over the linearization.\n+    for (int pass = 0; pass < 2; ++pass) {\n+        int rev = !(pass & 1);\n+        // Construct a sentinel group, identifying the start of the list.\n+        entries[0].prev_group = 0;\n+        Assume(entries[0].feerate.IsEmpty());\n+\n+        // Iterate over all elements in the existing linearization.\n+        for (ClusterIndex i = 0; i < linearization.size(); ++i) {\n+            // Even passes are from back to front; odd passes from front to back.\n+            ClusterIndex idx = linearization[rev ? linearization.size() - 1 - i : i];\n+            // Construct a new group containing just idx. In even passes, the meaning of\n+            // parent/child and high/low feerate are swapped.\n+            ClusterIndex cur_group = idx + 1;\n+            entries[cur_group].group = SetType::Singleton(idx);\n+            entries[cur_group].deps = rev ? depgraph.Descendants(idx): depgraph.Ancestors(idx);\n+            entries[cur_group].feerate = depgraph.FeeRate(idx);\n+            if (rev) entries[cur_group].feerate.fee = -entries[cur_group].feerate.fee;\n+            entries[cur_group].prev_tx = 0; // No previous transaction in group.\n+            entries[cur_group].first_tx = cur_group; // Transaction itself is first of group.\n+            // Insert the new group at the back of the groups linked list.\n+            entries[cur_group].prev_group = entries[0].prev_group;\n+            entries[0].prev_group = cur_group;\n+\n+            // Start merge/swap cycle.\n+            ClusterIndex next_group = 0; // We inserted at the end, so next group is sentinel.\n+            ClusterIndex prev_group = entries[cur_group].prev_group;\n+            // Continue as long as the current group has higher feerate than the previous one.\n+            while (entries[cur_group].feerate >> entries[prev_group].feerate) {\n+                // prev_group/cur_group/next_group refer to (the last transactions of) 3\n+                // consecutive entries in groups list.\n+                Assume(cur_group == entries[next_group].prev_group);\n+                Assume(prev_group == entries[cur_group].prev_group);\n+                // The sentinel has empty feerate, which is neither higher or lower than other\n+                // feerates. Thus, the while loop we are in here guarantees that cur_group and\n+                // prev_group are not the sentinel.\n+                Assume(cur_group != 0);\n+                Assume(prev_group != 0);\n+                if (entries[cur_group].deps.Overlaps(entries[prev_group].group)) {\n+                    // There is a dependency between cur_group and prev_group; merge prev_group\n+                    // into cur_group.\n+                    entries[cur_group].group |= entries[prev_group].group;",
      "path": "src/cluster_linearize.h",
      "position": 315,
      "original_position": 300,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1699058909,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, added a comment.",
      "created_at": "2024-08-01T20:15:57Z",
      "updated_at": "2024-08-01T20:15:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700791702",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791702"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 958,
      "original_line": 958,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791810",
      "pull_request_review_id": 2213842544,
      "id": 1700791810,
      "node_id": "PRRC_kwDOABII585lYAYC",
      "diff_hunk": "@@ -970,6 +970,47 @@ void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> lineari\n     }\n }\n \n+/** Merge two linearizations for the same cluster into one that is as good as both.\n+ *\n+ * Complexity: O(N^2) where N=depgraph.TxCount(); O(N) if both inputs are identical.\n+ */\n+template<typename SetType>\n+std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph, Span<const ClusterIndex> lin1, Span<const ClusterIndex> lin2)\n+{\n+    Assume(lin1.size() == depgraph.TxCount());\n+    Assume(lin2.size() == depgraph.TxCount());\n+\n+    /** Chunkings of what remains of both input linearizations. */\n+    LinearizationChunking chunking1(depgraph, lin1), chunking2(depgraph, lin2);\n+    /** Output linearization. */\n+    std::vector<ClusterIndex> ret;\n+    if (depgraph.TxCount() == 0) return ret;\n+    ret.reserve(depgraph.TxCount());\n+\n+    while (true) {\n+        // As long as we are not done, both linearizations must have chunks left.\n+        Assume(chunking1.NumChunksLeft() > 0);\n+        Assume(chunking2.NumChunksLeft() > 0);\n+        // Find the set to output by taking the best remaining chunk, and then intersecting it with\n+        // prefixes of remaining chunks of the other linearization.\n+        SetInfo<SetType> best;\n+        const auto& lin1_firstchunk = chunking1.GetChunk(0);\n+        const auto& lin2_firstchunk = chunking2.GetChunk(0);\n+        if (lin2_firstchunk.feerate >> lin1_firstchunk.feerate) {\n+            best = chunking1.IntersectPrefixes(lin2_firstchunk);\n+        } else {\n+            best = chunking2.IntersectPrefixes(lin1_firstchunk);\n+        }\n+        // Append the result to the output and mark it as done.\n+        depgraph.AppendTopo(ret, best.transactions);\n+        chunking1.MarkDone(best.transactions);\n+        if (chunking1.NumChunksLeft() == 0) break;\n+        chunking2.MarkDone(best.transactions);\n+    }\n+",
      "path": "src/cluster_linearize.h",
      "position": 402,
      "original_position": 41,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "17b29eae7cd71c2cc37ae413b3180eec77db3423",
      "in_reply_to_id": 1699981247,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2024-08-01T20:16:05Z",
      "updated_at": "2024-08-01T20:16:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700791810",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700791810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1045,
      "original_line": 1045,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700799126",
      "pull_request_review_id": 2213854542,
      "id": 1700799126,
      "node_id": "PRRC_kwDOABII585lYCKW",
      "diff_hunk": "@@ -171,6 +173,50 @@ class DepGraph\n         return ret;\n     }\n \n+    /** Find some connected component within the subset \"todo\" of this graph.\n+     *\n+     * Specifically, this finds the connected component which contains the first transaction of\n+     * todo (if any).\n+     *\n+     * Two transactions are considered connected if there is a path from one to the other inside",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 18,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "157464f3a9444ac9b2337227a2fee2f3adbd0918",
      "in_reply_to_id": 1698823693,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "definitely clearer on what the \"path\" is :+1:  (and matches my understanding of the code now)",
      "created_at": "2024-08-01T20:22:51Z",
      "updated_at": "2024-08-01T20:28:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1700799126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1700799126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701660707",
      "pull_request_review_id": 2215276451,
      "id": 1701660707,
      "node_id": "PRRC_kwDOABII585lbUgj",
      "diff_hunk": "@@ -738,6 +804,249 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   will not worsen linearizations through a \"drop conflicts, append new transactions,\n+ *   postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones operate from back to\n+    // front, the odd ones from front to back. Each results in an equal-or-better linearization\n+    // than the one started from.\n+    // - One pass in either direction guarantees that the resulting chunks are connected.\n+    // - Each direction corresponds to one shape of tree being linearized optimally (forward passes\n+    //   guarantee this for graphs where each transaction has at most one child; backward passes\n+    //   guarantee this for graphs where each transaction has at most one parent).\n+    // - Starting with a backward pass guarantees the moved-tree property.\n+    //\n+    // During an odd (forward) pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //     - If C depends on P:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even (backward) passes, i iterates from the back to the front of the existing\n+    // linearization, and new groups are prepended instead of appended to the list L. To enable\n+    // more code reuse, both passes append groups, but during even passes the meanings of\n+    // parent/child, and of high/low feerate are reversed, and the final concatenation is reversed\n+    // on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Index of the sentinel in the entries array below. */\n+    static constexpr ClusterIndex SENTINEL{0};\n+    /** Indicator that a group has no previous transaction. */\n+    static constexpr ClusterIndex NO_PREV_TX{0};\n+\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; NO_PREV_TX if this is the first\n+         *  entry of a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group\n+        // (referred to as tail transactions below).\n+\n+        /** Index of the first transaction in this group, possibly itself. */\n+        ClusterIndex first_tx;\n+        /** Index of the last transaction in the previous group. The first group (the sentinel)\n+         *  points back to the last group here, making it a singly-linked circular list. */\n+        ClusterIndex prev_group;\n+        /** All transactions in the group. Empty for the sentinel. */\n+        SetType group;\n+        /** All dependencies of the group (descendants in even passes; ancestors in odd ones). */\n+        SetType deps;\n+        /** The combined fee/size of transactions in the group. Fee is negated in even passes. */\n+        FeeFrac feerate;\n+    };\n+\n+    // As an example, consider the state corresponding to the linearization [1,0,3,2], with\n+    // groups [1,0,3] and [2], in an odd pass. The linked lists would be:\n+    //\n+    //                                        +-----+\n+    //                                 0<-P-- | 0 S | ---\\     Legend:\n+    //                                        +-----+    |\n+    //                                           ^       |     - digit in box: entries index\n+    //             /--------------F---------+    G       |       (note: one more than tx value)\n+    //             v                         \\   |       |     - S: sentinel group\n+    //          +-----+        +-----+        +-----+    |          (empty feerate)\n+    //   0<-P-- | 2   | <--P-- | 1   | <--P-- | 4 T |    |     - T: tail transaction, contains\n+    //          +-----+        +-----+        +-----+    |          fields beyond prev_tv.\n+    //                                           ^       |     - P: prev_tx reference\n+    //                                           G       G     - F: first_tx reference\n+    //                                           |       |     - G: prev_group reference\n+    //                                        +-----+    |\n+    //                                 0<-P-- | 3 T | <--/\n+    //                                        +-----+\n+    //                                         ^   |\n+    //                                         \\-F-/\n+    //\n+    // During an even pass, the diagram above would correspond to linearization [2,3,0,1], with\n+    // groups [2] and [3,0,1].\n+\n+    std::vector<TxEntry> entries(linearization.size() + 1);",
      "path": "src/cluster_linearize.h",
      "position": 271,
      "original_position": 271,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are we persisting `entries` between passes just so we don't need to reallocate this vector? I don't see that we need to keep any of the information from a previous pass. To check, added a `entries.clear()` which didn't seem to break anything for me.",
      "created_at": "2024-08-02T10:27:28Z",
      "updated_at": "2024-08-02T11:14:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1701660707",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701660707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 914,
      "original_line": 914,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701672279",
      "pull_request_review_id": 2215276451,
      "id": 1701672279,
      "node_id": "PRRC_kwDOABII585lbXVX",
      "diff_hunk": "@@ -738,6 +804,249 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all",
      "path": "src/cluster_linearize.h",
      "position": 172,
      "original_position": 172,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is a subset of the \"there exists a maximum of 1 path from any node to another\" definition of a tree, right? This definition seems to be like a... botanical tree?",
      "created_at": "2024-08-02T10:37:07Z",
      "updated_at": "2024-08-02T11:14:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1701672279",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701672279"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 815,
      "original_line": 815,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701685263",
      "pull_request_review_id": 2215276451,
      "id": 1701685263,
      "node_id": "PRRC_kwDOABII585lbagP",
      "diff_hunk": "@@ -766,3 +766,166 @@ FUZZ_TARGET(clusterlin_linearize)\n         }\n     }\n }\n+\n+FUZZ_TARGET(clusterlin_postlinearize)\n+{\n+    // Verify expected properties of PostLinearize() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph, reader);\n+    SanityCheck(depgraph, linearization);\n+\n+    // Produce a post-processed version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph, post_linearization);\n+    SanityCheck(depgraph, post_linearization);\n+\n+    // Compare diagrams: post-linearization cannot worsen anywhere.\n+    auto chunking = ChunkLinearization(depgraph, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Run again, things can keep improving (and never get worse)\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph, post_post_linearization);\n+    SanityCheck(depgraph, post_post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph, post_post_linearization);\n+    cmp = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp >= 0);\n+\n+    // The chunks that come out of postlinearizing are always connected.\n+    LinearizationChunking linchunking(depgraph, post_linearization);\n+    while (linchunking.NumChunksLeft()) {\n+        assert(depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+    }\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_tree)\n+{\n+    // Verify expected properties of PostLinearize() on linearizations of graphs that form either\n+    // an upright or reverse tree structure.\n+\n+    // Construct a direction, RNG seed, and an arbitrary graph from the fuzz input.\n+    SpanReader reader(buffer);\n+    uint64_t rng_seed{0};\n+    DepGraph<TestBitSet> depgraph_gen;\n+    uint8_t direction{0};\n+    try {\n+        reader >> direction >> rng_seed >> Using<DepGraphFormatter>(depgraph_gen);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Now construct a new graph, copying the nodes, but leaving only the first parent (even\n+    // direction) or the first child (odd direction).\n+    DepGraph<TestBitSet> depgraph_tree;\n+    for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+        depgraph_tree.AddTransaction(depgraph_gen.FeeRate(i));\n+    }\n+    if (direction & 1) {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto children = depgraph_gen.Descendants(i) - TestBitSet::Singleton(i);\n+            // Remove descendants that are children of other descendants.\n+            for (auto j : children) {\n+                if (!children[j]) continue;\n+                children -= depgraph_gen.Descendants(j);\n+                children.Set(j);\n+            }\n+            if (children.Any()) depgraph_tree.AddDependency(i, children.First());\n+         }\n+    } else {\n+        for (ClusterIndex i = 0; i < depgraph_gen.TxCount(); ++i) {\n+            auto parents = depgraph_gen.Ancestors(i) - TestBitSet::Singleton(i);\n+            // Remove ancestors that are parents of other ancestors.\n+            for (auto j : parents) {\n+                if (!parents[j]) continue;\n+                parents -= depgraph_gen.Ancestors(j);\n+                parents.Set(j);\n+            }\n+            if (parents.Any()) depgraph_tree.AddDependency(parents.First(), i);\n+        }\n+    }\n+\n+    // Retrieve a linearization from the fuzz input.\n+    std::vector<ClusterIndex> linearization;\n+    linearization = ReadLinearization(depgraph_tree, reader);\n+    SanityCheck(depgraph_tree, linearization);\n+\n+    // Produce a postlinearized version.\n+    auto post_linearization = linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+\n+    // Compare diagrams.\n+    auto chunking = ChunkLinearization(depgraph_tree, linearization);\n+    auto post_chunking = ChunkLinearization(depgraph_tree, post_linearization);\n+    auto cmp = CompareChunks(post_chunking, chunking);\n+    assert(cmp >= 0);\n+\n+    // Verify that post-linearizing again does not change the diagram. The result must be identical\n+    // as post_linearization ought to be optimal already with a tree-structured graph.\n+    auto post_post_linearization = post_linearization;\n+    PostLinearize(depgraph_tree, post_linearization);\n+    SanityCheck(depgraph_tree, post_linearization);\n+    auto post_post_chunking = ChunkLinearization(depgraph_tree, post_post_linearization);\n+    auto cmp_post = CompareChunks(post_post_chunking, post_chunking);\n+    assert(cmp_post == 0);\n+\n+    // Try to find an even better linearization directly. This must not change the diagram for the\n+    // same reason.\n+    auto [opt_linearization, _optimal] = Linearize(depgraph_tree, 100000, rng_seed, post_linearization);\n+    auto opt_chunking = ChunkLinearization(depgraph_tree, opt_linearization);\n+    auto cmp_opt = CompareChunks(opt_chunking, post_chunking);\n+    assert(cmp_opt == 0);\n+}\n+\n+FUZZ_TARGET(clusterlin_postlinearize_moved_leaf)\n+{\n+    // Verify that taking an existing linearization, and moving a leaf to the back, potentially\n+    // increasing its fee, and then post-linearizing, results in something as good as the\n+    // original. This guarantees that in an RBF that replaces a transaction with one of the same\n+    // size but higher fee, applying the \"remove conflicts, append new transaction, postlinearize\"\n+    // process to an optimalized linearization will retain optimality.\n+\n+    // Construct an arbitrary graph and a fee from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    int32_t fee_inc{0};\n+    try {\n+        uint64_t fee_inc_code;\n+        reader >> Using<DepGraphFormatter>(depgraph) >> VARINT(fee_inc_code);\n+        fee_inc = fee_inc_code & 0x3ffff;\n+    } catch (const std::ios_base::failure&) {}\n+    if (depgraph.TxCount() == 0) return;\n+\n+    // Retrieve two linearizations from the fuzz input.\n+    auto lin = ReadLinearization(depgraph, reader);\n+    auto lin_leaf = ReadLinearization(depgraph, reader);\n+\n+    // Construct a linearization identical to lin, but with the tail end of lin_leaf moved to the\n+    // back.\n+    std::vector<ClusterIndex> lin_moved;\n+    for (auto i : lin) {\n+        if (i != lin_leaf.back()) lin_moved.push_back(i);\n+    }\n+    lin_moved.push_back(lin_leaf.back());\n+\n+    // Postlinearize lin_moved.\n+    PostLinearize(depgraph, lin_moved);\n+    SanityCheck(depgraph, lin_moved);\n+\n+    // Compare diagrams (applying the fee delta after computing the old one).\n+    auto old_chunking = ChunkLinearization(depgraph, lin);\n+    depgraph.FeeRate(lin_leaf.back()).fee += fee_inc;",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 276,
      "original_position": 162,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "2df78c9cd617247f2bd0c073e7d9ee9a2086a702",
      "in_reply_to_id": 1700503698,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah okay my bad, I thought it was simulating the RBF strategy but it's actually asserting a more general property, that `PostLinearize` can bring us \"back\" to something at least as good as before the leaf was moved to the back.",
      "created_at": "2024-08-02T10:49:32Z",
      "updated_at": "2024-08-02T11:14:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1701685263",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701685263"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 927,
      "original_line": 927,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701726043",
      "pull_request_review_id": 2215384103,
      "id": 1701726043,
      "node_id": "PRRC_kwDOABII585lbkdb",
      "diff_hunk": "@@ -738,6 +804,249 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all\n+ *   transactions have at most one parent), the result is optimal.\n+ * - Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end,\n+ *   optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least\n+ *   as good as L1. This means that replacing transactions with same-size higher-fee transactions\n+ *   will not worsen linearizations through a \"drop conflicts, append new transactions,\n+ *   postlinearize\" process.\n+ */\n+template<typename SetType>\n+void PostLinearize(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization)\n+{\n+    // This algorithm performs a number of passes (currently 2); the even ones operate from back to\n+    // front, the odd ones from front to back. Each results in an equal-or-better linearization\n+    // than the one started from.\n+    // - One pass in either direction guarantees that the resulting chunks are connected.\n+    // - Each direction corresponds to one shape of tree being linearized optimally (forward passes\n+    //   guarantee this for graphs where each transaction has at most one child; backward passes\n+    //   guarantee this for graphs where each transaction has at most one parent).\n+    // - Starting with a backward pass guarantees the moved-tree property.\n+    //\n+    // During an odd (forward) pass, the high-level operation is:\n+    // - Start with an empty list of groups L=[].\n+    // - For every transaction i in the old linearization, from front to back:\n+    //   - Append a new group C=[i], containing just i, to the back of L.\n+    //   - While L has at least one group before C, and the group immediately before C has feerate\n+    //     lower than C:\n+    //     - If C depends on P:\n+    //       - Merge P into C, making C the concatenation of P+C, continuing with the combined C.\n+    //     - Otherwise:\n+    //       - Swap P with C, continuing with the now-moved C.\n+    // - The output linearization is the concatenation of the groups in L.\n+    //\n+    // During even (backward) passes, i iterates from the back to the front of the existing\n+    // linearization, and new groups are prepended instead of appended to the list L. To enable\n+    // more code reuse, both passes append groups, but during even passes the meanings of\n+    // parent/child, and of high/low feerate are reversed, and the final concatenation is reversed\n+    // on output.\n+    //\n+    // In the implementation below, the groups are represented by singly-linked lists (pointing\n+    // from the back to the front), which are themselves organized in a singly-linked circular\n+    // list (each group pointing to its predecessor, with a special sentinel group at the front\n+    // that points back to the last group).\n+    //\n+    // Information about transaction t is stored in entries[t + 1], while the sentinel is in\n+    // entries[0].\n+\n+    /** Index of the sentinel in the entries array below. */\n+    static constexpr ClusterIndex SENTINEL{0};\n+    /** Indicator that a group has no previous transaction. */\n+    static constexpr ClusterIndex NO_PREV_TX{0};\n+\n+\n+    /** Data structure per transaction entry. */\n+    struct TxEntry\n+    {\n+        /** The index of the previous transaction in this group; NO_PREV_TX if this is the first\n+         *  entry of a group. */\n+        ClusterIndex prev_tx;\n+\n+        // The fields below are only used for transactions that are the last one in a group\n+        // (referred to as tail transactions below).\n+\n+        /** Index of the first transaction in this group, possibly itself. */\n+        ClusterIndex first_tx;\n+        /** Index of the last transaction in the previous group. The first group (the sentinel)\n+         *  points back to the last group here, making it a singly-linked circular list. */\n+        ClusterIndex prev_group;\n+        /** All transactions in the group. Empty for the sentinel. */\n+        SetType group;\n+        /** All dependencies of the group (descendants in even passes; ancestors in odd ones). */\n+        SetType deps;\n+        /** The combined fee/size of transactions in the group. Fee is negated in even passes. */\n+        FeeFrac feerate;\n+    };\n+\n+    // As an example, consider the state corresponding to the linearization [1,0,3,2], with\n+    // groups [1,0,3] and [2], in an odd pass. The linked lists would be:\n+    //\n+    //                                        +-----+\n+    //                                 0<-P-- | 0 S | ---\\     Legend:\n+    //                                        +-----+    |\n+    //                                           ^       |     - digit in box: entries index\n+    //             /--------------F---------+    G       |       (note: one more than tx value)\n+    //             v                         \\   |       |     - S: sentinel group\n+    //          +-----+        +-----+        +-----+    |          (empty feerate)\n+    //   0<-P-- | 2   | <--P-- | 1   | <--P-- | 4 T |    |     - T: tail transaction, contains\n+    //          +-----+        +-----+        +-----+    |          fields beyond prev_tv.\n+    //                                           ^       |     - P: prev_tx reference\n+    //                                           G       G     - F: first_tx reference\n+    //                                           |       |     - G: prev_group reference\n+    //                                        +-----+    |\n+    //                                 0<-P-- | 3 T | <--/\n+    //                                        +-----+\n+    //                                         ^   |\n+    //                                         \\-F-/\n+    //\n+    // During an even pass, the diagram above would correspond to linearization [2,3,0,1], with\n+    // groups [2] and [3,0,1].\n+\n+    std::vector<TxEntry> entries(linearization.size() + 1);",
      "path": "src/cluster_linearize.h",
      "position": 271,
      "original_position": 271,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "in_reply_to_id": 1701660707,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed, the only reuse is the vector allocation.",
      "created_at": "2024-08-02T11:31:28Z",
      "updated_at": "2024-08-02T11:31:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1701726043",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701726043"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 914,
      "original_line": 914,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701763166",
      "pull_request_review_id": 2215445350,
      "id": 1701763166,
      "node_id": "PRRC_kwDOABII585lbthe",
      "diff_hunk": "@@ -738,6 +804,249 @@ std::pair<std::vector<ClusterIndex>, bool> Linearize(const DepGraph<SetType>& de\n     return {std::move(linearization), optimal};\n }\n \n+/** Improve a given linearization.\n+ *\n+ * @param[in]     depgraph       Dependency graph of the cluster being linearized.\n+ * @param[in,out] linearization  On input, an existing linearization for depgraph. On output, a\n+ *                               potentially better linearization for the same graph.\n+ *\n+ * Postlinearization guarantees:\n+ * - The resulting chunks are connected.\n+ * - If the input has a tree shape (either all transactions have at most one child, or all",
      "path": "src/cluster_linearize.h",
      "position": 172,
      "original_position": 172,
      "commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "original_commit_id": "bbcee5a0d67db46526ba29a1a4a7c590d303de03",
      "in_reply_to_id": 1701672279,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "According to https://en.wikipedia.org/wiki/Tree_(graph_theory), a transaction graph where each transaction has at most one child would be an *arborescence* or *out-tree*, and the opposite an *anti-arborescence* or *in-tree*.",
      "created_at": "2024-08-02T12:10:35Z",
      "updated_at": "2024-08-02T12:10:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30285#discussion_r1701763166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1701763166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30285"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 815,
      "original_line": 815,
      "side": "RIGHT"
    }
  ]
}