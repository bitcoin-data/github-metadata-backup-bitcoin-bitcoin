{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427",
    "id": 2501800868,
    "node_id": "PR_kwDOABII586VHnOk",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/32427",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/32427.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/32427.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/daf0e9a3d45f42889fc5895fc580c73d060d2711",
    "number": 32427,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "(RFC) kernel: Replace leveldb-based BlockTreeDB with flat-file based store",
    "user": {
      "login": "TheCharlatan",
      "id": 8421793,
      "node_id": "MDQ6VXNlcjg0MjE3OTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheCharlatan",
      "html_url": "https://github.com/TheCharlatan",
      "followers_url": "https://api.github.com/users/TheCharlatan/followers",
      "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
      "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
      "repos_url": "https://api.github.com/users/TheCharlatan/repos",
      "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Opening this PR mostly to get concept/approach feedback.\r\n\r\nThis is motivated by the kernel library, where the internal usage of leveldb is a limiting factor to its future use cases. Specifically it is not possible to share leveldb databases between two processes. A notable use-case for the kernel library is accessing and analyzing existing block data. Currently this can only be done by first shutting down the node writing this data. Moving away from leveldb opens the door towards doing this in parallel. A flat file based approach was chosen, since the requirements for persistence here are fairly simple (no deletion, constant-size entries). The change also offers better performance by making node startup faster, and has a smaller on-disk footprint, though this is negligible in the grand scheme of things.\r\n\r\nThe BlockTreeStore introduces a new data format for storing block indexes and headers on disk. The class is very similar to the existing CBlockTreeDB, which stores the same data in a leveldb database. Unlike CBlockTreeDB, the data stored through the BlockTreeStore is directly serialized and written to flat .dat files. The storage schema introduced\r\nis simple. It relies on the assumption that no entry is ever deleted and that no duplicate entries are written. These assumptions hold for the current users of CBlockTreeDB.\r\n\r\nA write ahead ahead log and boolean flags as file existence checks ensure write atomicity. Every data entry is also given a crc32c checksum to detect data corruption.\r\n\r\nThe change also opens the door towards getting rid of having to reindex the block tree due to corruption (though switching from pruned -> un-pruned still requires extra logic). This would simplify a lot of kernel/validation code, as can be seen in this [commit](https://github.com/TheCharlatan/bitcoin/commit/bfb2709e1d116d4e613601c3f0140f099530159d#diff-28f178018e05634ee3f8ddce3f4e0cec334ae69915cecf92be8299c749d8d470). The implementation here should be fairly robust against corruption (no parallel read/writes, no background compaction).\r\n\r\nAn alternative to this pull request, that could allow the same kernel feature, would be closing and opening the leveldb database only when reading and writing. This might incur a (negligible) performance penalty, but more importantly requires careful consideration of how to handle any contentions when opening, which might have complex side effects due to our current locking mode. It would also be possible to introduce an existing database with the required features for just the block tree, but that would introduce reliance on a new dependency and come with its own tradeoffs. For these reasons I chose this approach.",
    "labels": [
      {
        "id": 97470796,
        "node_id": "MDU6TGFiZWw5NzQ3MDc5Ng==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/UTXO%20Db%20and%20Indexes",
        "name": "UTXO Db and Indexes",
        "color": "fbca04",
        "default": false
      }
    ],
    "created_at": "2025-05-06T14:27:59Z",
    "updated_at": "2025-09-13T00:49:56Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "b1229b692aadf0037e69a5d422b8de90f4e4419e",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "TheCharlatan:blocktreestore",
      "ref": "blocktreestore",
      "sha": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 94456368,
        "node_id": "MDEwOlJlcG9zaXRvcnk5NDQ1NjM2OA==",
        "name": "bitcoin",
        "full_name": "TheCharlatan/bitcoin",
        "owner": {
          "login": "TheCharlatan",
          "id": 8421793,
          "node_id": "MDQ6VXNlcjg0MjE3OTM=",
          "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/TheCharlatan",
          "html_url": "https://github.com/TheCharlatan",
          "followers_url": "https://api.github.com/users/TheCharlatan/followers",
          "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
          "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
          "repos_url": "https://api.github.com/users/TheCharlatan/repos",
          "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/TheCharlatan/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/TheCharlatan/bitcoin",
        "archive_url": "https://api.github.com/repos/TheCharlatan/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/TheCharlatan/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/TheCharlatan/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/TheCharlatan/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/TheCharlatan/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/TheCharlatan/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/TheCharlatan/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/TheCharlatan/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/TheCharlatan/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/TheCharlatan/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/TheCharlatan/bitcoin/events",
        "forks_url": "https://api.github.com/repos/TheCharlatan/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/TheCharlatan/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/TheCharlatan/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/TheCharlatan/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/TheCharlatan/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/TheCharlatan/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/TheCharlatan/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/TheCharlatan/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/TheCharlatan/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/TheCharlatan/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/TheCharlatan/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/TheCharlatan/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/TheCharlatan/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:TheCharlatan/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/TheCharlatan/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/TheCharlatan/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/TheCharlatan/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/TheCharlatan/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/TheCharlatan/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/TheCharlatan/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/TheCharlatan/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/TheCharlatan/bitcoin/hooks",
        "svn_url": "https://github.com/TheCharlatan/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 275227,
        "default_branch": "master",
        "open_issues_count": 6,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-12T19:03:44Z",
        "created_at": "2017-06-15T16:03:35Z",
        "updated_at": "2025-08-19T10:10:57Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "2d8f5b91881e53a9d29e85aa796fbc7e53a1a380",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37773,
        "stargazers_count": 85465,
        "watchers_count": 85465,
        "size": 293563,
        "default_branch": "master",
        "open_issues_count": 776,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-09-12T13:42:12Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-09-12T21:53:06Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1228,
    "deletions": 106,
    "changed_files": 23,
    "commits": 6,
    "review_comments": 54,
    "comments": 28
  },
  "events": [
    {
      "event": "commented",
      "id": 2854787092,
      "node_id": "IC_kwDOABII586qKJgU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2854787092",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-06T14:28:01Z",
      "updated_at": "2025-09-13T00:49:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32427.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [josibake](https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2857741552), [theuni](https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2884164753), [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2894302384), [marcofleon](https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2943783645), [l0rinc](https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2822815289) |\n| Approach ACK | [w0xlt](https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2855495136) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33042](https://github.com/bitcoin/bitcoin/pull/33042) (refactor: inline constant return values from `dbwrapper` write methods by l0rinc)\n* [#31974](https://github.com/bitcoin/bitcoin/pull/31974) (Drop testnet3 by Sjors)\n* [#31645](https://github.com/bitcoin/bitcoin/pull/31645) ([IBD] coins: increase default UTXO flush batch size to 32 MiB by l0rinc)\n* [#28690](https://github.com/bitcoin/bitcoin/pull/28690) (build: Introduce internal kernel library by TheCharlatan)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (âœ¨ experimental)\n\nPossible typos and grammar issues:\n\n- \"Invalid magic in %s: 0x%08x (expected: 0x%08x)\" -> \"Invalid version in %s: 0x%08x (expected: 0x%08x)\" [The code branch checks the version but the error message says \"magic\", which is misleading for understanding which field failed.]\n\n<sup>drahtbot_id_5_m</sup>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2854787092",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2855495136,
      "node_id": "IC_kwDOABII586qM2Xg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2855495136",
      "actor": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-06T18:12:32Z",
      "updated_at": "2025-05-06T18:12:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK\r\n\r\nThe codebase changes seem surprisingly small for this proposal.\r\nChanging the code to reduce the dependency on LevelDB sounds good to me.",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2855495136",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "mentioned",
      "id": 17547927887,
      "node_id": "MEE_lADOABII5861YR-zzwAAAAQV8CFP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17547927887",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T02:43:26Z"
    },
    {
      "event": "subscribed",
      "id": 17547927892,
      "node_id": "SE_lADOABII5861YR-zzwAAAAQV8CFU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17547927892",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T02:43:26Z"
    },
    {
      "event": "reviewed",
      "id": 2820208053,
      "node_id": "PRR_kwDOABII586oGPW1",
      "url": null,
      "actor": null,
      "commit_id": "fabd3ab615a7c718f37a60298a125864edb6106b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-16T09:27:08Z",
      "author_association": "NONE",
      "body": "Thanks @TheCharlatan for this proposal and making the code changes.!\r\n\r\nPlease find my review comments, suggestions and some clarifying questions:\r\n\r\n1) How will concurrent reads (and potentially writes) be handled with the flat file format?\r\n\r\n2) Even if no deletion occurs, file corruption or partial writes can happen. Are you planning mmap or memory buffering?\r\n\r\n3) What would be the \"Corruption Recovery Strategy?\" -- While the write-ahead log is mentioned as future work, providing even a minimal rollback/recovery mechanism in the initial version would make this stronger.\r\n\r\n4) What would be the \"**Migration Path**\"? -- Will there be tooling or a migration process from existing leveldb-based data\r\n\r\n5) Data Integrity Guarantees? -- Are checksums or hash-based verifications being added per entry or per file?\r\n\r\n6) Consider including a pluggable interface that allows fallback to LevelDB for testing or backwards compatibility\r\n\r\n7) **Write contention and corruption risks:** -- While flat files avoid LevelDBâ€™s process-level locking, concurrent writes require a mechanism (e.g., file locks, flock()) to prevent race conditions.\r\n8) **Portability and Cross platform related edge cases:** -- Ensure file-locking mechanisms (e.g., fcntl on Unix, LockFileEx on Windows) are robust.\r\n\r\n9) How about Handling Large Files? -- Test edge cases like file sizes approaching OS limits (e.g., 2+ GB on 32-bit systems). What would happen in such cases?\r\n\r\n10) On similar lines to point-5 -- **Corruption Detection** mechanism could also be implemented to detect corruptions very early in the cycle.\r\n\r\nThe flat-file approach is a reasonable trade-off given the simplicity of the block tree storage requirements. \r\n\r\nHowever, there are major significant challenges and risks involved with this approach as highlighted in the above 10 comments. (Concurrency, Corruption/Integrity, Performance, Migration, Corruption detection, Portability, Backward compatibility etc.)",
      "user": {
        "login": "shahsb",
        "id": 20738488,
        "node_id": "MDQ6VXNlcjIwNzM4NDg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/20738488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/shahsb",
        "html_url": "https://github.com/shahsb",
        "followers_url": "https://api.github.com/users/shahsb/followers",
        "following_url": "https://api.github.com/users/shahsb/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/shahsb/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/shahsb/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/shahsb/subscriptions",
        "organizations_url": "https://api.github.com/users/shahsb/orgs",
        "repos_url": "https://api.github.com/users/shahsb/repos",
        "events_url": "https://api.github.com/users/shahsb/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/shahsb/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2820208053",
      "submitted_at": "2025-05-07T03:14:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
    },
    {
      "event": "labeled",
      "id": 17549552230,
      "node_id": "LE_lADOABII5861YR-zzwAAAAQWCOpm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17549552230",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T06:05:46Z",
      "label": {
        "name": "UTXO Db and Indexes",
        "color": "fbca04"
      }
    },
    {
      "event": "commented",
      "id": 2857741552,
      "node_id": "IC_kwDOABII586qVazw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2857741552",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T08:57:46Z",
      "updated_at": "2025-05-07T08:57:46Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\n> A notable use-case for the kernel library is accessing and analyzing existing block data\r\n\r\nA concrete example is index building in electrs / esplora / etc. For example, Electrs does this today by:\r\n\r\n1. Waiting for Bitcoin Core to finish IBD\r\n2. Reading all of the blocks out over JSON-RPC\r\n3. Parsing them and writing them into the appropriate indexes\r\n\r\nI started on a PoC for Electrs to use libbitcoinkernel for index building to demonstrate how this could be done much more efficiently and saw promising results. However, the requirement that Bitcoin Core be shut down before Electrs could process the block files made this approach clunky. I'll revive this PoC as a means of testing this PR and hopefully provide some use case motivated feedback on the approach.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2857741552",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2858496851,
      "node_id": "IC_kwDOABII586qYTNT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2858496851",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T12:58:00Z",
      "updated_at": "2025-05-07T12:58:18Z",
      "author_association": "MEMBER",
      "body": "Have you considered simply having one block per file? Typical blk files are 130 MB, so for \"modern\" blocks it would 50x the number of files. But is that actually a problem? It's a lot simpler if we can just have `$HASH.dat`, maybe grouped in a directory per 10k blocks.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2858496851",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2858550825,
      "node_id": "IC_kwDOABII586qYgYp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2858550825",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T13:13:46Z",
      "updated_at": "2025-05-07T13:13:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Have you considered simply having one block per file? Typical blk files are 130 MB, so for \"modern\" blocks it would 50x the number of files. But is that actually a problem? It's a lot simpler if we can just have $HASH.dat, maybe grouped in a directory per 10k blocks.\r\n\r\nI'm not sure what you are suggesting here. Are you suggesting we create ~900k files and then have some subdivision within those files into 10k groups where each of those has a single `$HASH.dat` with all the headers and file pointers for the blocks in that division? Is there something we gain through that? My impression is we do the file splitting in the first place to make pruning easier. We don't prune headers, so I don't think splitting the file gains us anything. I don't think there is much wrong with just having a single file. Maybe it even helps the OS a bit to manage the file buffers?",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2858550825",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2858637715,
      "node_id": "IC_kwDOABII586qY1mT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2858637715",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T13:33:53Z",
      "updated_at": "2025-05-07T13:36:59Z",
      "author_association": "MEMBER",
      "body": "> Are you suggesting we create ~900k files\r\n\r\nYes. If we're going to redesign block storage, it seems good to wonder why can't let the file system handle things.\r\n\r\n> with all the headers and file pointers for the blocks in that division\r\n\r\nOne block per file. We can still have a single file for the block index, which would contain the header (not just the hash) and validation state. Block files themselves would be in a predictable location, so we wouldn't need an index for that.\r\n\r\n> My impression is we do the file splitting in the first place to make pruning easier. \r\n\r\nDo you mean compared to the alternative of having a single file for _all_ blocks? I would imagine that would create I/O problems, since the operating system wouldn't know which part of the big file changed. And it can't defragment it.\r\n\r\nHaving one file per block makes pruning marginally easier than now, since you don't have to worry about keeping nearby blocks in the same file.\r\n\r\nOne downside of what I'm suggesting is that the headers would either be stored redundantly (in the block file as well as in the index), or anyone parsing the block files has to prepend the header themselves.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2858637715",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2858716091,
      "node_id": "IC_kwDOABII586qZIu7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2858716091",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T13:59:31Z",
      "updated_at": "2025-05-07T13:59:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "How worried are we about file corruption here? I thought the main reason we use leveldb and sqlite databases in places like this where we don't need indexing is that they support atomic updates, so you can pull the power cord any time and next time you reboot you will will see some consistent view of the data, even if it's not the latest data. I didn't look too closely at the implementation here but it seems like it is updating data in the files in place, so if writes are interrupted, data could be corrupt, and it's not clear if there are even checksums in place that would detect this.\r\n\r\nMaybe this is not an issue for the PR, but it would be good to make clear what types of corruption BlockTreeStore can and can't detect and what types of corruption it can recover from. If it can do simple things to detect corruption like adding checksums, or to prevent it like writing to temporary files and renaming them in place, those could be good to consider.\r\n\r\nIf this PR does introduce some increased risk of corruption, maybe that is worth it for reasons listed in the description. I also think another alternative could be to use sqlite for this since this would not necessarily introduce a new dependency and we already have a [ReadKey/WriteKey/EraseKey/HasKey](https://github.com/bitcoin/bitcoin/blob/6d5edfcc585bab3374ae14aa7918b3e178e016aa/src/wallet/sqlite.h#L76-L80) wrapper functions for sqlite that might help it be an easy replacement for leveldb.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2858716091",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2859864794,
      "node_id": "IC_kwDOABII586qdhLa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2859864794",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T18:44:22Z",
      "updated_at": "2025-05-07T18:44:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2858637715\r\n\r\n> Do you mean compared to the alternative of having a single file for all blocks? I would imagine that would create I/O problems, since the operating system wouldn't know which part of the big file changed. And it can't defragment it.\r\n\r\nYes, that is what I meant. We never change block files, so that is not a problem. I'm also not sure how real this problem actually is. A bunch of databases just maintain one big file and have good performance doing so. I'm still not sure what the benefit of what you propose would be. Either way, I think this is a bit out of scope, since while this change implements a database migration, it does not require a reindex, which a change to the block file format would. Improving pruning behavior is also not the goal here.\r\n\r\n\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2859864794",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2859921949,
      "node_id": "IC_kwDOABII586qdvId",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2859921949",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T19:05:17Z",
      "updated_at": "2025-05-07T19:05:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2858716091\r\n\r\n> How worried are we about file corruption here? \r\n\r\nI was hoping to provoke a discussion about this as I alluded to in the PR description - thanks for providing your thoughts on this. I think the proof of work and integrity checks done on loading the index already provide fairly solid guarantees on load, but agree that we should do better. I have also talked to some other people about it offline, and there seems to be some appetite for improving corruption resistance. It is my understanding that the feature for reindexing the block tree was added as a salvaging option, because leveldb does not provide strong anti-corruption guarantees, but has sprawled a bit since. Removing the need to provide code for reindexing the block tree would be a nice simplification of validation code in my eyes. I think adding a checksum for the entries and writing from a log file could be fairly simple to implement and provide strong guarantees. I'm open to suggestions here.\r\n\r\n> I also think another alternative could be to use sqlite for this since this would not necessarily introduce a new dependency and we already have a [ReadKey/WriteKey/EraseKey/HasKey](https://github.com/bitcoin/bitcoin/blob/6d5edfcc585bab3374ae14aa7918b3e178e016aa/src/wallet/sqlite.h#L76-L80) wrapper functions for sqlite that might help it be an easy replacement for leveldb.\r\n\r\nThis has also been brought up by some others. While I'm still not sure that we should be introducing a new validation dependency, maybe it would be good to implement it and open the change as an alternative draft / RFC pull request in the meantime?",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2859921949",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "reviewed",
      "id": 2823207472,
      "node_id": "PRR_kwDOABII586oRrow",
      "url": null,
      "actor": null,
      "commit_id": "fabd3ab615a7c718f37a60298a125864edb6106b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-07T21:11:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "A full `-reindex` can be necessary for two reasons:\r\n1. corruption in the block tree db\r\n2. corruption in the blk files.\r\n\r\nIn my personal experience of running a node on crappy hardware a long time ago, it was usually 2. that would happen (I knew that because the reindex wouldn't scan all block files but abort with an error somewhere, and switch to IBD from peers). My suspicion is that while 1. may have been the dominant reason in the early years, 2. may be just as important today.\r\n\r\nHowever, if that was the case, changing the block tree db format wouldn't allow us to get rid of `-reindex`, even if the new format would never corrupt.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2823207472",
      "submitted_at": "2025-05-07T21:06:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
    },
    {
      "event": "commented",
      "id": 2861994398,
      "node_id": "IC_kwDOABII586qlpGe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2861994398",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-08T07:01:05Z",
      "updated_at": "2025-05-08T07:07:27Z",
      "author_association": "MEMBER",
      "body": "> We never change block files, so that is not a problem. I'm also not sure how real this problem actually is. \r\n\r\nBut we prune blocks, and they may not all be at the start of the big file.\r\n\r\n> A bunch of databases just maintain one big file and have good performance doing so.\r\n\r\nEven on a spinning disk? That's where I tend to keep my `.dat` files.\r\n\r\n> I'm still not sure what the benefit of what you propose would be.\r\n\r\nCompared to the current situation where we bundle a bunch of, but not _all_, blocks in one file, it just seems simpler to have one file per block.\r\n\r\nIn the \"corruption in the blk files\" example above it also makes recovery really easy: just load the block files one by one, hash them, redownload if the hash doesn't match. No need to update any index.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2861994398",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2863677632,
      "node_id": "IC_kwDOABII586qsEDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2863677632",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-08T16:44:17Z",
      "updated_at": "2025-05-08T16:44:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "re: TheCharlatan https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2859921949\r\n\r\nThanks for clarifying the situation with leveldb. I just assumed based on its design that it would support atomic updates pretty robustly but if it has corruption problems of its own then it doesn't sound like we would lose much by switching to something simpler.\r\n\r\nI still do think using sqlite could be a nice solution because data consistency issues can be a significant source of pain for users and developers, and with sqlite we basically just don't need to think those issues. But I also understand not wanting to require sqlite as a kernel dependency. \r\n\r\nAnother thing about this PR (as of fabd3ab615a7c718f37a60298a125864edb6106b) is it seems like it doesn't actually remove much blockstorage code, and the BlockTreeDB class remains intact, I guess because migration code depends on it.\r\n\r\nAn idea that might improve this could be to make BlockTreeStore methods pure virtual and have FlatFile and LevelDB subclasses implementing them. This could organize the code more cleanly by letting FlatFile and LevelDB implementations both live side-by side outside of blockstorage instead of one being inside and one being outside. This could also let kernel applications provide alternate backends, and allow things like differential fuzz testing. (This was also the exact same approach used to replace bdb with sqlite in the wallet.)\r\n\r\nre: Sjors https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2861994398\r\n\r\nFWIW I also think using individual block files could be great (assuming a sharded directory structure like the .git/objects to avoid having many files per directory). That idea is mostly tangential to this PR though, I think? Possible I am missing some connections.\r\n\r\n\r\n\r\n\r\n\r\n",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2863677632",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2868847845,
      "node_id": "IC_kwDOABII586q_yTl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2868847845",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-10T13:24:48Z",
      "updated_at": "2025-05-10T13:24:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2823207472\r\n\r\n> In my personal experience of running a node on crappy hardware a long time ago, it was usually 2. that would happen (I knew that because the reindex wouldn't scan all block files but abort with an error somewhere, and switch to IBD from peers). \r\n\r\nThat is interesting, I don't think I've ever run into blk file corruption. I agree with you that if that is something we need to be able to salvage from, that the reindex logic would have to remain for it. If that is the case though, shouldn't we also be cleaning left over block data then? Seems like the user could just end up with 100's of GBs of unusable block data otherwise.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2868847845",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2881521463,
      "node_id": "IC_kwDOABII586rwIc3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2881521463",
      "actor": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-14T20:44:53Z",
      "updated_at": "2025-05-14T20:44:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "I didn't have time to review this in detail - nor to form a detailed concept/approach feedback, but I ran a few reindexes to see if it affects performance because somebody was referring to this as an optimization and wanted to understand if that's indeed the case.\r\n\r\nI ran a `reindex` until 888,888 comparing the speed against master.\r\n\r\n<details>\r\n<summary>Details</summary>\r\n\r\n```bash\r\nCOMMITS=\"14b8dfb2bd5e2ca2b7c0c9a7f7d50e1e60adf75c fabd3ab615a7c718f37a60298a125864edb6106b\"; \\\r\nSTOP_HEIGHT=888888; DBCACHE=4500; \\\r\nCC=gcc; CXX=g++; \\\r\nBASE_DIR=\"/mnt/my_storage\"; DATA_DIR=\"$BASE_DIR/BitcoinData\"; LOG_DIR=\"$BASE_DIR/logs\"; \\\r\n(echo \"\"; for c in $COMMITS; do git fetch origin $c -q && git log -1 --pretty=format:'%h %s' $c || exit 1; done; echo \"\") && \\\r\nhyperfine \\\r\n  --sort 'command' \\\r\n  --runs 1 \\\r\n  --export-json \"$BASE_DIR/rdx-$(sed -E 's/(\\w{8})\\w+ ?/\\1-/g; s/-$//' <<< \"$COMMITS\")-$STOP_HEIGHT-$DBCACHE-$CC.json\" \\\r\n  --parameter-list COMMIT ${COMMITS// /,} \\\r\n  --prepare \"killall bitcoind; rm -f $DATA_DIR/debug.log; git checkout {COMMIT}; git clean -fxd; git reset --hard; \\\r\n    cmake -B build -DCMAKE_BUILD_TYPE=Release -DENABLE_WALLET=OFF && cmake --build build -j$(nproc) --target bitcoind && \\\r\n    ./build/bin/bitcoind -datadir=$DATA_DIR -stopatheight=$STOP_HEIGHT -dbcache=5000 -printtoconsole=0; sleep 10\" \\\r\n  --cleanup \"cp $DATA_DIR/debug.log $LOG_DIR/debug-{COMMIT}-$(date +%s).log\" \\\r\n  \"COMPILER=$CC ./build/bin/bitcoind -datadir=$DATA_DIR -stopatheight=$STOP_HEIGHT -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=$DBCACHE\"\r\n```\r\n\r\n> 14b8dfb2bd Merge bitcoin/bitcoin#31398: wallet: refactor: various master key encryption cleanups\r\n> fabd3ab615 blockstorage: Remove BlockTreeDB dead code\r\n\r\n```python\r\nBenchmark 1: COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=4500 (COMMIT = 14b8dfb2bd5e2ca2b7c0c9a7f7d50e1e60adf75c)\r\n  Time (abs â‰¡):        27076.605 s               [User: 32171.870 s, System: 1311.182 s]\r\n\r\nBenchmark 2: COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=4500 (COMMIT = fabd3ab615a7c718f37a60298a125864edb6106b)\r\n  Time (abs â‰¡):        27034.197 s               [User: 32220.994 s, System: 1286.553 s]\r\n\r\nRelative speed comparison\r\n        1.00          COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=4500 (COMMIT = 14b8dfb2bd5e2ca2b7c0c9a7f7d50e1e60adf75c)\r\n        1.00          COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=4500 (COMMIT = fabd3ab615a7c718f37a60298a125864edb6106b)\r\n```\r\n\r\n</details>\r\n\r\nWhich indicates there's no measurable speed difference.\r\nBut here the chainstate reindexing dominates, so I did one until block 1 as well.\r\n\r\n<details>\r\n<summary>Details</summary>\r\n\r\n```bash\r\nCOMMITS=\"14b8dfb2bd5e2ca2b7c0c9a7f7d50e1e60adf75c fabd3ab615a7c718f37a60298a125864edb6106b\"; \\\r\nSTOP_HEIGHT=1; DBCACHE=450; \\\r\nCC=gcc; CXX=g++; \\\r\nBASE_DIR=\"/mnt/my_storage\"; DATA_DIR=\"$BASE_DIR/BitcoinData\"; LOG_DIR=\"$BASE_DIR/logs\"; \\\r\n(echo \"\"; for c in $COMMITS; do git fetch origin $c -q && git log -1 --pretty=format:'%h %s' $c || exit 1; done; echo \"\") && \\\r\nhyperfine \\\r\n  --sort 'command' \\\r\n  --runs 1 \\\r\n  --export-json \"$BASE_DIR/rdx-$(sed -E 's/(\\w{8})\\w+ ?/\\1-/g; s/-$//' <<< \"$COMMITS\")-$STOP_HEIGHT-$DBCACHE-$CC.json\" \\\r\n  --parameter-list COMMIT ${COMMITS// /,} \\\r\n  --prepare \"killall bitcoind; rm -f $DATA_DIR/debug.log; git checkout {COMMIT}; git clean -fxd; git reset --hard; \\\r\n    cmake -B build -DCMAKE_BUILD_TYPE=Release -DENABLE_WALLET=OFF && cmake --build build -j$(nproc) --target bitcoind && \\\r\n    ./build/bin/bitcoind -datadir=$DATA_DIR -stopatheight=$STOP_HEIGHT -dbcache=5000 -printtoconsole=0; sleep 10\" \\\r\n  --cleanup \"cp $DATA_DIR/debug.log $LOG_DIR/debug-{COMMIT}-$(date +%s).log\" \\\r\n  \"COMPILER=$CC ./build/bin/bitcoind -datadir=$DATA_DIR -stopatheight=$STOP_HEIGHT -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=$DBCACHE\"\r\n```\r\n    \r\n> 14b8dfb2bd Merge bitcoin/bitcoin#31398: wallet: refactor: various master key encryption cleanups\r\n> fabd3ab615 blockstorage: Remove BlockTreeDB dead code\r\n\r\n```python\r\nBenchmark 1: COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=1 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=450 (COMMIT = 14b8dfb2bd5e2ca2b7c0c9a7f7d50e1e60adf75c)\r\n  Time (abs â‰¡):        7718.677 s               [User: 7368.404 s, System: 174.230 s]\r\n\r\nBenchmark 2: COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=1 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=450 (COMMIT = fabd3ab615a7c718f37a60298a125864edb6106b)\r\n  Time (abs â‰¡):        7683.972 s               [User: 7344.276 s, System: 165.120 s]\r\n\r\nRelative speed comparison\r\n        1.00          COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=1 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=450 (COMMIT = 14b8dfb2bd5e2ca2b7c0c9a7f7d50e1e60adf75c)\r\n        1.00          COMPILER=gcc ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=1 -reindex -blocksonly -connect=0 -printtoconsole=0 -dbcache=450 (COMMIT = fabd3ab615a7c718f37a60298a125864edb6106b)\r\n```\r\n\r\n</details>\r\n\r\nWhich also indicates there's no measurable speed difference.\r\nSo at least I can confirm that - if my measurements were accurate - there doesn't seem to be a speed regression caused by this change.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2881521463",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2884164753,
      "node_id": "IC_kwDOABII586r6NyR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2884164753",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T15:03:48Z",
      "updated_at": "2025-05-15T15:03:48Z",
      "author_association": "MEMBER",
      "body": "Concept ACK. Neat :)\r\n\r\n> Maybe this is not an issue for the PR, but it would be good to make clear what types of corruption BlockTreeStore can and can't detect and what types of corruption it can recover from. If it can do simple things to detect corruption like adding checksums, or to prevent it like writing to temporary files and renaming them in place, those could be good to consider.\r\n\r\nYeah, I think this is the heart of it. I'm onboard for a new impl outside of leveldb, but before getting too deep into the implementation itself we need to decide 2 main things:\r\n\r\n1. Is the current block/index storage layout ideal? I think @Sjors's one-block-per-file idea is interesting. Undo data could go in the same file without breaking any append-only guarantees. Not requiring file offset record keeping sounds nice. But what would the consequences be? Do any filesystems hate that type of dir layout? Would performance suffer due to a bajillion opens/closes?\r\n2. After figuring out 1, like @ryanofsky asked, what guarantees do we need to provide? Are we just protecting against power outages? Cosmic bit-flip corruption? Bad sectors? Malicious users?\r\n\r\nThe impl here with no slicing or atomicity attempts isn't very robust, but that's obviously fine for an RFC. ",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2884164753",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "mentioned",
      "id": 17674300527,
      "node_id": "MEE_lADOABII5861YR-zzwAAAAQdeGxv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17674300527",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T15:03:49Z"
    },
    {
      "event": "subscribed",
      "id": 17674300559,
      "node_id": "SE_lADOABII5861YR-zzwAAAAQdeGyP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17674300559",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T15:03:49Z"
    },
    {
      "event": "mentioned",
      "id": 17674300592,
      "node_id": "MEE_lADOABII5861YR-zzwAAAAQdeGyw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17674300592",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T15:03:49Z"
    },
    {
      "event": "subscribed",
      "id": 17674300620,
      "node_id": "SE_lADOABII5861YR-zzwAAAAQdeGzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17674300620",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T15:03:49Z"
    },
    {
      "event": "commented",
      "id": 2884199732,
      "node_id": "IC_kwDOABII586r6WU0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2884199732",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T15:14:23Z",
      "updated_at": "2025-05-15T15:15:06Z",
      "author_association": "MEMBER",
      "body": "I think a file structure of `$DATADIR/blocks/[${(HEIGHT//2016)*2016}]/$HEIGHT-$HASH.dat` would be a nice color for the bikeshed. That would mean typically 2016 block files per directory (if no branches appear), organized neatly per retarget period.\r\n\r\nAs for putting block and undo data in the same file, I'm unsure. Undo data to me feels more like a validation-level thing, while block data is more a storage-level thing.\r\n\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2884199732",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2885100223,
      "node_id": "IC_kwDOABII586r9yK_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2885100223",
      "actor": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-15T21:31:37Z",
      "updated_at": "2025-05-15T21:31:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "### Re: One file per block\r\n\r\nFWIW the idea of using one file per block gets me going too. :) It is slightly orthogonal but would be nice to avoid changing formats twice in short succession.\r\n\r\nMy bikeshed color: Since block hashes start with zeroes, maybe one could shard based off the last two bytes:\r\n\r\nGenesis block ends up in something like:\r\n`$DATADIR/blocks/e2/6f/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f.dat`\r\nBlock [896819](https://mempool.space/block/000000000000000000012f13426140d43426f9db96fe9c93d3db4ebddfbf8428) from today ends up in:\r\n`$DATADIR/blocks/84/28/000000000000000000012f13426140d43426f9db96fe9c93d3db4ebddfbf8428.dat`\r\n\r\nUsing two levels deep directories of 256 entries at each branch point means we start averaging 1000 files per leaf directory at block height 65'536'000 (a bit earlier due to re-orgs). (File system limitations: <https://stackoverflow.com/a/466596>).\r\n\r\nIf having the height as the key is more useful than the hash, I prefer  https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2884199732.\r\n\r\n#### Possible argument against\r\n\r\nSpinning disks typically perform much better when sequentially accessed data is stored within the same file, so the current approach of multiple blocks per file may be more performant for some types of operations. I don't know if or how frequently we access the contents of blocks sequentially though.\r\n",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2885100223",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2885370086,
      "node_id": "IC_kwDOABII586r-0Dm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2885370086",
      "actor": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T00:57:51Z",
      "updated_at": "2025-05-16T00:57:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "> My bikeshed color: Since block hashes start with zeroes, maybe one could shard based off the last two bytes:\r\n\r\nJust curious because the FAT32 file limit per-directory is so small, is there any scenario where a miner could DoS nodes with this format by also mining the last two bytes? \r\n\r\nI think no, because at tip the additional hash needed for two bytes would be prohibitively expensive, although I'm not sure if there is a birthday-problem-like advantage because an attacker doesn't necessarily need to target only one two-byte suffix. And for IBD, headers-first sync would prevent an attack where someone suffix-mines >65,000 blocks from genesis and tries to get nodes to download them.",
      "user": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2885370086",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "comment_deleted",
      "id": 17685776392,
      "node_id": "CDE_lADOABII5861YR-zzwAAAAQeJ4gI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17685776392",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T09:25:53Z"
    },
    {
      "event": "comment_deleted",
      "id": 17685781243,
      "node_id": "CDE_lADOABII5861YR-zzwAAAAQeJ5r7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17685781243",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T09:26:11Z"
    },
    {
      "event": "comment_deleted",
      "id": 17685784348,
      "node_id": "CDE_lADOABII5861YR-zzwAAAAQeJ6cc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17685784348",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T09:26:22Z"
    },
    {
      "event": "comment_deleted",
      "id": 17685787324,
      "node_id": "CDE_lADOABII5861YR-zzwAAAAQeJ7K8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17685787324",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T09:26:34Z"
    },
    {
      "event": "comment_deleted",
      "id": 17685796907,
      "node_id": "CDE_lADOABII5861YR-zzwAAAAQeJ9gr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17685796907",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T09:27:13Z"
    },
    {
      "event": "commented",
      "id": 2886216404,
      "node_id": "IC_kwDOABII586sCCrU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2886216404",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T09:44:08Z",
      "updated_at": "2025-05-16T09:44:08Z",
      "author_association": "MEMBER",
      "body": "> 2\\. what guarantees do we need to provide? Are we just protecting against power outages? Cosmic bit-flip corruption? Bad sectors?\r\n\r\nI'd say ideally all of them. In the rare case where they happen, detecting them early on Bitcoin Core startup (before a validation-internal assert is hit) may help finding the root-cause and also could free up some developer time due to making it easier to remote-diagnose hardware issues (many of them have more than 5 comments: https://github.com/bitcoin/bitcoin/issues?q=is%3Aissue%20%20memtest86). So I'd see it as a benefit if this change can provide stronger detection-checks than leveldb.",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2886216404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "commented",
      "id": 2887607766,
      "node_id": "IC_kwDOABII586sHWXW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2887607766",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T20:20:34Z",
      "updated_at": "2025-05-16T20:20:34Z",
      "author_association": "MEMBER",
      "body": "> > My bikeshed color: Since block hashes start with zeroes, maybe one could shard based off the last two bytes:\r\n> \r\n> Just curious because the FAT32 file limit per-directory is so small, is there any scenario where a miner could DoS nodes with this format by also mining the last two bytes?\r\n> \r\n> I think no, because at tip the additional hash needed for two bytes would be prohibitively expensive, although I'm not sure if there is a birthday-problem-like advantage because an attacker doesn't necessarily need to target only one two-byte suffix. And for IBD, headers-first sync would prevent an attack where someone suffix-mines >65,000 blocks from genesis and tries to get nodes to download them.\r\n\r\nThere's also the possibility of using a local salt like we do for most other game-able data, as opposed to using the actual block hash. Block data is already xor'd with a per-node value, doing something similar with the filenames doesn't seem unreasonable to me. Maybe we'd even want to for the same reason we xor the data? And if already obfuscated, we could go a step further and ascii-encode to trim the file length. Of course, if there's no real need for that salting/obfuscation, it would just make blocks needlessly impossible to eyeball.\r\n\r\n\r\n\r\n> My bikeshed color: Since block hashes start with zeroes, maybe one could shard based off the last two bytes:\r\n> \r\n> Genesis block ends up in something like: `$DATADIR/blocks/e2/6f/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f.dat` Block [896819](https://mempool.space/block/000000000000000000012f13426140d43426f9db96fe9c93d3db4ebddfbf8428) from today ends up in: `$DATADIR/blocks/84/28/000000000000000000012f13426140d43426f9db96fe9c93d3db4ebddfbf8428.dat`\r\n\r\nNote that without the block heights as @sipa proposed, reindexing would be significantly more complicated. With the current impl the blocks on disk are going to be at least vaguely in-order, the above proposal would make them random.",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2887607766",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "mentioned",
      "id": 17694068657,
      "node_id": "MEE_lADOABII5861YR-zzwAAAAQepg-x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17694068657",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T20:20:35Z"
    },
    {
      "event": "subscribed",
      "id": 17694068665,
      "node_id": "SE_lADOABII5861YR-zzwAAAAQepg-5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17694068665",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T20:20:35Z"
    },
    {
      "event": "subscribed",
      "id": 17698979869,
      "node_id": "SE_lADOABII5861YR-zzwAAAAQe8QAd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17698979869",
      "actor": {
        "login": "dn4vzdx8xS15wUV0",
        "id": 211630628,
        "node_id": "U_kgDODJ06JA",
        "avatar_url": "https://avatars.githubusercontent.com/u/211630628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dn4vzdx8xS15wUV0",
        "html_url": "https://github.com/dn4vzdx8xS15wUV0",
        "followers_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/followers",
        "following_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/subscriptions",
        "organizations_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/orgs",
        "repos_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/repos",
        "events_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dn4vzdx8xS15wUV0/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-17T12:25:12Z"
    },
    {
      "event": "reviewed",
      "id": 2894302384,
      "node_id": "PRR_kwDOABII586sg4yw",
      "url": null,
      "actor": null,
      "commit_id": "fabd3ab615a7c718f37a60298a125864edb6106b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-03T22:38:43Z",
      "author_association": "MEMBER",
      "body": "> Moving away from leveldb opens the door towards doing this in parallel. \r\n\r\nFor this reason, I am Concept ACK. \r\nNo opinion on the approach yet; I am still studying the PR and prev discussion.\r\n\r\nIt might be a little too early for this  but I'm excited and tried testing it out on Signet.\r\n\r\nJust by building the branch and running the node on Signet, it crashes. See logs (I didnt start the node with `-reindex` option or maybe I might be doing something wrong though):\r\nhttps://gist.github.com/ismaelsadeeq/18889a42b6e8bd20560198e5e6d52607\r\n\r\nHowever after the crash, starting the node again with `-reindex` option seems to run smoothly.\r\n\r\nAlso when I messed a bit with the `/blocks` directory specifically by attempting to use py-bitcoinkernel to read block saved using this blockstreedb, the data got corrupted and I had to sync the node again from genesis block.",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2894302384",
      "submitted_at": "2025-06-03T22:38:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
    },
    {
      "event": "commented",
      "id": 2938977867,
      "node_id": "IC_kwDOABII586vLT5L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2938977867",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-04T07:46:58Z",
      "updated_at": "2025-06-04T07:46:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for giving this a try @ismaelsadeeq! I'm working on adding a write ahead log at the moment, so will draft this PR in the meantime. Bit surprised that you immediately ran into some corruption, maybe it is caused by the library attempting to still write some data like the genesis block? I think it would be good to have a test for parallel reads/writes here as well as a demo branch for the library.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2938977867",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "mentioned",
      "id": 17976056211,
      "node_id": "MEE_lADOABII5861YR-zzwAAAAQvdNmT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17976056211",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-04T07:47:00Z"
    },
    {
      "event": "subscribed",
      "id": 17976056231,
      "node_id": "SE_lADOABII5861YR-zzwAAAAQvdNmn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17976056231",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-04T07:47:00Z"
    },
    {
      "event": "convert_to_draft",
      "id": 17976058916,
      "node_id": "CTDE_lADOABII5861YR-zzwAAAAQvdOQk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17976058916",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-04T07:47:09Z"
    },
    {
      "event": "commented",
      "id": 2943783645,
      "node_id": "IC_kwDOABII586vdpLd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2943783645",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-05T11:17:11Z",
      "updated_at": "2025-06-05T11:17:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nI've differentially [fuzzed](https://github.com/marcofleon/bitcoin/blob/084d430dcb87e708e0fc9a65dc3d0c4d1f468f85/src/test/fuzz/block_index_diff.cpp) `BlockTreeDB` and `BlockTreeStore` for ~5000 cpu hours so far and no issues. Happy to continue testing (differentially fuzzing or otherwise) once the final approach is implemented.",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2943783645",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18062512338,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAQ0nBDS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18062512338",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "edab2627022de7bd27399e1e3fee9104207270f3",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/edab2627022de7bd27399e1e3fee9104207270f3",
      "created_at": "2025-06-09T20:37:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18062546769,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAQ0nJdR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18062546769",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fcf3cb1d561355de26de62def90c2dfaa0e436e4",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/fcf3cb1d561355de26de62def90c2dfaa0e436e4",
      "created_at": "2025-06-09T20:39:50Z"
    },
    {
      "event": "labeled",
      "id": 18062549017,
      "node_id": "LE_lADOABII5861YR-zzwAAAAQ0nKAZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18062549017",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-09T20:40:00Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2956979334,
      "node_id": "IC_kwDOABII586wP-yG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2956979334",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-09T20:40:02Z",
      "updated_at": "2025-06-09T20:40:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/runs/43761651546</sub>\n<sub>LLM reason (âœ¨ experimental): The CI failure is caused by a lint test error.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2956979334",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18062615517,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAQ0naPd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18062615517",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eecc29c77622c459428a52eecca7abe5e8865d34",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/eecc29c77622c459428a52eecca7abe5e8865d34",
      "created_at": "2025-06-09T20:45:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18062944145,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAQ0oqeR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18062944145",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ffc8a21f310a2030bb75c859878d40095234fc6e",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/ffc8a21f310a2030bb75c859878d40095234fc6e",
      "created_at": "2025-06-09T21:11:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18063089367,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAQ0pN7X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18063089367",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "155afe8529a611c3dcb3fb76101abd01020a24ea",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/155afe8529a611c3dcb3fb76101abd01020a24ea",
      "created_at": "2025-06-09T21:24:21Z"
    },
    {
      "event": "unlabeled",
      "id": 18064142696,
      "node_id": "UNLE_lADOABII5861YR-zzwAAAAQ0tPFo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18064142696",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-09T23:02:08Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2957923761,
      "node_id": "IC_kwDOABII586wTlWx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2957923761",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-10T07:08:28Z",
      "updated_at": "2025-06-10T07:08:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "The latest push updates the block tree store to use a write ahead log for atomic writes, and crc32c checksums to detect data corruption. As mentioned, taking this out of draft again.\r\n\r\nDid not spend too much time yet on evaluating the various proposals for reforming block storage yet, but I am warming up to the idea. I still think it is largely orthogonal to the work here, besides potentially needing another change to the data serialization.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-2957923761",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "ready_for_review",
      "id": 18068465717,
      "node_id": "RFRE_lADOABII5861YR-zzwAAAAQ09ug1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18068465717",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-10T07:08:30Z"
    },
    {
      "event": "comment_deleted",
      "id": 18367154205,
      "node_id": "CDE_lADOABII5861YR-zzwAAAARGxIgd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18367154205",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-28T04:14:02Z"
    },
    {
      "event": "comment_deleted",
      "id": 18367154569,
      "node_id": "CDE_lADOABII5861YR-zzwAAAARGxImJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18367154569",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-28T04:14:06Z"
    },
    {
      "event": "labeled",
      "id": 18492339439,
      "node_id": "LE_lADOABII5861YR-zzwAAAAROOrTv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18492339439",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-06T15:38:41Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3042013943,
      "node_id": "IC_kwDOABII5861UXL3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3042013943",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-06T15:38:43Z",
      "updated_at": "2025-07-06T15:38:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `tidy`: https://github.com/bitcoin/bitcoin/runs/43764366691</sub>\n<sub>LLM reason (âœ¨ experimental): Compilation failed due to errors caused by ignoring return values of 'nodiscard' functions, triggering compile-time errors with -Werror.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-3042013943",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18493666189,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAROTvON",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18493666189",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "80810b6011e30ac5ff72c43a2fbfd0e13df0c4cc",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/80810b6011e30ac5ff72c43a2fbfd0e13df0c4cc",
      "created_at": "2025-07-06T20:46:16Z"
    },
    {
      "event": "commented",
      "id": 3042550496,
      "node_id": "IC_kwDOABII5861WaLg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3042550496",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-06T20:46:23Z",
      "updated_at": "2025-07-06T20:46:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 155afe8529a611c3dcb3fb76101abd01020a24ea -> 80810b6011e30ac5ff72c43a2fbfd0e13df0c4cc ([blocktreestore_0](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_0) -> [blocktreestore_1](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_1), [compare](https://github.com/TheCharlatan/bitcoin/compare/blocktreestore_0..blocktreestore_1))\r\n\r\n* Fixed silent merge conflict with #29307",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-3042550496",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18493807655,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAROURwn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18493807655",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "98a34dd55ac32f323b297bb6d77eefe096f27074",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/98a34dd55ac32f323b297bb6d77eefe096f27074",
      "created_at": "2025-07-06T21:19:04Z"
    },
    {
      "event": "unlabeled",
      "id": 18494125431,
      "node_id": "UNLE_lADOABII5861YR-zzwAAAAROVfV3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18494125431",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-06T22:16:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 18515756824,
      "node_id": "LE_lADOABII5861YR-zzwAAAARPoAcY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18515756824",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-08T01:53:47Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18546499697,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAARRdSBx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18546499697",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/254d0a75b50b0eaf91003ea8a0534981ec740090",
      "created_at": "2025-07-09T13:27:03Z"
    },
    {
      "event": "commented",
      "id": 3052676701,
      "node_id": "IC_kwDOABII58619CZd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3052676701",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-09T13:27:08Z",
      "updated_at": "2025-07-09T13:27:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 98a34dd55ac32f323b297bb6d77eefe096f27074 -> 254d0a75b50b0eaf91003ea8a0534981ec740090 ([blocktreestore_1](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_1) -> [blocktreestore_2](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_2), [compare](https://github.com/TheCharlatan/bitcoin/compare/blocktreestore_1..blocktreestore_2))\r\n\r\n* Fixed conflict with #32835",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-3052676701",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "unlabeled",
      "id": 18547218513,
      "node_id": "UNLE_lADOABII5861YR-zzwAAAARRgBhR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18547218513",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-09T14:04:26Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2822815289,
      "node_id": "PRR_kwDOABII586oQL45",
      "url": null,
      "actor": null,
      "commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-28T17:29:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK, not yet sure about the approach\r\n\r\n### LevelDB migration\r\n\r\nMoving away from unmaintained LevelDB makes sense and aligns with other modularization and optimization efforts.\r\nWhether that means switching to SQLite or a custom solution like this one is debatable, but removing LevelDB already paves the way for further migrations - which still seem somewhat taboo at this point.\r\n\r\nBefore merging something like this, I'd be interested in seeing a full migration story (including other indexes, blocks, and the UTXO set). Otherwise, we risk supporting multiple formats indefinitely. Happy to help with that.\r\n\r\n### Migration mechanism\r\n\r\nDo we need a big-bang migration, or would an on-demand, copy-on-first-touch scheme (with an optional background migrator) also work?\r\nWe'd simply check the new location first, and if missing, migrate, delete the old entry, and serve from the new location - until all migration is done.\r\nThis would avoid delays at startup, wouldn't require doubling the space usage of the full index (only the entries in flight), and could be reused for future migrations.\r\nIt could also allow us to perform *both* operations for a while, comparing that we're always reading/writing the **exact** same data. Could be enabled on CI + background fuzzing for a few months before merging.\r\n\r\n### Code structure\r\n\r\nThe first commit currently does everything. I understand it's a draft/RFC, but it would help reviewers if the commits told a story through small, focused steps.\r\n\r\nWe're also missing dedicated data structures for the new feature (with serialization, validation, etc.). Right now, the logic seems scattered across unrelated parts of the codebase.\r\n\r\nThere's also heavy repetition: magic/version checks, CRC validation, WAL record sizing. We could introduce these incrementally in separate commits, possibly splitting out helpers that could be reused elsewhere into separate refactor PRs.\r\n\r\nThe tests seem to cover a lot of ground, but I didn't see many negative cases (e.g. invalid headers), nothing with `wipe_block_tree_data = true`, and I'm not sure migration, pruning, and reorgs are covered.\r\n\r\n### Questions & notes\r\n\r\n* I understand it's not strictly part of this PR, but I agree with Sjors that we should consider letting the filesystem handle some of this. The downside is that OSs behave differently - some nodes could break simultaneously if we hit file handle or filesystem limits that we haven't tested for. This assumes there even is an OS (i.e. not bare metal).\r\n  * How much extra space would this cost (considering 32/64-bit platforms, various I/O-caching filesystems, file permission attributes, fragmentation)?\r\n  * If we stored blocks separately, could we redownload only corrupted ones in parallel - even for missing pruned blocks?\r\n  * We might also want to investigate block compression - it looked like we could gain \\~20%, although maybe only when we already have all blocks.\r\n  * Can we design this to avoid duplication? Currently we duplicate most block data in the chainstate index. Are we planning to make the blocks indexable, so we can locate a script by offset instead of storing it in the index (at least for non-pruned nodes)? This might be relevant if future migrations depend on how this one is structured.\r\n* Related to Russ's concerns: are the integrity checks meant to guard against accidental bit-rot only, or also malicious tampering? Or do we assume physical access means full compromise?\r\n* I don't yet understand pruned behavior (this may be orthogonal, feel free to ignore): what should happen if a node is asked for a block that's about to be deleted?\r\n* You mentioned that \"no entry is ever deleted\", but I'm not yet sure how that holds under reorgs.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#pullrequestreview-2822815289",
      "submitted_at": "2025-07-28T17:29:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
    },
    {
      "event": "labeled",
      "id": 18890947480,
      "node_id": "LE_lADOABII5861YR-zzwAAAARl_PuY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18890947480",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-30T04:27:06Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 18893989112,
      "node_id": "UNLE_lADOABII5861YR-zzwAAAARmK2T4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18893989112",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-30T08:24:17Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 19211286996,
      "node_id": "LE_lADOABII5861YR-zzwAAAAR5FPnU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19211286996",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-18T20:25:53Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19239844562,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAAR6yLrS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19239844562",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d35ceaeb463bc836ac4fc4bd6dd4f387647f33fb",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/d35ceaeb463bc836ac4fc4bd6dd4f387647f33fb",
      "created_at": "2025-08-20T07:52:35Z"
    },
    {
      "event": "commented",
      "id": 3204696862,
      "node_id": "IC_kwDOABII586_A8se",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3204696862",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T07:52:44Z",
      "updated_at": "2025-08-20T07:52:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the review @l0rinc!\r\n\r\nRebased 254d0a75b50b0eaf91003ea8a0534981ec740090 -> fc07ce3718b5b8cc168ab634885e0317b9621e8c ([blocktreestore_2](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_2) -> [blocktreestore_3](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_3), [compare](https://github.com/TheCharlatan/bitcoin/compare/blocktreestore_2..blocktreestore_3))\r\n\r\nUpdated fc07ce3718b5b8cc168ab634885e0317b9621e8c -> d35ceaeb463bc836ac4fc4bd6dd4f387647f33fb ([blocktreestore_3](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_3) -> [blocktreestore_4](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_4), [compare](https://github.com/TheCharlatan/bitcoin/compare/blocktreestore_3..blocktreestore_4))\r\n\r\n* The review comments are addressed inline, the change also includes some other smaller cleanups.\r\n\r\nRe https://github.com/bitcoin/bitcoin/pull/32427\r\n\r\n> Before merging something like this, I'd be interested in seeing a full migration story (including other indexes, blocks, and the UTXO set). Otherwise, we risk supporting multiple formats indefinitely. Happy to help with that.\r\n\r\nI have no intention of moving any of the other dbs away from leveldb at this point in time. Currently this PR serves as a basis for a bunch of other applications that leverage its additional capability for allowing other applications to read block data in parallel.\r\n\r\n> Do we need a big-bang migration, or would an on-demand, copy-on-first-touch scheme (with an optional background migrator) also work?\r\n\r\nThe current migration delay is pretty much negligible compared to normal startup times. Once migrated, startup is significantly faster. \r\n\r\n> I'm not sure migration, pruning, and reorgs are covered.\r\n\r\nThis still needs a functional test for the migration, but pruning should be covered through existing tests and reorgs are not really relevant for this, since they only influence the chain and not the topology of the block tree.\r\n\r\n> You mentioned that \"no entry is ever deleted\", but I'm not yet sure how that holds under reorgs.\r\n\r\nDuring a reorg we change the contents of the  `Chain` data structure, i.e. we remove pointers to the block tree and add others back again. The topology of the block tree in `m_block_index` is not changed.\r\n\r\n> What should happen if a node is asked for a block that's about to be deleted?\r\n\r\nThis behaviour is not changed in this PR and is already correctly handled in net_processing and with our prune locks. I think a similar approach would still be possible if we do one-block-one-file.\r\n\r\n> are the integrity checks meant to guard against accidental bit-rot only, or also malicious tampering? Or do we assume physical access means full compromise?\r\n\r\nThe CRC checks are only for data integrity. The should guard against data corruption.\r\n\r\nI have also briefly looked at how this might be related to a one-block-one-file approach. I think one possibility could be to store and read the header directly alongside the block in the same file. While it is not clear to me yet what we'd do with the rest of the `CBlockIndex` data, a clear downside of this is that at startup we'd have to read the headers from a million files, which is much slower than reading everything from a contiguous, single file. I tried benching this a bit and my startup times went from around six seconds (this PR) to around a minute.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-3204696862",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "mentioned",
      "id": 19239847532,
      "node_id": "MEE_lADOABII5861YR-zzwAAAAR6yMZs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19239847532",
      "actor": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T07:52:46Z"
    },
    {
      "event": "subscribed",
      "id": 19239847573,
      "node_id": "SE_lADOABII5861YR-zzwAAAAR6yMaV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19239847573",
      "actor": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T07:52:46Z"
    },
    {
      "event": "unlabeled",
      "id": 19241570471,
      "node_id": "UNLE_lADOABII5861YR-zzwAAAAR64xCn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19241570471",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-20T09:22:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 19479474025,
      "node_id": "LE_lADOABII5861YR-zzwAAAASJES9p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19479474025",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-03T10:46:42Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc5OTRjZDgxOWNhOGI1OWU3NjczZDZkZGZhNzQwZjliYzUxNzA2NTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7994cd819ca8b59e7673d6ddfa740f9bc5170656",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7994cd819ca8b59e7673d6ddfa740f9bc5170656",
      "tree": {
        "sha": "0ff20c7b244a11ec0cc35f63680a39d5e54726c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ff20c7b244a11ec0cc35f63680a39d5e54726c2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0ff20c7b244a11ec0cc35f63680a39d5e54726c2\nparent 2562fe1b2b63c3a510735ba417935340d533a844\nauthor TheCharlatan <seb.kung@gmail.com> 1746200542 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1756990001 +0200\n\nkernel: Add blocktreestorage module\n\nThe BlockTreeStore introduces a new data format for storing block\nindexes and headers on disk. The class is very similar to the existing\nCBlockTreeDB, which stores the same data in a leveldb database. Unlike\nCBlockTreeDB, the data stored through the BlockTreeStore is directly\nserialized and written to flat .dat files. The storage schema introduced\nis simple. It relies on the assumption that no entry is ever\ndeleted and that no duplicate entries are written. These assumptions\nhold for the current users of CBlockTreeDB.\n\nIn order to efficiently update a CBlockIndex entry in the store, a new\nfield is added to the class that tracks its position in the file. New\nserialization wrappers are added for both the CBlockIndex and\nCBlockFileInfo classes to avoid serializing integers as VARINT. Using\nVARINT encoding would make updating these fields impossible, since\nchanging them might overwrite existing entries in the file.\n\nThe new store supports atomic writes by using a write ahead log. Boolean\nflags are persisted through the (non-)existence of certain files. Data\nintegrity is verified through the use of crc32c checksums on each data\nentry.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n\nAlso make flags based on file existence, instead of complicated boolean\nfields. This makes the operations atomic.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmi5ijEACgkQm3m0VpHb\nQXNT3g//QighFfp8OnGzmrhmy+EJWX4CXics7lvo+MTqyss50SJpJEmHIHWIHqCh\njW84RaOs3TKER+MZjhZ3U2UmYk2n18EDRGw0Fi28Ivy/IKPgm+tGdBkMkylODsCp\nSzyrHg8CJGpk+qc3SlHgtK1TTIaKBNCqt7pLH13zH8G7uBtJR9vipAfP0kRgL1N0\nv97iueC8VN1vS4R+jQIgJqgYSU8Gyc7dh8Ji9i6QwLZbyvCtQV4fUyAG6cHWwXNC\nOU2P4KLShJTy9XhTGDW0QkyF2KkvNXArJqQgP6dMU6+x5tEXjk95PGda+tE8HeNd\nzwXOHCN+jaJ1YFd9AecNQB0WTHGvvJNl8n0WCHRWbza32idrYh32QDRhPL5/Zt0e\n4wdSWVupFYzLZQHXrxCQJprS+aLiwct1IR6QcbiE55g95B19ANx7890U62mX55fG\nu1BOKCjXE12s36DHlXXOoZFBNle7vAHgT8gGPl6OoJc0mSceYAsnxMWHx01MIyIT\nJl/72ke24c0mCNoQAH2Fnn9SDjaDgIxP5Zxr8r3mmJWfdFSH26R+JQQHLkPow10w\nRYY9xOn8t3MYN5e2IORhHilZ56bk8N/SqpODG6UIWkDAxYhsiUS77CNmfvKwc/uI\nmxDiAl1ZMcnMEAU4MdF6FIOrmfEstmhHWF3hyofALGbHJb4p9Gw=\n=BRyO\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2562fe1b2b63c3a510735ba417935340d533a844",
          "sha": "2562fe1b2b63c3a510735ba417935340d533a844",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2562fe1b2b63c3a510735ba417935340d533a844"
        }
      ],
      "message": "kernel: Add blocktreestorage module\n\nThe BlockTreeStore introduces a new data format for storing block\nindexes and headers on disk. The class is very similar to the existing\nCBlockTreeDB, which stores the same data in a leveldb database. Unlike\nCBlockTreeDB, the data stored through the BlockTreeStore is directly\nserialized and written to flat .dat files. The storage schema introduced\nis simple. It relies on the assumption that no entry is ever\ndeleted and that no duplicate entries are written. These assumptions\nhold for the current users of CBlockTreeDB.\n\nIn order to efficiently update a CBlockIndex entry in the store, a new\nfield is added to the class that tracks its position in the file. New\nserialization wrappers are added for both the CBlockIndex and\nCBlockFileInfo classes to avoid serializing integers as VARINT. Using\nVARINT encoding would make updating these fields impossible, since\nchanging them might overwrite existing entries in the file.\n\nThe new store supports atomic writes by using a write ahead log. Boolean\nflags are persisted through the (non-)existence of certain files. Data\nintegrity is verified through the use of crc32c checksums on each data\nentry.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n\nAlso make flags based on file existence, instead of complicated boolean\nfields. This makes the operations atomic.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-04T12:46:41Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-05-02T15:42:22Z"
      },
      "sha": "7994cd819ca8b59e7673d6ddfa740f9bc5170656"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU4OTBlYzRmNGNhZTE2YTQ4Njk3NTAyN2UzOTlhY2M5YzM1N2FmZGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e890ec4f4cae16a486975027e399acc9c357afdd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e890ec4f4cae16a486975027e399acc9c357afdd",
      "tree": {
        "sha": "b2fceea17cc344b64b9843e83c6f068e36a2775a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b2fceea17cc344b64b9843e83c6f068e36a2775a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b2fceea17cc344b64b9843e83c6f068e36a2775a\nparent 7994cd819ca8b59e7673d6ddfa740f9bc5170656\nauthor TheCharlatan <seb.kung@gmail.com> 1746279594 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1756990003 +0200\n\nfuzz: Use BlockTreeStore in block index fuzz test\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmi5ijMACgkQm3m0VpHb\nQXMLJQ/8DnbPK4p77RqUtmDRML7Os4OiTJwFL/p/1sHsnXqA8cEnn2CWDDmcK77Z\n/tPs2q3KWm7qNWs4c/Wg0Eup7Ssmo/JRn3hKWXPDBNcougggZekUgbsS/P66TFlO\nYSnJvQeENB9t06HZbB9oHvzSbNg8Gv/KbZYRSpxJKi7PW4nTp31alQkvpGIyge4t\nvEPKMCXwFGMhDRd9cDopZnaMgy9BKKHLi2oeou3JKu4o0KXZ+CfJgDZqio6emXkW\n/UnBMlFuZX55OV2jmyeU8Xx8GqU5lWioolHaQzV/gvQW4QWCkL8QY5Twx0TTRGC2\nR6le5E6G+u7Zisp/Iwk9aHlwt3E8Zj6QzM2TNbmWkC2P7ilqqre3ZKQUL4EU3ml0\nvWiGUKw2RMy+rHjUuv+SSMNU9OK8f/34eInjto5R5KHmzf2F/6BgOXdETrwTv5Zy\nrWtgONfv0CTPubytcI8s4IznjSWF95EI+i0JE1Es1/2mnBGxJDmDZGrUlqW5rwGo\n96GH4V8X59X8lDZovAMPFlF3pz7pJicevI5Mp9YR0jIbRIKJzaAtwINSUBBiQctG\n1/09gwoy2PAc7fyqXm76g7bTbaDs09IyNmeOpJIn8y3Fq1mOpRmI++ETTrd1i5Nv\n6OeSuR7ygSd6yPyQ0ev9uTVv5ynFd/hHTBtH1lMHOl1kOqBo07g=\n=nQhO\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7994cd819ca8b59e7673d6ddfa740f9bc5170656",
          "sha": "7994cd819ca8b59e7673d6ddfa740f9bc5170656",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7994cd819ca8b59e7673d6ddfa740f9bc5170656"
        }
      ],
      "message": "fuzz: Use BlockTreeStore in block index fuzz test\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-04T12:46:43Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-05-03T13:39:54Z"
      },
      "sha": "e890ec4f4cae16a486975027e399acc9c357afdd"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZmMGRjNTQxYTg4ZmZkNzg1OWFkY2YyZTA0OWNkNTRjMzdhOTA4M2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f0dc541a88ffd7859adcf2e049cd54c37a9083b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6f0dc541a88ffd7859adcf2e049cd54c37a9083b",
      "tree": {
        "sha": "5ed66cf6bd695b8f2e552f6a541455482951cf02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ed66cf6bd695b8f2e552f6a541455482951cf02"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5ed66cf6bd695b8f2e552f6a541455482951cf02\nparent e890ec4f4cae16a486975027e399acc9c357afdd\nauthor TheCharlatan <seb.kung@gmail.com> 1746281020 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1756990005 +0200\n\nblockstorage: Replace BlockTreeDB with BlockTreeStore\n\nThis hooks up the newly introduced BlockTreeStore class to the actual\ncodebase. It also adds a migration function to migrate old leveldb block\nindexes to the new format on startup.\n\nThe migration first reads from leveldb (blocks/index), and writes it to\na BlockTreeStore in a separate migration directory (blocks/migration).\nOnce done, the original directory (blocks/index) is deleted and the\nmigration directory renamed to the original name.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmi5ijUACgkQm3m0VpHb\nQXPCfA/8D2BN/JoVdrj8S0lGlX4IKh5K4MJ58b9WfaolpP2/l+AQTIAOQ+fFBxBj\n2OTWcpOMI9doOQfQj/1n8zqcTKKHgPI2QOS7+l2pawFwRPutDW9XKoE9Sc3tlzHf\nufgXLlRHZ89XqVy7BCgFPu5ry4psOYROrbIbIlMrQTfIpkws0A6v6BRFZcjEuofe\nlxNPGyZ+XwfzDppTpc3S67xmAPEiQaLdOXQiAGnBWwPEIuOn0JJ0wSm6wJZxHI83\nczu2JXnvxus6xEjyQ86eqvautU6qhiXLWcT8901rddhGPQOdugHbEehIjOiLx9mx\n1bfuR5eIEcf2pbCk2gcjP1bFgNjqju0kElruwJbG/pwhRUMiFSSsfa/LasgsAuCO\nHpbdHua5Au/yzhBjScKmvqIsJYSguHF1jcEw8WTNtu8/eJh/FHiVnQXTqMQq1Bcb\n/FQmAa03H6p28EiR3LMZjYExMHF6KTn4g+HsjEHgYZg9sMolvFY35RPElJ7bYPzB\n5nwxfRNO+ZPbkeMBJUZs1UDatAQziduEk6dd7AAR1TyZm0U2fnSyjRg5tS6VfZkp\nFfeM52OaB12u9iNZtmzxc5foOwmMu4pZS3VGjPQ5f2iLgkSFr/UgTMx6g+3Ocj/u\nX9Bcd5xf2u4nEfQphB9WphI/7sx2XP0mvWLPWj7ykAgsrZmNX08=\n=IYOa\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e890ec4f4cae16a486975027e399acc9c357afdd",
          "sha": "e890ec4f4cae16a486975027e399acc9c357afdd",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e890ec4f4cae16a486975027e399acc9c357afdd"
        }
      ],
      "message": "blockstorage: Replace BlockTreeDB with BlockTreeStore\n\nThis hooks up the newly introduced BlockTreeStore class to the actual\ncodebase. It also adds a migration function to migrate old leveldb block\nindexes to the new format on startup.\n\nThe migration first reads from leveldb (blocks/index), and writes it to\na BlockTreeStore in a separate migration directory (blocks/migration).\nOnce done, the original directory (blocks/index) is deleted and the\nmigration directory renamed to the original name.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-04T12:46:45Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-05-03T14:03:40Z"
      },
      "sha": "6f0dc541a88ffd7859adcf2e049cd54c37a9083b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdkZDU1OTkzZDg3NWViOTNhMTE5MGJjYzE2MDU2OWUwN2QyODEzMWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dd55993d875eb93a1190bcc160569e07d28131b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7dd55993d875eb93a1190bcc160569e07d28131b",
      "tree": {
        "sha": "583e37456a2cb9a8cc95508a868ec4a5a6bf895c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/583e37456a2cb9a8cc95508a868ec4a5a6bf895c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 583e37456a2cb9a8cc95508a868ec4a5a6bf895c\nparent 6f0dc541a88ffd7859adcf2e049cd54c37a9083b\nauthor TheCharlatan <seb.kung@gmail.com> 1746177840 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1756990006 +0200\n\nkernel: Remove block tree db params\n\nThese are no longer needed after the migration to the new\nBlockTreeStore. The cache for the block tree db is also no longer\nneeded, so grant what has been freed up to the coins db.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmi5ijYACgkQm3m0VpHb\nQXPGjw/7BXza7Uo3rcBx6JYP0Xkg6Tl1XoI3BLV0HxbBipqbqOdTB9FWWHWnRGpl\nOevIOriW4EP1g8IFXB6WdzTb+QUvRH6ymDFEjghAkeiXiBgCDQULs4wGUzqK6Lp4\nAr/g6KPu5yrCQ0vPZRLXBoeY+LN4dTvOLLsCKatWSq1oJ6jw5+S5pCq8Ps5EmuOD\nx8o75JUExaxPnSVn3U6dNjcLaIu4XDBQckCJ62YR7OuizTQIF0G3grDeisR0utgR\nm1VRhp+Hv0EuWLINz2r45VNeOAb8VdrWM65GB6MUWjnRIudL6+QBwZ75AU+BoWac\n4O+TaEjPPDz4QC1a0Igz4/1Aq7KuNDEMGongupbQBxAl02ff4m7w1rBs5vMm9m3m\nInpampB1jA7bl0E/O44XkVSziMMmiVFDrRzgDfD6JiGtMLSF7+NwDjgQ3C4cLSWk\nfQdRWjFevC2OXhYHcVZkHRio+rhBVOB2+uGquGv5jJ6PNIh++1jO4nmO9vZ/a0Fq\nfdkByhtFnwZElMHniAx33XmPthQ0kVIqiQpOsYZ1JzQJHm/bT12UzHPDt9wQ/CeB\nuZW+v3jvHwhrMqdEpAAM9ap2G9gktIK9E5cnnMLdEq1UEpXeHkwkzsRM3AuGZdCx\nkpJCxHr8OfMaxFxiTrMF4Kp2A2gX3u2m+zCdd1/q51L5jvxvei0=\n=UlL4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f0dc541a88ffd7859adcf2e049cd54c37a9083b",
          "sha": "6f0dc541a88ffd7859adcf2e049cd54c37a9083b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6f0dc541a88ffd7859adcf2e049cd54c37a9083b"
        }
      ],
      "message": "kernel: Remove block tree db params\n\nThese are no longer needed after the migration to the new\nBlockTreeStore. The cache for the block tree db is also no longer\nneeded, so grant what has been freed up to the coins db.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-04T12:46:46Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-05-02T09:24:00Z"
      },
      "sha": "7dd55993d875eb93a1190bcc160569e07d28131b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM0MWQ2YTJjNTA2ZTFlYmM1YTA5ZjNjYTQ0NDRkNWU3OGIyMTlhYmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/341d6a2c506e1ebc5a09f3ca4444d5e78b219aba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/341d6a2c506e1ebc5a09f3ca4444d5e78b219aba",
      "tree": {
        "sha": "d34b866c195c78cd145920bf0cff56e1cfb709a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d34b866c195c78cd145920bf0cff56e1cfb709a1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d34b866c195c78cd145920bf0cff56e1cfb709a1\nparent 7dd55993d875eb93a1190bcc160569e07d28131b\nauthor TheCharlatan <seb.kung@gmail.com> 1746281806 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1756990228 +0200\n\nkernel: Add assumed header store to chainparams\n\nAdds constants for pre-allocating the file size of the header storage\nfile in the BlockTreeStore. The chosen constants leave a bit of extra\nspace beyond the actual requirement. They may be updated on every\nrelease, though it is also not a strict requirement to do so.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmi5ixUACgkQm3m0VpHb\nQXParQ//XIqixo2ROvblM1G+KfDOVyZC1cGUvBHIbmYz1XQ5L9cGo89J26ttlwE6\ns+1Js0HIy4vFnPnuk/qT7Bu+NS/emM33CGpVGOSbYvYwIWhjwZHr2EClgTO+rA9A\n6IF5yTz+on952fAGsk6ZYs1tcmwSwg39ZWegdwauewqPvA/iTc8O5Wpm/t7/HkCt\nUKK+mIK52S7D+eBj3sxuMItkghylXpC4TTYsMm7mDUroV9aNU1x3YFBQHhk2sESI\n0vQnRk4MZ9NN3AXU1mAsrkr5y2fMnbN8Q3hdn4Svy/X7HXv20kwgk7gNRvXqvr3l\nZ9utR/TJggEKNpmdODzb2bEZUWqbTk9tlW7PzSiLCXM4e5m30EkgQXwvs8+wuoP+\nfJWXy3+68Iqjj2kRKWLBIF+ML+XjG8fnA6tqIzqa4OxFu44gLz+pwmwP1TIp49cY\nfEboWFlp4dfjKtVEEoVEPwQ2y0wVfFAUtf4YoEobmGeM9dbr2V/6F9ucLDuLOG73\n1vokOoRCi2bMu8fksiCF4NaaM33zkI0oa1IiHut5jfE+6MiBkPE4G0Jnh4r8jMm5\ng1+aqX7+nt787PCB3s3FbVOWZ8KBUs/0DCFLdseIpPuGyIInF3qpcBPx4gQSNRLt\nLqfJi8YynNcBMRovs+wULedGw/Fhb9MTQdTckhXST49Wb25UpfI=\n=pdgM\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7dd55993d875eb93a1190bcc160569e07d28131b",
          "sha": "7dd55993d875eb93a1190bcc160569e07d28131b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7dd55993d875eb93a1190bcc160569e07d28131b"
        }
      ],
      "message": "kernel: Add assumed header store to chainparams\n\nAdds constants for pre-allocating the file size of the header storage\nfile in the BlockTreeStore. The chosen constants leave a bit of extra\nspace beyond the actual requirement. They may be updated on every\nrelease, though it is also not a strict requirement to do so.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-04T12:50:28Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-05-03T14:16:46Z"
      },
      "sha": "341d6a2c506e1ebc5a09f3ca4444d5e78b219aba"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRhZjBlOWEzZDQ1ZjQyODg5ZmM1ODk1ZmM1ODBjNzNkMDYwZDI3MTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "tree": {
        "sha": "a58881485b40cb03107fcdf31f23efd48231aa1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a58881485b40cb03107fcdf31f23efd48231aa1c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a58881485b40cb03107fcdf31f23efd48231aa1c\nparent 341d6a2c506e1ebc5a09f3ca4444d5e78b219aba\nauthor TheCharlatan <seb.kung@gmail.com> 1746349898 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1756990231 +0200\n\nblockstorage: Remove BlockTreeDB dead code\n\nThis is not called by anything anymore, so just remove it.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmi5ixcACgkQm3m0VpHb\nQXMt4xAAiYAB5HM12a+3pU/trm2m9lY5cQR7+vY12gpIpTAto5HadMZ5+lJDutRx\nZIx1DplfL6KvyixFvYF0yRGTfUdZkOSEljP5fzeLoMOuOwUpXYXYR6COQ7lZPzfm\nmhpGZFOI1sTUAjdjnF2VN2gUwmmltMueb0e4fA3iiIKEIUys/ENY/J3xskw8Ol66\ndOxlEDe2DshUBy2TKdNZw4sDxMAtmwdFpa3HUjqxyV1uWJrtVsBrlyrbOqO3oToI\nYBAZ2/UxkAhMku1A32c5vnQJUlogSM33zW95BzCbmVuGhr5HSd5G67XfKQmzNK4G\ng97tH/7RkKNU10IykcAFx0M/xawZKytxvJf8pvnaEMAzu1SVuu6PAyWpCgIVzabo\ni8lWXeUm5Fe7k/4mR5wAthaLTXULYfjRPcZ777TTkEGDKtuj8mz63sh5bVRbNLW9\nIC5uxF/pHFiQ+uLDyYYBTea19NFjCigVuq31pfZezeMXC27uQXZzWwbW+7UYsyU/\n6Ym7IFT46pQgE6oaq11+EJ8cwtKolOiRFPTaO7eI7h1ko6NjN5F/y8cdzz0/U81H\nWe0fjCQhnk02N6j4K3Q1/4t1+Iq2IdxOT5jfg/1XXUvZRTofGw5y+iS6/qbPoWxU\nVaSHPcCDvCj3VNzBEdG1AnozSZZ+JyDMdhX9j1IfR2RMSqPusLE=\n=VZnp\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/341d6a2c506e1ebc5a09f3ca4444d5e78b219aba",
          "sha": "341d6a2c506e1ebc5a09f3ca4444d5e78b219aba",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/341d6a2c506e1ebc5a09f3ca4444d5e78b219aba"
        }
      ],
      "message": "blockstorage: Remove BlockTreeDB dead code\n\nThis is not called by anything anymore, so just remove it.\n\nThis commit is part of a series to replace the leveldb database\ncurrently used for storing block indexes and headers with a flat file\nstorage. This is motivated by the kernel library, where the usage of\nleveldb is a limiting factor to its future use cases. It also offers better\nperformance and has a smaller on-disk footprint, though this is mostly\nnegligible in the grand scheme of things.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-04T12:50:31Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-05-04T09:11:38Z"
      },
      "sha": "daf0e9a3d45f42889fc5895fc580c73d060d2711"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19504837299,
      "node_id": "HRFPE_lADOABII5861YR-zzwAAAASKlDKz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19504837299",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "created_at": "2025-09-04T13:26:28Z"
    },
    {
      "event": "commented",
      "id": 3253719585,
      "node_id": "IC_kwDOABII587B79Ih",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3253719585",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T13:26:31Z",
      "updated_at": "2025-09-04T13:26:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased d35ceaeb463bc836ac4fc4bd6dd4f387647f33fb -> daf0e9a3d45f42889fc5895fc580c73d060d2711 ([blocktreestore_4](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_4) -> [blocktreestore_5](https://github.com/TheCharlatan/bitcoin/tree/blocktreestore_5), [compare](https://github.com/TheCharlatan/bitcoin/compare/blocktreestore_4..blocktreestore_5))\r\n\r\n* Fixed conflict with #33274",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#issuecomment-3253719585",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32427"
    },
    {
      "event": "unlabeled",
      "id": 19507693075,
      "node_id": "UNLE_lADOABII5861YR-zzwAAAASKv8YT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19507693075",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-04T15:20:10Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234044885",
      "pull_request_review_id": 2822815289,
      "id": 2234044885,
      "node_id": "PRRC_kwDOABII586FKNHV",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 47,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: The comment repeats the code and has a typo; consider deleting or expanding with a rationale.",
      "created_at": "2025-07-27T16:10:24Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234044885",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234044885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234045732",
      "pull_request_review_id": 2822815289,
      "id": 2234045732,
      "node_id": "PRRC_kwDOABII586FKNUk",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 93,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\r\n```",
      "created_at": "2025-07-27T16:13:04Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234045732",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234045732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234046260",
      "pull_request_review_id": 2822815289,
      "id": 2234046260,
      "node_id": "PRRC_kwDOABII586FKNc0",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 105,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It seem we need this in multiple places, maybe we could add a sub-helper, something like:\r\n```C++\r\nvoid BlockTreeStore::CheckMagicAndVersion() const\r\n{\r\n    auto check{[](const fs::path& path, uint32_t magic_expected, uint32_t version_expected) {\r\n        AutoFile file{fsbridge::fopen(path, \"rb\")};\r\n        if (file.IsNull()) {\r\n            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\", fs::PathToString(path)));\r\n        }\r\n        if (auto magic{ser_readdata32(file)}; magic != magic_expected) {\r\n            throw BlockTreeStoreError(strprintf(\"Invalid magic in %s: got 0x%08x\", fs::PathToString(path.filename()), magic));\r\n        }\r\n        if (auto version{ser_readdata32(file)}; version != version_expected) {\r\n            throw BlockTreeStoreError(strprintf(\"Invalid version in %s: got %u\", fs::PathToString(path.filename()), version));\r\n        }\r\n    }};\r\n\r\n    check(m_header_file_path, HEADER_FILE_MAGIC, HEADER_FILE_VERSION);\r\n    check(m_block_files_file_path, BLOCK_FILES_FILE_MAGIC, BLOCK_FILES_FILE_VERSION);\r\n}\r\n```\r\nThe errors would look like:\r\n* > [error] Unable to open file .../bitcoin/demo/blocks/migration/headers.dat\r\n* > [error] Invalid magic in headers.dat: got 0x2d5e2eb2\r\n* > [error] Invalid version in headers.dat: got 2\r\n----\r\n\r\nGiven that we're redoing something similar in multiple places, maybe we could extract these to static helper methods as well.",
      "created_at": "2025-07-27T16:15:05Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234046260",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234046260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 95,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234046538",
      "pull_request_review_id": 2822815289,
      "id": 2234046538,
      "node_id": "PRRC_kwDOABII586FKNhK",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 122,
      "original_position": 116,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: These asserts run at runtime, consider moving to a unit test to avoid overhead.",
      "created_at": "2025-07-27T16:16:08Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234046538",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234046538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": 121,
      "original_start_line": 115,
      "start_side": "RIGHT",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234046731",
      "pull_request_review_id": 2822815289,
      "id": 2234046731,
      "node_id": "PRRC_kwDOABII586FKNkL",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 124,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This may be a bit more desciptive:\r\n```suggestion\r\n    if (header_file_exists != block_files_file_exists) {\r\n```",
      "created_at": "2025-07-27T16:16:49Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234046731",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234046731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234048113",
      "pull_request_review_id": 2822815289,
      "id": 2234048113,
      "node_id": "PRRC_kwDOABII586FKN5x",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 68,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We could include the bad `value_type` in these errors:\r\n```suggestion\r\n    default:\r\n        throw BlockTreeStoreError(strprintf(\"Unrecognized value_type (%u) in block tree store\", value_type));\r\n    }\r\n```",
      "created_at": "2025-07-27T16:21:11Z",
      "updated_at": "2025-07-28T17:30:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234048113",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234048113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 67,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234048984",
      "pull_request_review_id": 2822815289,
      "id": 2234048984,
      "node_id": "PRRC_kwDOABII586FKOHY",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 56,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "To make sure the serialization stays stable (e.g when somebody renames one of them and reorders for some reason):\r\n```suggestion\r\nenum class ValueType : uint32_t {\r\n    LAST_BLOCK       = 0,\r\n    BLOCK_FILE_INFO  = 1,\r\n    DISK_BLOCK_INDEX = 2,\r\n    HEADER_DATA_END  = 3,\r\n};\r\n```",
      "created_at": "2025-07-27T16:23:58Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234048984",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234048984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 51,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234058517",
      "pull_request_review_id": 2822815289,
      "id": 2234058517,
      "node_id": "PRRC_kwDOABII586FKQcV",
      "diff_hunk": "@@ -161,6 +183,9 @@ class CBlockIndex\n     //! Byte offset within rev?????.dat where this block's undo data is stored\n     unsigned int nUndoPos GUARDED_BY(::cs_main){0};\n \n+    //! Byte offset within headers.dat where this block's header data is stored\n+    int64_t header_pos GUARDED_BY(::cs_main){0};",
      "path": "src/chain.h",
      "position": 33,
      "original_position": 34,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "How would this behave in case of a reorg when the block size differs from the previous one?\r\n\r\nnit: other positions were stored as unsigned",
      "created_at": "2025-07-27T16:54:11Z",
      "updated_at": "2025-07-28T17:31:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234058517",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234058517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234065617",
      "pull_request_review_id": 2822815289,
      "id": 2234065617,
      "node_id": "PRRC_kwDOABII586FKSLR",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 29,
      "original_position": 29,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "we don't have signed 64 bit reading/writing (we're casting to unsigned and back), would it be simpler to make this unsigned in the first place?",
      "created_at": "2025-07-27T17:17:11Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234065617",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234065617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234067471",
      "pull_request_review_id": 2822815289,
      "id": 2234067471,
      "node_id": "PRRC_kwDOABII586FKSoP",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 37,
      "original_position": 37,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I find this reading and writing back and forth confusing.\r\nWe could bring `checksum` and `data` closer to the first usage and maybe add more info to the error and reduce the scope of the variables we only need for validation, maybe something like:\r\n```C++\r\nstatic uint64_t ReadHeaderFileDataEnd(AutoFile& file)\r\n{\r\n    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\r\n    auto data_end{ser_readdata64(file)};\r\n    if (auto checksum{ser_readdata32(file)},\r\n        re_check{crc32c::Crc32c((DataStream{} << data_end << HEADER_FILE_DATA_END_POS).str())};\r\n        re_check != checksum) {\r\n        throw BlockTreeStoreError(strprintf(\"Header file data failed integrity check: got 0x%08x, expected 0x%08x\", re_check, checksum));\r\n    }\r\n    return data_end;\r\n}\r\n```\r\n\r\n-----\r\nAlternatively we could also have a header data structure which is read and written and skipped atomically.",
      "created_at": "2025-07-27T17:23:32Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234067471",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234067471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": 33,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234070173",
      "pull_request_review_id": 2822815289,
      "id": 2234070173,
      "node_id": "PRRC_kwDOABII586FKTSd",
      "diff_hunk": "@@ -412,6 +437,34 @@ class CDiskBlockIndex : public CBlockIndex\n     std::string ToString() = delete;\n };\n \n+struct DiskBlockIndexWrapper : public CDiskBlockIndex {\n+public:\n+    DiskBlockIndexWrapper() = default;",
      "path": "src/chain.h",
      "position": 1,
      "original_position": 45,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "isn't `public` implied?\r\n```suggestion\r\nstruct DiskBlockIndexWrapper : CDiskBlockIndex {\r\n    DiskBlockIndexWrapper() = default;\r\n```",
      "created_at": "2025-07-27T17:33:43Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234070173",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234070173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 440,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234071782",
      "pull_request_review_id": 2822815289,
      "id": 2234071782,
      "node_id": "PRRC_kwDOABII586FKTrm",
      "diff_hunk": "@@ -412,6 +437,34 @@ class CDiskBlockIndex : public CBlockIndex\n     std::string ToString() = delete;\n };\n \n+struct DiskBlockIndexWrapper : public CDiskBlockIndex {\n+public:\n+    DiskBlockIndexWrapper() = default;\n+\n+    explicit DiskBlockIndexWrapper(const CDiskBlockIndex* pindex) : CDiskBlockIndex(*pindex)\n+    {\n+    }\n+\n+    SERIALIZE_METHODS(DiskBlockIndexWrapper, obj)\n+    {\n+        LOCK(::cs_main);\n+        READWRITE(obj.nHeight);\n+        READWRITE(obj.nStatus);\n+        READWRITE(obj.nTx);\n+        READWRITE(obj.nFile);\n+        READWRITE(obj.nDataPos);\n+        READWRITE(obj.nUndoPos);\n+        READWRITE(obj.header_pos);\n+        // block header\n+        READWRITE(obj.nVersion);\n+        READWRITE(obj.hashPrev);\n+        READWRITE(obj.hashMerkleRoot);\n+        READWRITE(obj.nTime);\n+        READWRITE(obj.nBits);\n+        READWRITE(obj.nNonce);",
      "path": "src/chain.h",
      "position": 1,
      "original_position": 67,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`READWRITE` is a variadic macro, in many other cases we're batching these to avoid repetition, e.g.\r\nhttps://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L48, consider simplifying:\r\n```suggestion\r\n        READWRITE(obj.nHeight, obj.nStatus, obj.nTx, obj.nFile, obj.nDataPos, obj.nUndoPos, obj.header_pos);\r\n        READWRITE(obj.nVersion, obj.hashPrev, obj.hashMerkleRoot, obj.nTime, obj.nBits, obj.nNonce); // block header\r\n```\r\n\r\n---\r\n\r\nnit: wouldn't it make more sense to start with the header data (in case we need to read only that)?",
      "created_at": "2025-07-27T17:39:27Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234071782",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234071782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 451,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 464,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234074490",
      "pull_request_review_id": 2822815289,
      "id": 2234074490,
      "node_id": "PRRC_kwDOABII586FKUV6",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 149,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: \"Failed to close\" (verb phrase) is more consistent with other such messages.\r\nnit2: do we really care if we can't close after a successful commit?",
      "created_at": "2025-07-27T17:47:44Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234074490",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234074490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234075383",
      "pull_request_review_id": 2822815289,
      "id": 2234075383,
      "node_id": "PRRC_kwDOABII586FKUj3",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 206,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What's the reason for serializing this and `HEADER_FILE_DATA_START_POS` differently and not directly (like we do with other positions)?\r\n\r\nIf we keep it, consider simplifying:\r\n```suggestion\r\n    file << std::span{data};\r\n```",
      "created_at": "2025-07-27T17:50:09Z",
      "updated_at": "2025-07-28T17:32:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234075383",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234075383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234078009",
      "pull_request_review_id": 2822815289,
      "id": 2234078009,
      "node_id": "PRRC_kwDOABII586FKVM5",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 260,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As far as I can tell exceptions don't need trailing newline:\r\n```\r\n2025-07-27T17:57:41Z Loading block index db: last block file = 0\r\n2025-07-27T17:57:41Z [error] Unable to open file .../bitcoin/demo/blocks/index/headers.dat\r\n\r\n2025-07-27T17:57:41Z : Error loading databases.\r\n```\r\n\r\n(nit: the errors should likely reference `m_block_files_file_path` instead of `m_header_file_path`, but the mentioned helpers should take care of these problems)",
      "created_at": "2025-07-27T17:58:11Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234078009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234078009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234078377",
      "pull_request_review_id": 2822815289,
      "id": 2234078377,
      "node_id": "PRRC_kwDOABII586FKVSp",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 264,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: redundant comment, we already have everything in the code to deduce this",
      "created_at": "2025-07-27T17:59:26Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234078377",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234078377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234080721",
      "pull_request_review_id": 2822815289,
      "id": 2234080721,
      "node_id": "PRRC_kwDOABII586FKV3R",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 361,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: can we avoid the magic number (and comment explaining it) here?",
      "created_at": "2025-07-27T18:07:02Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234080721",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234080721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234081314",
      "pull_request_review_id": 2822815289,
      "id": 2234081314,
      "node_id": "PRRC_kwDOABII586FKWAi",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+            }\n+\n+            if (data_file.tell() != pos) {\n+                data_file.seek(pos, SEEK_SET);\n+            }\n+            stream.Rewind();\n+\n+            data_file << std::span<std::byte>{stream.data(), type_size};\n+            data_file << checksum;\n+            stream.clear();\n+            stream.resize(entry_size);\n+\n+            // TEST ONLY\n+            if (m_incomplete_log_apply) {\n+                (void)data_file.fclose();\n+                return false;\n+            }\n+        }\n+\n+        if (!data_file.Commit()) {\n+            LogError(\"Failed to commit write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+        if (data_file.fclose() != 0) {\n+            LogError(\"Failed to close after write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+    }\n+\n+    if (rolling_checksum != re_rolling_checksum) {\n+        throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+    }\n+\n+    (void)log_file.fclose();\n+    fs::remove(m_log_file_path);\n+    return true;\n+}\n+\n+bool BlockTreeStore::WriteBatchSync(const std::vector<std::pair<int, CBlockFileInfo*>>& fileInfo, int32_t last_file, const std::vector<CBlockIndex*>& blockinfo)\n+{\n+    AssertLockHeld(::cs_main);\n+    LOCK(m_mutex);\n+\n+    // Use a write-ahead log file that gets atomically flushed to the target files.\n+\n+    { // start log_file scope",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 423,
      "original_position": 440,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "seems a bit unconventional to do this, looks like a code smell - can we extract to a method instead, if we need RAII?",
      "created_at": "2025-07-27T18:08:50Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234081314",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234081314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 423,
      "original_line": 423,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234081861",
      "pull_request_review_id": 2822815289,
      "id": 2234081861,
      "node_id": "PRRC_kwDOABII586FKWJF",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+            }\n+\n+            if (data_file.tell() != pos) {\n+                data_file.seek(pos, SEEK_SET);\n+            }\n+            stream.Rewind();\n+\n+            data_file << std::span<std::byte>{stream.data(), type_size};\n+            data_file << checksum;\n+            stream.clear();\n+            stream.resize(entry_size);\n+\n+            // TEST ONLY\n+            if (m_incomplete_log_apply) {\n+                (void)data_file.fclose();\n+                return false;\n+            }\n+        }\n+\n+        if (!data_file.Commit()) {\n+            LogError(\"Failed to commit write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+        if (data_file.fclose() != 0) {\n+            LogError(\"Failed to close after write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+    }\n+\n+    if (rolling_checksum != re_rolling_checksum) {\n+        throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+    }\n+\n+    (void)log_file.fclose();\n+    fs::remove(m_log_file_path);\n+    return true;\n+}\n+\n+bool BlockTreeStore::WriteBatchSync(const std::vector<std::pair<int, CBlockFileInfo*>>& fileInfo, int32_t last_file, const std::vector<CBlockIndex*>& blockinfo)\n+{\n+    AssertLockHeld(::cs_main);\n+    LOCK(m_mutex);\n+\n+    // Use a write-ahead log file that gets atomically flushed to the target files.\n+\n+    { // start log_file scope\n+    FILE* raw_log_file{fsbridge::fopen(m_log_file_path, \"wb\")};\n+    if (!raw_log_file) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    size_t log_file_prealloc_size{fileInfo.size() * (BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE) + blockinfo.size() * (DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE)};",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 445,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We could extract these and reuse them, there's a lot of repetition here:\r\n```C++\r\nconstexpr size_t header_entry_size{DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE};\r\nsize_t log_file_prealloc_size{fileInfo.size() * (BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE) + blockinfo.size() * header_entry_size};\r\nstream.reserve(header_entry_size);\r\n```",
      "created_at": "2025-07-27T18:10:40Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234081861",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234081861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 445,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234099540",
      "pull_request_review_id": 2822815289,
      "id": 2234099540,
      "node_id": "PRRC_kwDOABII586FKadU",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+            }\n+\n+            if (data_file.tell() != pos) {\n+                data_file.seek(pos, SEEK_SET);\n+            }\n+            stream.Rewind();\n+\n+            data_file << std::span<std::byte>{stream.data(), type_size};\n+            data_file << checksum;\n+            stream.clear();\n+            stream.resize(entry_size);\n+\n+            // TEST ONLY\n+            if (m_incomplete_log_apply) {\n+                (void)data_file.fclose();\n+                return false;\n+            }\n+        }\n+\n+        if (!data_file.Commit()) {\n+            LogError(\"Failed to commit write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+        if (data_file.fclose() != 0) {\n+            LogError(\"Failed to close after write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+    }\n+\n+    if (rolling_checksum != re_rolling_checksum) {\n+        throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+    }\n+\n+    (void)log_file.fclose();\n+    fs::remove(m_log_file_path);\n+    return true;\n+}\n+\n+bool BlockTreeStore::WriteBatchSync(const std::vector<std::pair<int, CBlockFileInfo*>>& fileInfo, int32_t last_file, const std::vector<CBlockIndex*>& blockinfo)\n+{\n+    AssertLockHeld(::cs_main);\n+    LOCK(m_mutex);\n+\n+    // Use a write-ahead log file that gets atomically flushed to the target files.\n+\n+    { // start log_file scope\n+    FILE* raw_log_file{fsbridge::fopen(m_log_file_path, \"wb\")};\n+    if (!raw_log_file) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    size_t log_file_prealloc_size{fileInfo.size() * (BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE) + blockinfo.size() * (DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE)};\n+    AllocateFileRange(raw_log_file, 0, log_file_prealloc_size);\n+    auto log_file{AutoFile{raw_log_file}};\n+    log_file.seek(0, SEEK_SET); // on windows AllocateFileRange moves the pointer to the end, so move it to the beginning again\n+\n+    DataStream stream;\n+    stream.reserve(DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+    uint32_t rolling_checksum = 0;\n+\n+    log_file << uint32_t{4}; // We are writing four different types to the log file for now.\n+\n+    // Write the last block file number to the log\n+    log_file << ValueType::LAST_BLOCK;\n+    log_file << uint32_t{sizeof(uint32_t)};\n+    log_file << uint64_t{1}; // just the one entry\n+    stream << last_file;\n+    stream << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(stream.data()), stream.size());\n+    rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), stream.size());\n+    log_file << std::span<std::byte>{stream};\n+    log_file << checksum;\n+    stream.clear();\n+\n+    // Write thefileInfo entries to the log\n+    log_file << ValueType::BLOCK_FILE_INFO;\n+    log_file << BLOCK_FILE_INFO_WRAPPER_SIZE;\n+    log_file << uint64_t{fileInfo.size()};\n+    constexpr size_t block_file_entry_size{BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE};\n+    for (const auto& [file, info] : fileInfo) {\n+        int64_t pos{CalculateBlockFilesPos(file)};\n+        stream << BlockFileInfoWrapper{info};\n+        stream << pos;\n+        checksum = crc32c::Crc32c(UCharCast(stream.data()), block_file_entry_size);\n+        rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), block_file_entry_size);\n+        log_file.write(stream);\n+        log_file << checksum;\n+        stream.clear();\n+    }\n+\n+    // TEST ONLY\n+    if (m_incomplete_log_write) {\n+        (void)log_file.fclose();\n+        return false;\n+    }\n+\n+    // Read the header data end position\n+    int64_t header_data_end;\n+    {\n+        auto header_file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (header_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        header_data_end = ReadHeaderFileDataEnd(header_file);\n+    }\n+\n+    // Write the header data to the log\n+    log_file << ValueType::DISK_BLOCK_INDEX;\n+    log_file << DISK_BLOCK_INDEX_WRAPPER_SIZE;\n+    log_file << uint64_t{blockinfo.size()};\n+    constexpr size_t header_entry_size{DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE};\n+\n+    for (CBlockIndex* bi : blockinfo) {\n+        int64_t pos = bi->header_pos == 0 ? header_data_end : bi->header_pos;\n+        auto disk_bi{CDiskBlockIndex{bi}};\n+        stream << DiskBlockIndexWrapper{&disk_bi};\n+        stream << pos;\n+        checksum = crc32c::Crc32c(UCharCast(stream.data()), header_entry_size);\n+        rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), header_entry_size);\n+        log_file.write(stream);\n+        log_file << checksum;\n+        stream.clear();\n+        if (bi->header_pos == 0) {\n+            bi->header_pos = header_data_end;\n+            header_data_end += DISK_BLOCK_INDEX_WRAPPER_SIZE + CHECKSUM_SIZE;\n+        }\n+    }\n+\n+    // Write the last header position to the log\n+    log_file << ValueType::HEADER_DATA_END;\n+    log_file << uint32_t{FILE_POSITION_SIZE};\n+    log_file << uint64_t{1}; // just the one entry\n+    stream << header_data_end;\n+    stream << HEADER_FILE_DATA_END_POS;\n+    checksum = crc32c::Crc32c(UCharCast(stream.data()), stream.size());\n+    rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), stream.size());\n+    log_file << std::span<std::byte>{stream.data(), stream.size()};\n+    log_file << checksum;\n+\n+    // Finally write the rolling checksum, commit, and close\n+    log_file << rolling_checksum;\n+    if (!log_file.Commit()) {\n+        LogError(\"Failed to commit write to log file %s\", PathToString(m_log_file_path));\n+        return false;\n+    }\n+    if (log_file.fclose() != 0) {\n+        LogError(\"Failed to close after write to log file %s\", PathToString(m_log_file_path));\n+        return false;\n+    }\n+\n+    } // end log_file scope\n+\n+    if (!ApplyLog()) {\n+        LogError(\"Failed to apply write-ahead log to data files\");",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 532,
      "original_position": 547,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "not sure I fully understand when we're returning and when we're throwing - how come the WAL write isn't fatal as well?",
      "created_at": "2025-07-27T18:54:45Z",
      "updated_at": "2025-07-28T17:33:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234099540",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234099540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 532,
      "original_line": 532,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234099771",
      "pull_request_review_id": 2822815289,
      "id": 2234099771,
      "node_id": "PRRC_kwDOABII586FKag7",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 383,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: the outer loop is already `i`\r\nnit2: `++i` is more common in these cases",
      "created_at": "2025-07-27T18:55:32Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234099771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234099771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234103309",
      "pull_request_review_id": 2822815289,
      "id": 2234103309,
      "node_id": "PRRC_kwDOABII586FKbYN",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 394,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: as mentioned, I'd unify these checksum checks - and not sure we need to be this specific about interpreting the results, we're usually not this friendly :)",
      "created_at": "2025-07-27T19:07:51Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234103309",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234103309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 394,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234104889",
      "pull_request_review_id": 2822815289,
      "id": 2234104889,
      "node_id": "PRRC_kwDOABII586FKbw5",
      "diff_hunk": "@@ -58,15 +58,6 @@ bool BlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n     return Read(std::make_pair(DB_BLOCK_FILES, nFile), info);\n }\n \n-bool BlockTreeDB::WriteReindexing(bool fReindexing)\n-{\n-    if (fReindexing) {\n-        return Write(DB_REINDEX_FLAG, uint8_t{'1'});\n-    } else {\n-        return Erase(DB_REINDEX_FLAG);",
      "path": "src/node/blockstorage.cpp",
      "position": 9,
      "original_position": 9,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "is `Erase` still used after this?",
      "created_at": "2025-07-27T19:14:05Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234104889",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234104889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234503358",
      "pull_request_review_id": 2822815289,
      "id": 2234503358,
      "node_id": "PRRC_kwDOABII586FL9C-",
      "diff_hunk": "@@ -11,21 +11,16 @@\n \n //! Suggested default amount of cache reserved for the kernel (bytes)\n static constexpr size_t DEFAULT_KERNEL_CACHE{450_MiB};\n-//! Max memory allocated to block tree DB specific cache (bytes)\n-static constexpr size_t MAX_BLOCK_DB_CACHE{2_MiB};\n //! Max memory allocated to coin DB specific cache (bytes)\n-static constexpr size_t MAX_COINS_DB_CACHE{8_MiB};\n+static constexpr size_t MAX_COINS_DB_CACHE{10_MiB};",
      "path": "src/kernel/caches.h",
      "position": 8,
      "original_position": 8,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "these changes might need some (commit message) explanations",
      "created_at": "2025-07-28T02:59:16Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234503358",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234503358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234504393",
      "pull_request_review_id": 2822815289,
      "id": 2234504393,
      "node_id": "PRRC_kwDOABII586FL9TJ",
      "diff_hunk": "@@ -478,13 +451,13 @@ bool BlockManager::LoadBlockIndex(const std::optional<uint256>& snapshot_blockha\n bool BlockManager::WriteBlockIndexDB()\n {\n     AssertLockHeld(::cs_main);\n-    std::vector<std::pair<int, const CBlockFileInfo*>> vFiles;\n+    std::vector<std::pair<int, CBlockFileInfo*>> vFiles;",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 46,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there a const-correct serialization where we don't have to change this?",
      "created_at": "2025-07-28T02:59:56Z",
      "updated_at": "2025-07-28T17:34:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234504393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234504393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 454,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234574948",
      "pull_request_review_id": 2822815289,
      "id": 2234574948,
      "node_id": "PRRC_kwDOABII586FMOhk",
      "diff_hunk": "",
      "path": "src/init.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "original_commit_id": "a2ff8f482c17b95f709ed6371038072b282ddb59",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "typo in commit message: \"newly introduced BlockTreeStore",
      "created_at": "2025-07-28T03:34:56Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234574948",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234574948"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234582790",
      "pull_request_review_id": 2822815289,
      "id": 2234582790,
      "node_id": "PRRC_kwDOABII586FMQcG",
      "diff_hunk": "@@ -298,7 +298,7 @@ class BlockManager\n      */\n     std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n \n-    std::unique_ptr<BlockTreeDB> m_block_tree_db GUARDED_BY(::cs_main);\n+    std::unique_ptr<kernel::BlockTreeStore> m_block_tree_db GUARDED_BY(::cs_main);",
      "path": "src/node/blockstorage.h",
      "position": 35,
      "original_position": 35,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "do we still call the field `tree db`?\r\n```suggestion\r\n    std::unique_ptr<kernel::BlockTreeStore> m_block_tree_store GUARDED_BY(::cs_main);\r\n```",
      "created_at": "2025-07-28T03:41:55Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234582790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234582790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234615191",
      "pull_request_review_id": 2822815289,
      "id": 2234615191,
      "node_id": "PRRC_kwDOABII586FMYWX",
      "diff_hunk": "@@ -1176,6 +1149,80 @@ static auto InitBlocksdirXorKey(const BlockManager::Options& opts)\n     return std::vector<std::byte>{xor_key.begin(), xor_key.end()};\n }\n \n+std::unique_ptr<kernel::BlockTreeStore> BlockManager::CreateAndMigrateBlockTree()\n+{\n+    LOCK(::cs_main);\n+    if (!fs::exists(m_opts.block_tree_dir / \"CURRENT\")) {\n+        return std::make_unique<kernel::BlockTreeStore>(m_opts.block_tree_dir, m_opts.chainparams, m_opts.wipe_block_tree_data);\n+    }\n+\n+    if (m_opts.wipe_block_tree_data) {\n+        fs::remove_all(m_opts.block_tree_dir);\n+        return std::make_unique<kernel::BlockTreeStore>(m_opts.block_tree_dir, m_opts.chainparams, m_opts.wipe_block_tree_data);\n+    }\n+\n+    LogInfo(\"Migrating leveldb block tree db to new flat file block tree store.\");\n+    DBParams db_params{};\n+    db_params.path = m_opts.block_tree_dir;\n+    auto block_tree_db{std::make_unique<BlockTreeDB>(db_params)};\n+\n+    std::vector<std::pair<int, CBlockFileInfo>> files;\n+    int max_blockfile_num{0};\n+    bool reindexing{false};\n+    bool pruned_block_files{false};\n+\n+    {\n+        LogInfo(\"   Reading data from existing leveldb block tree db...\");\n+        block_tree_db->ReadLastBlockFile(max_blockfile_num);\n+        files.reserve(max_blockfile_num);\n+        for (int i = 0; i < max_blockfile_num; i++) {\n+            CBlockFileInfo info;\n+            block_tree_db->ReadBlockFileInfo(i, info);\n+            files.emplace_back(i, info);\n+        }\n+\n+        if (!block_tree_db->LoadBlockIndexGuts(\n+                GetConsensus(), [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); }, m_interrupt)) {\n+            throw std::runtime_error(\"Failed to load block index guts\");\n+        }\n+        block_tree_db->ReadReindexing(reindexing);\n+        block_tree_db->ReadFlag(\"prunedblockfiles\", pruned_block_files);\n+    }\n+\n+    auto migration_dir{m_opts.block_tree_dir.parent_path() / \"migration\"};\n+\n+    {\n+        // Cleanup a potentially previously failed migration\n+        fs::remove_all(migration_dir);\n+        LogInfo(\"    Writing data back to migration directory, reindexing: %b, pruned: %b\", reindexing, pruned_block_files);\n+        auto block_tree_store{std::make_unique<kernel::BlockTreeStore>(migration_dir, m_opts.chainparams, m_opts.wipe_block_tree_data)};\n+        block_tree_store->WritePruned(pruned_block_files);\n+        block_tree_store->WriteReindexing(reindexing);\n+\n+        std::vector<std::pair<int, CBlockFileInfo*>> dump_files;\n+        dump_files.reserve(files.size());\n+        for (auto& file : files) {\n+            dump_files.emplace_back(file.first, &file.second);\n+        }\n+        std::vector<CBlockIndex*> dump_blockindexes;\n+        dump_blockindexes.reserve(m_block_index.size());\n+        for (auto& pair : m_block_index) {\n+            dump_blockindexes.push_back(&pair.second);\n+        }\n+\n+        if (!block_tree_store->WriteBatchSync(dump_files, max_blockfile_num, dump_blockindexes)) {",
      "path": "src/node/blockstorage.cpp",
      "position": 140,
      "original_position": 140,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can we do a load from the new location to make absolutely sure we've indeed written the data correctly and only delete after we validate that?",
      "created_at": "2025-07-28T04:08:05Z",
      "updated_at": "2025-07-28T17:29:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2234615191",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2234615191"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1221,
      "original_line": 1221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285303148",
      "pull_request_review_id": 3132388827,
      "id": 2285303148,
      "node_id": "PRRC_kwDOABII586INvVs",
      "diff_hunk": "@@ -161,6 +183,9 @@ class CBlockIndex\n     //! Byte offset within rev?????.dat where this block's undo data is stored\n     unsigned int nUndoPos GUARDED_BY(::cs_main){0};\n \n+    //! Byte offset within headers.dat where this block's header data is stored\n+    int64_t header_pos GUARDED_BY(::cs_main){0};",
      "path": "src/chain.h",
      "position": 33,
      "original_position": 34,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234058517,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This should not change across re-orgs. Only the `Chain` class mutates during re-orgs, the block index remains unchanged.",
      "created_at": "2025-08-19T13:36:44Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285303148",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285303148"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 186,
      "original_line": 186,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285416813",
      "pull_request_review_id": 3132388827,
      "id": 2285416813,
      "node_id": "PRRC_kwDOABII586IOLFt",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 37,
      "original_position": 37,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234067471,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-19T14:14:24Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285416813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285416813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": 33,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285417562",
      "pull_request_review_id": 3132388827,
      "id": 2285417562,
      "node_id": "PRRC_kwDOABII586IOLRa",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 47,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234044885,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, removed.",
      "created_at": "2025-08-19T14:14:32Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285417562",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285417562"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285420051",
      "pull_request_review_id": 3132388827,
      "id": 2285420051,
      "node_id": "PRRC_kwDOABII586IOL4T",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 56,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234048984,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, raw enums are also not portable. This is better, but also required a small change to allow serialization.",
      "created_at": "2025-08-19T14:15:19Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285420051",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285420051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 51,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285420384",
      "pull_request_review_id": 3132388827,
      "id": 2285420384,
      "node_id": "PRRC_kwDOABII586IOL9g",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 68,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234048113,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-19T14:15:28Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285420384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285420384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 67,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285423317",
      "pull_request_review_id": 3132388827,
      "id": 2285423317,
      "node_id": "PRRC_kwDOABII586IOMrV",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 93,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234045732,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-08-19T14:16:10Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285423317",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285423317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285424999",
      "pull_request_review_id": 3132388827,
      "id": 2285424999,
      "node_id": "PRRC_kwDOABII586IONFn",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 105,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234046260,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Taken, thanks!",
      "created_at": "2025-08-19T14:16:31Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285424999",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285424999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 95,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285428314",
      "pull_request_review_id": 3132388827,
      "id": 2285428314,
      "node_id": "PRRC_kwDOABII586ION5a",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 122,
      "original_position": 116,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234046538,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be nice if `GetSerializeSize` would be a constexpr. But yes, moving this out.\r\nEDIT: Left it for now, but leaving this unresolved.",
      "created_at": "2025-08-19T14:17:14Z",
      "updated_at": "2025-08-20T07:53:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285428314",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285428314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": 121,
      "original_start_line": 115,
      "start_side": "RIGHT",
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285429465",
      "pull_request_review_id": 3132388827,
      "id": 2285429465,
      "node_id": "PRRC_kwDOABII586IOOLZ",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 124,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234046731,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-19T14:17:34Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285429465",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285429465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285432748",
      "pull_request_review_id": 3132388827,
      "id": 2285432748,
      "node_id": "PRRC_kwDOABII586IOO-s",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 149,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234074490,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed the message. I think we should error here, since a subsequent open might fail too, and then it seems better to fail earlier.",
      "created_at": "2025-08-19T14:18:36Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285432748",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285432748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285439773",
      "pull_request_review_id": 3132388827,
      "id": 2285439773,
      "node_id": "PRRC_kwDOABII586IOQsd",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 264,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234078377,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed.",
      "created_at": "2025-08-19T14:20:58Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285439773",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285439773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285444545",
      "pull_request_review_id": 3132388827,
      "id": 2285444545,
      "node_id": "PRRC_kwDOABII586IOR3B",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 361,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234080721,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, replaced the magic number and removed the comment.",
      "created_at": "2025-08-19T14:22:37Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285444545",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285444545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 361,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285451112",
      "pull_request_review_id": 3132388827,
      "id": 2285451112,
      "node_id": "PRRC_kwDOABII586IOTdo",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+            }\n+\n+            if (data_file.tell() != pos) {\n+                data_file.seek(pos, SEEK_SET);\n+            }\n+            stream.Rewind();\n+\n+            data_file << std::span<std::byte>{stream.data(), type_size};\n+            data_file << checksum;\n+            stream.clear();\n+            stream.resize(entry_size);\n+\n+            // TEST ONLY\n+            if (m_incomplete_log_apply) {\n+                (void)data_file.fclose();\n+                return false;\n+            }\n+        }\n+\n+        if (!data_file.Commit()) {\n+            LogError(\"Failed to commit write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+        if (data_file.fclose() != 0) {\n+            LogError(\"Failed to close after write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+    }\n+\n+    if (rolling_checksum != re_rolling_checksum) {\n+        throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+    }\n+\n+    (void)log_file.fclose();\n+    fs::remove(m_log_file_path);\n+    return true;\n+}\n+\n+bool BlockTreeStore::WriteBatchSync(const std::vector<std::pair<int, CBlockFileInfo*>>& fileInfo, int32_t last_file, const std::vector<CBlockIndex*>& blockinfo)\n+{\n+    AssertLockHeld(::cs_main);\n+    LOCK(m_mutex);\n+\n+    // Use a write-ahead log file that gets atomically flushed to the target files.\n+\n+    { // start log_file scope\n+    FILE* raw_log_file{fsbridge::fopen(m_log_file_path, \"wb\")};\n+    if (!raw_log_file) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    size_t log_file_prealloc_size{fileInfo.size() * (BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE) + blockinfo.size() * (DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE)};",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 445,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234081861,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, done.",
      "created_at": "2025-08-19T14:24:50Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285451112",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285451112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 445,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285462571",
      "pull_request_review_id": 3132388827,
      "id": 2285462571,
      "node_id": "PRRC_kwDOABII586IOWQr",
      "diff_hunk": "@@ -298,7 +298,7 @@ class BlockManager\n      */\n     std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n \n-    std::unique_ptr<BlockTreeDB> m_block_tree_db GUARDED_BY(::cs_main);\n+    std::unique_ptr<kernel::BlockTreeStore> m_block_tree_db GUARDED_BY(::cs_main);",
      "path": "src/node/blockstorage.h",
      "position": 35,
      "original_position": 35,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": 2234582790,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, just wanted to not do this particular rename to make it clearer that the new store is really just a drop in replacement. Could then easily be done in a follow-up.",
      "created_at": "2025-08-19T14:29:02Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285462571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285462571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285551772",
      "pull_request_review_id": 3132388827,
      "id": 2285551772,
      "node_id": "PRRC_kwDOABII586IOsCc",
      "diff_hunk": "@@ -412,6 +437,34 @@ class CDiskBlockIndex : public CBlockIndex\n     std::string ToString() = delete;\n };\n \n+struct DiskBlockIndexWrapper : public CDiskBlockIndex {\n+public:\n+    DiskBlockIndexWrapper() = default;",
      "path": "src/chain.h",
      "position": 1,
      "original_position": 45,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234070173,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, changed.",
      "created_at": "2025-08-19T15:00:30Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285551772",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285551772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 440,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 441,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285554498",
      "pull_request_review_id": 3132388827,
      "id": 2285554498,
      "node_id": "PRRC_kwDOABII586IOstC",
      "diff_hunk": "@@ -412,6 +437,34 @@ class CDiskBlockIndex : public CBlockIndex\n     std::string ToString() = delete;\n };\n \n+struct DiskBlockIndexWrapper : public CDiskBlockIndex {\n+public:\n+    DiskBlockIndexWrapper() = default;\n+\n+    explicit DiskBlockIndexWrapper(const CDiskBlockIndex* pindex) : CDiskBlockIndex(*pindex)\n+    {\n+    }\n+\n+    SERIALIZE_METHODS(DiskBlockIndexWrapper, obj)\n+    {\n+        LOCK(::cs_main);\n+        READWRITE(obj.nHeight);\n+        READWRITE(obj.nStatus);\n+        READWRITE(obj.nTx);\n+        READWRITE(obj.nFile);\n+        READWRITE(obj.nDataPos);\n+        READWRITE(obj.nUndoPos);\n+        READWRITE(obj.header_pos);\n+        // block header\n+        READWRITE(obj.nVersion);\n+        READWRITE(obj.hashPrev);\n+        READWRITE(obj.hashMerkleRoot);\n+        READWRITE(obj.nTime);\n+        READWRITE(obj.nBits);\n+        READWRITE(obj.nNonce);",
      "path": "src/chain.h",
      "position": 1,
      "original_position": 67,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234071782,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-08-19T15:01:35Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285554498",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285554498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": 451,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 464,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285792571",
      "pull_request_review_id": 3132388827,
      "id": 2285792571,
      "node_id": "PRRC_kwDOABII586IPm07",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 29,
      "original_position": 29,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234065617,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be, but we use the positions with the result of `ftell`, which returns a signed type, so I made them signed too.",
      "created_at": "2025-08-19T16:38:35Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285792571",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285792571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285816792",
      "pull_request_review_id": 3132388827,
      "id": 2285816792,
      "node_id": "PRRC_kwDOABII586IPsvY",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 206,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234075383,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We need the extra step to calculate the checksum.  But I removed the unneeded cast and got rid of the superfluous seek (which was still there from a prior version).",
      "created_at": "2025-08-19T16:50:35Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285816792",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285816792"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285825190",
      "pull_request_review_id": 3132388827,
      "id": 2285825190,
      "node_id": "PRRC_kwDOABII586IPuym",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 383,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234099771,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-08-19T16:54:53Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285825190",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285825190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 383,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285867053",
      "pull_request_review_id": 3132388827,
      "id": 2285867053,
      "node_id": "PRRC_kwDOABII586IP5At",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 260,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234078009,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a helper for opening these files. Should be a bit clearer now. Also removed all the newlines.",
      "created_at": "2025-08-19T17:15:45Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285867053",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285867053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285887680",
      "pull_request_review_id": 3132388827,
      "id": 2285887680,
      "node_id": "PRRC_kwDOABII586IP-DA",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+            }\n+\n+            if (data_file.tell() != pos) {\n+                data_file.seek(pos, SEEK_SET);\n+            }\n+            stream.Rewind();\n+\n+            data_file << std::span<std::byte>{stream.data(), type_size};\n+            data_file << checksum;\n+            stream.clear();\n+            stream.resize(entry_size);\n+\n+            // TEST ONLY\n+            if (m_incomplete_log_apply) {\n+                (void)data_file.fclose();\n+                return false;\n+            }\n+        }\n+\n+        if (!data_file.Commit()) {\n+            LogError(\"Failed to commit write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+        if (data_file.fclose() != 0) {\n+            LogError(\"Failed to close after write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+    }\n+\n+    if (rolling_checksum != re_rolling_checksum) {\n+        throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+    }\n+\n+    (void)log_file.fclose();\n+    fs::remove(m_log_file_path);\n+    return true;\n+}\n+\n+bool BlockTreeStore::WriteBatchSync(const std::vector<std::pair<int, CBlockFileInfo*>>& fileInfo, int32_t last_file, const std::vector<CBlockIndex*>& blockinfo)\n+{\n+    AssertLockHeld(::cs_main);\n+    LOCK(m_mutex);\n+\n+    // Use a write-ahead log file that gets atomically flushed to the target files.\n+\n+    { // start log_file scope",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 423,
      "original_position": 440,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234081314,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Mmh, not sure what to do here. Extracting a method seems a bit heavy?",
      "created_at": "2025-08-19T17:25:54Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285887680",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285887680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 423,
      "original_line": 423,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285916417",
      "pull_request_review_id": 3132388827,
      "id": 2285916417,
      "node_id": "PRRC_kwDOABII586IQFEB",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 1,
      "original_position": 394,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234103309,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I couldn't come up with a clean extraction. We could add a callback, but seems like a smell too. We do get some decent protection through the rolling checksum from missing anything during the dry run, so we also don't need to be super defensive here.",
      "created_at": "2025-08-19T17:40:23Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285916417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285916417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 394,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285925490",
      "pull_request_review_id": 3132388827,
      "id": 2285925490,
      "node_id": "PRRC_kwDOABII586IQHRy",
      "diff_hunk": "@@ -0,0 +1,620 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <kernel/blocktreestorage.h>\n+\n+#include <crc32c/include/crc32c/crc32c.h>\n+\n+#include <chain.h>\n+#include <logging.h>\n+#include <pow.h>\n+#include <streams.h>\n+#include <util/check.h>\n+#include <util/fs.h>\n+#include <util/fs_helpers.h>\n+#include <util/signalinterrupt.h>\n+\n+#include <fstream>\n+\n+namespace kernel {\n+\n+static uint32_t constexpr BLOCK_FILE_INFO_WRAPPER_SIZE{36};\n+static uint32_t constexpr DISK_BLOCK_INDEX_WRAPPER_SIZE{112};\n+static size_t constexpr CHECKSUM_SIZE{sizeof(uint32_t)};\n+static size_t constexpr FILE_POSITION_SIZE{sizeof(int64_t)};\n+\n+static int64_t ReadHeaderFileDataEnd(AutoFile& file)\n+{\n+    int64_t data_end;\n+    uint32_t checksum;\n+    DataStream data;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    file >> data_end;\n+    data << data_end;\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Header file data failed integrity check.\");\n+    }\n+    data >> data_end;\n+    return data_end;\n+}\n+\n+static int64_t CalculateBlockFilesPos(int nFile)\n+{\n+    // start position + nFile * (BLOCK_FILE_IFO_WRAPPER_SIZE + checksum)\n+    return BLOCK_FILES_DATA_START_POS + nFile * (BLOCK_FILE_INFO_WRAPPER_SIZE + CHECKSUM_SIZE);\n+}\n+\n+enum ValueType : uint32_t {\n+    LAST_BLOCK,\n+    BLOCK_FILE_INFO,\n+    DISK_BLOCK_INDEX,\n+    HEADER_DATA_END,\n+};\n+\n+const fs::path& BlockTreeStore::GetDataFile(uint32_t value_type) const\n+{\n+    switch (value_type) {\n+    case LAST_BLOCK:\n+    case BLOCK_FILE_INFO:\n+        return m_block_files_file_path;\n+    case DISK_BLOCK_INDEX:\n+    case HEADER_DATA_END:\n+        return m_header_file_path;\n+    }\n+    throw BlockTreeStoreError(\"Unrecognized value in block tree store\");\n+}\n+\n+void BlockTreeStore::CheckMagicAndVersion() const\n+{\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != HEADER_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid header file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != HEADER_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid header file version\");\n+        }\n+    }\n+\n+    {\n+        auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+        if (file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        uint32_t magic;\n+        file >> magic;\n+        if (magic != BLOCK_FILES_FILE_MAGIC) {\n+            throw BlockTreeStoreError(\"Invalid block files file magic\");\n+        }\n+        uint32_t version;\n+        file >> version;\n+        if (version != BLOCK_FILES_FILE_VERSION) {\n+            throw BlockTreeStoreError(\"Invalid block files file version\");\n+        }\n+    }\n+}\n+\n+BlockTreeStore::BlockTreeStore(const fs::path& path, const CChainParams& params, bool wipe_data)\n+    : m_header_file_path{path / HEADER_FILE_NAME},\n+      m_log_file_path{path / LOG_FILE_NAME},\n+      m_block_files_file_path{path / BLOCK_FILES_FILE_NAME},\n+      m_reindex_flag_file_path{path / REINDEX_FLAG_FILE_NAME},\n+      m_prune_flag_file_path{path / PRUNE_FLAG_FILE_NAME}\n+{\n+    assert(GetSerializeSize(DiskBlockIndexWrapper{}) == DISK_BLOCK_INDEX_WRAPPER_SIZE);\n+    assert(GetSerializeSize(BlockFileInfoWrapper{}) == BLOCK_FILE_INFO_WRAPPER_SIZE);\n+    fs::create_directories(path);\n+    if (wipe_data) {\n+        fs::remove(m_header_file_path);\n+        fs::remove(m_block_files_file_path);\n+    }\n+    bool header_file_exists{fs::exists(m_header_file_path)};\n+    bool block_files_file_exists{fs::exists(m_block_files_file_path)};\n+    if (header_file_exists ^ block_files_file_exists) {\n+        throw BlockTreeStoreError(\"Block tree store is in an inconsistent state\");\n+    }\n+    if (!header_file_exists && !block_files_file_exists) {\n+        CreateHeaderFile();\n+        CreateBlockFilesFile();\n+    }\n+    CheckMagicAndVersion();\n+    LOCK(m_mutex);\n+    (void)ApplyLog(); // Ignore an incomplete log file here, the integrity of the data is still intact.\n+}\n+\n+void BlockTreeStore::CreateHeaderFile() const\n+{\n+    {\n+        FILE* file = fsbridge::fopen(m_header_file_path, \"wb\");\n+        if (!file) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        AllocateFileRange(file, 0, HEADER_FILE_SIZE);\n+        auto autofile{AutoFile{file}};\n+        if (!autofile.Commit()) {\n+            throw BlockTreeStoreError(strprintf(\"Failed to create header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        if (autofile.fclose() != 0) {\n+            throw BlockTreeStoreError(strprintf(\"Failure when closing created header file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+    }\n+\n+    auto file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb+\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << HEADER_FILE_MAGIC;\n+    file << HEADER_FILE_VERSION;\n+    file.seek(HEADER_FILE_DATA_END_POS, SEEK_SET);\n+    DataStream data;\n+    data << HEADER_FILE_DATA_START_POS;\n+    file << std::span<std::byte>{data};\n+    data << HEADER_FILE_DATA_END_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to header file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadReindexing(bool& reindexing) const\n+{\n+    LOCK(m_mutex);\n+    reindexing = fs::exists(m_reindex_flag_file_path);\n+}\n+\n+void BlockTreeStore::WriteReindexing(bool reindexing) const\n+{\n+    LOCK(m_mutex);\n+    if (reindexing) {\n+        std::ofstream{m_reindex_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_reindex_flag_file_path);\n+    }\n+}\n+\n+void BlockTreeStore::CreateBlockFilesFile() const\n+{\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"wb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+\n+    // Write the magic, version, and last block entry (0 on init) with its checksum\n+    file << BLOCK_FILES_FILE_MAGIC;\n+    file << BLOCK_FILES_FILE_VERSION;\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    DataStream data;\n+    data << 0;\n+    file << std::span<std::byte>{data};\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    file << checksum;\n+\n+    if (!file.Commit()) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to write file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+    if (file.fclose() != 0) {\n+        throw BlockTreeStoreError(strprintf(\"Failed to close after write to block files file %s\\n\", fs::PathToString(m_block_files_file_path)));\n+    }\n+}\n+\n+void BlockTreeStore::ReadLastBlockFile(int32_t& last_block) const\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(BLOCK_FILES_LAST_BLOCK_POS, SEEK_SET);\n+    file >> last_block;\n+    DataStream data;\n+    data << last_block;\n+    data << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), data.size());\n+    uint32_t checksum;\n+    file >> checksum;\n+    if (re_check != checksum) {\n+        throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+    }\n+}\n+\n+void BlockTreeStore::ReadPruned(bool& pruned) const\n+{\n+    LOCK(m_mutex);\n+    pruned = fs::exists(m_prune_flag_file_path);\n+}\n+\n+void BlockTreeStore::WritePruned(bool pruned) const\n+{\n+    LOCK(m_mutex);\n+    if (pruned) {\n+        std::ofstream{m_prune_flag_file_path}.close();\n+    } else {\n+        fs::remove(m_prune_flag_file_path);\n+    }\n+}\n+\n+bool BlockTreeStore::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n+{\n+    LOCK(m_mutex);\n+    auto file{AutoFile{fsbridge::fopen(m_block_files_file_path, \"rb\")}};\n+    if (file.IsNull()) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    file.seek(CalculateBlockFilesPos(nFile), SEEK_SET);\n+    if (file.feof()) {\n+        // return in case the info was not found\n+        return false;\n+    }\n+\n+    BlockFileInfoWrapper info_wrapper;\n+\n+    try {\n+        DataStream data;\n+        data.resize(BLOCK_FILE_INFO_WRAPPER_SIZE);\n+        file.read(std::span<std::byte, BLOCK_FILE_INFO_WRAPPER_SIZE>{data});\n+        data << CalculateBlockFilesPos(nFile);\n+        data >> info_wrapper;\n+        data.Rewind();\n+\n+        uint32_t checksum;\n+        file >> checksum;\n+        uint32_t re_check = crc32c::Crc32c(UCharCast(data.data()), BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+        if (re_check != checksum) {\n+            throw BlockTreeStoreError(\"Block files data failed integrity check.\");\n+        }\n+    } catch (std::ios_base::failure::exception&) {\n+        return false;\n+    }\n+\n+    info.nBlocks = info_wrapper.nBlocks;\n+    info.nSize = info_wrapper.nSize;\n+    info.nUndoSize = info_wrapper.nUndoSize;\n+    info.nHeightFirst = info_wrapper.nHeightFirst;\n+    info.nHeightLast = info_wrapper.nHeightLast;\n+    info.nTimeFirst = info_wrapper.nTimeFirst;\n+    info.nTimeLast = info_wrapper.nTimeLast;\n+    return true;\n+}\n+\n+bool BlockTreeStore::ApplyLog() const\n+{\n+    AssertLockHeld(m_mutex);\n+\n+    if (!fs::exists(m_log_file_path)) {\n+        return false;\n+    }\n+\n+    auto log_file{AutoFile{fsbridge::fopen(m_log_file_path, \"rb\")}};\n+    if (log_file.IsNull()) {\n+        return false;\n+    }\n+\n+    uint32_t re_rolling_checksum = 0;\n+\n+    uint32_t number_of_types;\n+    log_file >> number_of_types;\n+\n+    // Do a dry run to check the integrity of the log file. This should prevent corrupting the data with a corrupt/incomplete log\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t j = 0; j < num_iterations; j++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (checksum != re_checksum) {\n+                LogDebug(BCLog::BLOCKSTORAGE, \"Found invalid entry in blocktree store log file. Will not apply log.\");\n+                (void)log_file.fclose();\n+                fs::remove(m_log_file_path);\n+                return false;\n+            }\n+\n+            stream.Rewind();\n+            stream.resize(entry_size);\n+        }\n+    }\n+\n+    uint32_t rolling_checksum;\n+    log_file >> rolling_checksum;\n+    if (rolling_checksum != re_rolling_checksum) {\n+        LogDebug(BCLog::BLOCKSTORAGE, \"Found incomplete blocktree store log file. Will not apply log.\");\n+        (void)log_file.fclose();\n+        fs::remove(m_log_file_path);\n+        return false;\n+    }\n+    re_rolling_checksum = 0;\n+    log_file.seek(4, SEEK_SET); // we already read the number of types, so skip ahead of it\n+\n+    // Run through the file again, but this time write it to the target data file.\n+    for (uint32_t i = 0; i < number_of_types; i++) {\n+        uint32_t value_type;\n+        log_file >> value_type;\n+\n+        auto data_file_path = GetDataFile(value_type);\n+        auto data_file{AutoFile{fsbridge::fopen(data_file_path, \"rb+\")}};\n+        if (data_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(data_file_path)));\n+        }\n+\n+        uint32_t type_size;\n+        log_file >> type_size;\n+        uint64_t num_iterations;\n+        log_file >> num_iterations;\n+        uint32_t entry_size = type_size + FILE_POSITION_SIZE;\n+\n+        DataStream stream;\n+        stream.resize(entry_size);\n+\n+        for (uint32_t i = 0; i < num_iterations; i++) {\n+            log_file.read(std::span<std::byte>(stream));\n+            stream.ignore(type_size);\n+            int64_t pos;\n+            stream >> pos;\n+\n+            uint32_t re_checksum = crc32c::Crc32c(UCharCast(stream.data()), entry_size);\n+            re_rolling_checksum = crc32c::Extend(re_rolling_checksum, UCharCast(stream.data()), entry_size);\n+            uint32_t checksum;\n+            log_file >> checksum;\n+            if (re_checksum != checksum) {\n+                throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+            }\n+\n+            if (data_file.tell() != pos) {\n+                data_file.seek(pos, SEEK_SET);\n+            }\n+            stream.Rewind();\n+\n+            data_file << std::span<std::byte>{stream.data(), type_size};\n+            data_file << checksum;\n+            stream.clear();\n+            stream.resize(entry_size);\n+\n+            // TEST ONLY\n+            if (m_incomplete_log_apply) {\n+                (void)data_file.fclose();\n+                return false;\n+            }\n+        }\n+\n+        if (!data_file.Commit()) {\n+            LogError(\"Failed to commit write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+        if (data_file.fclose() != 0) {\n+            LogError(\"Failed to close after write to data file %s\", PathToString(data_file_path));\n+            return false;\n+        }\n+    }\n+\n+    if (rolling_checksum != re_rolling_checksum) {\n+        throw BlockTreeStoreError(\"Detected on-disk file corruption. The disk might be nearing its end of life\");\n+    }\n+\n+    (void)log_file.fclose();\n+    fs::remove(m_log_file_path);\n+    return true;\n+}\n+\n+bool BlockTreeStore::WriteBatchSync(const std::vector<std::pair<int, CBlockFileInfo*>>& fileInfo, int32_t last_file, const std::vector<CBlockIndex*>& blockinfo)\n+{\n+    AssertLockHeld(::cs_main);\n+    LOCK(m_mutex);\n+\n+    // Use a write-ahead log file that gets atomically flushed to the target files.\n+\n+    { // start log_file scope\n+    FILE* raw_log_file{fsbridge::fopen(m_log_file_path, \"wb\")};\n+    if (!raw_log_file) {\n+        throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+    }\n+    size_t log_file_prealloc_size{fileInfo.size() * (BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE) + blockinfo.size() * (DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE)};\n+    AllocateFileRange(raw_log_file, 0, log_file_prealloc_size);\n+    auto log_file{AutoFile{raw_log_file}};\n+    log_file.seek(0, SEEK_SET); // on windows AllocateFileRange moves the pointer to the end, so move it to the beginning again\n+\n+    DataStream stream;\n+    stream.reserve(DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE);\n+    uint32_t rolling_checksum = 0;\n+\n+    log_file << uint32_t{4}; // We are writing four different types to the log file for now.\n+\n+    // Write the last block file number to the log\n+    log_file << ValueType::LAST_BLOCK;\n+    log_file << uint32_t{sizeof(uint32_t)};\n+    log_file << uint64_t{1}; // just the one entry\n+    stream << last_file;\n+    stream << BLOCK_FILES_LAST_BLOCK_POS;\n+    uint32_t checksum = crc32c::Crc32c(UCharCast(stream.data()), stream.size());\n+    rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), stream.size());\n+    log_file << std::span<std::byte>{stream};\n+    log_file << checksum;\n+    stream.clear();\n+\n+    // Write thefileInfo entries to the log\n+    log_file << ValueType::BLOCK_FILE_INFO;\n+    log_file << BLOCK_FILE_INFO_WRAPPER_SIZE;\n+    log_file << uint64_t{fileInfo.size()};\n+    constexpr size_t block_file_entry_size{BLOCK_FILE_INFO_WRAPPER_SIZE + FILE_POSITION_SIZE};\n+    for (const auto& [file, info] : fileInfo) {\n+        int64_t pos{CalculateBlockFilesPos(file)};\n+        stream << BlockFileInfoWrapper{info};\n+        stream << pos;\n+        checksum = crc32c::Crc32c(UCharCast(stream.data()), block_file_entry_size);\n+        rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), block_file_entry_size);\n+        log_file.write(stream);\n+        log_file << checksum;\n+        stream.clear();\n+    }\n+\n+    // TEST ONLY\n+    if (m_incomplete_log_write) {\n+        (void)log_file.fclose();\n+        return false;\n+    }\n+\n+    // Read the header data end position\n+    int64_t header_data_end;\n+    {\n+        auto header_file{AutoFile{fsbridge::fopen(m_header_file_path, \"rb\")}};\n+        if (header_file.IsNull()) {\n+            throw BlockTreeStoreError(strprintf(\"Unable to open file %s\\n\", fs::PathToString(m_header_file_path)));\n+        }\n+        header_data_end = ReadHeaderFileDataEnd(header_file);\n+    }\n+\n+    // Write the header data to the log\n+    log_file << ValueType::DISK_BLOCK_INDEX;\n+    log_file << DISK_BLOCK_INDEX_WRAPPER_SIZE;\n+    log_file << uint64_t{blockinfo.size()};\n+    constexpr size_t header_entry_size{DISK_BLOCK_INDEX_WRAPPER_SIZE + FILE_POSITION_SIZE};\n+\n+    for (CBlockIndex* bi : blockinfo) {\n+        int64_t pos = bi->header_pos == 0 ? header_data_end : bi->header_pos;\n+        auto disk_bi{CDiskBlockIndex{bi}};\n+        stream << DiskBlockIndexWrapper{&disk_bi};\n+        stream << pos;\n+        checksum = crc32c::Crc32c(UCharCast(stream.data()), header_entry_size);\n+        rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), header_entry_size);\n+        log_file.write(stream);\n+        log_file << checksum;\n+        stream.clear();\n+        if (bi->header_pos == 0) {\n+            bi->header_pos = header_data_end;\n+            header_data_end += DISK_BLOCK_INDEX_WRAPPER_SIZE + CHECKSUM_SIZE;\n+        }\n+    }\n+\n+    // Write the last header position to the log\n+    log_file << ValueType::HEADER_DATA_END;\n+    log_file << uint32_t{FILE_POSITION_SIZE};\n+    log_file << uint64_t{1}; // just the one entry\n+    stream << header_data_end;\n+    stream << HEADER_FILE_DATA_END_POS;\n+    checksum = crc32c::Crc32c(UCharCast(stream.data()), stream.size());\n+    rolling_checksum = crc32c::Extend(rolling_checksum, UCharCast(stream.data()), stream.size());\n+    log_file << std::span<std::byte>{stream.data(), stream.size()};\n+    log_file << checksum;\n+\n+    // Finally write the rolling checksum, commit, and close\n+    log_file << rolling_checksum;\n+    if (!log_file.Commit()) {\n+        LogError(\"Failed to commit write to log file %s\", PathToString(m_log_file_path));\n+        return false;\n+    }\n+    if (log_file.fclose() != 0) {\n+        LogError(\"Failed to close after write to log file %s\", PathToString(m_log_file_path));\n+        return false;\n+    }\n+\n+    } // end log_file scope\n+\n+    if (!ApplyLog()) {\n+        LogError(\"Failed to apply write-ahead log to data files\");",
      "path": "src/kernel/blocktreestorage.cpp",
      "position": 532,
      "original_position": 547,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "8858c43ee081e6a9651c7458c4b7b71112ec9050",
      "in_reply_to_id": 2234099540,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It is fatal, returning false here triggers a `FatalError` further up the callstack in our code. I think I am trying to bend towards our previous method of indicating a failure through a boolean, but as you are pointing out, this is just inconsistent. I'd prefer to make this void and throw, but then I'd have to change some things in the callers of this function. Maybe once #33042 is in we can make all of these throw instead?",
      "created_at": "2025-08-19T17:44:49Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285925490",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285925490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 532,
      "original_line": 532,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285936942",
      "pull_request_review_id": 3132388827,
      "id": 2285936942,
      "node_id": "PRRC_kwDOABII586IQKEu",
      "diff_hunk": "@@ -58,15 +58,6 @@ bool BlockTreeDB::ReadBlockFileInfo(int nFile, CBlockFileInfo& info)\n     return Read(std::make_pair(DB_BLOCK_FILES, nFile), info);\n }\n \n-bool BlockTreeDB::WriteReindexing(bool fReindexing)\n-{\n-    if (fReindexing) {\n-        return Write(DB_REINDEX_FLAG, uint8_t{'1'});\n-    } else {\n-        return Erase(DB_REINDEX_FLAG);",
      "path": "src/node/blockstorage.cpp",
      "position": 9,
      "original_position": 9,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": 2234104889,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, no, and looks like we did not even have coverage for it :/, Removed it.",
      "created_at": "2025-08-19T17:50:38Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2285936942",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2285936942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2286238024",
      "pull_request_review_id": 3132388827,
      "id": 2286238024,
      "node_id": "PRRC_kwDOABII586IRTlI",
      "diff_hunk": "@@ -478,13 +451,13 @@ bool BlockManager::LoadBlockIndex(const std::optional<uint256>& snapshot_blockha\n bool BlockManager::WriteBlockIndexDB()\n {\n     AssertLockHeld(::cs_main);\n-    std::vector<std::pair<int, const CBlockFileInfo*>> vFiles;\n+    std::vector<std::pair<int, CBlockFileInfo*>> vFiles;",
      "path": "src/node/blockstorage.cpp",
      "position": 1,
      "original_position": 46,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": 2234504393,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I missed this from an earlier change. The serialization is already correct, but I did not revert back all the call sites again. Fixed.",
      "created_at": "2025-08-19T20:18:32Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2286238024",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2286238024"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 454,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2286254495",
      "pull_request_review_id": 3132388827,
      "id": 2286254495,
      "node_id": "PRRC_kwDOABII586IRXmf",
      "diff_hunk": "@@ -1176,6 +1149,80 @@ static auto InitBlocksdirXorKey(const BlockManager::Options& opts)\n     return std::vector<std::byte>{xor_key.begin(), xor_key.end()};\n }\n \n+std::unique_ptr<kernel::BlockTreeStore> BlockManager::CreateAndMigrateBlockTree()\n+{\n+    LOCK(::cs_main);\n+    if (!fs::exists(m_opts.block_tree_dir / \"CURRENT\")) {\n+        return std::make_unique<kernel::BlockTreeStore>(m_opts.block_tree_dir, m_opts.chainparams, m_opts.wipe_block_tree_data);\n+    }\n+\n+    if (m_opts.wipe_block_tree_data) {\n+        fs::remove_all(m_opts.block_tree_dir);\n+        return std::make_unique<kernel::BlockTreeStore>(m_opts.block_tree_dir, m_opts.chainparams, m_opts.wipe_block_tree_data);\n+    }\n+\n+    LogInfo(\"Migrating leveldb block tree db to new flat file block tree store.\");\n+    DBParams db_params{};\n+    db_params.path = m_opts.block_tree_dir;\n+    auto block_tree_db{std::make_unique<BlockTreeDB>(db_params)};\n+\n+    std::vector<std::pair<int, CBlockFileInfo>> files;\n+    int max_blockfile_num{0};\n+    bool reindexing{false};\n+    bool pruned_block_files{false};\n+\n+    {\n+        LogInfo(\"   Reading data from existing leveldb block tree db...\");\n+        block_tree_db->ReadLastBlockFile(max_blockfile_num);\n+        files.reserve(max_blockfile_num);\n+        for (int i = 0; i < max_blockfile_num; i++) {\n+            CBlockFileInfo info;\n+            block_tree_db->ReadBlockFileInfo(i, info);\n+            files.emplace_back(i, info);\n+        }\n+\n+        if (!block_tree_db->LoadBlockIndexGuts(\n+                GetConsensus(), [this](const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return this->InsertBlockIndex(hash); }, m_interrupt)) {\n+            throw std::runtime_error(\"Failed to load block index guts\");\n+        }\n+        block_tree_db->ReadReindexing(reindexing);\n+        block_tree_db->ReadFlag(\"prunedblockfiles\", pruned_block_files);\n+    }\n+\n+    auto migration_dir{m_opts.block_tree_dir.parent_path() / \"migration\"};\n+\n+    {\n+        // Cleanup a potentially previously failed migration\n+        fs::remove_all(migration_dir);\n+        LogInfo(\"    Writing data back to migration directory, reindexing: %b, pruned: %b\", reindexing, pruned_block_files);\n+        auto block_tree_store{std::make_unique<kernel::BlockTreeStore>(migration_dir, m_opts.chainparams, m_opts.wipe_block_tree_data)};\n+        block_tree_store->WritePruned(pruned_block_files);\n+        block_tree_store->WriteReindexing(reindexing);\n+\n+        std::vector<std::pair<int, CBlockFileInfo*>> dump_files;\n+        dump_files.reserve(files.size());\n+        for (auto& file : files) {\n+            dump_files.emplace_back(file.first, &file.second);\n+        }\n+        std::vector<CBlockIndex*> dump_blockindexes;\n+        dump_blockindexes.reserve(m_block_index.size());\n+        for (auto& pair : m_block_index) {\n+            dump_blockindexes.push_back(&pair.second);\n+        }\n+\n+        if (!block_tree_store->WriteBatchSync(dump_files, max_blockfile_num, dump_blockindexes)) {",
      "path": "src/node/blockstorage.cpp",
      "position": 140,
      "original_position": 140,
      "commit_id": "daf0e9a3d45f42889fc5895fc580c73d060d2711",
      "original_commit_id": "254d0a75b50b0eaf91003ea8a0534981ec740090",
      "in_reply_to_id": 2234615191,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Mmh, I guess that would improve things a bit by guaranteeing that the migration absent a failure during the rename would be successful. There is also a race condition, since we could have a power outage after removing the old db, but before the rename is complete.",
      "created_at": "2025-08-19T20:26:33Z",
      "updated_at": "2025-08-20T07:52:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32427#discussion_r2286254495",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2286254495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32427"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1221,
      "original_line": 1221,
      "side": "RIGHT"
    }
  ]
}