{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595",
    "id": 2005623544,
    "node_id": "PR_kwDOABII5853i2L4",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30595",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30595.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30595.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/7bcb122e6e55339f25238a44433cc5aadc4526f1",
    "number": 30595,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "kernel: Introduce initial C header API",
    "user": {
      "login": "TheCharlatan",
      "id": 8421793,
      "node_id": "MDQ6VXNlcjg0MjE3OTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheCharlatan",
      "html_url": "https://github.com/TheCharlatan",
      "followers_url": "https://api.github.com/users/TheCharlatan/followers",
      "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
      "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
      "repos_url": "https://api.github.com/users/TheCharlatan/repos",
      "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This is a first attempt at introducing a C header for the libbitcoinkernel library that may be used by external applications for interfacing with Bitcoin Core's validation logic. It currently is limited to operations on blocks. This is a conscious choice, since it already offers a lot of powerful functionality, but sits just on the cusp of still being reviewable scope-wise while giving some pointers on how the rest of the API could look like.\r\n\r\nThe current design was informed by the development of some tools using the C header:\r\n\r\n* A re-implementation (part of this pull request) of [bitcoin-chainstate](https://github.com/bitcoin/bitcoin/blob/master/src/bitcoin-chainstate.cpp).\r\n* A re-implementation of the python [block linearize](https://github.com/bitcoin/bitcoin/tree/master/contrib/linearize) scripts: https://github.com/TheCharlatan/bitcoin/tree/kernelLinearize \r\n* A silent payment scanner: https://github.com/josibake/silent-payments-scanner\r\n* An electrs index builder: https://github.com/josibake/electrs/commits/electrs-kernel-integration\r\n* A rust bitcoin node: https://github.com/TheCharlatan/kernel-node\r\n* A reindexer: https://github.com/TheCharlatan/bitcoin/tree/kernelApi_Reindexer\r\n\r\nThe library has also been used by other developers already:\r\n\r\n* A historical block analysis tool: https://github.com/ismaelsadeeq/mining-analysis\r\n* A swiftsync hints generator: https://github.com/theStack/swiftsync-hints-gen\r\n* Fast script validation in floresta: https://github.com/vinteumorg/Floresta/pull/456\r\n\r\nNext to the C++ header also made available in this pull request, bindings for other languages are available here: \r\n\r\n* Rust: https://github.com/TheCharlatan/rust-bitcoinkernel\r\n* Python: https://github.com/stickies-v/py-bitcoinkernel \r\n* Go: https://github.com/stringintech/go-bitcoinkernel\r\n* Java: https://github.com/yuvicc/java-bitcoinkernel\r\n\r\nThe rust bindings include unit and fuzz tests for the API.\r\n\r\nThe header currently exposes logic for enabling the following functionality:\r\n* Feature-parity with the now deprecated libbitcoin-consensus\r\n* Optimized sha256 implementations that were not available to previous users of libbitcoin-consensus thanks to a static kernel context\r\n* Full support for logging as well as control over categories and severity\r\n* Feature parity with the existing experimental bitcoin-chainstate\r\n* Traversing the block index as well as using block index entries for reading block and undo data.\r\n* Running the chainstate in memory\r\n* Reindexing (both full and chainstate-only)\r\n* Interrupting long-running functions\r\n\r\nThe pull request introduces a new kernel-only test binary that purely relies on the kernel C header and the C++ standard library. This is intentionally done to show its capabilities without relying on other code inside the project. This may be relaxed to include some of the existing utilities, or even be merged into the existing test suite.\r\n\r\nThe complete docs for the API as well as some usage examples are hosted on [thecharlatan.ch/kernel-docs](https://thecharlatan.ch/kernel-docs/index.html). The docs are generated from the following repository (which also holds the examples): [github.com/TheCharlatan/kernel-docs](https://github.com/TheCharlatan/kernel-docs).\r\n\r\n#### How can I review this PR?\r\n\r\nScrutinize the commit messages, run the tests, write your own little applications using the library, let your favorite code sanitizer loose on it, hook it up to your fuzzing infrastructure, profile the difference between the existing bitcoin-chainstate and the bitcoin-chainstate introduced here, be nitty on the documentation, police the C interface, opine on your own API design philosophy.\r\n\r\nTo get a feeling for the API, read through the tests, or one of the examples.\r\n\r\nTo configure this PR for making the shared library and the bitcoin-chainstate and test_kernel utilities available:\r\n```\r\ncmake -B build -DBUILD_KERNEL_LIB=ON -DBUILD_UTIL_CHAINSTATE=ON\r\n```\r\n\r\nOnce compiled the library is part of the build artifacts that can be installed with:\r\n```\r\ncmake --install build\r\n```\r\n\r\n#### Why a C header (and not a C++ header)\r\n\r\n* Shipping a shared library with a C++ header is hard, because of name mangling and an unstable ABI.\r\n* Mature and well-supported tooling for integrating C exists for nearly every popular language.\r\n* C offers a reasonably stable ABI\r\n\r\nAlso see https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2285719575.\r\n\r\n#### What about versioning?\r\n\r\nThe header and library are still experimental and I would expect this to remain so for some time, so best not to worry about versioning yet.\r\n\r\n#### Potential future additions\r\n\r\nIn future, the C header could be expanded to support (some of these have been roughly implemented):\r\n\r\n* Handling transactions, block headers, coins cache, utxo set, meta data, and the mempool\r\n* Adapters for an abstract coins store\r\n* Adapters for an abstract block store\r\n* Adapters for an abstract block tree store\r\n* Allocators and buffers for more efficient memory usage\r\n* An \"[io-less](https://sans-io.readthedocs.io/how-to-sans-io.html)\" interface\r\n* Hooks for an external mempool, or external policy rules\r\n\r\n#### Current drawbacks\r\n\r\n* For external applications to read the block index of an existing Bitcoin Core node, Bitcoin Core needs to shut down first, since leveldb does not support reading across multiple processes. Other than migrating away from leveldb, there does not seem to be a solution for this problem. Such a migration is implemented in #32427.\r\n* The fatal error handling through the notifications is awkward. This is partly improved through #29642.\r\n* Handling shared pointers in the interfaces is unfortunate. They make ownership and freeing of the resources fuzzy and poison the interfaces with additional types and complexity. However, they seem to be an artifact of the current code that interfaces with the validation engine. The validation engine itself does not seem to make extensive use of these shared pointers.\r\n* If multiple instances of the same type of objects are used, there is no mechanism for distinguishing the log messages produced by each of them. A potential solution is #30342.\r\n* The background leveldb compaction thread may not finish in time leading to a non-clean exit. There seems to be nothing we can do about this, outside of patching leveldb.",
    "labels": [
      {
        "id": 118379652,
        "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
        "name": "Validation",
        "color": "6060aa",
        "default": false
      }
    ],
    "created_at": "2024-08-06T09:18:27Z",
    "updated_at": "2025-08-18T13:12:09Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "e9e47104825d9e46d58e99b2031d498a06de479c",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "TheCharlatan:kernelApi",
      "ref": "kernelApi",
      "sha": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 94456368,
        "node_id": "MDEwOlJlcG9zaXRvcnk5NDQ1NjM2OA==",
        "name": "bitcoin",
        "full_name": "TheCharlatan/bitcoin",
        "owner": {
          "login": "TheCharlatan",
          "id": 8421793,
          "node_id": "MDQ6VXNlcjg0MjE3OTM=",
          "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/TheCharlatan",
          "html_url": "https://github.com/TheCharlatan",
          "followers_url": "https://api.github.com/users/TheCharlatan/followers",
          "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
          "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
          "repos_url": "https://api.github.com/users/TheCharlatan/repos",
          "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/TheCharlatan/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/TheCharlatan/bitcoin",
        "archive_url": "https://api.github.com/repos/TheCharlatan/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/TheCharlatan/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/TheCharlatan/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/TheCharlatan/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/TheCharlatan/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/TheCharlatan/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/TheCharlatan/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/TheCharlatan/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/TheCharlatan/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/TheCharlatan/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/TheCharlatan/bitcoin/events",
        "forks_url": "https://api.github.com/repos/TheCharlatan/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/TheCharlatan/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/TheCharlatan/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/TheCharlatan/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/TheCharlatan/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/TheCharlatan/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/TheCharlatan/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/TheCharlatan/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/TheCharlatan/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/TheCharlatan/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/TheCharlatan/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/TheCharlatan/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/TheCharlatan/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:TheCharlatan/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/TheCharlatan/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/TheCharlatan/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/TheCharlatan/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/TheCharlatan/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/TheCharlatan/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/TheCharlatan/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/TheCharlatan/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/TheCharlatan/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/TheCharlatan/bitcoin/hooks",
        "svn_url": "https://github.com/TheCharlatan/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 272556,
        "default_branch": "master",
        "open_issues_count": 6,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-17T21:24:26Z",
        "created_at": "2017-06-15T16:03:35Z",
        "updated_at": "2025-08-08T12:23:14Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "57e8f34fe20620b3350ca1f0fa5c7d8d3a06be82",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37648,
        "stargazers_count": 85075,
        "watchers_count": 85075,
        "size": 291259,
        "default_branch": "master",
        "open_issues_count": 753,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-18T10:54:35Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-08-18T13:34:50Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 4954,
    "deletions": 248,
    "changed_files": 18,
    "commits": 24,
    "review_comments": 108,
    "comments": 107
  },
  "events": [
    {
      "event": "commented",
      "id": 2270798867,
      "node_id": "IC_kwDOABII586HWaQT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2270798867",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T09:18:31Z",
      "updated_at": "2025-08-16T14:05:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/30595.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [stickies-v](https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2297633388), [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2518337899), [stringintech](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2994351556), [yuvicc](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3045757878) |\n| Approach NACK | [josibake](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3069964449), [purpleKarrot](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3069994277) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33191](https://github.com/bitcoin/bitcoin/pull/33191) (net: Provide block templates to peers on request by ajtowns)\n* [#33078](https://github.com/bitcoin/bitcoin/pull/33078) (kernel: improve BlockChecked ownership semantics by stickies-v)\n* [#32953](https://github.com/bitcoin/bitcoin/pull/32953) ([POC] ci: Skip compilation when running static code analysis by hebasto)\n* [#32427](https://github.com/bitcoin/bitcoin/pull/32427) ((RFC) kernel: Replace leveldb-based BlockTreeDB with flat-file based store by TheCharlatan)\n* [#31507](https://github.com/bitcoin/bitcoin/pull/31507) (build: Use clang-cl to build on Windows natively by hebasto)\n* [#31382](https://github.com/bitcoin/bitcoin/pull/31382) (kernel: Flush in ChainstateManager destructor by TheCharlatan)\n* [#29700](https://github.com/bitcoin/bitcoin/pull/29700) (kernel, refactor: return error status on all fatal errors by ryanofsky)\n* [#28792](https://github.com/bitcoin/bitcoin/pull/28792) (Embed default ASMap as binary dump header file by fjahr)\n* [#26022](https://github.com/bitcoin/bitcoin/pull/26022) (Add util::ResultPtr class by ryanofsky)\n* [#25665](https://github.com/bitcoin/bitcoin/pull/25665) (refactor: Add util::Result failure values, multiple error and warning messages by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2270798867",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 13775536223,
      "node_id": "LE_lADOABII586SDdapzwAAAAM1FgBf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13775536223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T09:18:33Z",
      "label": {
        "name": "Validation",
        "color": "6060aa"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13776622682,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAM1JpRa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13776622682",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "13d9cbba755cfab74982c741ceb415190b9621e3",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/13d9cbba755cfab74982c741ceb415190b9621e3",
      "created_at": "2024-08-06T10:42:04Z"
    },
    {
      "event": "labeled",
      "id": 13776623455,
      "node_id": "LE_lADOABII586SDdapzwAAAAM1Jpdf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13776623455",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T10:42:07Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2270967742,
      "node_id": "IC_kwDOABII586HXDe-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2270967742",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T10:42:08Z",
      "updated_at": "2024-08-06T10:42:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/28396412371</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2270967742",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13776932895,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAM1K1Af",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13776932895",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7d3154faecb71a7df1c4a95554984b3adec555cb",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/7d3154faecb71a7df1c4a95554984b3adec555cb",
      "created_at": "2024-08-06T11:07:12Z"
    },
    {
      "event": "unlabeled",
      "id": 13778638981,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAM1RViF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13778638981",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-06T13:18:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2274440199,
      "node_id": "IC_kwDOABII586HkTQH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2274440199",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-07T22:14:51Z",
      "updated_at": "2024-08-07T22:14:51Z",
      "author_association": "MEMBER",
      "body": "Very cool. Can't wait to dig in when I have some free time.",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2274440199",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2284621389,
      "node_id": "IC_kwDOABII586ILI5N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2284621389",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-12T18:05:53Z",
      "updated_at": "2024-08-12T18:05:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "This seems to offer a lot of nice features, but can you explain the tradeoffs of wrapping the C++ interface in C instead of using C++ from rust directly? It seems like having a C middle layer introduces a lot of boilerplate, and I'm wondering if it is really necessary. For example it seems like there is a rust cxx crate (https://docs.rs/cxx/latest/cxx/, https://chatgpt.com/share/dd4dde59-66d6-4486-88a6-2f42144be056) that lets you call C++ directly from Rust and avoid the need for C boilerplate. It looks like https://cppyy.readthedocs.io/en/latest/index.html is an even more full-featured way of calling c++ from python.\r\n\r\nAnother drawback of going through a C API seems like not just increased boilerplate, but reduced safety. For example, the implementation is using reinterpret_cast everywhere and it seems like the exposed C functions use a `kernel_ErrorCode` enum type with the union of every possible error type, so callers don't have a way to know which functions can return which errors.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2284621389",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2285719575,
      "node_id": "IC_kwDOABII586IPVAX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2285719575",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-13T08:54:20Z",
      "updated_at": "2024-09-03T12:03:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the questions and kicking this discussion off @ryanofsky! I'll update the PR description with a better motiviation re. C vs C++ header, but will also try to answer your questions here.\r\n\r\n> This seems to offer a lot of nice features, but can you explain the tradeoffs of wrapping the C++ interface in C instead of using C++ from rust directly? It seems like having a C middle layer introduces a lot of boilerplate, and I'm wondering if it is really necessary. For example it seems like there is a rust cxx crate (https://docs.rs/cxx/latest/cxx/, https://chatgpt.com/share/dd4dde59-66d6-4486-88a6-2f42144be056) that lets you call C++ directly from Rust and avoid the need for C boilerplate. It looks like https://cppyy.readthedocs.io/en/latest/index.html is an even more full-featured way of calling c++ from python.\r\n\r\nIt is true that the interoperability between C++ and Rust has become very good. In fact there is someone working on wrapping the entirety of Bitcoin Core in Rust: https://github.com/klebs6/bitcoin-rs.\r\n\r\nDuring the last Core Dev meeting in Berlin I also asked if a C API were desirable in the first place ([notes here](https://btctranscripts.com/bitcoin-core-dev-tech/2024-04/kernel/)) during the libbitcoinkernel session. I moved forward with this implementation, because the consensus at the time with many contributors in the room was that it was desirable. The reasons for this as discussed during the session at the meeting can be briefly summarised:\r\n\r\n* Shipping a shared library with a C++ header is hard\r\n* Mature and well-supported tooling for integrating C exists for nearly every popular language.\r\n* C offers a reasonably stable ABI\r\n\r\nSo if we want the broadest possible support, across as many languages as possible with both dynamic and statically compiled libraries, a C header is the go-to option. I'm speculating here, but a C++ header might also make future standard version bumps and adoption of new standard library features harder. If having some trade-offs with compatibility, library portability, and language support is acceptable, a C++ header might be acceptaple though. It would be nice to hear more reviewers give their opinions here. \r\n\r\nI'd also like to add that two libraries that we use and depend on in this project, [minisketch](https://github.com/sipa/minisketch/tree/master) and [zeromq](https://github.com/zeromq/libzmq/), use the same pattern. They are C++ codebases, that only expose a C API that in both instances can be used with a C++ RAII wrapper. So there is precedent in the free software ecosystem for doing things this way.\r\n\r\nThe quality of C++ language interop seems to vary a lot between languages. Python and Rust seem to have decent support, ziglang on the other hand has no support for C++ bindings. JVM family languages are a bit hit and miss, and many of the common academic and industrial data analysis languages, like Julia, R, and Matlab have no support for direct C++ bindings. The latter category should not be disregarded as potential future users, since this library might be useful to access Bitcoin Core data for data analysis projects.\r\n\r\n> Another drawback of going through a C API seems like not just increased boilerplate, but reduced safety. For example, the implementation is using reinterpret_cast everywhere\r\n\r\nI feel like the reduced type safety due to casting is bit of a red herring. The type casting can be harder to abuse if you always use a dedicated helper function for interpreting passed in data types (as I believe is implemented here). Casting is also a pattern used in many other projects; both minisketch and libzmq use similar type casts extensively. It should definitely be possible to scrutinize the API in this PR to a point where it offers decent safety to its users as well as contributors to and maintainers of this code base.\r\n\r\nThe concerns around boilerplate are more serious in my view, but at least with the current internal code and headers I feel like exposing a _safe_ C++ API is not trivial either. The current headers do not lend themselves to it well, for example through tricky locking mechanics, exposing boost types, or confusing lifetimes. There also comes a point where we should probably stop extensively refactoring internal code for the kernel. I've heard some voices during the last two Core Dev meetings with concerns that the kernel project might turn the validation code into an extensive forever building site. Having some boilerplate and glue to abstract some the ugliness and make it safe seems like an acceptable solution for this dilemma. If this means boilerplate is required anyway, I would personally prefer a C API.\r\n\r\nSome of the boilerplate-y duplicate definitions in the header could be dropped again eventually if some of the `enum`s are moved to C-style `enum`s instead of `class enum`. As long as they are properly namespaced, I don't see a big drawback for this. Similarly, some of the structs could be defined in a way where they can be used on both sides using pimpl or similar idioms. All in all, most of these translations seem very straightforward.\r\n\r\nIt might be interesting to see how some of the RPC methods could be re-implemented using the kernel header. There have been some RPC implementation bugs over the years that were due to unsafe usage of our internal code within the method implementations. Using the kernel header instead might make this safer and reduce boilerplate. To  be clear, I am not suggesting replacing the implementations, but separately re-implementing some of them to show where the kernel header might shine.\r\n\r\n> it seems like the exposed C functions use a kernel_ErrorCode enum type with the union of every possible error type, so callers don't have a way to know which functions can return which errors.\r\n\r\nWe have disagreed on the design of this before. If I understood you correctly, consolidating all error codes into a single enumeration was one of the reasons you opened your version for handling fatal errors in the kernel: https://github.com/bitcoin/bitcoin/pull/29700 as an alternative to my original: https://github.com/bitcoin/bitcoin/pull/29642. I am still a bit torn by the two approaches. I get that it may be useful to exactly see which errors may be encountered by invoking a certain routine, but at the same time I get the feeling this often ends up splintering the error handling to the point where you end up with a catch all approach after all. I also think that it is nice to have a single, central list for looking up all error codes and defining some routines for handling them in close proximity to their definition. It would be nice to finally hear some more voices besides the two of us discussing this. real-or-random has recently provided some good points on error handling in the libsecp [silent payments pr](https://github.com/bitcoin-core/secp256k1/pull/1519#issuecomment-2142599641) (that I mostly did not adopt in this PR) and argues that most error codes are not useful to the user. As mentioned in the description, error handling is a weak spot of this pull request and I would like to improve it.\r\n\r\n\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2285719575",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 13860034421,
      "node_id": "MEE_lADOABII586SDdapzwAAAAM6H1d1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13860034421",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-13T08:54:22Z"
    },
    {
      "event": "subscribed",
      "id": 13860034437,
      "node_id": "SE_lADOABII586SDdapzwAAAAM6H1eF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13860034437",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-13T08:54:22Z"
    },
    {
      "event": "commented",
      "id": 2286604343,
      "node_id": "IC_kwDOABII586IStA3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2286604343",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-13T16:01:30Z",
      "updated_at": "2024-08-13T17:31:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "I guess another thing I'd like to know is if this is the initial C API, and the implementation is around 3000 lines, and it doesn't handle \"transactions, block headers, coins cache, utxo set, meta data, and the mempool\", how much bigger do you think it will get if it does cover most of the things you would like it to cover? Like is this 20%, 30%, or 50% of the expected size?\r\n\r\nI like the idea of reviewing and merging this PR, and establishing a way to interoperate with rust libraries and external projects. I just think going forward we should not lock ourselves into an approach that requires everything to go through a C interface. As we build on this and add features, we should experiment with other approaches that use C++ directly, especially when it can reduce boilerplate and avoid bugs.\r\n\r\nThanks for pointing to me to the other error handling discussion. I very much agree with the post that says having a single error handling path is highly desirable. I especially agree with this in cases where detailed error messages are still provided (keeping in mind that error handling != error reporting, you can return simple error states with detailed messages or logging). Of course there are places where callers do need to handle separate error cases, especially when there are temporary failures, timeouts, and interruptions, and in these cases functions should return 2 or 3 error states instead of 1. But I don't think there is a reason in modern application code for functions to be able to return 5, 10, 20, or 50 error states generally. In low-level or very general OS, networking or DBMS code it might make sense, but for application code it seems like a cargo cult programming practice that made IBM service manuals very impressive in the 1980s but does not have a present day rationale. There are special cases, but I don't think it should be a normal thing for functions to be returning 15 error codes if we are trying to provide a safe and easy to use API.\r\n\r\nAgain though, if this approach is the easiest way to get cross-language interoperability working right now, I think we should try it. I just think we should be looking for ways to make things simpler and safer going forward.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2286604343",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2286994610,
      "node_id": "IC_kwDOABII586IUMSy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2286994610",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-13T19:38:46Z",
      "updated_at": "2024-08-13T19:38:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I guess another thing I'd like to know is if this is the initial C API, and the implementation is around 3000 lines, and it doesn't handle \"transactions, block headers, coins cache, utxo set, meta data, and the mempool\", how much bigger do you think it will get if it does cover most of the things you would like it to cover? Like is this 20%, 30%, or 50% of the expected size?\r\n\r\nI think a fair comparison would be comparing the amount of code \"glue\" required, e.g. the size of the `bitcoinkernel.cpp` file in this pull request. The size of the header is very dependent on the detail of documentation and I think judging it by the amount of test code is also hard. On my branch including iterators for the UTXO set, handling headers, and simple mempool processing, basically all the stuff required to drop-in replace the calls to validation code in `net_processing` with the C API, is about similar in size: https://github.com/bitcoin/bitcoin/pull/30595/files#diff-cc28221ef8d0c7294dda4e3df9f70bb6c062006b387468380c2c2cc02b6762c3 . The code on that branch is more hacky than the code here, so I would expect a bit less than a doubling in size to get all the features  required to run a full node with transaction relay.\r\n\r\n> In low-level or very general OS, networking or DBMS code it might make sense, but for application code it seems like a cargo cult programming practice that made IBM service manuals very impressive in the 1980s but does not have a present day rationale.\r\n\r\nHeh, well put. I think for most functions here it could be feasible to have more concise error codes without too much effort, but I feel like I have to detach from this a bit before being able to come up with an alternative.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2286994610",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2287225308,
      "node_id": "IC_kwDOABII586IVEnc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2287225308",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-13T22:09:05Z",
      "updated_at": "2024-08-13T22:09:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I think for most functions here it could be feasible to have more concise error codes without too much effort, but I feel like I have to detach from this a bit before being able to come up with an alternative.\r\n\r\nThanks, I think I'd need to look at this more to give concrete suggestions, but I'd hope most functions would just return a simple success or failure status, with a descriptive error message in the case of failure. When functions need to return more complicated information or can fail in different ways that callers will want to distinguish, it should be easy to return the relevant information in custom struct or enum types. I think it's usually better for functions to return simpler custom types than more complicated shared types, because it lets callers know what values functions can return just by looking at their declarations.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2287225308",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 13908890225,
      "node_id": "LE_lADOABII586SDdapzwAAAAM9CNJx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13908890225",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-16T10:00:58Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14044032945,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANFFu-x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14044032945",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cdec7404bf204edf957edad899004caf2cb27553",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/cdec7404bf204edf957edad899004caf2cb27553",
      "created_at": "2024-08-28T10:10:14Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14058087390,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANF7WPe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14058087390",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1932d1039d7b07b1dade253b209faee59273e922",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/1932d1039d7b07b1dade253b209faee59273e922",
      "created_at": "2024-08-29T08:48:07Z"
    },
    {
      "event": "unlabeled",
      "id": 14059546247,
      "node_id": "UNLE_lADOABII586SDdapzwAAAANGA6aH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14059546247",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-29T10:35:37Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14070483742,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANGqose",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14070483742",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9246f36013b7caeabd531c32ee02457b56f7e175",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/9246f36013b7caeabd531c32ee02457b56f7e175",
      "created_at": "2024-08-29T21:11:37Z"
    },
    {
      "event": "labeled",
      "id": 14075219831,
      "node_id": "LE_lADOABII586SDdapzwAAAANG8s93",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14075219831",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-30T04:56:16Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 14077777424,
      "node_id": "UNLE_lADOABII586SDdapzwAAAANHGdYQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14077777424",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-30T08:59:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14095507400,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANIKF_I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14095507400",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "de298e6d94684b3a7b29ecd1fdea03ce07bdbbc6",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/de298e6d94684b3a7b29ecd1fdea03ce07bdbbc6",
      "created_at": "2024-09-01T19:46:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14095512074,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANIKHIK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14095512074",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8345e0ec6e5cd76bf6dbc7c27cef6f1f370613b7",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/8345e0ec6e5cd76bf6dbc7c27cef6f1f370613b7",
      "created_at": "2024-09-01T19:48:20Z"
    },
    {
      "event": "commented",
      "id": 2323487524,
      "node_id": "IC_kwDOABII586KfZsk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2323487524",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-01T20:29:45Z",
      "updated_at": "2024-09-01T20:29:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I think for most functions here it could be feasible to have more concise error codes without too much effort, but I feel like I have to detach from this a bit before being able to come up with an alternative.\r\n\r\nCompletely got rid of the `kernel_Error` with the last push. Thanks for laying out your logic ryanofsky, I feel like this is cleaner now. When looking at the Rust wrapper, the code seems much clearer too. Errors are now communicated through nullptr or false values. Where required, so far only for the verification functions, a richer status code is communicated to the developer.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2323487524",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2325264926,
      "node_id": "IC_kwDOABII586KmLoe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2325264926",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:13:34Z",
      "updated_at": "2024-09-02T20:13:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the update. It's good to drop the error codes so the C API can correspond 1:1 with the C++ API and not be tied to a more old fashioned and cumbersome error handling paradigm (for callers that want to know which errors are possible and not have to code defensively or fall back to failing generically).\r\n\r\nI am still -0 on the approach of introducing a C API to begin with, but happy to help review this and get merged and maintain it if other developers think this is the right approach to take (short term or long term). **It would be great to have more concept and approach ACKs for this PR** particularly from the @theuni who commented earlier and @josibake who seems to have some projects built on this and linked in the PR description.\r\n\r\nI think personally, if I wanted to use bitcoin core code from python or rust I would use tools like:\r\n\r\n- https://github.com/pybind/pybind11\r\n- https://docs.rs/cxx/latest/cxx/\r\n- https://hkalbasi.github.io/zngur/\r\n\r\nAnd interoperate with C++ directly,  instead of wrapping the C++ interface in a C interface first. Tools like these do not support all C++ types and features, and can make it necessary to selectively wrap more complicated C++ interfaces with simpler C++ interfaces, or even C interfaces, but I don't think this would be a justification for preemptively requiring every C++ type and function to be wrapped in C before it can be exposed. I just think the resulting boilerplate code:\r\n\r\n```c++\r\nkernel_Warning cast_kernel_warning(kernel::Warning warning)\r\n{\r\n    switch (warning) {\r\n    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\r\n        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\r\n    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\r\n        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\r\n    } // no default case, so the compiler can warn about missing cases\r\n    assert(false);\r\n}\r\n```\r\n\r\nand duplicative type definitions and documentation:\r\n\r\n```c++\r\n/**\r\n * A struct for holding the kernel notification callbacks. The user data pointer\r\n * may be used to point to user-defined structures to make processing the\r\n * notifications easier.\r\n */\r\ntypedef struct {\r\n    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\r\n    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\r\n    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\r\n    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\r\n    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\r\n    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\r\n    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\r\n    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\r\n} kernel_NotificationInterfaceCallbacks;\r\n```\r\n\r\nare fundamentally unnecessary and not worth effort of writing and maintaining when C++ is not a new or unusual language and not meaningfully less accessible or interoperable than C is.\r\n\r\nThere are legitimate reasons to wrap C++ in C. One reason would be to provide ABI compatibility. Another would be to make code accessible with dlopen/dlsym. But I think even in these cases you would want to wrap C++ in C selectively, or just define an intermediate C interface to pass pointers but use C++ on either side of the interface. I don't think you would want to drop down to C when not otherwise needed.\r\n\r\nThis is just to explain my point of view though. Overall I think this is very nice work, and I want to help with it, not hold it up.\r\n",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2325264926",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 14106972079,
      "node_id": "MEE_lADOABII586SDdapzwAAAANI10-v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14106972079",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:13:35Z"
    },
    {
      "event": "subscribed",
      "id": 14106972088,
      "node_id": "SE_lADOABII586SDdapzwAAAANI10-4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14106972088",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:13:35Z"
    },
    {
      "event": "mentioned",
      "id": 14106972097,
      "node_id": "MEE_lADOABII586SDdapzwAAAANI10_B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14106972097",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:13:35Z"
    },
    {
      "event": "subscribed",
      "id": 14106972099,
      "node_id": "SE_lADOABII586SDdapzwAAAANI10_D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14106972099",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:13:35Z"
    },
    {
      "event": "commented",
      "id": 2325272366,
      "node_id": "IC_kwDOABII586KmNcu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2325272366",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-02T20:24:15Z",
      "updated_at": "2024-09-02T20:25:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "Another idea worth mentioning is that a bitcoin kernel C API could be implemented as a separate C library depending on the C++ library. The new code here does not necessarily need to be part of the main bitcoin core git repository, and it could be in a separate project. A benefit of this approach is it could relieve bitcoin core developers from the responsibility of updating the C API and API documention when they change the C++ code. But a drawback is that C API might not always be up to date with latest version of bitcoin core code and could be broken between releases. Also it might not be as well reviewed or understood and might have more bugs.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2325272366",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2325848908,
      "node_id": "IC_kwDOABII586KoaNM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2325848908",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T07:59:36Z",
      "updated_at": "2024-09-03T07:59:36Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nAlso an implicit approach ACK despite not heavily reviewing the code (yet). I have been focusing on using the kernel library in proof of concept applications to get a better sense of how well the library works for downstream users and to hopefully uncover any pain points preemptively. A few of these projects are linked in the PR description.\r\n\r\nRegarding a C header vs C++ header, thanks @ryanofsky for taking the time to explain your thought process. I think you raise some excellent points. I'll try to respond as best I can, despite being slightly out of my depth on this topic ðŸ˜… \r\n\r\n---\r\n\r\nFor me, the value of libbitcoinkernel is only fully realised with the broadest possible language support and ease of use for downstream projects. This is why I strongly prefer the C header approach for the following reasons:\r\n\r\n1. Mature tooling for C language bindings\r\n2. Stable ABI\r\n3. Well established pattern in other open source projects\r\n\r\nIf we agree that broad language support is a goal of libbitcoinkernel, highlighting languages that _do not_ support C++ bindings is a much more compelling argument for a C header than highlighting languages that _do_ support C++ bindings as an argument for a C++ header.\r\n\r\nRegarding some of the mentioned languages/tools which do have C++ language binding support: \r\n\r\n> Tools like these do not support all C++ types and features, and can make it necessary to selectively wrap more complicated C++ interfaces with simpler C++ interfaces, or even C interfaces\r\n\r\nIn this example, who is doing the wrapping to be able to use these tools? If it's us, this seems much more complicated to ship and maintain a mixed wrapper and also feels over engineered to a specific set of tools and languages. It also does nothing for languages that do not support C++ bindings at all. As @TheCharlatan mentioned, languages favoured by academia lack C++ binding support and making libbitcoinkernel useful for academic research is a particularly important use case of libbitcoinkernel for me. \r\n\r\nIf we are exposing just a C++ header and expecting the downstream user to wrap selective parts in C interfaces to use libbitcoinkernel, we've eroded a fundamental value proposition of libbitcoinkernel, in my opinion. Namely, we want to provide a safe to use consensus library for users and minimise the risk of downstream projects introducing consensus bugs. Requiring downstream projects to write their own C++/C interfaces to be able to use kernel means that a) they just won't use libbitcoinkernel or b) will introduce bugs when writing these wrappers. Said differently, if boilerplate will be needed for broad language support, I would prefer we focus our energy on writing and reviewing boilerplate code that ensures the usefulness of the library for the broadest possible user base, instead of requiring a subset of users to each write their own boilerplate without any review from us.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2325848908",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 14110905700,
      "node_id": "MEE_lADOABII586SDdapzwAAAANJE1Vk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14110905700",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T07:59:37Z"
    },
    {
      "event": "subscribed",
      "id": 14110905724,
      "node_id": "SE_lADOABII586SDdapzwAAAANJE1V8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14110905724",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T07:59:37Z"
    },
    {
      "event": "mentioned",
      "id": 14110905746,
      "node_id": "MEE_lADOABII586SDdapzwAAAANJE1WS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14110905746",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T07:59:38Z"
    },
    {
      "event": "subscribed",
      "id": 14110905768,
      "node_id": "SE_lADOABII586SDdapzwAAAANJE1Wo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14110905768",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T07:59:38Z"
    },
    {
      "event": "labeled",
      "id": 14121577521,
      "node_id": "LE_lADOABII586SDdapzwAAAANJtiwx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14121577521",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-03T21:47:50Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14132738442,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANKYHmK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14132738442",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/33c71843e3fde0b795687a8626220f02f7243662",
      "created_at": "2024-09-04T14:55:31Z"
    },
    {
      "event": "unlabeled",
      "id": 14134579721,
      "node_id": "UNLE_lADOABII586SDdapzwAAAANKfJIJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14134579721",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-04T16:58:53Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 14235825318,
      "node_id": "LE_lADOABII586SDdapzwAAAANQhXSm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14235825318",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T16:28:40Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14239085806,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANQtzTu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14239085806",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "acca9ee21652d8cffac14926511c2d7a3e40043d",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/acca9ee21652d8cffac14926511c2d7a3e40043d",
      "created_at": "2024-09-12T21:19:08Z"
    },
    {
      "event": "commented",
      "id": 2347263134,
      "node_id": "IC_kwDOABII586L6GSe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2347263134",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T21:19:19Z",
      "updated_at": "2024-09-12T21:19:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2347263134",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 14239824640,
      "node_id": "UNLE_lADOABII586SDdapzwAAAANQwnsA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14239824640",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-12T22:52:24Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14250154975,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANRYBvf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14250154975",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c2806df5200e9f2a10f02ce7730d74bb4d47f05b",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/c2806df5200e9f2a10f02ce7730d74bb4d47f05b",
      "created_at": "2024-09-13T14:47:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14250745451,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANRaR5r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14250745451",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "20e0b8178ff931672717ba401c083d03712b3f28",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/20e0b8178ff931672717ba401c083d03712b3f28",
      "created_at": "2024-09-13T15:33:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14260729113,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANSAXUZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14260729113",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8777c555fc2da3fab14e7031f80681d9f2e193c6",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/8777c555fc2da3fab14e7031f80681d9f2e193c6",
      "created_at": "2024-09-14T20:06:35Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14562230874,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANj-gJa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14562230874",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b129d35f682d02d32a1915c922f2941ca37b42a0",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/b129d35f682d02d32a1915c922f2941ca37b42a0",
      "created_at": "2024-10-08T20:01:05Z"
    },
    {
      "event": "commented",
      "id": 2400726577,
      "node_id": "IC_kwDOABII586PGC4x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2400726577",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-08T20:07:11Z",
      "updated_at": "2024-10-08T20:07:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "Reworked after receiving a bunch of out-of-band feedback. In short:\r\n\r\n* Got rid of the `void *` option handling. Options are now set through dedicated functions instead of a single setter for all options.\r\n* Got rid of the `kernel_TaskRunner`. The context now holds an immediate task runner internally on which a user can register various validation interfaces. It is now the user's responsibility to process the validation callbacks in a non-blocking fashion with their own infrastructure.\r\n* Got rid of raw data types in validation functions. Instead the raw data is now parsed and processed beforehand and the user always passes opaque data types.\r\n* Got rid of the explicit transaction output struct. The user can now retrieve the data with helper functions applied on opaque transaction output objects.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2400726577",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14613502863,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANnCFuP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14613502863",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e70e527ef215197cac56b3f6e065abd891724c13",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/e70e527ef215197cac56b3f6e065abd891724c13",
      "created_at": "2024-10-11T19:47:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14657994685,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAANprz-9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14657994685",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aa59e3323aad98560204f6dead4bfec5feff8078",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/aa59e3323aad98560204f6dead4bfec5feff8078",
      "created_at": "2024-10-15T13:47:39Z"
    },
    {
      "event": "review_requested",
      "id": 14787629773,
      "node_id": "RRE_lADOABII586SDdapzwAAAANxaVLN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787629773",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T15:17:04Z",
      "requested_reviewer": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "comment_deleted",
      "id": 14792106355,
      "node_id": "CDE_lADOABII586SDdapzwAAAANxraFz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14792106355",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T20:13:08Z"
    },
    {
      "event": "labeled",
      "id": 14845106922,
      "node_id": "LE_lADOABII586SDdapzwAAAAN01lrq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14845106922",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-24T09:18:04Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14847200048,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAN09ksw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14847200048",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "60e81f72a4fc4a45a0a48e434174813367a57a36",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/60e81f72a4fc4a45a0a48e434174813367a57a36",
      "created_at": "2024-10-24T10:12:34Z"
    },
    {
      "event": "unlabeled",
      "id": 14849342084,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAN1FvqE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14849342084",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-24T11:32:01Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14852191297,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAN1QnRB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14852191297",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a3f95c7c5e41da0439f4398249a60fb7b4f72548",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/a3f95c7c5e41da0439f4398249a60fb7b4f72548",
      "created_at": "2024-10-24T14:00:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14869766856,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAN2TqLI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14869766856",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8a7167c2bdd7d5629013a5c43ed48f724f92fa56",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/8a7167c2bdd7d5629013a5c43ed48f724f92fa56",
      "created_at": "2024-10-25T10:19:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15084388468,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAODGYB0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15084388468",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1047757ea3b4b78b51d7338ea44e2123851143fe",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/1047757ea3b4b78b51d7338ea44e2123851143fe",
      "created_at": "2024-11-02T20:39:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15211184239,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOKqEBv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15211184239",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a65c1cb6bc34010e81501ae0f3d3859cfb8e9650",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/a65c1cb6bc34010e81501ae0f3d3859cfb8e9650",
      "created_at": "2024-11-08T11:01:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15242060548,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOMf2ME",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15242060548",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2795c1c0786ea63a5bae65a985fbf7890e8fcd0c",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/2795c1c0786ea63a5bae65a985fbf7890e8fcd0c",
      "created_at": "2024-11-10T21:13:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15296213529,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOPubIZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15296213529",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "48158303fe276cb2f8fbc53ff31a4162d8f55c84",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/48158303fe276cb2f8fbc53ff31a4162d8f55c84",
      "created_at": "2024-11-14T10:17:15Z"
    },
    {
      "event": "subscribed",
      "id": 15303468226,
      "node_id": "SE_lADOABII586SDdapzwAAAAOQKGTC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15303468226",
      "actor": {
        "login": "rsantacroce",
        "id": 112706229,
        "node_id": "U_kgDOBrfCtQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/112706229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rsantacroce",
        "html_url": "https://github.com/rsantacroce",
        "followers_url": "https://api.github.com/users/rsantacroce/followers",
        "following_url": "https://api.github.com/users/rsantacroce/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rsantacroce/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rsantacroce/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rsantacroce/subscriptions",
        "organizations_url": "https://api.github.com/users/rsantacroce/orgs",
        "repos_url": "https://api.github.com/users/rsantacroce/repos",
        "events_url": "https://api.github.com/users/rsantacroce/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rsantacroce/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T19:29:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15324983917,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAORcLJt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15324983917",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "26042c718462bc4e484526fa14fb962e95e8bc13",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/26042c718462bc4e484526fa14fb962e95e8bc13",
      "created_at": "2024-11-17T14:13:59Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15325411292,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAORdzfc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15325411292",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "created_at": "2024-11-17T16:51:40Z"
    },
    {
      "event": "reviewed",
      "id": 2297633388,
      "node_id": "PRR_kwDOABII586I8xps",
      "url": null,
      "actor": null,
      "commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2024-11-19T19:19:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Strong concept ACK.\r\n\r\nI've started building a python wrapper library to get familiar with and actually use the interface, so most of my comments for now will be based on that experience and reading the documentation.",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2297633388",
      "submitted_at": "2024-11-19T19:19:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "commented",
      "id": 2486794714,
      "node_id": "IC_kwDOABII586UOXna",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2486794714",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-19T21:31:43Z",
      "updated_at": "2024-11-19T21:31:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the review @stickies-v!\r\n\r\nUpdated 6c9121f7907262b2bf065a7ceeb8bca620060a7f -> 6c9121f7907262b2bf065a7ceeb8bca620060a7f ([kernelApi_0](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_0) -> [kernelApi_1](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_1), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_0..kernelApi_1))\r\n\r\n* Added, cleaned up, and precised a bunch of documentation\r\n* Slightly changed the order of a function's arguments, such that it takes the kernel context first.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2486794714",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15355609963,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOTRANr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15355609963",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-19T21:31:45Z"
    },
    {
      "event": "subscribed",
      "id": 15355609974,
      "node_id": "SE_lADOABII586SDdapzwAAAAOTRAN2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15355609974",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-19T21:31:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15355610268,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOTRASc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15355610268",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6c9121f7907262b2bf065a7ceeb8bca620060a7f",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/6c9121f7907262b2bf065a7ceeb8bca620060a7f",
      "created_at": "2024-11-19T21:31:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15370401029,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOUJbUF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15370401029",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "97fe2b25af31ca612c1f8d9f3de739fa3dee3902",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/97fe2b25af31ca612c1f8d9f3de739fa3dee3902",
      "created_at": "2024-11-20T17:04:13Z"
    },
    {
      "event": "commented",
      "id": 2489128571,
      "node_id": "IC_kwDOABII586UXRZ7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2489128571",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-20T17:04:18Z",
      "updated_at": "2024-11-20T17:04:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 6c9121f7907262b2bf065a7ceeb8bca620060a7f -> 97fe2b25af31ca612c1f8d9f3de739fa3dee3902 ([kernelApi_1](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_1) -> [kernelApi_2](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_2), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_1..kernelApi_2))\r\n\r\n* Added @stickies-v's [suggestion](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1757015877), implementing variadic args for nonnull attribute macro.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2489128571",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15370403729,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOUJb-R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15370403729",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-20T17:04:20Z"
    },
    {
      "event": "subscribed",
      "id": 15370403751,
      "node_id": "SE_lADOABII586SDdapzwAAAAOUJb-n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15370403751",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-20T17:04:20Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15389463292,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOVSJL8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15389463292",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5910f9bb18da35101144304d385618d7b82420f5",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/5910f9bb18da35101144304d385618d7b82420f5",
      "created_at": "2024-11-21T22:11:01Z"
    },
    {
      "event": "commented",
      "id": 2492442146,
      "node_id": "IC_kwDOABII586Uj6Yi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2492442146",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-21T22:11:03Z",
      "updated_at": "2024-11-21T22:18:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 97fe2b25af31ca612c1f8d9f3de739fa3dee3902 -> a9b71eadb8eff5530500cdb7d7227b8575948df6 ([kernelApi_2](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_2) -> [kernelApi_3](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_3), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_2..kernelApi_3))\r\n\r\n* As discussed with @stickies-v out of band, make callbacks only return `const` pointers, which further ensures that the user does not de-allocate or take ownership of them.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2492442146",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15389463705,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOVSJSZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15389463705",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-21T22:11:04Z"
    },
    {
      "event": "subscribed",
      "id": 15389463721,
      "node_id": "SE_lADOABII586SDdapzwAAAAOVSJSp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15389463721",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-21T22:11:04Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15389525737,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOVSYbp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15389525737",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a9b71eadb8eff5530500cdb7d7227b8575948df6",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/a9b71eadb8eff5530500cdb7d7227b8575948df6",
      "created_at": "2024-11-21T22:18:49Z"
    },
    {
      "event": "labeled",
      "id": 15389526570,
      "node_id": "LE_lADOABII586SDdapzwAAAAOVSYoq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15389526570",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-21T22:18:54Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2492461843,
      "node_id": "IC_kwDOABII586Uj_MT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2492461843",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-21T22:18:55Z",
      "updated_at": "2024-11-21T22:18:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/33351144688</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2492461843",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 15390044587,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAOVUXGr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15390044587",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-21T23:07:43Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15395688304,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOVp49w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15395688304",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fc67047b7e1fb7031285f790ea3a7ea349474f31",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/fc67047b7e1fb7031285f790ea3a7ea349474f31",
      "created_at": "2024-11-22T10:36:41Z"
    },
    {
      "event": "commented",
      "id": 2493443688,
      "node_id": "IC_kwDOABII586Unu5o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2493443688",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-22T10:36:47Z",
      "updated_at": "2024-11-22T10:37:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated a9b71eadb8eff5530500cdb7d7227b8575948df6 -> fc67047b7e1fb7031285f790ea3a7ea349474f31 ([kernelApi_3](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_3) -> [kernelApi_4](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_4), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_3..kernelApi_4))\r\n\r\n* Made the `user_data` argument passed in with the callbacks `const` to better convey that the library doesn't do anything with it besides passing it back to the user when the callback is triggered. This mimics the behaviour in libsecp: https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L361",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2493443688",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15397783487,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOVx4e_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15397783487",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "created_at": "2024-11-22T13:47:23Z"
    },
    {
      "event": "commented",
      "id": 2493809430,
      "node_id": "IC_kwDOABII586UpIMW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2493809430",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-22T13:47:29Z",
      "updated_at": "2024-11-22T13:47:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated fc67047b7e1fb7031285f790ea3a7ea349474f31 -> 34a8429ff3a870c0caaf4c4790becd86c5acde38 ([kernelApi_4](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_4) -> [kernelApi_5](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_5), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_4..kernelApi_5))\r\n\r\n* More consistent `const` usage ",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2493809430",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2448664774,
      "node_id": "PRR_kwDOABII586R86jG",
      "url": null,
      "actor": null,
      "commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2024-11-25T21:41:35Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2448664774",
      "submitted_at": "2024-11-25T21:41:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15427548828,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOXjbac",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15427548828",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "35f8503285c672e8ee7e98617e236b38d8ce7a7f",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/35f8503285c672e8ee7e98617e236b38d8ce7a7f",
      "created_at": "2024-11-25T22:32:27Z"
    },
    {
      "event": "commented",
      "id": 2499171169,
      "node_id": "IC_kwDOABII586U9lNh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2499171169",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-25T22:32:40Z",
      "updated_at": "2024-11-25T22:32:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the review @stickies-v!\r\n\r\nUpdated 34a8429ff3a870c0caaf4c4790becd86c5acde38 -> 35f8503285c672e8ee7e98617e236b38d8ce7a7f ([kernelApi_5](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_5) -> [kernelApi_6](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_6), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_5..kernelApi_6))\r\n\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1850657572), fixed worker threads docstring.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1852510169), make argument ordering more consistent.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1852512769), name functions consistently that return a new object with the help of other objects with `from` instead of `by`.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2499171169",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15427550576,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOXjb1w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15427550576",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-25T22:32:41Z"
    },
    {
      "event": "subscribed",
      "id": 15427550590,
      "node_id": "SE_lADOABII586SDdapzwAAAAOXjb1-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15427550590",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-25T22:32:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15464373294,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOZv5wu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15464373294",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "403c20980ec118f6efdd21d7c25646e20574583b",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/403c20980ec118f6efdd21d7c25646e20574583b",
      "created_at": "2024-11-28T11:43:37Z"
    },
    {
      "event": "commented",
      "id": 2505923802,
      "node_id": "IC_kwDOABII586VXVza",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2505923802",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-28T11:43:42Z",
      "updated_at": "2024-11-28T11:43:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 35f8503285c672e8ee7e98617e236b38d8ce7a7f -> 403c20980ec118f6efdd21d7c25646e20574583b ([kernelApi_6](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_6) -> [kernelApi_7](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_7), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_6..kernelApi_7))\r\n\r\n* Integrate the validation interface into the context. This avoids having to create/destroy and register/deregister a standalone validation interface object and should make it a bit easier to use. I was hesitant to do this, because it doesn't allow the user to register multiple interfaces anymore. However, since the user can multiplex the notifications by themselves, I don't think this is something worth keeping around.\r\n* Consistently apply the block hash deleter ",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2505923802",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15492449188,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAObbAOk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15492449188",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8598bc9e5d3fb7ebc08cf0c6422b3e44c56230d6",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/8598bc9e5d3fb7ebc08cf0c6422b3e44c56230d6",
      "created_at": "2024-12-02T12:41:52Z"
    },
    {
      "event": "commented",
      "id": 2511440437,
      "node_id": "IC_kwDOABII586VsYo1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2511440437",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-02T12:42:24Z",
      "updated_at": "2024-12-02T12:42:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 403c20980ec118f6efdd21d7c25646e20574583b -> 8598bc9e5d3fb7ebc08cf0c6422b3e44c56230d6 ([kernelApi_7](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_7) -> [kernelApi_8](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_8), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_7..kernelApi_8))\r\n\r\n* Get build system fixes from #31395 and #31357",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2511440437",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15520834085,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOdHSIl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15520834085",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6090df267dfece6192b567fed6582445aa811e7f",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/6090df267dfece6192b567fed6582445aa811e7f",
      "created_at": "2024-12-04T08:01:26Z"
    },
    {
      "event": "commented",
      "id": 2516465730,
      "node_id": "IC_kwDOABII586V_jhC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2516465730",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-04T08:01:31Z",
      "updated_at": "2024-12-04T08:01:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 8598bc9e5d3fb7ebc08cf0c6422b3e44c56230d6 -> 6090df267dfece6192b567fed6582445aa811e7f ([kernelApi_8](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_8) -> [kernelApi_9](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_9), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_8..kernelApi_9))\r\n\r\n* Alligned process block pre-checks through https://github.com/bitcoin/bitcoin/pull/31175\r\n* Clamp the work threads number so we properly handle the value range through  https://github.com/bitcoin/bitcoin/pull/31313\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2516465730",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15662470033,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOljlOR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15662470033",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "247a8a02c636250ee7e5c06f08cd18ddb1de6be5",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/247a8a02c636250ee7e5c06f08cd18ddb1de6be5",
      "created_at": "2024-12-15T22:52:37Z"
    },
    {
      "event": "commented",
      "id": 2544151447,
      "node_id": "IC_kwDOABII586XpKuX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2544151447",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-15T22:54:08Z",
      "updated_at": "2024-12-15T22:54:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 6090df267dfece6192b567fed6582445aa811e7f -> 247a8a02c636250ee7e5c06f08cd18ddb1de6be5 ([kernelApi_9](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_9) -> [kernelApi_10](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_10), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_9..kernelApi_10))\r\n\r\n* Tweaked docs to be more doxygen friendly.\r\n* Corrected transaction in taproot script validation tests. I must have committed a version where I was testing a different invariant by mistake. The test now correctly asserts that a taproot transaction can pass validation.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2544151447",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15668897562,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOl8Gca",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15668897562",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e203b460d8ab1d92949ab8714a9265c343a5eee",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/9e203b460d8ab1d92949ab8714a9265c343a5eee",
      "created_at": "2024-12-16T11:23:37Z"
    },
    {
      "event": "commented",
      "id": 2545355032,
      "node_id": "IC_kwDOABII586XtwkY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2545355032",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-16T11:23:41Z",
      "updated_at": "2024-12-16T11:23:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 247a8a02c636250ee7e5c06f08cd18ddb1de6be5 -> 9e203b460d8ab1d92949ab8714a9265c343a5eee ([kernelApi_10](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_10) -> [kernelApi_11](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_11), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_10..kernelApi_11))\r\n\r\n* Changed how the notification callbacks are set. There was no real need for a separate notifications object, so I removed it.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2545355032",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2508874952,
      "node_id": "PRR_kwDOABII586VimTI",
      "url": null,
      "actor": null,
      "commit_id": "9e203b460d8ab1d92949ab8714a9265c343a5eee",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2024-12-17T13:23:56Z",
      "author_association": "MEMBER",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2508874952",
      "submitted_at": "2024-12-17T13:23:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15687423979,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOnCxfr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15687423979",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "73acb3ff8a04cddc4904c446c2521dd2b2abc84d",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/73acb3ff8a04cddc4904c446c2521dd2b2abc84d",
      "created_at": "2024-12-17T14:57:50Z"
    },
    {
      "event": "commented",
      "id": 2548677901,
      "node_id": "IC_kwDOABII586X6b0N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2548677901",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T14:58:36Z",
      "updated_at": "2024-12-17T14:58:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for having a look @laanwj!\r\n\r\nUpdated 9e203b460d8ab1d92949ab8714a9265c343a5eee -> 73acb3ff8a04cddc4904c446c2521dd2b2abc84d ([kernelApi_11](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_11) -> [kernelApi_12](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_12), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_11..kernelApi_12))\r\n\r\n* Addressed @laanwj's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1888513807), added a size parameter to all functions taking a null terminated `const char*` string parameter. This is arguably safer, since we don't completely rely on the null terminator for safety.\r\n* Removed '\\n' newlines in the log calls in the kernel wrapper calls.\r\n* Added the `progress` callback back again. I disabled it some time ago, and forgot to add it back again.\r\n* Use string views instead of `const char*` in the c++ wrapper.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2548677901",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15687438141,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOnC089",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15687438141",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T14:58:38Z"
    },
    {
      "event": "subscribed",
      "id": 15687438159,
      "node_id": "SE_lADOABII586SDdapzwAAAAOnC09P",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15687438159",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T14:58:38Z"
    },
    {
      "event": "commented",
      "id": 2548839707,
      "node_id": "IC_kwDOABII586X7DUb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2548839707",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T15:54:42Z",
      "updated_at": "2024-12-17T15:54:42Z",
      "author_association": "MEMBER",
      "body": "To make the [doxygen documentation](http://thecharlatan.ch/kernel-docs/bitcoinkernel_8h.html) nicer to read, i've added grouping to the list of functions, and reordered a bit to make sure `create` is first and `destroy` always last within the group (if applicable), feel free to take over this patch:\r\n\r\nhttps://github.com/laanwj/bitcoin/commit/c222651aca4578857f5d432bd6ce221b5602ee38",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2548839707",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15690259436,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOnNlvs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15690259436",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/20eec64b5e417cac8c68100826c0adf2152a49eb",
      "created_at": "2024-12-17T17:40:31Z"
    },
    {
      "event": "commented",
      "id": 2549143345,
      "node_id": "IC_kwDOABII586X8Ncx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2549143345",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T17:40:37Z",
      "updated_at": "2024-12-17T17:40:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the doc suggestions @laanwj, I just moved a few functions to different places compared to your patch. Feel free to send me another me, if you think it still is not ideal. The groupings do look very nice in the docs now and also makes it a bit more straight forward to decide where to put new functions.\r\n\r\nUpdated 73acb3ff8a04cddc4904c446c2521dd2b2abc84d -> 20eec64b5e417cac8c68100826c0adf2152a49eb ([kernelApi_12](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_12) -> [kernelApi_13](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_13), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_12..kernelApi_13))\r\n\r\n* Applied @laanwj's [patch](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2548839707), introducing doc groupings for the header functions.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2549143345",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15690260923,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOnNmG7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15690260923",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T17:40:39Z"
    },
    {
      "event": "subscribed",
      "id": 15690260945,
      "node_id": "SE_lADOABII586SDdapzwAAAAOnNmHR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15690260945",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-17T17:40:39Z"
    },
    {
      "event": "referenced",
      "id": 15707084769,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoNxfh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707084769",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d7c4348efefdb3858184a42678f1571dbb820361",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/d7c4348efefdb3858184a42678f1571dbb820361",
      "created_at": "2024-12-18T17:59:40Z"
    },
    {
      "event": "referenced",
      "id": 15707084784,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoNxfw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707084784",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "576176ce7962b31a76948bfdf524b3fd0acffc89",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/576176ce7962b31a76948bfdf524b3fd0acffc89",
      "created_at": "2024-12-18T17:59:40Z"
    },
    {
      "event": "referenced",
      "id": 15707084801,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoNxgB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707084801",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "198280656b70fd7eef9bf4c0e2260475539d24b7",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/198280656b70fd7eef9bf4c0e2260475539d24b7",
      "created_at": "2024-12-18T17:59:40Z"
    },
    {
      "event": "referenced",
      "id": 15707084827,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoNxgb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707084827",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1ed55b80716d4b82ca27caa014b2295792d4d03f",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/1ed55b80716d4b82ca27caa014b2295792d4d03f",
      "created_at": "2024-12-18T17:59:40Z"
    },
    {
      "event": "referenced",
      "id": 15707492152,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoPU84",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707492152",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7fac90b9cc71863a6246444da96c9346de0e3389",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/7fac90b9cc71863a6246444da96c9346de0e3389",
      "created_at": "2024-12-18T18:39:51Z"
    },
    {
      "event": "referenced",
      "id": 15707492165,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoPU9F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707492165",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e5d92ac2f6c7c4e1d7eb1ae17be096de26e3841",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/9e5d92ac2f6c7c4e1d7eb1ae17be096de26e3841",
      "created_at": "2024-12-18T18:39:51Z"
    },
    {
      "event": "referenced",
      "id": 15707492181,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoPU9V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707492181",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d624a26513a6448412b34d128b94fb951ae5a468",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/d624a26513a6448412b34d128b94fb951ae5a468",
      "created_at": "2024-12-18T18:39:51Z"
    },
    {
      "event": "referenced",
      "id": 15707492209,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoPU9x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707492209",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7e4c76c9d80f21e34bc1fe86131c6185d413fbd1",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/7e4c76c9d80f21e34bc1fe86131c6185d413fbd1",
      "created_at": "2024-12-18T18:39:51Z"
    },
    {
      "event": "referenced",
      "id": 15707822293,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoQljV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707822293",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4103e2cb36b189fed5112b3461d7e673ee4b2533",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/4103e2cb36b189fed5112b3461d7e673ee4b2533",
      "created_at": "2024-12-18T19:12:30Z"
    },
    {
      "event": "referenced",
      "id": 15707822308,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoQljk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707822308",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b7b739325c31e44d482e7c35ece13160fe5a843f",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/b7b739325c31e44d482e7c35ece13160fe5a843f",
      "created_at": "2024-12-18T19:12:30Z"
    },
    {
      "event": "referenced",
      "id": 15707822323,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoQljz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707822323",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1db5599b6d0ca92085b9f0970724abc0155a96f7",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/1db5599b6d0ca92085b9f0970724abc0155a96f7",
      "created_at": "2024-12-18T19:12:30Z"
    },
    {
      "event": "referenced",
      "id": 15707822343,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOoQlkH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15707822343",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b42cf6ac982c210856fb5c5c12d2cc9a088b7194",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/b42cf6ac982c210856fb5c5c12d2cc9a088b7194",
      "created_at": "2024-12-18T19:12:31Z"
    },
    {
      "event": "reviewed",
      "id": 2512695597,
      "node_id": "PRR_kwDOABII586VxLEt",
      "url": null,
      "actor": null,
      "commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2024-12-18T19:26:38Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2512695597",
      "submitted_at": "2024-12-18T19:26:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "reviewed",
      "id": 2513154038,
      "node_id": "PRR_kwDOABII586Vy6_2",
      "url": null,
      "actor": null,
      "commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2024-12-19T01:36:11Z",
      "author_association": "MEMBER",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2513154038",
      "submitted_at": "2024-12-19T01:36:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15715703477,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAOoupq1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15715703477",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "created_at": "2024-12-19T10:57:50Z"
    },
    {
      "event": "commented",
      "id": 2553418201,
      "node_id": "IC_kwDOABII586YMhHZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2553418201",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-19T10:58:01Z",
      "updated_at": "2024-12-19T10:58:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the suggestion @stickies-v, I think it is the right call.\r\n\r\nUpdated 20eec64b5e417cac8c68100826c0adf2152a49eb -> f157b0cbc7d90075858a6522d13a7bc4f0b25a5f ([kernelApi_13](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_13) -> [kernelApi_14](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_14), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_13..kernelApi_14))\r\n\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1890734754), applying the suggestion for rolling chainstate loading into chainstate creation.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2553418201",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15715706191,
      "node_id": "MEE_lADOABII586SDdapzwAAAAOouqVP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15715706191",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-19T10:58:02Z"
    },
    {
      "event": "subscribed",
      "id": 15715706210,
      "node_id": "SE_lADOABII586SDdapzwAAAAOouqVi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15715706210",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-19T10:58:02Z"
    },
    {
      "event": "referenced",
      "id": 15719682717,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOo91Kd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15719682717",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "523dee4273f1020c25695e81f62014178cc19205",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/523dee4273f1020c25695e81f62014178cc19205",
      "created_at": "2024-12-19T14:19:10Z"
    },
    {
      "event": "referenced",
      "id": 15720728795,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOpB0jb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15720728795",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "514f22fc450944ddb27d313ae0db95241e7f2989",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/514f22fc450944ddb27d313ae0db95241e7f2989",
      "created_at": "2024-12-19T15:08:59Z"
    },
    {
      "event": "referenced",
      "id": 15720991178,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOpC0nK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15720991178",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "dec7ebd46919d799ee011a71768090b046a2d0a1",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/dec7ebd46919d799ee011a71768090b046a2d0a1",
      "created_at": "2024-12-19T15:23:45Z"
    },
    {
      "event": "referenced",
      "id": 15721024220,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOpC8rc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15721024220",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f9408aadadfc566c4250b3158139921ebc0fd02a",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/f9408aadadfc566c4250b3158139921ebc0fd02a",
      "created_at": "2024-12-19T15:25:40Z"
    },
    {
      "event": "referenced",
      "id": 15721045447,
      "node_id": "REFE_lADOABII586SDdapzwAAAAOpDB3H",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15721045447",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "befc5e7a09e5505c1faab78f249d3d9ab5aadf0c",
      "commit_url": "https://api.github.com/repos/stickies-v/py-bitcoinkernel/commits/befc5e7a09e5505c1faab78f249d3d9ab5aadf0c",
      "created_at": "2024-12-19T15:26:46Z"
    },
    {
      "event": "reviewed",
      "id": 2518337899,
      "node_id": "PRR_kwDOABII586WGslr",
      "url": null,
      "actor": null,
      "commit_id": "f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2024-12-20T21:03:12Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2518337899",
      "submitted_at": "2024-12-20T21:03:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "reviewed",
      "id": 2552730240,
      "node_id": "PRR_kwDOABII586YJ5KA",
      "url": null,
      "actor": null,
      "commit_id": "f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-01-15T13:18:20Z",
      "author_association": "MEMBER",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2552730240",
      "submitted_at": "2025-01-15T13:18:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "reviewed",
      "id": 2552732729,
      "node_id": "PRR_kwDOABII586YJ5w5",
      "url": null,
      "actor": null,
      "commit_id": "f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-01-15T13:19:28Z",
      "author_association": "MEMBER",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2552732729",
      "submitted_at": "2025-01-15T13:19:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "labeled",
      "id": 15945075638,
      "node_id": "LE_lADOABII586SDdapzwAAAAO2Zou2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15945075638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-15T18:10:19Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15947065131,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAO2hOcr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15947065131",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4dde75858a3b08f84d71176c7be14bae62020b1f",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/4dde75858a3b08f84d71176c7be14bae62020b1f",
      "created_at": "2025-01-15T21:00:17Z"
    },
    {
      "event": "commented",
      "id": 2593925274,
      "node_id": "IC_kwDOABII586anCia",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2593925274",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-15T21:00:27Z",
      "updated_at": "2025-01-15T21:00:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the suggestions @laanwj,\r\n\r\nRebased f157b0cbc7d90075858a6522d13a7bc4f0b25a5f -> f25616bec485ee6a70e4b797758d4987d25a7c25 ([kernelApi_14](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_14) -> [kernelApi_15](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_15), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_14..kernelApi_15))\r\n\r\n* Fixed conflict with #31061\r\n\r\nUpdated f25616bec485ee6a70e4b797758d4987d25a7c25 -> 4dde75858a3b08f84d71176c7be14bae62020b1f ([kernelApi_15](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_15) -> [kernelApi_16](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_16), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_15..kernelApi_16))\r\n\r\n* Took @laanwj's [suggestion](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1916637752), avoiding strtol in hex string to byte vector conversion\r\n* Addressed @laanwj's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1916639299), added missing `vector` include.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2593925274",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 15947069715,
      "node_id": "MEE_lADOABII586SDdapzwAAAAO2hPkT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15947069715",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-15T21:00:29Z"
    },
    {
      "event": "subscribed",
      "id": 15947069734,
      "node_id": "SE_lADOABII586SDdapzwAAAAO2hPkm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15947069734",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-15T21:00:29Z"
    },
    {
      "event": "unlabeled",
      "id": 15951226105,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAO2xGT5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15951226105",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-16T04:13:53Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15974098528,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAO4IWZg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15974098528",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3eefbda3710aad3adc4aac3a6a36e381f9e9f555",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/3eefbda3710aad3adc4aac3a6a36e381f9e9f555",
      "created_at": "2025-01-17T09:30:28Z"
    },
    {
      "event": "commented",
      "id": 2597803878,
      "node_id": "IC_kwDOABII586a11dm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2597803878",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-17T09:30:32Z",
      "updated_at": "2025-01-17T09:34:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 4dde75858a3b08f84d71176c7be14bae62020b1f -> 538671edce5813a62405b9bd5c50c39263c58435 ([kernelApi_16](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_16) -> [kernelApi_17](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_17), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_16..kernelApi_17))\r\n\r\n* Get new method for computing cache sizes from https://github.com/bitcoin/bitcoin/pull/31483",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2597803878",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15974144234,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAO4Ihjq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15974144234",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "538671edce5813a62405b9bd5c50c39263c58435",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/538671edce5813a62405b9bd5c50c39263c58435",
      "created_at": "2025-01-17T09:34:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15976852232,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAO4S2sI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15976852232",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "created_at": "2025-01-17T12:34:56Z"
    },
    {
      "event": "commented",
      "id": 2599599923,
      "node_id": "IC_kwDOABII586a8r8z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2599599923",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-18T07:55:49Z",
      "updated_at": "2025-01-18T07:55:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 538671edce5813a62405b9bd5c50c39263c58435 -> 01a43b24436e0aed7b8f79d3857630a4bf6a0545 ([kernelApi_17](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_17) -> [kernelApi_18](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_18), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_17..kernelApi_18))\r\n\r\n* Get functional test fix from #31675",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2599599923",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2584276519,
      "node_id": "PRR_kwDOABII586aCO4n",
      "url": null,
      "actor": null,
      "commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-01-30T15:39:49Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2584276519",
      "submitted_at": "2025-01-30T15:39:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "unsubscribed",
      "id": 16129570394,
      "node_id": "UE_lADOABII586SDdapzwAAAAPBZbZa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16129570394",
      "actor": {
        "login": "PRADACANDI18",
        "id": 91190628,
        "node_id": "MDQ6VXNlcjkxMTkwNjI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/91190628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PRADACANDI18",
        "html_url": "https://github.com/PRADACANDI18",
        "followers_url": "https://api.github.com/users/PRADACANDI18/followers",
        "following_url": "https://api.github.com/users/PRADACANDI18/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PRADACANDI18/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PRADACANDI18/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PRADACANDI18/subscriptions",
        "organizations_url": "https://api.github.com/users/PRADACANDI18/orgs",
        "repos_url": "https://api.github.com/users/PRADACANDI18/repos",
        "events_url": "https://api.github.com/users/PRADACANDI18/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PRADACANDI18/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-30T20:14:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16138805067,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPB8p9L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16138805067",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "10e71b4c47e1b199622280d100155ed5d6ef6d66",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/10e71b4c47e1b199622280d100155ed5d6ef6d66",
      "created_at": "2025-01-31T12:20:24Z"
    },
    {
      "event": "commented",
      "id": 2627079274,
      "node_id": "IC_kwDOABII586clgxq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2627079274",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T12:20:31Z",
      "updated_at": "2025-01-31T12:20:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 01a43b24436e0aed7b8f79d3857630a4bf6a0545 -> 10e71b4c47e1b199622280d100155ed5d6ef6d66 ([kernelApi_18](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_18) -> [kernelApi_19](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_19), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_18..kernelApi_19))\r\n\r\n* Hooked up kernel tests to cmake so the CI can run them through `ctest`\r\n* Added `test_kernel`, `libbitcoinkernel.so`, and `kernel/bitcoin-chainstate` to some more CI builds.\r\n* Patched some small build errors related to unused variables and type narrowing.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1935834281), fixing path to string conversion.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2627079274",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16138806644,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPB8qV0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16138806644",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T12:20:33Z"
    },
    {
      "event": "subscribed",
      "id": 16138806760,
      "node_id": "SE_lADOABII586SDdapzwAAAAPB8qXo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16138806760",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T12:20:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16138978742,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPB9UW2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16138978742",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f4cdffba0d8c60ff6e6eb9732bd1b1f02fcada56",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/f4cdffba0d8c60ff6e6eb9732bd1b1f02fcada56",
      "created_at": "2025-01-31T12:27:44Z"
    },
    {
      "event": "commented",
      "id": 2627119867,
      "node_id": "IC_kwDOABII586clqr7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2627119867",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T12:27:54Z",
      "updated_at": "2025-01-31T15:30:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased  10e71b4c47e1b199622280d100155ed5d6ef6d66 -> fb6e0deee18dff38219c9646d2461a40de03ed66 ([kernelApi_19](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_19) -> [kernelApi_20](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_20), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_19..kernelApi_20))\r\n\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2627119867",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2627360248,
      "node_id": "IC_kwDOABII586cmlX4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2627360248",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T13:36:47Z",
      "updated_at": "2025-01-31T13:36:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36477768799</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2627360248",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 16140552502,
      "node_id": "LE_lADOABII586SDdapzwAAAAPCDUk2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16140552502",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T13:36:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16141820420,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPCIKIE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16141820420",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8a2a44012f0250026ce3f0e00b0014c59b4bbe7d",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/8a2a44012f0250026ce3f0e00b0014c59b4bbe7d",
      "created_at": "2025-01-31T15:08:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16142178152,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPCJhdo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16142178152",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fb6e0deee18dff38219c9646d2461a40de03ed66",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/fb6e0deee18dff38219c9646d2461a40de03ed66",
      "created_at": "2025-01-31T15:31:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16150099004,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPCnvQ8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16150099004",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f926d7ef34773b7836e94491a16021288c125b11",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/f926d7ef34773b7836e94491a16021288c125b11",
      "created_at": "2025-02-01T13:12:53Z"
    },
    {
      "event": "commented",
      "id": 2628948969,
      "node_id": "IC_kwDOABII586cspPp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2628948969",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-01T13:13:02Z",
      "updated_at": "2025-02-01T13:13:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated fb6e0deee18dff38219c9646d2461a40de03ed66 -> f926d7ef34773b7836e94491a16021288c125b11 ([kernelApi_20](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_20) -> [kernelApi_21](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_21), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_20..kernelApi_21))\r\n\r\n* Added symbol exports where appropriate in the header to enable windows support\r\n* Completely replaced the existing bitcoin-chainstate with the new kernel-API-only bitcoin-chainstate.\r\n* Removed the cmake symbol visibility patch, instead relying on the header.\r\n* Removed flaky filesystem-related chainman and blockman opts tests.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2628948969",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16150383863,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPCo0z3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16150383863",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "817865d57daa822370b0f67e1e079fdd25ab3130",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/817865d57daa822370b0f67e1e079fdd25ab3130",
      "created_at": "2025-02-01T15:32:35Z"
    },
    {
      "event": "commented",
      "id": 2628997388,
      "node_id": "IC_kwDOABII586cs1EM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2628997388",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-01T15:33:00Z",
      "updated_at": "2025-02-01T15:33:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased f926d7ef34773b7836e94491a16021288c125b11 -> 817865d57daa822370b0f67e1e079fdd25ab3130 ([kernelApi_21](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_21) -> [kernelApi_22](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_22), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_21..kernelApi_22))\r\n\r\n* Fixed conflict with #30965, which necessitated some changes to the API: The block manager options are now responsible for the options affecting the block tree db.  ",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2628997388",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16163946539,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPDckAr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16163946539",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-03T15:08:55Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2592272385,
      "node_id": "PRR_kwDOABII586agvAB",
      "url": null,
      "actor": null,
      "commit_id": "817865d57daa822370b0f67e1e079fdd25ab3130",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-02-04T09:44:04Z",
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Armss9936",
        "id": 193652958,
        "node_id": "U_kgDOC4ro3g",
        "avatar_url": "https://avatars.githubusercontent.com/u/193652958?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Armss9936",
        "html_url": "https://github.com/Armss9936",
        "followers_url": "https://api.github.com/users/Armss9936/followers",
        "following_url": "https://api.github.com/users/Armss9936/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Armss9936/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Armss9936/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Armss9936/subscriptions",
        "organizations_url": "https://api.github.com/users/Armss9936/orgs",
        "repos_url": "https://api.github.com/users/Armss9936/repos",
        "events_url": "https://api.github.com/users/Armss9936/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Armss9936/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2592272385",
      "submitted_at": "2025-02-04T09:44:04Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "reviewed",
      "id": 2592273156,
      "node_id": "PRR_kwDOABII586agvME",
      "url": null,
      "actor": null,
      "commit_id": "817865d57daa822370b0f67e1e079fdd25ab3130",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-02-04T09:44:23Z",
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Armss9936",
        "id": 193652958,
        "node_id": "U_kgDOC4ro3g",
        "avatar_url": "https://avatars.githubusercontent.com/u/193652958?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Armss9936",
        "html_url": "https://github.com/Armss9936",
        "followers_url": "https://api.github.com/users/Armss9936/followers",
        "following_url": "https://api.github.com/users/Armss9936/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Armss9936/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Armss9936/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Armss9936/subscriptions",
        "organizations_url": "https://api.github.com/users/Armss9936/orgs",
        "repos_url": "https://api.github.com/users/Armss9936/repos",
        "events_url": "https://api.github.com/users/Armss9936/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Armss9936/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2592273156",
      "submitted_at": "2025-02-04T09:44:23Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "reviewed",
      "id": 2599912096,
      "node_id": "PRR_kwDOABII586a94Kg",
      "url": null,
      "actor": null,
      "commit_id": "817865d57daa822370b0f67e1e079fdd25ab3130",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-02-06T20:56:13Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2599912096",
      "submitted_at": "2025-02-06T20:56:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16282819593,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPKiBwJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16282819593",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "efbd187a1ff4409ca54ef94bcd97359e0948077e",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/efbd187a1ff4409ca54ef94bcd97359e0948077e",
      "created_at": "2025-02-12T15:23:04Z"
    },
    {
      "event": "commented",
      "id": 2654044188,
      "node_id": "IC_kwDOABII586eMYAc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2654044188",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T15:23:20Z",
      "updated_at": "2025-02-12T17:17:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for all the suggestions made over the past week @stickies-v!\r\n\r\nUpdated 817865d57daa822370b0f67e1e079fdd25ab3130 -> 5aeaa3f49d10562b8936ef36b1c25a6466dbe03e ([kernelApi_22](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_22) -> [kernelApi_23](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_23), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_22..kernelApi_23))\r\n\r\n* Adapted @stickies-v's suggestion made in https://github.com/TheCharlatan/bitcoin/pull/24 , by merging the `ChainstateManager::Options`, `BlockManager::Options`, or `ChainstateLoadOptions` into a single options struct. This should simplifies `ChainstateManager` initialization and slims down the API a bit.\r\n* Ran `clang-format` over the commits\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1945424649), taking the suggestion for making building the kernel tests only conditional on the kernel lib.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2654044188",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16282824053,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPKiC11",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16282824053",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T15:23:23Z"
    },
    {
      "event": "subscribed",
      "id": 16282824077,
      "node_id": "SE_lADOABII586SDdapzwAAAAPKiC2N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16282824077",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T15:23:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16284048307,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPKmtuz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16284048307",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5aeaa3f49d10562b8936ef36b1c25a6466dbe03e",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/5aeaa3f49d10562b8936ef36b1c25a6466dbe03e",
      "created_at": "2025-02-12T16:41:00Z"
    },
    {
      "event": "labeled",
      "id": 16284049550,
      "node_id": "LE_lADOABII586SDdapzwAAAAPKmuCO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16284049550",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:41:06Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2654274331,
      "node_id": "IC_kwDOABII586eNQMb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2654274331",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T16:41:07Z",
      "updated_at": "2025-02-12T16:41:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/37104019999</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2654274331",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16285363682,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPKru3i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16285363682",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T18:25:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 16312778223,
      "node_id": "LE_lADOABII586SDdapzwAAAAPMUT3v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16312778223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-14T14:38:06Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16313195955,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPMV52z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16313195955",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a604321c3e4bd50b52fa28e8567f6b068b2d2fb3",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/a604321c3e4bd50b52fa28e8567f6b068b2d2fb3",
      "created_at": "2025-02-14T15:10:20Z"
    },
    {
      "event": "commented",
      "id": 2659582312,
      "node_id": "IC_kwDOABII586ehgFo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2659582312",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-14T15:10:26Z",
      "updated_at": "2025-02-14T15:10:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 5aeaa3f49d10562b8936ef36b1c25a6466dbe03e -> a604321c3e4bd50b52fa28e8567f6b068b2d2fb3 ([kernelApi_23](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_23) -> [kernelApi_24](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_24), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_23..kernelApi_24))\r\n\r\n* Fixed conflict with #31844",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2659582312",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16314779708,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPMb8g8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16314779708",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-14T16:48:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2619786584,
      "node_id": "PRR_kwDOABII586cJsVY",
      "url": null,
      "actor": null,
      "commit_id": "a604321c3e4bd50b52fa28e8567f6b068b2d2fb3",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-02-17T00:59:37Z",
      "author_association": "NONE",
      "user": {
        "login": "walterl",
        "id": 23798,
        "node_id": "MDQ6VXNlcjIzNzk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/23798?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/walterl",
        "html_url": "https://github.com/walterl",
        "followers_url": "https://api.github.com/users/walterl/followers",
        "following_url": "https://api.github.com/users/walterl/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/walterl/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/walterl/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/walterl/subscriptions",
        "organizations_url": "https://api.github.com/users/walterl/orgs",
        "repos_url": "https://api.github.com/users/walterl/repos",
        "events_url": "https://api.github.com/users/walterl/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/walterl/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2619786584",
      "submitted_at": "2025-02-17T00:59:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16335402679,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPNqna3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16335402679",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2b743adeb0c59b815b84d8473486f46eaba12ad4",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/2b743adeb0c59b815b84d8473486f46eaba12ad4",
      "created_at": "2025-02-17T15:19:42Z"
    },
    {
      "event": "labeled",
      "id": 16360037364,
      "node_id": "LE_lADOABII586SDdapzwAAAAPPIlv0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16360037364",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-19T06:59:41Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16364179160,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPPYY7Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16364179160",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "251a55f2f0cc3cdfb7fa0015b76772586134cde3",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/251a55f2f0cc3cdfb7fa0015b76772586134cde3",
      "created_at": "2025-02-19T11:41:07Z"
    },
    {
      "event": "commented",
      "id": 2668392827,
      "node_id": "IC_kwDOABII586fDHF7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2668392827",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-19T11:41:35Z",
      "updated_at": "2025-02-19T11:41:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased a604321c3e4bd50b52fa28e8567f6b068b2d2fb3 -> 251a55f2f0cc3cdfb7fa0015b76772586134cde3 ([kernelApi_24](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_24) -> [kernelApi_25](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_25), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_24..kernelApi_25))\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2668392827",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16365555730,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPPdpAS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16365555730",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-19T13:20:04Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 16386468773,
      "node_id": "LE_lADOABII586SDdapzwAAAAPQtaul",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16386468773",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-20T17:21:24Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16386952044,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPQvQts",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16386952044",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c72b2c2883d4c8791267133f326e3f9347d1520b",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/c72b2c2883d4c8791267133f326e3f9347d1520b",
      "created_at": "2025-02-20T17:58:30Z"
    },
    {
      "event": "commented",
      "id": 2672264338,
      "node_id": "IC_kwDOABII586fR4SS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2672264338",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-20T17:58:54Z",
      "updated_at": "2025-02-20T17:58:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 251a55f2f0cc3cdfb7fa0015b76772586134cde3 -> c72b2c2883d4c8791267133f326e3f9347d1520b ([kernelApi_25](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_25) -> [kernelApi_26](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_26), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_25..kernelApi_26))",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2672264338",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16388214887,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPQ0FBn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16388214887",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-20T19:43:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16412466696,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPSQl4I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16412466696",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/29513955891e40e78466f2c666dfa13e9c1b2914",
      "created_at": "2025-02-22T11:54:38Z"
    },
    {
      "event": "commented",
      "id": 2676164722,
      "node_id": "IC_kwDOABII586fgwhy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2676164722",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-22T11:54:41Z",
      "updated_at": "2025-02-22T11:54:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated c72b2c2883d4c8791267133f326e3f9347d1520b -> 29513955891e40e78466f2c666dfa13e9c1b2914 ([kernelApi_26](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_26) -> [kernelApi_27](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_27), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_26..kernelApi_27))\r\n\r\n* Cleaned up some dead code missed while removing the `kernel_ValidationInterface`.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2676164722",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2675490600,
      "node_id": "PRR_kwDOABII586feL8o",
      "url": null,
      "actor": null,
      "commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-03-13T13:35:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've been looking at thread-safety, and left some comments on it (as well as some unrelated ones).\r\n\r\nI think the API is pretty close to being thread-safe. Would be nice if we can make some guarantees on it and document it as such?",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2675490600",
      "submitted_at": "2025-03-13T13:35:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "labeled",
      "id": 16752228712,
      "node_id": "LE_lADOABII586SDdapzwAAAAPmgrlo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16752228712",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T01:28:26Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2725437236,
      "node_id": "IC_kwDOABII586ict80",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2725437236",
      "actor": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T18:16:38Z",
      "updated_at": "2025-03-14T18:16:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "rust-bitcoin maintains a file of [constants](https://github.com/tcharding/rust-bitcoin/blob/0ca9fcfd0ea81a7bb0d781bdc07a136cea9d0796/bitcoin/src/policy.rs) which are meant to mirror values in core.  We've discussed trying to find an automated solution to keep these consts synchronized since right now, these are manually maintained.  This is a point of annoyance since these values are constantly becoming stale (pun intended).  Would it be possible to use these C headers to automatically build a rust crate of constants from a C header API?  Or would that be overkill..",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2725437236",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2725441239,
      "node_id": "IC_kwDOABII586icu7X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2725441239",
      "actor": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T18:18:03Z",
      "updated_at": "2025-03-14T18:18:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "Furthermore, besides keeping values synchronized, an automated solution which would generate all available consts would be ideal.",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2725441239",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2685229851,
      "node_id": "PRR_kwDOABII586gDVsb",
      "url": null,
      "actor": null,
      "commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-03-14T18:41:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "A few comments regarding logging. It's a bit awkward to have LoggingConnection instances, but only global setters to update their granularity, so #30342 looks like a welcome improvement.\r\n\r\nBesides that, hooking up a downstream log viewer in py-bitcoinkernel was fairly straightforward. Having a struct `kernel_Log` callback instead of having to parse a string for various fields (time, threadname, level, ...) would be nice, and I think not even a huge left (can be done without upstream changes, even if that would be more efficient).",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2685229851",
      "submitted_at": "2025-03-14T18:41:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "commented",
      "id": 2725832595,
      "node_id": "IC_kwDOABII586ieOeT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2725832595",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T21:42:36Z",
      "updated_at": "2025-03-14T21:42:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2725437236 and https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2725441239\r\n\r\nThank you for your suggestions!\r\n\r\n> Would it be possible to use these C headers to automatically build a rust crate of constants from a C header API? Or would that be overkill..\r\n\r\nLooking at the constants in the linked file they all seem to be policy-related, which is out of scope for now. I don't think we'll add a header for that in the near future. Generally speaking I am open towards exposing details of Bitcoin Core's policy to applications that use it already anyway. For example it might be useful to expose some parts of policy for protocols using pre-signed transactions.\r\n\r\n> Furthermore, besides keeping values synchronized, an automated solution which would generate all available consts would be ideal.\r\n\r\nWe've recently discussed  auto-generating parts of the header and library code instead of writing it by hand as done here. I think for exposing some of the consensus-related constants in that manner might be a good way forward eventually.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2725832595",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16781632816,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPoQ2Uw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16781632816",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "21f6a3de77a9eedcca5d47f694d540d42b3ddbcc",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/21f6a3de77a9eedcca5d47f694d540d42b3ddbcc",
      "created_at": "2025-03-14T22:33:14Z"
    },
    {
      "event": "commented",
      "id": 2725912225,
      "node_id": "IC_kwDOABII586ieh6h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2725912225",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T22:33:17Z",
      "updated_at": "2025-03-14T22:33:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 29513955891e40e78466f2c666dfa13e9c1b2914 -> 21f6a3de77a9eedcca5d47f694d540d42b3ddbcc ([kernelApi_27](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_27) -> [kernelApi_28](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_28), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_27..kernelApi_28))\r\n\r\n* Fixed conflict with #31649",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2725912225",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16781634719,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPoQ2yf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16781634719",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-14T22:33:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2726938039,
      "node_id": "IC_kwDOABII586iicW3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2726938039",
      "actor": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T19:00:37Z",
      "updated_at": "2025-03-15T19:00:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "> We've recently discussed auto-generating parts of the header and library code instead of writing it by hand as done here. I think for exposing some of the consensus-related constants in that manner might be a good way forward eventually.\r\n\r\n@TheCharlatan thanks for the reply.  How would auto-generating parts work?  That does sound potentially promising as a way to build rust crates as well if we can use the same input data for auto-generating.",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2726938039",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16787883355,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPoosVb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16787883355",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T19:00:38Z"
    },
    {
      "event": "subscribed",
      "id": 16787883359,
      "node_id": "SE_lADOABII586SDdapzwAAAAPoosVf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16787883359",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T19:00:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16788468693,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPoq7PV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16788468693",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5991a69ee0000de551955846d7d21733c326a748",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/5991a69ee0000de551955846d7d21733c326a748",
      "created_at": "2025-03-15T21:45:22Z"
    },
    {
      "event": "commented",
      "id": 2727013588,
      "node_id": "IC_kwDOABII586iiuzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2727013588",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T21:46:06Z",
      "updated_at": "2025-03-15T21:46:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 21f6a3de77a9eedcca5d47f694d540d42b3ddbcc -> 5991a69ee0000de551955846d7d21733c326a748 ([kernelApi_28](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_28) -> [kernelApi_29](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_29), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_28..kernelApi_29))\r\n\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1989793614), removed outdated comment about the validation interface in the `kernel_Context`.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991230564), removed const qualifier from `kernel_ChainParameters`.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991236489), removed unneeded const cast.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991290582), removed unneeded mention of thread safety for the `kernel_Context`.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1995405051), introduce a helper function in the `Logger` to allow us to get rid of the string conversion functions.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1995880696), use the same order for the kernel log levels as done in the internal enum.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1995386796), make the logging setter functions return `void` instead of `bool`. With the new methods, there is no error case to report anymore.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2727013588",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16788469949,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPoq7i9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16788469949",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T21:46:07Z"
    },
    {
      "event": "subscribed",
      "id": 16788469955,
      "node_id": "SE_lADOABII586SDdapzwAAAAPoq7jD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16788469955",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T21:46:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16815047565,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPqQUON",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16815047565",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/2dc27e2860b97c2bffa5f18706917b21858e5594",
      "created_at": "2025-03-17T21:45:51Z"
    },
    {
      "event": "commented",
      "id": 2731007985,
      "node_id": "IC_kwDOABII586ix9_x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2731007985",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-17T21:46:15Z",
      "updated_at": "2025-03-17T21:46:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 5991a69ee0000de551955846d7d21733c326a748 -> 2dc27e2860b97c2bffa5f18706917b21858e5594 ([kernelApi_29](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_29) -> [kernelApi_30](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_30), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_29..kernelApi_30))\r\n\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1999116127), add notice in the documentation about logging settings being thread unsafe and global.\r\n* Added a mutex to the options objects to make setting them thread safe.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2731007985",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16815051941,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPqQVSl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16815051941",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-17T21:46:16Z"
    },
    {
      "event": "subscribed",
      "id": 16815051966,
      "node_id": "SE_lADOABII586SDdapzwAAAAPqQVS-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16815051966",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-17T21:46:16Z"
    },
    {
      "event": "commented",
      "id": 2736469179,
      "node_id": "IC_kwDOABII586jGzS7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2736469179",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:31:18Z",
      "updated_at": "2025-03-19T12:31:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "I had an idea I wanted to suggest here. What if instead of adding C bindings to the bitcoin/bitcoin git repository we took inspiration from @darosior's thoughts about [project scope](https://delvingbitcoin.org/t/antoine-poinsot-on-bitcoin-cores-priorities/1470) and developed the C, rust, and python bindings in a separate bitcoin-core/bindings repository, or even separate bitcoin-core/bindings-{c,rust,python} repositories?\r\n\r\nTechnically I think there are two ways we could implement this:\r\n\r\n1. Add cmake install rules to `bitcoin/bitcoin` to install kernel and util headers to `$prefix/include/`, install the kernel library to `$prefix/lib/`, and install a cmake [config package](https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#id1) to `$prefix/lib/cmake/Libbitcoinkernel/LibbitcoinkernelConfig.cmake` that the `bitcoin-core/bindings` repo can import with [`find_package` config mode](https://cmake.org/cmake/help/latest/command/find_package.html#search-modes). This approach was implemented by @hebasto for libmultiprocess in https://github.com/bitcoin-core/libmultiprocess/pull/96 and I've been impressed by how easily it lets different cmake projects share code while still providing a clear boundary between them.\r\n\r\n2. Avoid needing to write cmake install rules and just include the `bitcoin/bitcoin` repository as a git subtree in the `bitcoin-core/bindings` repository that can be built with [`add_subdirectory`](https://cmake.org/cmake/help/latest/command/add_subdirectory.html) in the same cmake project.\r\n\r\nHaving a separate repository for C bindings could have a number of advantages over merging this PR to `bitcoin/bitcoin`:\r\n\r\n- It could allow faster development of C/rust/python bindings since they could take place outside the main repository and potentially have faster release cycles.\r\n  \r\n- It could reduce burden on other core bitcoin developers since they would not have to worry about maintaining the C bindings implementation and keeping the C and C++ interfaces in sync.\r\n\r\n- It could enable other approaches to building bindings and using kernel code in external projects. It is great if developers want to build on the C++>C>Python and C++>C>Rust approaches we are providing. But I also think it would be great if developers could try other approaches like going directly from C++ to Python with [pybind](https://github.com/pybind/pybind11) or [nanobind](https://github.com/wjakob/nanobind), or directly to from C++ to Rust with [cxx](https://cxx.rs/), [autocxx](https://github.com/google/autocxx),  or [zngur](https://github.com/HKalbasi/zngur) or going directly from C++ to any number of other languages with [SWIG](https://www.swig.org/). These approaches may not be preferred by us but they are proven and established (particularly pybind and SWIG, which has been around for decades) that can be much more convenient than dropping down to C.\r\n\r\n - It could open a way to expose other bitcoin core code besides the kernel code externally. For example, it's possible to imagine exposing python or javascript bindings for bitcoin wallet code and having tools and UIs written in different languages that are able to use bitcoin wallet files.\r\n\r\nThere would be some disadvantages to having a separate repository for C bindings:\r\n\r\n- It would not be posssible to use C++ wrappers that have been written around the C bindings to write internal tools in the bitcoin/bitcoin repository. \r\n\r\n- We would need to clearly communicate to outside developers that bitcoin/bitcoin C++ interfaces are not stable, and that if projects want a more stable interface they need to use the C interface or the C++ wrappers around the C interface.\r\n\r\nThis idea should not be incompatible with the current PR and I'd be happy to see this PR being merged whenever it is ready. But it could be something we think about going forward.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2736469179",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16863809663,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPtKVB_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16863809663",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:31:19Z"
    },
    {
      "event": "subscribed",
      "id": 16863809696,
      "node_id": "SE_lADOABII586SDdapzwAAAAPtKVCg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16863809696",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:31:19Z"
    },
    {
      "event": "mentioned",
      "id": 16863809728,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPtKVDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16863809728",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:31:19Z"
    },
    {
      "event": "subscribed",
      "id": 16863809756,
      "node_id": "SE_lADOABII586SDdapzwAAAAPtKVDc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16863809756",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:31:19Z"
    },
    {
      "event": "commented",
      "id": 2738349197,
      "node_id": "IC_kwDOABII586jN-SN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2738349197",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:41Z",
      "updated_at": "2025-03-19T22:40:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "> It could enable other approaches to building bindings and using kernel code in external projects. \r\n\r\nI have done some experimentation with using c++ bindings directly. \r\n\r\n> [SWIG](https://www.swig.org/)\r\n\r\nI tried creating python bindings through swig without looping through the C bindings and I could not get it to work within a reasonable amount of time. While likely a skill issue, it does seem to be struggling with some of our c++20 features and heavily templated code.\r\n\r\n> [pybind](https://github.com/pybind/pybind11)\r\n\r\nI was more successful here; this took me about a day to setup: https://github.com/TheCharlatan/bitcoinkernel-pybind. For now it just exposes a chainparams and one of its methods, but it does use our c++ methods directly. While an llm helped with the boilerplate, I did spend most of the time figuring out how to pass in some of our required pre-processor definitions and compiler options. Comparing it to my experience with the C headers the setup seems a bit more involved, but also not too horrible in comparison.\r\n\r\n> [cxx](https://cxx.rs/)\r\n\r\nI tried this quite some time ago now (iirc one and half years ago). It seemed to work as well, but was a bit rough to use, so I ended up wrapping it in more rust code. Having to wrap it again would take away some of the utility over using C bindings, so not too sure about this approach. I might revisit `cxx` soon though.\r\n\r\nI think the key differences between using these frameworks on our existing code and curating our own API are safety, documentation, consistency, and discoverability. Developers wishing to create language bindings can take the C header here and understand how to use it in reasonable time. I don't think this is true for our current c++ code. Whether this is worth the additional maintenance is another question though. As you say:\r\n\r\n> It could reduce burden on other core bitcoin developers since they would not have to worry about maintaining the C bindings implementation and keeping the C and C++ interfaces in sync.\r\n\r\nLooking at the footprint introduced here, I am not too worried about creating significantly more maintenance burden. On the contrary, just like the current `bitcoin-chainstate` binary acted as a north star for the kernel library development leading up to this pull request, the code in `bitcoinkernel.cpp` can act as a way to directly inform us on useful future changes. This could include things like logging, locking and mutexes, removing more \"Bitcoin Core\"-isms, adding hooks for db and file readers, and validating against user-provided UTXOs. It might be a bit more cognitive load when introducing new code to also think about potential external usage, but that might just mean the code changes are a bit better thought through on an architectural level. However, future feature additions to the API and the bindings would obviously mean more open PRs.\r\n\r\n> It could open a way to expose other bitcoin core code besides the kernel code externally. For example, it's possible to imagine exposing python or javascript bindings for bitcoin wallet code and having tools and UIs written in different languages that are able to use bitcoin wallet files.\r\n\r\nI'm not sure how this would be related with moving the API introduced here into a separate repository , but given that we already have a hierarchy of internal libraries, isn't that already possible? \r\n\r\n> This idea should not be incompatible with the current PR and I'd be happy to see this PR being merged whenever it is ready. But it could be something we think about going forward.\r\n\r\nThe work leading up to this pull request has focused on improving the existing c++ code. If there comes a time where the internal code is consistent and documented enough, I think splitting out foreign bindings could indeed be a final step. Next to @darosior, I would be keen on hearing other people's thoughts, like @laanwj and @theuni, that have advocated for the C bindings as part of bitcoin/bitcoin in the past. Some people have expressed their long-term hope that this library and header could become one of the few things shipped directly from the bitcoin/bitcoin repository, while most of the other existing components are split out into feature repositories. I think for this PR to move forward it would have to get a bit more contributor buy-in anyway. The projects built on top of this PR already gained some users, but I am not sure if that is enough to get it merged.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2738349197",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16882015257,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPuPxwZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16882015257",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:42Z"
    },
    {
      "event": "subscribed",
      "id": 16882015270,
      "node_id": "SE_lADOABII586SDdapzwAAAAPuPxwm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16882015270",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:42Z"
    },
    {
      "event": "mentioned",
      "id": 16882015281,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPuPxwx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16882015281",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:42Z"
    },
    {
      "event": "subscribed",
      "id": 16882015288,
      "node_id": "SE_lADOABII586SDdapzwAAAAPuPxw4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16882015288",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:42Z"
    },
    {
      "event": "mentioned",
      "id": 16882015299,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPuPxxD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16882015299",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:42Z"
    },
    {
      "event": "subscribed",
      "id": 16882015314,
      "node_id": "SE_lADOABII586SDdapzwAAAAPuPxxS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16882015314",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T22:40:42Z"
    },
    {
      "event": "commented",
      "id": 2741144182,
      "node_id": "IC_kwDOABII586jYop2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2741144182",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T17:09:50Z",
      "updated_at": "2025-03-20T17:09:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "re: https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2738349197\r\n\r\nThanks, if you don't think a separate repository for C bindings would be good, or worth the tradeoffs, that's fine. I was just excited about the idea because I realized with cmake config modules it would be easy to implement technically, and it seemed like a natural starting point to experiment with splitting the project up into different repositories while being able to share utilities and infrastructure.\r\n\r\nJust to explain my perspective:\r\n\r\n- My main motivation for suggesting this was that I thought it might help with development of the C bindings. This was speculation on my part because I can see they are about 4K lines now, but I don't have an idea of how big they will be when they are complete. This was also speculation because I can see you and others hashing out issues and making progress here, but don't know if there could be more progress if there were a github repository people could push to and open PRs and issues against, so work could happen in parallel and developments might be easier to track. I also didn't know if bindings might benefit from having more frequent releases as they are developed, or if they could benefit from being built against bitcoin core stable releases instead a embedding custom or bleeding edge versions of bitcoin core code. If using a separate repository wouldn't help with these things or solve real problems, then I wouldn't favor having one.\r\n\r\n- I may also have a different view of this PR because I look at C and C++ as being different languages with some syntax in common but pretty different features and idioms. To me C++ has more in common with Python than it does with C in how code is written and what features are used. So the choice to expose C++ code with a C API does not seem very natural to me. I understand the value of treating the C++ code as unstable and having a translation layer to expose it to other projects and languages, but I'd think different approaches to translation should be possible and we wouldn't need to choose a single one and maintain it the main repository, even if it'd be fine to do that.\r\n\r\n> I have done some experimentation with using c++ bindings directly.\r\n\r\nThanks for the details and links and this is interesting to know about. I have a lot of experience with swig but mostly just think any of these approaches could work and be useful, and it should be fine to choose what seems convenient and expose a simple and stable API.\r\n\r\n> Looking at the footprint introduced here, I am not too worried about creating significantly more maintenance burden. On the contrary, just like the current `bitcoin-chainstate` binary acted as a north star for the kernel library development leading up to this pull request, the code in `bitcoinkernel.cpp` can act as a way to directly inform us on useful future changes. This could include things like logging, locking and mutexes, removing more \"Bitcoin Core\"-isms, adding hooks for db and file readers, and validating against user-provided UTXOs. It might be a bit more cognitive load when introducing new code to also think about potential external usage, but that might just mean the code changes are a bit better thought through on an architectural level. However, future feature additions to the API and the bindings would obviously mean more open PRs.\r\n\r\nI can see the analogy, but not really how it applies. The chainstate program was useful because it was small and we could see it doing clumsy things because the C++ API was clumsy, so we would improve the C++ API, and the chainstate program would get simpler. Maybe I need to think about it more, but I don't see how a similar process could play out between the C++ API and the C bindings, or how there could be other benefits to the C++ code from just maintaining the C bindings. I could see there being benefits from developing the bindings, but would expect those to be the same regardless of repository layout.\r\n\r\n> > It could open a way to expose other bitcoin core code besides the kernel code externally. For example, it's possible to imagine exposing python or javascript bindings for bitcoin wallet code and having tools and UIs written in different languages that are able to use bitcoin wallet files.\r\n> \r\n> I'm not sure how this would be related with moving the API introduced here into a separate repository , but given that we already have a hierarchy of internal libraries, isn't that already possible?\r\n\r\nYes, I was just thinking a bitcoin-core/bindings repository would be a natural place for an API like that to live, be discoverable, have documentation, and have issues reported against, rather than the main repository.\r\n\r\n> I think for this PR to move forward it would have to get a bit more contributor buy-in anyway. The projects built on top of this PR already gained some users, but I am not sure if that is enough to get it merged.\r\n\r\nIt seems fine to me to merge this PR and maintain this code as a separate library in the main repository. My reason for bringing this up was to question whether we actually needed to do that, and if there might be benefits to maintaining it in a separate repository. I don't have a great sense of the tradeoffs and both approaches do seem reasonable to me.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2741144182",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2694197292,
      "node_id": "PRR_kwDOABII586gljAs",
      "url": null,
      "actor": null,
      "commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-03-20T19:03:03Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2694197292",
      "submitted_at": "2025-03-20T19:03:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "reviewed",
      "id": 2703841630,
      "node_id": "PRR_kwDOABII586hKVle",
      "url": null,
      "actor": null,
      "commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-03-20T19:10:59Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2703841630",
      "submitted_at": "2025-03-20T19:10:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16918201013,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPwZ0K1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16918201013",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9fc6accf89ed001f70e107a8e9936f6dc3a35f41",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/9fc6accf89ed001f70e107a8e9936f6dc3a35f41",
      "created_at": "2025-03-20T21:21:27Z"
    },
    {
      "event": "commented",
      "id": 2741688322,
      "node_id": "IC_kwDOABII586jatgC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2741688322",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T21:21:33Z",
      "updated_at": "2025-03-20T21:21:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 2dc27e2860b97c2bffa5f18706917b21858e5594 -> 9fc6accf89ed001f70e107a8e9936f6dc3a35f41 ([kernelApi_30](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_30) -> [kernelApi_31](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_31), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_30..kernelApi_31))\r\n\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2000864918), fixed naming in docstring for `kernel_LoggingConnection`.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2006272875), fixed constructor for `Context` and added a test to catch the regression.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2741688322",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16918202116,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPwZ0cE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16918202116",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T21:21:34Z"
    },
    {
      "event": "subscribed",
      "id": 16918202132,
      "node_id": "SE_lADOABII586SDdapzwAAAAPwZ0cU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16918202132",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T21:21:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16918754366,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAPwb7Q-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16918754366",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "29f05b91cf8a479e403b0322afeb5ff1133da221",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/29f05b91cf8a479e403b0322afeb5ff1133da221",
      "created_at": "2025-03-20T22:14:40Z"
    },
    {
      "event": "commented",
      "id": 2741785172,
      "node_id": "IC_kwDOABII586jbFJU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2741785172",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T22:14:52Z",
      "updated_at": "2025-03-20T22:14:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39141725876</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2741785172",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 16918756032,
      "node_id": "LE_lADOABII586SDdapzwAAAAPwb7rA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16918756032",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T22:14:52Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2741785465,
      "node_id": "IC_kwDOABII586jbFN5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2741785465",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T22:15:04Z",
      "updated_at": "2025-03-20T22:15:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 9fc6accf89ed001f70e107a8e9936f6dc3a35f41 -> 29f05b91cf8a479e403b0322afeb5ff1133da221 ([kernelApi_31](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_31) -> [kernelApi_32](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_32), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_31..kernelApi_32))\r\n\r\n* Fixed silent merge conflict with #31519",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2741785465",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 16920597415,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAPwi9On",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16920597415",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T02:03:04Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2742398706,
      "node_id": "IC_kwDOABII586jda7y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2742398706",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T06:00:43Z",
      "updated_at": "2025-03-21T06:00:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I had an idea I wanted to suggest here. What if instead of adding C bindings to the bitcoin/bitcoin git repository we took inspiration from @darosior's thoughts about [project scope](https://delvingbitcoin.org/t/antoine-poinsot-on-bitcoin-cores-priorities/1470) and developed the C, rust, and python bindings in a separate bitcoin-core/bindings repository, or even separate bitcoin-core/bindings-{c,rust,python} repositories?\r\n\r\nI think this is an interesting idea, and may be worth exploring independently of this PR. Couple of comments:\r\n\r\n>     * It would not be posssible to use C++ wrappers that have been written around the C bindings to write internal tools in the bitcoin/bitcoin repository.\r\n\r\nI think for things like that we'd just include the wrapper in core because it's not an external maintenance burden but a natural part of core, and we'd already judged that that was less maintenance burden in total than writing the code in C++ in the first place.\r\n\r\n>     * We would need to clearly communicate to outside developers that bitcoin/bitcoin C++ interfaces are not stable, and that if projects want a more stable interface they need to use the C interface or the C++ wrappers around the C interface.\r\n\r\nI think you could just treat that as part of API versioning -- bitcoin core updates to version 30.0, tweaking a bunch of internal structures that result in C/python/rust API changes, so that results in a semver bump to version 30 for the C/python/rust API. But if the API is an independent product, that doesn't have to happen on any particular schedule -- you can keep using API version 28 even if your node is running v31 (modulo security update policies perhaps).\r\n\r\nI find having the test framework code handy for doing python bitcoin things and use jamesob's [verystable](https://github.com/jamesob/verystable) for that (eg [powcoins](https://github.com/ajtowns/powcoins/tree/master/verystable), [bllsh](https://github.com/ajtowns/powcoins/tree/master/verystable). It's just an externally maintained copy of relevant bits of bitcoin core code, that is manually synced to new upstream releases every now and then. That model seems workable to me.\r\n\r\nI think maybe exposing some of our complicated internal logic for direct manipulation/experimentation in python might be helpful for debugging -- the new [txgraph](https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2684192006) stuff in particular, but perhaps also the fee estimation code. \r\n\r\nI think separate repos for python/rust APIs is probably more compelling than for C, since C APIs are naturally fairly basic and are also pretty well supported by C++ without introducing any extra dependencies. With good python/rust APIs available externally, I could imagine the C API not being very useful, but wouldn't want to bet on it either way.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2742398706",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16922444626,
      "node_id": "MEE_lADOABII586SDdapzwAAAAPwqANS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16922444626",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T06:00:43Z"
    },
    {
      "event": "subscribed",
      "id": 16922444640,
      "node_id": "SE_lADOABII586SDdapzwAAAAPwqANg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16922444640",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T06:00:44Z"
    },
    {
      "event": "commented",
      "id": 2742479648,
      "node_id": "IC_kwDOABII586jdusg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2742479648",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T06:38:33Z",
      "updated_at": "2025-03-21T06:38:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Maybe I need to think about it more, but I don't see how a similar process could play out between the C++ API and the C bindings, or how there could be other benefits to the C++ code from just maintaining the C bindings. I could see there being benefits from developing the bindings, but would expect those to be the same regardless of repository layout.\r\n\r\nI think I was conflating the introduction of some consolidating code here, like a separate context, methods that map to multiple calls to our validation code, logging initialization, etc., and the code really only required to do the C translation. The former could probably be viewed as a safe \"interface\" of sorts into some of the existing code in the kernel library and could be useful for our internal code, while the latter is more useful for external callers. A long term goal if this gets merged would be evolving the internal code to absorb most of the code in this \"interface\". Maybe the approach taken here is not ideal for actually surfacing that, but it is also not clear to me what a better approach might be, since such an \"interface\" is best designed based on the requirements of an actual user (i.e. the C API in the case of this PR).",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2742479648",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2752629027,
      "node_id": "IC_kwDOABII586kEckj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2752629027",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T21:50:58Z",
      "updated_at": "2025-03-27T12:22:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "@stickies-v found an interesting example of a library, [SFML](https://www.sfml-dev.org/), that ships C++ headers from its \"core\" [repository](https://github.com/SFML/SFML), but also hosts C bindings in [another repository](https://github.com/SFML/CSFML/tree/master) in their organisation. They have a list of all known bindings to their library on their website: https://www.sfml-dev.org/download/bindings. I did a tour of some of them and most seem to be using the C bindings, but interestingly there seems to be a trend among them to move from the C headers to the C++ headers. For example the [first python bindings](https://github.com/bastienleonard/pysfml-cython) used the C header, while the [current python bindings](https://github.com/intjelic/python-sfml/tree/master) use a mix. The [ocaml bindings](https://github.com/fccm/ocaml-sfml) even mention in their project readme how they migrated over time to the C++ headers. What I also find interesting is that SFML has a mix of internal and external headers, that live in the `src` and `include` directory respectively, but use both of them in their core codebase.\r\nEDIT: I looked through their git history a bit and saw that they originally had their bindings in the same codebase.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2752629027",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 16982401391,
      "node_id": "MEE_lADOABII586SDdapzwAAAAP0OuFv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16982401391",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T21:50:58Z"
    },
    {
      "event": "subscribed",
      "id": 16982401408,
      "node_id": "SE_lADOABII586SDdapzwAAAAP0OuGA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16982401408",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T21:50:58Z"
    },
    {
      "event": "commented",
      "id": 2754051147,
      "node_id": "IC_kwDOABII586kJ3xL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2754051147",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-26T11:14:21Z",
      "updated_at": "2025-03-26T11:14:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "Pushed 29f05b91cf8a479e403b0322afeb5ff1133da221 -> 97d1edcdafe074e910ed647dcb6beedd24744b17 ([kernelApi_32](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_32) -> [kernelApi_33](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_33), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_32..kernelApi_33))\r\n\r\n* Added a commit introducing a small purpose section in the header documentation. It briefly mentions the features, that the header is unversioned, might just break with future updates, and won't be released yet.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2754051147",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "referenced",
      "id": 17015634917,
      "node_id": "REFE_lADOABII586SDdapzwAAAAP2Nfvl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17015634917",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "74c23f80abbe72c1cc00604ec438498e6a20d3e6",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/74c23f80abbe72c1cc00604ec438498e6a20d3e6",
      "created_at": "2025-03-27T15:02:08Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17028809067,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAP2_wFr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17028809067",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a0d24ff9a9337770dae668d7b0ea0a6e62ed086a",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/a0d24ff9a9337770dae668d7b0ea0a6e62ed086a",
      "created_at": "2025-03-28T09:40:40Z"
    },
    {
      "event": "commented",
      "id": 2760729847,
      "node_id": "IC_kwDOABII586kjWT3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2760729847",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-28T09:40:45Z",
      "updated_at": "2025-03-28T09:40:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 97d1edcdafe074e910ed647dcb6beedd24744b17 -> a0d24ff9a9337770dae668d7b0ea0a6e62ed086a ([kernelApi_33](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_33) -> [kernelApi_34](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_34), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_33..kernelApi_34))\r\n\r\n* Integrated the new `bitcoin-chainstate` functional tests from #32145 to demonstrate that it is still working.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2760729847",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 17058734895,
      "node_id": "LE_lADOABII586SDdapzwAAAAP4x6Mv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17058734895",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-31T14:46:48Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2775941461,
      "node_id": "IC_kwDOABII586ldYFV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2775941461",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T14:15:45Z",
      "updated_at": "2025-04-03T14:15:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "I pushed a branch that re-writes this PR by inverting the relationship between the C and the C++ API: https://github.com/TheCharlatan/bitcoin/tree/kernelApi_Cpp.\r\n\r\nIts new C++ header is here: https://github.com/TheCharlatan/bitcoin/blob/kernelApi_Cpp/src/kernel/bitcoinkernel.hpp\r\n\r\nI think this could a viable alternative to move this PR forward beyond the C/C++ API discussion. The C API could now easily live outside this repository. \r\n\r\nCircling back to what I said in this comment https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2742479648:\r\n>  \"I think I was conflating the introduction of some consolidating code here, like a separate context, methods that map to multiple calls to our validation code, logging initialization, etc., and the code really only required to do the C translation.\"\r\n\r\nThe code required on the C side now hardly contains any business logic and only does very mechanical C++ to C translations: https://github.com/TheCharlatan/bitcoin/blob/kernelApi_Cpp/src/kernel/bitcoinkernel_c.cpp . \r\n\r\n@ryanofsky since you were active in these discussions here, would you support such an approach over the current PR?",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2775941461",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 17114776772,
      "node_id": "MEE_lADOABII586SDdapzwAAAAP8HsTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17114776772",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T14:15:47Z"
    },
    {
      "event": "subscribed",
      "id": 17114776789,
      "node_id": "SE_lADOABII586SDdapzwAAAAP8HsTV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17114776789",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T14:15:47Z"
    },
    {
      "event": "commented",
      "id": 2776268675,
      "node_id": "IC_kwDOABII586len-D",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2776268675",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T15:58:35Z",
      "updated_at": "2025-04-03T15:58:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @ryanofsky since you were active in these discussions here, would you support such an approach over the current PR?\r\n\r\nI'd support it and I also support the current PR. It seems like if you are an external kernel user, the approach in https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2775941461 shouldn't change things very much for you, since either way you are provided with an alternate set of C++ classes and flags that that mirror the internal ones. I feel like if I *personally* were writing python or rust bindings, I'd want to just use the original classes and flags so I wouldn't need to go through an extra level of code to expose new functionality. But I understand reasons for wanting this code, and if this approach helps organize it better or make it easier to maintain that seems great.\r\n\r\n> The C API could now easily live outside this repository.\r\n\r\nAm curious about this. Since https://github.com/TheCharlatan/bitcoin/blob/kernelApi_Cpp/src/kernel/bitcoinkernel.hpp includes `kernel/bitcoinkernel.h` it seems like C++ API at least partially depends on the C API, but maybe it could be broken up. I do think even in the current master branch, we could add a simple install rule to install headers (as described https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2736469179) and a C API could also be built outside that way. Maybe this new approach provides some more appealing alternatives though.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2776268675",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 17116757656,
      "node_id": "MEE_lADOABII586SDdapzwAAAAP8PP6Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17116757656",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T15:58:36Z"
    },
    {
      "event": "subscribed",
      "id": 17116757682,
      "node_id": "SE_lADOABII586SDdapzwAAAAP8PP6y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17116757682",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T15:58:36Z"
    },
    {
      "event": "commented",
      "id": 2776371013,
      "node_id": "IC_kwDOABII586lfA9F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2776371013",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-03T16:36:42Z",
      "updated_at": "2025-04-04T13:10:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "> t seems like C++ API at least partially depends on the C API, but maybe it could be broken up. I do think even in the current master branch, we could add a simple install rule to install headers (as described https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2736469179) and a C API could also be built outside that way. Maybe this new approach provides some more appealing alternatives though.\r\n\r\nHaving separate installable headers for these basic enum and result types is very much what I had in mind. Maybe something like the `kernel/types.h` from one of your PRs, or a bunch of similarly scoped headers could be the way forward. I think it would be trivial to do that for all the extra types that currently are included through the C header on that branch. I did not do it, because I am a bit apprehensive when it comes to shuffling around internal declarations into smaller headers that can be used externally before we have agreed on an approach here. I think the scope here is already quite big, but would it help you evaluate if I would add these additional installable headers?\r\n\r\nEDIT: Did the header split here and added some of our internal headers to the install list: https://github.com/TheCharlatan/bitcoin/tree/kernelApi_Cpp_Internal_Headers\r\n\r\nI think wholesale exposing all kernel library headers vs. having a dedicated external API and a few \"blessed\" / \"installable\" headers is a different discussion though. If the conversation moves to that over the choice of language in the exposed headers, I'd be happy to discuss that too.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2776371013",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2748265226,
      "node_id": "PRR_kwDOABII586jzzMK",
      "url": null,
      "actor": null,
      "commit_id": "a0d24ff9a9337770dae668d7b0ea0a6e62ed086a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-04-07T22:39:11Z",
      "author_association": "MEMBER",
      "body": "The Windows CI jobs seems to require the following patch:\r\n```diff\r\n--- a/.github/workflows/ci.yml\r\n+++ b/.github/workflows/ci.yml\r\n@@ -242,6 +242,7 @@ jobs:\r\n           BITCOINCLI: '${{ github.workspace }}\\build\\bin\\Release\\bitcoin-cli.exe'\r\n           BITCOINUTIL: '${{ github.workspace }}\\build\\bin\\Release\\bitcoin-util.exe'\r\n           BITCOINWALLET: '${{ github.workspace }}\\build\\bin\\Release\\bitcoin-wallet.exe'\r\n+          BITCOINCHAINSTATE: '${{ github.workspace }}\\build\\bin\\Release\\bitcoin-chainstate.exe'\r\n           TEST_RUNNER_EXTRA: ${{ github.event_name != 'pull_request' && '--extended' || '' }}\r\n         shell: cmd\r\n         run: py -3 test\\functional\\test_runner.py --jobs %NUMBER_OF_PROCESSORS% --ci --quiet --tmpdirprefix=%RUNNER_TEMP% --combinedlogslen=99999999 --timeout-factor=%TEST_RUNNER_TIMEOUT_FACTOR% %TEST_RUNNER_EXTRA%\r\n```",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2748265226",
      "submitted_at": "2025-04-07T22:39:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "commented",
      "id": 2785627754,
      "node_id": "IC_kwDOABII586mCU5q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2785627754",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-08T08:20:13Z",
      "updated_at": "2025-04-08T08:20:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2748265226\r\n\r\n> The Windows CI jobs seems to require the following patch:\r\n\r\nYes, I already did that on https://github.com/TheCharlatan/bitcoin/tree/kernelApi_35, but it still failed. ",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2785627754",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2785858656,
      "node_id": "IC_kwDOABII586mDNRg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2785858656",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-08T09:44:34Z",
      "updated_at": "2025-04-08T10:39:17Z",
      "author_association": "MEMBER",
      "body": "> Re [#30595 (review)](https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2748265226)\r\n> \r\n> > The Windows CI jobs seems to require the following patch:\r\n> \r\n> Yes, I already did that on https://github.com/TheCharlatan/bitcoin/tree/kernelApi_35, but it still failed.\r\n\r\nHmm... The test passes on my machine:\r\n```\r\n> py -3 build-static\\test\\functional\\tool_bitcoin_chainstate.py\r\n2025-04-08T09:43:10.604000Z TestFramework (INFO): PRNG seed is: 7627559442665807582\r\n2025-04-08T09:43:10.622000Z TestFramework (INFO): Initializing test directory C:\\Users\\hebasto\\AppData\\Local\\Temp\\bitcoin_func_test_wlc9wod3\r\n2025-04-08T09:43:11.026000Z TestFramework (INFO): Testing bitcoin-chainstate ['C:\\\\Users\\\\hebasto\\\\bitcoin\\\\build-static\\\\bin\\\\Release\\\\bitcoin-chainstate.exe'] with datadir: C:\\Users\\hebasto\\AppData\\Local\\Temp\\bitcoin_func_test_wlc9wod3\\node0\r\n2025-04-08T09:43:11.251000Z TestFramework (INFO): STDERR: Block has not yet been rejected\r\n2025-04-08T09:43:11.449000Z TestFramework (INFO): STDERR: Block has not yet been rejected\r\nBlock is a duplicate\r\n2025-04-08T09:43:11.701000Z TestFramework (INFO): STDERR: Block decode failed, try again:\r\n2025-04-08T09:43:11.909000Z TestFramework (INFO): STDERR: Empty line found, try again:\r\n2025-04-08T09:43:11.961000Z TestFramework (INFO): Stopping nodes\r\n2025-04-08T09:43:11.961000Z TestFramework (INFO): Cleaning up C:\\Users\\hebasto\\AppData\\Local\\Temp\\bitcoin_func_test_wlc9wod3 on exit\r\n2025-04-08T09:43:11.961000Z TestFramework (INFO): Tests successful\r\n```\r\n\r\nWill investigate it further.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2785858656",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 2786700985,
      "node_id": "IC_kwDOABII586mGa65",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2786700985",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-08T14:45:43Z",
      "updated_at": "2025-04-08T14:45:43Z",
      "author_association": "MEMBER",
      "body": "> > Re [#30595 (review)](https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2748265226)\r\n> > > The Windows CI jobs seems to require the following patch:\r\n> > \r\n> > \r\n> > Yes, I already did that on https://github.com/TheCharlatan/bitcoin/tree/kernelApi_35, but it still failed.\r\n> \r\n> Hmm... The test passes on my machine:\r\n> \r\n> ```\r\n> > py -3 build-static\\test\\functional\\tool_bitcoin_chainstate.py\r\n> 2025-04-08T09:43:10.604000Z TestFramework (INFO): PRNG seed is: 7627559442665807582\r\n> 2025-04-08T09:43:10.622000Z TestFramework (INFO): Initializing test directory C:\\Users\\hebasto\\AppData\\Local\\Temp\\bitcoin_func_test_wlc9wod3\r\n> 2025-04-08T09:43:11.026000Z TestFramework (INFO): Testing bitcoin-chainstate ['C:\\\\Users\\\\hebasto\\\\bitcoin\\\\build-static\\\\bin\\\\Release\\\\bitcoin-chainstate.exe'] with datadir: C:\\Users\\hebasto\\AppData\\Local\\Temp\\bitcoin_func_test_wlc9wod3\\node0\r\n> 2025-04-08T09:43:11.251000Z TestFramework (INFO): STDERR: Block has not yet been rejected\r\n> 2025-04-08T09:43:11.449000Z TestFramework (INFO): STDERR: Block has not yet been rejected\r\n> Block is a duplicate\r\n> 2025-04-08T09:43:11.701000Z TestFramework (INFO): STDERR: Block decode failed, try again:\r\n> 2025-04-08T09:43:11.909000Z TestFramework (INFO): STDERR: Empty line found, try again:\r\n> 2025-04-08T09:43:11.961000Z TestFramework (INFO): Stopping nodes\r\n> 2025-04-08T09:43:11.961000Z TestFramework (INFO): Cleaning up C:\\Users\\hebasto\\AppData\\Local\\Temp\\bitcoin_func_test_wlc9wod3 on exit\r\n> 2025-04-08T09:43:11.961000Z TestFramework (INFO): Tests successful\r\n> ```\r\n> \r\n> Will investigate it further.\r\n\r\nPassing `DATADIR` to `bitcoin-chainstate.exe` as a command-line argument fails to handle UTF-8 characters, which results in an unhandled exception in this code: https://github.com/bitcoin/bitcoin/blob/987ad25bd9ee520dcf1ca96702ff4ad51392f765/src/bitcoin-chainstate.cpp#L61-L62",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2786700985",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17177971253,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAP_4wo1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17177971253",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "27308240c6f06781f5eca3e40133d477e49d3695",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/27308240c6f06781f5eca3e40133d477e49d3695",
      "created_at": "2025-04-08T21:07:53Z"
    },
    {
      "event": "commented",
      "id": 2787666353,
      "node_id": "IC_kwDOABII586mKGmx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2787666353",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-08T21:07:59Z",
      "updated_at": "2025-04-09T10:26:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated a0d24ff9a9337770dae668d7b0ea0a6e62ed086a -> 9e8b7f8f47af566324df475853e9281937a0c5e2 ([kernelApi_34](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_34) -> [kernelApi_35](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_35), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_34..kernelApi_35))\r\n\r\n* Fixed bitcoin-chainstate on windows. This was not working before, because it did not support UTF-8 strings passed as arguments.\r\n\r\nRebased 9e8b7f8f47af566324df475853e9281937a0c5e2 -> 720f253abbbeb56872b6c16deee26f3fab842254 ([kernelApi_35](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_35) -> [kernelApi_36](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_36), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_35..kernelApi_36))\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2787666353",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 17178457468,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAP_6nV8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17178457468",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-08T21:56:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17186842997,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAQAaml1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17186842997",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "720f253abbbeb56872b6c16deee26f3fab842254",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/720f253abbbeb56872b6c16deee26f3fab842254",
      "created_at": "2025-04-09T10:25:23Z"
    },
    {
      "event": "labeled",
      "id": 17353223642,
      "node_id": "LE_lADOABII586SDdapzwAAAAQKVS3a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17353223642",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-22T12:39:12Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17358378526,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAQKo9Ye",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17358378526",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4a4eeb94339bb9200012df6a57769dc28e35f553",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/4a4eeb94339bb9200012df6a57769dc28e35f553",
      "created_at": "2025-04-22T18:21:05Z"
    },
    {
      "event": "commented",
      "id": 2822126808,
      "node_id": "IC_kwDOABII586oNjzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2822126808",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-22T18:21:10Z",
      "updated_at": "2025-04-22T18:21:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 720f253abbbeb56872b6c16deee26f3fab842254 -> 4a4eeb94339bb9200012df6a57769dc28e35f553 ([kernelApi_36](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_36) -> [kernelApi_37](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_37), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_36..kernelApi_37))\r\n\r\n* Fixed conflict with #32308",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2822126808",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 17359039653,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAQKreyl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17359039653",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-22T19:14:56Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2855208506,
      "node_id": "IC_kwDOABII586qLwY6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2855208506",
      "actor": {
        "login": "Davidson-Souza",
        "id": 40968167,
        "node_id": "MDQ6VXNlcjQwOTY4MTY3",
        "avatar_url": "https://avatars.githubusercontent.com/u/40968167?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Davidson-Souza",
        "html_url": "https://github.com/Davidson-Souza",
        "followers_url": "https://api.github.com/users/Davidson-Souza/followers",
        "following_url": "https://api.github.com/users/Davidson-Souza/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Davidson-Souza/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Davidson-Souza/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Davidson-Souza/subscriptions",
        "organizations_url": "https://api.github.com/users/Davidson-Souza/orgs",
        "repos_url": "https://api.github.com/users/Davidson-Souza/repos",
        "events_url": "https://api.github.com/users/Davidson-Souza/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Davidson-Souza/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-06T16:26:48Z",
      "updated_at": "2025-05-06T16:26:48Z",
      "author_association": "NONE",
      "body": "I've tried out some of the code, specifically the API for validating transactions. I'm reporting back some of the results I've got so far, hopefully this info is useful for reviewers.\r\n\r\nAs some of you might know, I have a [project](https://github.com/vinteumorg/floresta) that uses the now deprecated (see #29189) `libbitcoinconsensus` for script validation. This is a nice feature, since script is usually the hardest part to re-implement when it comes to Bitcoin consensus. However, apart from being deprecated, `libbitcoinconsensus` had a huge performance bottleneck: it deserialized transactions every time we called it. And since the expose `verify_script` function was called per input, a `tx` with several inputs would cause the same `tx` to be deserialized several times. To make things worse, Bitcoin Core appears to have an optimization for `CTransaction`, where it pre-computes the `txid` and `wtxid` when the tx is deserialized. I believe this is due to those values being used all the time, wouldn't make sense to keep recomputing it. But for this case, it meant that we would recompute the `txid` and `wtxid` of the same transaction, for every input.\r\n\r\nWhen profiling `Floresta`, I've realized that after our `assumevalid` height (in this context `assumevalid` is the same concept as core's), we would take about 40% of CPU time computing those hashes, as shown in this flamegraph.\r\n\r\n![Image](https://github.com/user-attachments/assets/5f380940-7c4f-495d-ad18-f91572e5d1f4)\r\n\r\nThe API introduced in this PR, exposes a opaque type for `CTransaction`, that is then passed as parameter to the `verify` function. So no per-input deserialization, you parse it once and re-use it in all calls for the same tx. Here's a flamegraph using the new api:\r\n\r\n![flamegraph](https://github.com/user-attachments/assets/cd3994e9-999d-4e12-ab15-7c294b7ae273)\r\n\r\nSome functions' names haven't been resolved, but most of the functions we see here are what we would expect (verify signatures, sighash calculation...). This flamegraph may not look like much, but it was recorded while validating the last 50k blocks on mainnet, and the `perf.dat` file is >100GB big.\r\n\r\nWe also have two benchmarks that are relevant in this case: one fully validating block 866342 (just a random block, the tip when this benchmark was written), and one fully validating block 367891 (a block with a 19k inputs transaction). I've ran both 4 times, although the too we use already samples over multiple runs. Both shows incredible improvements.\r\n\r\nBench: Block 866342\r\n\r\n| Run | Consensus | Kernel(this PR) |\r\n|----------|----------------|-----------------------|\r\n| 1         |      2.0391 s      |    613.81 ms   |\r\n| 2         |      2.0351 s     |    604.42 ms     |\r\n| 3         |     2.0821  s    |   622.37    |\r\n| 4         |     1.9660  s    |    619.45     |\r\n\r\n\r\nBenchmark: block 367891\r\n\r\n| Run | Consensus | Kernel(this PR) |\r\n|----------|----------------|-----------------------|\r\n| 1         |      92.469 s     |   6.1111 s     |\r\n| 2         |      91.411 s     |    5.8172 s    |\r\n| 3         |     93.894 s    |   6.3067 s       |\r\n| 4         |     88.523 s    |    6.2245 s      |\r\n\r\nFor the second case, we can see a ~15x speedup using the new code.",
      "user": {
        "login": "Davidson-Souza",
        "id": 40968167,
        "node_id": "MDQ6VXNlcjQwOTY4MTY3",
        "avatar_url": "https://avatars.githubusercontent.com/u/40968167?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Davidson-Souza",
        "html_url": "https://github.com/Davidson-Souza",
        "followers_url": "https://api.github.com/users/Davidson-Souza/followers",
        "following_url": "https://api.github.com/users/Davidson-Souza/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Davidson-Souza/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Davidson-Souza/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Davidson-Souza/subscriptions",
        "organizations_url": "https://api.github.com/users/Davidson-Souza/orgs",
        "repos_url": "https://api.github.com/users/Davidson-Souza/repos",
        "events_url": "https://api.github.com/users/Davidson-Souza/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Davidson-Souza/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2855208506",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 17557687866,
      "node_id": "LE_lADOABII586SDdapzwAAAAQWhQ46",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17557687866",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T14:30:37Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17561594631,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAQWwKsH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17561594631",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "65fe5d03e7a2d0d00d7d37bd426fd6532fff3c06",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/65fe5d03e7a2d0d00d7d37bd426fd6532fff3c06",
      "created_at": "2025-05-07T18:31:36Z"
    },
    {
      "event": "commented",
      "id": 2859819482,
      "node_id": "IC_kwDOABII586qdWHa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2859819482",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T18:31:44Z",
      "updated_at": "2025-05-07T18:32:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 4a4eeb94339bb9200012df6a57769dc28e35f553 -> 65fe5d03e7a2d0d00d7d37bd426fd6532fff3c06 ([kernelApi_37](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_37) -> [kernelApi_38](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_38), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_37..kernelApi_38))\r\n\r\n* Fixed conflict with #28710",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2859819482",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 17561837913,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAQWxGFZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17561837913",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-07T18:49:53Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 17840394610,
      "node_id": "LE_lADOABII586SDdapzwAAAAQnXtFy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17840394610",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T00:03:22Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17851628526,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAQoCjvu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17851628526",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1417e0b3b1b03dd014a3459c10a5ae7ab0c3687f",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/1417e0b3b1b03dd014a3459c10a5ae7ab0c3687f",
      "created_at": "2025-05-28T13:54:32Z"
    },
    {
      "event": "commented",
      "id": 2916452571,
      "node_id": "IC_kwDOABII586t1Yjb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2916452571",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T13:54:40Z",
      "updated_at": "2025-05-28T13:54:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 65fe5d03e7a2d0d00d7d37bd426fd6532fff3c06 -> 1417e0b3b1b03dd014a3459c10a5ae7ab0c3687f ([kernelApi_38](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_38) -> [kernelApi_39](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_39), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_38..kernelApi_39))\r\n\r\n* Fixed conflict with #32528",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2916452571",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 17852589540,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAQoGOXk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17852589540",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T14:43:20Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 18084364084,
      "node_id": "LE_lADOABII586SDdapzwAAAAQ16X80",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18084364084",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-11T00:10:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18088207420,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAQ2JCQ8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18088207420",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "43535b545ca6dd7e0221b7c25abfc8409885f7c0",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/43535b545ca6dd7e0221b7c25abfc8409885f7c0",
      "created_at": "2025-06-11T07:13:19Z"
    },
    {
      "event": "commented",
      "id": 2961510497,
      "node_id": "IC_kwDOABII586whRBh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2961510497",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-11T07:13:27Z",
      "updated_at": "2025-06-11T07:13:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 1417e0b3b1b03dd014a3459c10a5ae7ab0c3687f -> 43535b545ca6dd7e0221b7c25abfc8409885f7c0 ([kernelApi_39](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_39) -> [kernelApi_40](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_40), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_39..kernelApi_40))\r\n\r\n* Fixed conflict with #32680",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2961510497",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 18089602756,
      "node_id": "UNLE_lADOABII586SDdapzwAAAAQ2OW7E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18089602756",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-11T08:38:22Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2968121015,
      "node_id": "IC_kwDOABII586w6e63",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2968121015",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-12T20:50:52Z",
      "updated_at": "2025-06-12T20:50:52Z",
      "author_association": "NONE",
      "body": "I'm working on a v2 of my silent payment indexer in GO. I've been able to create a small library to get the basic functionality going https://github.com/setavenger/go-bitcoinkernel.\r\nIn the current version I'm using Bitcoin Cores RPC getblock endpoint with verbosity 3. That gives me the necessary prevouts and also for convience their height. Knowing when a prevout was created helps a lot with efficient cut-through.\r\nBuilding on lib-bitcoinkernel I noticed that there does not seem to be a way yet to fetch the block of a transaction output (neither height nor hash).",
      "user": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2968121015",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unsubscribed",
      "id": 18124849534,
      "node_id": "UE_lADOABII586SDdapzwAAAAQ4U0F-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18124849534",
      "actor": {
        "login": "romanz",
        "id": 9900,
        "node_id": "MDQ6VXNlcjk5MDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/romanz",
        "html_url": "https://github.com/romanz",
        "followers_url": "https://api.github.com/users/romanz/followers",
        "following_url": "https://api.github.com/users/romanz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/romanz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/romanz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/romanz/subscriptions",
        "organizations_url": "https://api.github.com/users/romanz/orgs",
        "repos_url": "https://api.github.com/users/romanz/repos",
        "events_url": "https://api.github.com/users/romanz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/romanz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T00:35:44Z"
    },
    {
      "event": "commented",
      "id": 2969913702,
      "node_id": "IC_kwDOABII586xBUlm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2969913702",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T10:41:15Z",
      "updated_at": "2025-06-13T10:41:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for testing this out @setavenger! I think exposing the height from the coin containing the `CTxOut` in the undo data would be a nice improvement and should be easy to do. Once you have the height, you can get the block through `kernel_get_block_index_from_height` and then `kernel_read_block_from_disk`, which I think would provide what you are looking for.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2969913702",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18131591325,
      "node_id": "MEE_lADOABII586SDdapzwAAAAQ4uiCd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18131591325",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T10:41:17Z"
    },
    {
      "event": "subscribed",
      "id": 18131591380,
      "node_id": "SE_lADOABII586SDdapzwAAAAQ4uiDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18131591380",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T10:41:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18132758054,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAQ4y-4m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18132758054",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d9e030d56343bb452d86169f77ddfb64f7160235",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/d9e030d56343bb452d86169f77ddfb64f7160235",
      "created_at": "2025-06-13T11:53:16Z"
    },
    {
      "event": "commented",
      "id": 2970158132,
      "node_id": "IC_kwDOABII586xCQQ0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2970158132",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T11:53:29Z",
      "updated_at": "2025-06-13T11:54:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 43535b545ca6dd7e0221b7c25abfc8409885f7c0 -> d9e030d56343bb452d86169f77ddfb64f7160235 ([kernelApi_40](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_40) -> [kernelApi_41](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_41), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_40..kernelApi_41))\r\n\r\n* Addressed @setavenger's [comment](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2968121015), added a function to retrieve the block height an output contained in the undo data was created at.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2970158132",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18132774473,
      "node_id": "MEE_lADOABII586SDdapzwAAAAQ4zC5J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18132774473",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T11:54:25Z"
    },
    {
      "event": "subscribed",
      "id": 18132774495,
      "node_id": "SE_lADOABII586SDdapzwAAAAQ4zC5f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18132774495",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-13T11:54:25Z"
    },
    {
      "event": "commented",
      "id": 2972781400,
      "node_id": "IC_kwDOABII586xMQtY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2972781400",
      "actor": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-14T14:04:21Z",
      "updated_at": "2025-06-14T14:04:21Z",
      "author_association": "NONE",
      "body": "Wow quick, thanks a lot! This should work well. Will give feedback once I had time to try it out properly.",
      "user": {
        "login": "setavenger",
        "id": 34041358,
        "node_id": "MDQ6VXNlcjM0MDQxMzU4",
        "avatar_url": "https://avatars.githubusercontent.com/u/34041358?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/setavenger",
        "html_url": "https://github.com/setavenger",
        "followers_url": "https://api.github.com/users/setavenger/followers",
        "following_url": "https://api.github.com/users/setavenger/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/setavenger/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/setavenger/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/setavenger/subscriptions",
        "organizations_url": "https://api.github.com/users/setavenger/orgs",
        "repos_url": "https://api.github.com/users/setavenger/repos",
        "events_url": "https://api.github.com/users/setavenger/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/setavenger/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2972781400",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "subscribed",
      "id": 18236479938,
      "node_id": "SE_lADOABII586SDdapzwAAAAQ--pnC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18236479938",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-19T21:50:20Z"
    },
    {
      "event": "commented",
      "id": 2994351556,
      "node_id": "IC_kwDOABII586yei3E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2994351556",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-22T18:01:47Z",
      "updated_at": "2025-06-22T18:01:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK.\r\n\r\nI have also been working on a Go wrapper; I mostly started it to learn and familiarize myself with what is possible with the API, but I intend to maintain it, so I appreciate any feedback:\r\n\r\n[github.com/stringintech/go-bitcoinkernel](https://github.com/stringintech/go-bitcoinkernel)\r\n\r\nI have already taken a brief look at the existing [Python](https://github.com/stickies-v/py-bitcoinkernel) and [Rust](https://github.com/TheCharlatan/rust-bitcoinkernel) wrappers and borrowed ideas for tests, but I should take a closer look.",
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2994351556",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 2969368786,
      "node_id": "PRR_kwDOABII586w_PjS",
      "url": null,
      "actor": null,
      "commit_id": "d9e030d56343bb452d86169f77ddfb64f7160235",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-29T18:29:16Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2969368786",
      "submitted_at": "2025-06-29T18:29:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18383669538,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARHwIki",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18383669538",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "created_at": "2025-06-30T10:15:21Z"
    },
    {
      "event": "commented",
      "id": 3018588171,
      "node_id": "IC_kwDOABII586z7AAL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3018588171",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T10:15:30Z",
      "updated_at": "2025-06-30T10:15:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated d9e030d56343bb452d86169f77ddfb64f7160235 -> 690a5dac223ed18a65c9d9e6c535466cc3ad4511 ([kernelApi_41](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_41) -> [kernelApi_42](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_42), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_41..kernelApi_42))\r\n\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2173853678), using the correct name for the kernel component. This was missed after rebasing on https://github.com/bitcoin/bitcoin/pull/31869.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3018588171",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18383672274,
      "node_id": "MEE_lADOABII586SDdapzwAAAARHwJPS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18383672274",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T10:15:31Z"
    },
    {
      "event": "subscribed",
      "id": 18383672308,
      "node_id": "SE_lADOABII586SDdapzwAAAARHwJP0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18383672308",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-30T10:15:31Z"
    },
    {
      "event": "commented",
      "id": 3045757878,
      "node_id": "IC_kwDOABII5861ipO2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3045757878",
      "actor": {
        "login": "yuvicc",
        "id": 92994932,
        "node_id": "U_kgDOBYr9dA",
        "avatar_url": "https://avatars.githubusercontent.com/u/92994932?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yuvicc",
        "html_url": "https://github.com/yuvicc",
        "followers_url": "https://api.github.com/users/yuvicc/followers",
        "following_url": "https://api.github.com/users/yuvicc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yuvicc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yuvicc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yuvicc/subscriptions",
        "organizations_url": "https://api.github.com/users/yuvicc/orgs",
        "repos_url": "https://api.github.com/users/yuvicc/repos",
        "events_url": "https://api.github.com/users/yuvicc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yuvicc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-07T16:12:16Z",
      "updated_at": "2025-07-07T16:12:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nMade a Java wrapper library for the Java folks out there!\r\nhttps://github.com/yuvicc/java-bitcoinkernel\r\n\r\nWhile playing with the API I also wrote a [benchmarking test](https://github.com/yuvicc/bitcoin/tree/2025-06-kernel_benchmarking) for the script validation using the API vs the internal code just to see the performane overhead:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|           34,138.87 |           29,292.12 |    0.2% |      457,313.10 |      144,899.28 |  3.156 |       9,465.17 |    0.5% |      0.01 | `VerifyScriptBench`\r\n|           34,229.45 |           29,214.61 |    0.1% |      457,313.10 |      144,994.30 |  3.154 |       9,465.17 |    0.5% |      0.01 | `VerifyScriptBench`\r\n|           34,001.07 |           29,410.84 |    0.2% |      457,313.11 |      144,108.48 |  3.173 |       9,465.17 |    0.5% |      0.01 | `VerifyScriptBench`\r\n\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|           34,867.07 |           28,680.36 |    0.2% |      465,484.22 |      148,107.37 |  3.143 |      12,150.19 |    0.4% |      0.01 | `VerifyScriptKernelApiBench`\r\n|           34,999.80 |           28,571.59 |    0.2% |      465,484.22 |      148,375.57 |  3.137 |      12,150.19 |    0.4% |      0.01 | `VerifyScriptKernelApiBench`\r\n|           34,853.13 |           28,691.82 |    0.2% |      465,484.22 |      147,583.89 |  3.154 |      12,150.19 |    0.4% |      0.01 | `VerifyScriptKernelApiBench`",
      "user": {
        "login": "yuvicc",
        "id": 92994932,
        "node_id": "U_kgDOBYr9dA",
        "avatar_url": "https://avatars.githubusercontent.com/u/92994932?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yuvicc",
        "html_url": "https://github.com/yuvicc",
        "followers_url": "https://api.github.com/users/yuvicc/followers",
        "following_url": "https://api.github.com/users/yuvicc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yuvicc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yuvicc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yuvicc/subscriptions",
        "organizations_url": "https://api.github.com/users/yuvicc/orgs",
        "repos_url": "https://api.github.com/users/yuvicc/repos",
        "events_url": "https://api.github.com/users/yuvicc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yuvicc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3045757878",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 3052764983,
      "node_id": "IC_kwDOABII58619X83",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3052764983",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-09T13:51:41Z",
      "updated_at": "2025-07-09T13:51:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Made a Java wrapper library for the Java folks out there! https://github.com/yuvicc/java-bitcoinkernel\r\n\r\nCool!\r\n\r\n> While playing with the API I also wrote a [benchmarking test](https://github.com/yuvicc/bitcoin/tree/2025-06-kernel_benchmarking) for the script validation using the API vs the internal code just to see the performane overhead\r\n\r\nIt looks like your benchmark includes serialization in its hot loop, which is not the case for our internal `VerifyScriptBench`. I'd be surprised if there was any overhead if the serialization is performed externally in your bench too.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3052764983",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 3057521471,
      "node_id": "IC_kwDOABII5862PhM_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3057521471",
      "actor": {
        "login": "yuvicc",
        "id": 92994932,
        "node_id": "U_kgDOBYr9dA",
        "avatar_url": "https://avatars.githubusercontent.com/u/92994932?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yuvicc",
        "html_url": "https://github.com/yuvicc",
        "followers_url": "https://api.github.com/users/yuvicc/followers",
        "following_url": "https://api.github.com/users/yuvicc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yuvicc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yuvicc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yuvicc/subscriptions",
        "organizations_url": "https://api.github.com/users/yuvicc/orgs",
        "repos_url": "https://api.github.com/users/yuvicc/repos",
        "events_url": "https://api.github.com/users/yuvicc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yuvicc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-10T13:44:59Z",
      "updated_at": "2025-07-10T13:44:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "> It looks like your benchmark includes serialization in its hot loop, which is not the case for our internal `VerifyScriptBench`. I'd be surprised if there was any overhead if the serialization is performed externally in your bench too.\r\n\r\nAgree, I think I shall keep the script serialization for the internal code inside the hot loop as well and also vice versa. Let me check!\r\n",
      "user": {
        "login": "yuvicc",
        "id": 92994932,
        "node_id": "U_kgDOBYr9dA",
        "avatar_url": "https://avatars.githubusercontent.com/u/92994932?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yuvicc",
        "html_url": "https://github.com/yuvicc",
        "followers_url": "https://api.github.com/users/yuvicc/followers",
        "following_url": "https://api.github.com/users/yuvicc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yuvicc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yuvicc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yuvicc/subscriptions",
        "organizations_url": "https://api.github.com/users/yuvicc/orgs",
        "repos_url": "https://api.github.com/users/yuvicc/repos",
        "events_url": "https://api.github.com/users/yuvicc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yuvicc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3057521471",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 3014202096,
      "node_id": "PRR_kwDOABII586zqRLw",
      "url": null,
      "actor": null,
      "commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-13T20:21:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "Had some time to go over the commits and code changes and left a number of documentation-related comments.  The existing docs are already really solid and helpful - just suggestions that might add clarity.",
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-3014202096",
      "submitted_at": "2025-07-13T18:56:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "commented",
      "id": 3068613759,
      "node_id": "IC_kwDOABII586251R_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3068613759",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T09:28:05Z",
      "updated_at": "2025-07-14T09:28:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "NACK\r\n\r\nAfter working with the API for a few days and reviewing the various language bindings listed in the PR summary, I found that the API requires some fundamental changes in order to reduce the amount of glue code required in language bindings and client code. I wrote a rather detailed analysis here: https://njump.me/naddr1qvzqqqr4gupzqrcxrljwdpfz2qn5a57hse6ez6pkd34pe0wpeskmktt2p62yeketqqvxy6t5vdhkjmntv4exuetv94shq6fdwfjhv6t9wuxrjull",
      "user": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3068613759",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18614757568,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARVhqjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18614757568",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "267a7b3f321304f75e8c47e380da49ba9c64bc84",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/267a7b3f321304f75e8c47e380da49ba9c64bc84",
      "created_at": "2025-07-14T10:10:01Z"
    },
    {
      "event": "commented",
      "id": 3068782737,
      "node_id": "IC_kwDOABII58626eiR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3068782737",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T10:10:05Z",
      "updated_at": "2025-07-14T10:10:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the review @stringintech!\r\n\r\nRebased 690a5dac223ed18a65c9d9e6c535466cc3ad4511 -> 52bab146a5045899ea6800305fa6d9b4efdcc6bd ([kernelApi_42](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_42) -> [kernelApi_43](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_43), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_42..kernelApi_43))\r\n\r\nUpdated 52bab146a5045899ea6800305fa6d9b4efdcc6bd -> 267a7b3f321304f75e8c47e380da49ba9c64bc84 ([kernelApi_43](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_43) -> [kernelApi_44](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_44), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_43..kernelApi_44))\r\n\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203431643), check bounds on `kernel_get_transaction_undo_size`.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203432158), add returning 0 as a potential mark for failure.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203435973), clarify ownership of `kernel_TransactionOutput`.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203438688), clarify copy on copying of the notifications callback struct.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203460324), renaming `kernel_add_log_level_category` to `kernel_set_log_level_category`.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203462548), describe what precisely happens when we call `DisconnectTestLogger()`.\r\n* Addressed @stringintech's comments [1](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203475130), [2](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203475273), [3](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203479560), [4](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203479761), [5](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203480066), [6](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203480066), [7](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203480783), [8](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203488049) improving documentation around returning failure values and types.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203482913), mention that validation interface callbacks block in the documentation.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203492012), updated commit description around deserializing blocks.\r\n* Addressed @stringintech's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203492384), removed name that was left dangling after a prior update.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3068782737",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18614759100,
      "node_id": "MEE_lADOABII586SDdapzwAAAARVhq68",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18614759100",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T10:10:06Z"
    },
    {
      "event": "subscribed",
      "id": 18614759165,
      "node_id": "SE_lADOABII586SDdapzwAAAARVhq79",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18614759165",
      "actor": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T10:10:06Z"
    },
    {
      "event": "commented",
      "id": 3068922992,
      "node_id": "IC_kwDOABII58627Axw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3068922992",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T10:44:25Z",
      "updated_at": "2025-07-14T10:44:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3068613759\r\n\r\nThanks for writing all of that up and your detailed tour @purpleKarrot. I think you raise some excellent points on your blog, but I am not sure how I am to interpret your NACK here.\r\n\r\nYou mention that fundamental changes are required, but after reading some of your proposed changes in `/btck` I am not sure how materially different those are from what is proposed here. I think naming conventions is probably the easiest win here, I am currently working on re-writing the header with proper noun-verb-object separation. I think your suggestions for using similar names for the various manipulations we do so we can better map them to ranges, or other standard interfaces is great too!\r\n\r\nThe `BlockUndo` is a data type used in Bitcoin Core to populate the `rev*.dat` data. It contains all the information required to \"undo\" spending a coin in case of a block reorg. It thus contains the transaction outputs consumed by each transaction in a block. It is really useful to have this information in order to build indexes and do rudimentary data analysis.\r\n\r\nI think one problem here is that I may have been too conservative with both the capabilities of the API, i.e. no reference counting, no richer data getters for e.g. blocks and transactions, in order to keep the scope of this PR manageable. The current PR does not have many of the richer things you seem to desire for the fear of scope creep. There is endless bikeshedding potential here, and radically limiting the scope seemed like a solution for this to me. The current header implements the bare minimum required to get a) a full node running, b) read block and undo data, and c) do script validation.\r\n\r\nI'd gladly roll your suggestions into the PR here, but if you think this is not salvageable, I'd like to know which conceptual part you disagree with, i.e. this repository shipping a C header, the relationship between the C and C++ headers, or all the deeper memory management and ref counting issues.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3068922992",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18615344995,
      "node_id": "MEE_lADOABII586SDdapzwAAAARVj59j",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18615344995",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T10:44:27Z"
    },
    {
      "event": "subscribed",
      "id": 18615345023,
      "node_id": "SE_lADOABII586SDdapzwAAAARVj59_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18615345023",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T10:44:27Z"
    },
    {
      "event": "commented",
      "id": 3069008389,
      "node_id": "IC_kwDOABII58627VoF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3069008389",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T11:04:13Z",
      "updated_at": "2025-07-14T11:04:13Z",
      "author_association": "CONTRIBUTOR",
      "body": ">  am not sure how I am to interpret your NACK here.\r\n\r\nJust as \"I think this PR should not be merged in its current form.\" I definitely do agree with the approach of adding a C API.\r\n\r\nRegarding the other points, maybe we should have a private discussion.",
      "user": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3069008389",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 3069964449,
      "node_id": "IC_kwDOABII5862-_Ch",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3069964449",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:11:06Z",
      "updated_at": "2025-07-14T15:11:06Z",
      "author_association": "MEMBER",
      "body": "\r\n\r\n\r\n> > am not sure how I am to interpret your NACK here.\r\n> \r\n> Just as \"I think this PR should not be merged in its current form.\" I definitely do agree with the approach of adding a C API.\r\n\r\nFWIW, I read this as \"Concept ACK, Approach NACK\" (per https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#conceptual-review), which I think is a helpful distinction.\r\n\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3069964449",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "commented",
      "id": 3069994277,
      "node_id": "IC_kwDOABII5862_GUl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3069994277",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:20:06Z",
      "updated_at": "2025-07-14T15:20:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "Yes, Concept ACK, Approach NACK\r\n\r\nThanks, @josibake.",
      "user": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3069994277",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18620384247,
      "node_id": "MEE_lADOABII586SDdapzwAAAARV3IP3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18620384247",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:20:07Z"
    },
    {
      "event": "subscribed",
      "id": 18620384274,
      "node_id": "SE_lADOABII586SDdapzwAAAARV3IQS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18620384274",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:20:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18620486912,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARV3hUA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18620486912",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "created_at": "2025-07-14T15:25:46Z"
    },
    {
      "event": "commented",
      "id": 3070013951,
      "node_id": "IC_kwDOABII5862_LH_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3070013951",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T15:26:18Z",
      "updated_at": "2025-07-14T15:26:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 267a7b3f321304f75e8c47e380da49ba9c64bc84 -> 1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe ([kernelApi_44](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_44) -> [kernelApi_45](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_45), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_44..kernelApi_45))\r\n\r\n* Enforce better function names in the API, which should make future discussions on their desired end format a bit easier.\r\n* Dropped the macro check for gcc 4.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3070013951",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18860030729,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARkJTsJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18860030729",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "938767d957b7669accfb554a7cbb25141f7e8632",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/938767d957b7669accfb554a7cbb25141f7e8632",
      "created_at": "2025-07-28T16:19:52Z"
    },
    {
      "event": "commented",
      "id": 3128011661,
      "node_id": "IC_kwDOABII5866cauN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3128011661",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T16:20:15Z",
      "updated_at": "2025-07-28T16:20:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe -> 938767d957b7669accfb554a7cbb25141f7e8632 ([kernelApi_45](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_45) -> [kernelApi_46](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_46), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_45..kernelApi_46))\r\n\r\n* Fixed symbol visibility for windows static builds and simplified the macro checks in the header a bit.\r\n* Removed the kernel library symbol visibility hack, this allows the user to reduce exports for the library.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3128011661",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 3030139760,
      "node_id": "PRR_kwDOABII5860nENw",
      "url": null,
      "actor": null,
      "commit_id": "938767d957b7669accfb554a7cbb25141f7e8632",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-28T16:29:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "Did another review round while updating py-bitcoinkernel. The main themes are:\r\n- using reference counting internally to let us simplify the interface (e.g. [expose `kernel_TransactionUndo` and `kernel_Coin`](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237111430) instead of letting the user manage indexes) as well as replace expensive `_copy` operations with `_get` ones\r\n  - note: in the WG we have discussed exposing reference counting through the public interface too, but personally I don't see the benefits for that complexity yet, even if I'm happy to convinced otherwise.\r\n- [avoid/minimize using `reinterpret_cast` and all the `cast_{const}_` functions](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237140589) - instead just implement the `kernel_` structs. The overhead should be negligible in most cases and I think it'll make the code safer and easier to read.\r\n- [remove `kernel_BlockPointer`](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237124698) if/when #33078 gets merged.",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-3030139760",
      "submitted_at": "2025-07-28T16:28:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18861213106,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARkN0Wy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18861213106",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4eb1c66dbdaf35cbc480cb201f6019bc0f5fde95",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/4eb1c66dbdaf35cbc480cb201f6019bc0f5fde95",
      "created_at": "2025-07-28T17:23:40Z"
    },
    {
      "event": "commented",
      "id": 3128247787,
      "node_id": "IC_kwDOABII5866dUXr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3128247787",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T17:23:47Z",
      "updated_at": "2025-07-28T17:23:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you so much for the review @stickies-v! Picked off the smaller items here, while we are still experimenting with the rest:\r\n\r\nUpdated 938767d957b7669accfb554a7cbb25141f7e8632 -> 4eb1c66dbdaf35cbc480cb201f6019bc0f5fde95 ([kernelApi_46](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_46) -> [kernelApi_47](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_47), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_46..kernelApi_47)).\r\n\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2213740015), fixed some docstrings.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2213968769), removed unnecessary `const`.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2214073393), added guards against `clang-format` moving order sensitive includes.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2216084200), fixed memory leak on read error. This was not caught before, because the error path is untested. Will add a test in a later push.\r\n* Addressed @stickies-v's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2219798945), use a cast for getting a `CTxOut*`.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3128247787",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 18861214962,
      "node_id": "MEE_lADOABII586SDdapzwAAAARkN0zy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18861214962",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T17:23:48Z"
    },
    {
      "event": "subscribed",
      "id": 18861214998,
      "node_id": "SE_lADOABII586SDdapzwAAAARkN00W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18861214998",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T17:23:48Z"
    },
    {
      "event": "commented",
      "id": 3129870494,
      "node_id": "IC_kwDOABII5866jgie",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3129870494",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-28T20:57:42Z",
      "updated_at": "2025-07-28T21:00:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I see in the C++ wrapper that a lot of functions are marked `noexcept`. I assume that the rationale is: \"since this function just wraps a C function and C functions cannot throw, the function could just as well be marked `noexcept`\".\r\n\r\nBut this is not how the keyword is meant to be used. The `noexcept` keyword is intended to be used on functions that should not be *allowed* to throw. The compiler then generates a runtime check to terminate the program in the case that the function throws. You certainly don't need those checks when wrapping a C function.\r\n\r\nAlso, per the [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Re-invariant), \r\n\r\n> Leaving an object without its invariant established is asking for trouble\r\n\r\nYou cannot make a constructor `noexcept` if it fails to establish the invariant of a class.\r\n\r\nMake sure to study: http://www.exceptionsafecode.com/",
      "user": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3129870494",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18872320713,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARk4MLJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18872320713",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3d6b3fd8f65e8d4ea2c26d61c3dee89f5da10fac",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/3d6b3fd8f65e8d4ea2c26d61c3dee89f5da10fac",
      "created_at": "2025-07-29T07:53:53Z"
    },
    {
      "event": "commented",
      "id": 3131141240,
      "node_id": "IC_kwDOABII5866oWx4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3131141240",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-29T07:54:02Z",
      "updated_at": "2025-07-29T07:54:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 4eb1c66dbdaf35cbc480cb201f6019bc0f5fde95 -> 3d6b3fd8f65e8d4ea2c26d61c3dee89f5da10fac ([kernelApi_47](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_47) -> [kernelApi_48](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_48), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_47..kernelApi_48))\r\n\r\n* Added test for failed block and undo data reads.\r\n* Migrated unit tests to use our usual boost test framework. This was done initially to demonstrate that indeed nothing boost related leaked out of the library, but with all other users this is no longer a good reason.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3131141240",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 18882229296,
      "node_id": "LE_lADOABII586SDdapzwAAAARld_Qw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18882229296",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-29T16:11:59Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18894580629,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARmNGuV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18894580629",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6a9fdf7ae58a85ccc08c5f6917f64f28f5a330ad",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/6a9fdf7ae58a85ccc08c5f6917f64f28f5a330ad",
      "created_at": "2025-07-30T08:58:16Z"
    },
    {
      "event": "commented",
      "id": 3135423918,
      "node_id": "IC_kwDOABII58664sWu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3135423918",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-30T08:58:22Z",
      "updated_at": "2025-07-30T08:58:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 3d6b3fd8f65e8d4ea2c26d61c3dee89f5da10fac -> 6a9fdf7ae58a85ccc08c5f6917f64f28f5a330ad ([kernelApi_48](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_48) -> [kernelApi_49](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_49), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_48..kernelApi_49))\r\n\r\n* Fixed conflict with #33079",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3135423918",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "unlabeled",
      "id": 18895214503,
      "node_id": "UNLE_lADOABII586SDdapzwAAAARmPhen",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18895214503",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-30T09:33:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3143645791,
      "node_id": "IC_kwDOABII5867YDpf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3143645791",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T08:04:42Z",
      "updated_at": "2025-08-01T08:05:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3129870494\r\n\r\n> You cannot make a constructor noexcept if it fails to establish the invariant of a class.\r\n\r\nThe question of how to handle constructor errors has been annoying me in this code base for a long time. We do everything from throwing, to output error parameters, to factory functions returning optionals, to `bool` operator style validity checks. My feeling is we recently tend to avoid throwing exceptions, my personal preference would be using c++23's `std::expected`, but that will take more time to land.\r\n\r\nThe current approach here mimics the approach in our existing minisketch c++ wrapper: https://github.com/bitcoin/bitcoin/blob/master/src/minisketch/include/minisketch.h#L232-L269. I think it would be nice to at least attempt consistency for our C API wrapper classes.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3143645791",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "labeled",
      "id": 19013728562,
      "node_id": "LE_lADOABII586SDdapzwAAAARtTnky",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19013728562",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-06T13:44:21Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3163466142,
      "node_id": "IC_kwDOABII5868jqme",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3163466142",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-07T10:19:28Z",
      "updated_at": "2025-08-07T10:19:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased 6a9fdf7ae58a85ccc08c5f6917f64f28f5a330ad -> ce8003578e725cf3c64a0f3e1447459e26955a3d ([kernelApi_49](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_49) -> [kernelApi_50](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_50), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_49..kernelApi_50))\r\n\r\n* Fixed conflict with #33077\r\n\r\n@stickies-v want to give the mono lib a try in your python bindings?",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3163466142",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 19032136507,
      "node_id": "MEE_lADOABII586SDdapzwAAAARuZ1s7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19032136507",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-07T10:19:30Z"
    },
    {
      "event": "subscribed",
      "id": 19032136545,
      "node_id": "SE_lADOABII586SDdapzwAAAARuZ1th",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19032136545",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-07T10:19:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19032143856,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARuZ3fw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19032143856",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ce8003578e725cf3c64a0f3e1447459e26955a3d",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/ce8003578e725cf3c64a0f3e1447459e26955a3d",
      "created_at": "2025-08-07T10:19:55Z"
    },
    {
      "event": "unlabeled",
      "id": 19033433791,
      "node_id": "UNLE_lADOABII586SDdapzwAAAARueya_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19033433791",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-07T11:35:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19083363877,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARxdQYl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19083363877",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "825f9032dd464cc5d2cdf6493d4a5ddbb2f2ab93",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/825f9032dd464cc5d2cdf6493d4a5ddbb2f2ab93",
      "created_at": "2025-08-11T09:00:14Z"
    },
    {
      "event": "commented",
      "id": 3173835277,
      "node_id": "IC_kwDOABII5869LOIN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3173835277",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T09:00:22Z",
      "updated_at": "2025-08-11T09:00:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "Rebased ce8003578e725cf3c64a0f3e1447459e26955a3d -> 825f9032dd464cc5d2cdf6493d4a5ddbb2f2ab93 ([kernelApi_50](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_50) -> [kernelApi_51](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_51), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_50..kernelApi_51))",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3173835277",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19083870643,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARxfMGz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19083870643",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "created_at": "2025-08-11T09:26:15Z"
    },
    {
      "event": "commented",
      "id": 3173927602,
      "node_id": "IC_kwDOABII5869Lkqy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3173927602",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T09:26:21Z",
      "updated_at": "2025-08-13T07:30:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you @stickies-v and @purpleKarrot for the discussions, pushing some work now here:\r\n\r\nUpdated 825f9032dd464cc5d2cdf6493d4a5ddbb2f2ab93 -> 39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5 ([kernelApi_51](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_51) -> [kernelApi_52](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_52), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_51..kernelApi_52))\r\n\r\n* Rename C function prefix from `kernel` to `btck`\r\n* Introduce new `btck` namespace\r\n* Rename `BlockUndo` to `BlockSpentOutputs`.\r\n* Introduce clearer type hierarchy to go from `BlockSpentOutputs` to `ScriptPubkeys`: `BlockSpentOutputs`->`TransadctionSpentOutputs` ->  `Coin` -> `TransactionOutput` -> `ScriptPubkey`.\r\n* Remove `noexcept` from most methods in the C++ wrapper, but explicitly add it to the invocations of the `Deleter` structs.\r\n* Throw if there is a constructor failure in the C++ wrapper.\r\n* Enforce some more errors that might occur when the programmer passes in bad input (e.g. through out-of-bounds indeces) by asserts.\r\n* Make `CBlock`, `CTransaction`, and `Context` shared_ptrs internally. This avoids expensive copies of our larger data structures and avoids having to pass the `Context` to `ChainstateManager` related functions.\r\n* Avoid using `reinterpret_cast` by introducing wrapper structs in the c++ glue code for all opaque structs.\r\n* Add a new way to express ownership: Functions now document if they return pointers to non-owned data structures. Non-owned pointers are mostly useful while iterating, and are wrapped in a new `RefWrapper` type in the C++ wrapper. Internally their ownership is tracked by the wrapper struct to ensure that destroying them again remains safe.\r\n* Add functions to explicity `_copy` an object. Depending on the object type this either increments a reference counter, or does a deep copy of the underlying data. This is also documented. This also allows copying data from `RefWrapper`-wrapper types.\r\n\r\nWill re-work the `BlockIndex`<->`ChainstateManager` relationship next and replace the `ByteArray` struct with a writer callback like purpleKarrot suggested here: https://purplekarrot.github.io/btck/design/memory_management.html\r\n",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3173927602",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 19083872850,
      "node_id": "MEE_lADOABII586SDdapzwAAAARxfMpS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19083872850",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T09:26:23Z"
    },
    {
      "event": "subscribed",
      "id": 19083872877,
      "node_id": "SE_lADOABII586SDdapzwAAAARxfMpt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19083872877",
      "actor": {
        "login": "purpleKarrot",
        "id": 185240,
        "node_id": "MDQ6VXNlcjE4NTI0MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/185240?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/purpleKarrot",
        "html_url": "https://github.com/purpleKarrot",
        "followers_url": "https://api.github.com/users/purpleKarrot/followers",
        "following_url": "https://api.github.com/users/purpleKarrot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/purpleKarrot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/purpleKarrot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/purpleKarrot/subscriptions",
        "organizations_url": "https://api.github.com/users/purpleKarrot/orgs",
        "repos_url": "https://api.github.com/users/purpleKarrot/repos",
        "events_url": "https://api.github.com/users/purpleKarrot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/purpleKarrot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T09:26:23Z"
    },
    {
      "event": "mentioned",
      "id": 19083872908,
      "node_id": "MEE_lADOABII586SDdapzwAAAARxfMqM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19083872908",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T09:26:23Z"
    },
    {
      "event": "subscribed",
      "id": 19083872933,
      "node_id": "SE_lADOABII586SDdapzwAAAARxfMql",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19083872933",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-11T09:26:23Z"
    },
    {
      "event": "reviewed",
      "id": 3109486218,
      "node_id": "PRR_kwDOABII5865Vv6K",
      "url": null,
      "actor": null,
      "commit_id": "39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-12T09:23:20Z",
      "author_association": "NONE",
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-3109486218",
      "submitted_at": "2025-08-12T09:23:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19115174509,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAARzWmpt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19115174509",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "abffb6d6587502371a59d37c043d3d644846c267",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/abffb6d6587502371a59d37c043d3d644846c267",
      "created_at": "2025-08-12T15:06:44Z"
    },
    {
      "event": "commented",
      "id": 3179763360,
      "node_id": "IC_kwDOABII5869h1ag",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3179763360",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T15:09:04Z",
      "updated_at": "2025-08-12T15:09:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5 -> abffb6d6587502371a59d37c043d3d644846c267 ([kernelApi_52](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_52) -> [kernelApi_53](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_53), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_52..kernelApi_53))\r\n\r\n* Addressed @alexanderwiederin's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2269696749), add `btck_transaction_count_inputs` and assert on the selected input index being out of bounds.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3179763360",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 19115227920,
      "node_id": "MEE_lADOABII586SDdapzwAAAARzWzsQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19115227920",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T15:09:05Z"
    },
    {
      "event": "subscribed",
      "id": 19115227961,
      "node_id": "SE_lADOABII586SDdapzwAAAARzWzs5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19115227961",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-12T15:09:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19157626124,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAR14i0M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19157626124",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e31863bd764037eb7fc6b28fae0030ce76c8f8c6",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/e31863bd764037eb7fc6b28fae0030ce76c8f8c6",
      "created_at": "2025-08-14T11:38:29Z"
    },
    {
      "event": "commented",
      "id": 3188141709,
      "node_id": "IC_kwDOABII586-By6N",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3188141709",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-14T11:38:33Z",
      "updated_at": "2025-08-14T11:38:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated abffb6d6587502371a59d37c043d3d644846c267 -> e31863bd764037eb7fc6b28fae0030ce76c8f8c6 ([kernelApi_53](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_53) -> [kernelApi_54](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_54), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_53..kernelApi_54))\r\n\r\n* Renamed `BlockIndex` to `BlockTreeEntry`, which more accurately conveys what it is.\r\n* Wrap the `CBlockIndex*` in a `BlockTreeEntry` struct. \r\n* Introduce a `Chain` type to clearly delineate between block tree entries in the chain and not in the chain. Entries can be retrieved by height from the `Chain` and by hash from the `ChainstateManager`.\r\n* Add a `contains` function for the `Chain` to allow a user to check if a certain `BlockTreeEntry` is in the `Chain`.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3188141709",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19174754924,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAR254ps",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19174754924",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ab06b85bc2c0f4733dd96f9694c0c3d972004a36",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/ab06b85bc2c0f4733dd96f9694c0c3d972004a36",
      "created_at": "2025-08-15T11:13:00Z"
    },
    {
      "event": "commented",
      "id": 3191273846,
      "node_id": "IC_kwDOABII586-Nvl2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3191273846",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T11:13:06Z",
      "updated_at": "2025-08-15T11:13:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated e31863bd764037eb7fc6b28fae0030ce76c8f8c6 -> b554606c787c082196dd60ea14539bfd08dad80b ([kernelApi_54](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_54) -> [kernelApi_55](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_55), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_54..kernelApi_55))\r\n\r\n* Swapped out `unsigned char` types representing raw byte arrays with void pointers. This should make it a little easier to other languages which may use a host of other types to represent bytes.\r\n* Added serialization through a callback function as laid out by purpleKarrot in his two blog posts about [memory management](https://purplekarrot.github.io/btck/design/memory_management.html) and [delegates](https://purplekarrot.github.io/btck/design/delegates.html). This avoids having to copy the data into separate byte array type and then again into whatever the respective language uses to represent bytes, thus avoiding at least one additional copy during serialization. Removed the `ByteArray` type entirely.\r\n* Added function to serialize a transaction and expanded tests a bit to ensure that roundtrips work for the types where we allow serialization.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3191273846",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 3123663045,
      "node_id": "PRR_kwDOABII5866L1DF",
      "url": null,
      "actor": null,
      "commit_id": "ab06b85bc2c0f4733dd96f9694c0c3d972004a36",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-15T11:35:41Z",
      "author_association": "NONE",
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-3123663045",
      "submitted_at": "2025-08-15T11:35:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19176052331,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAR2-1Zr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19176052331",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "35fced5df783bc79720d8a74b89a5a0a62ebab72",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/35fced5df783bc79720d8a74b89a5a0a62ebab72",
      "created_at": "2025-08-15T13:21:14Z"
    },
    {
      "event": "commented",
      "id": 3191487708,
      "node_id": "IC_kwDOABII586-Ojzc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3191487708",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T13:21:31Z",
      "updated_at": "2025-08-15T13:21:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated ab06b85bc2c0f4733dd96f9694c0c3d972004a36 -> 35fced5df783bc79720d8a74b89a5a0a62ebab72 ([kernelApi_55](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_55) -> [kernelApi_56](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_56), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_55..kernelApi_56))\r\n\r\n* Removed `bool` types from the C header and replaced them with `int`. Where used a success code, return 0 on success, where used to signal presence, e.g. `*_contains` functions, return 1 on presence, and where used as an on-off switch for an option, return 1 for `on`.\r\n* Addressed @alexanderwiederin's [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2278842152), renamed `btck_chain_get_next_block_tree_entry`.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3191487708",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "mentioned",
      "id": 19176055896,
      "node_id": "MEE_lADOABII586SDdapzwAAAAR2-2RY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19176055896",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T13:21:33Z"
    },
    {
      "event": "subscribed",
      "id": 19176055916,
      "node_id": "SE_lADOABII586SDdapzwAAAAR2-2Rs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19176055916",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-15T13:21:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19188572247,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAR3umBX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19188572247",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1e2dc7527c33524414ec409e37e10408adde8fd7",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/1e2dc7527c33524414ec409e37e10408adde8fd7",
      "created_at": "2025-08-16T21:26:06Z"
    },
    {
      "event": "commented",
      "id": 3193915803,
      "node_id": "IC_kwDOABII586-X0mb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3193915803",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-16T21:26:18Z",
      "updated_at": "2025-08-17T11:23:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 35fced5df783bc79720d8a74b89a5a0a62ebab72 -> fdc9f98caeb9e77f20e55c4446a3c23d2da51011 ([kernelApi_56](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_56) -> [kernelApi_57](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_57), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_56..kernelApi_57))\r\n\r\n* Re-implemented enumerations as suggested by purpleKarrot [here](https://purplekarrot.github.io/btck/design/enumerations.html). This should be clearer about the actual capabilities of enums in C and guard against potential portability problems.\r\n* Removed another script verify error code. Assuring that only valid bits are set in the bitfield is now entirely the responsibility of the caller and is enforced through an `assert`. \r\n* Added an abstract `Handle` class for wrapping the pointers returned by the C functions in the C++ wrapper.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3193915803",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19190459524,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAR31yyE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19190459524",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fdc9f98caeb9e77f20e55c4446a3c23d2da51011",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/fdc9f98caeb9e77f20e55c4446a3c23d2da51011",
      "created_at": "2025-08-17T08:40:33Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI0MWVhZWRmOTEwYjY2NWMyZjcwMmY5ZTk1ZDdmYWRkNmFiODdhN2E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b41eaedf910b665c2f702f9e95d7fadd6ab87a7a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b41eaedf910b665c2f702f9e95d7fadd6ab87a7a",
      "tree": {
        "sha": "4536fb99ace35101217abae55edd825ce2922b4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4536fb99ace35101217abae55edd825ce2922b4e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4536fb99ace35101217abae55edd825ce2922b4e\nparent daca51bf80e7168cefaf226262c5bcb3d9cc6148\nauthor TheCharlatan <seb.kung@gmail.com> 1716885172 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460139 +0200\n\nkernel: Introduce initial kernel C header API\n\nAs a first step, implement the equivalent of what was implemented in the\nnow deprecated libbitcoinconsensus header. Also add a test binary to\nexercise the header and library.\n\nUnlike the deprecated libbitcoinconsensus the kernel library can now use\nthe hardware-accelerated sha256 implementations thanks for its\nstatically-initialzed context. The functions kept around for\nbackwards-compatibility in the libbitcoinconsensus header are not ported\nover. As a new header, it should not be burdened by previous\nimplementations. Also add a new error code for handling invalid flag\ncombinations, which would otherwise cause a crash.\n\nThe macros used in the new C header were adapted from the libsecp256k1\nheader.\n\nTo make use of the C header from C++ code, a C++ header is also\nintroduced for wrapping the C header. This makes it safer and easier to\nuse from C++ code.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMiwACgkQm3m0VpHb\nQXNZ6w//XeYtGQKxOCDzToztWDkmwzNf8YTn/qcLELAZPJxyW7SMauPjynBSc/WB\nF4hBX2mStLt0xEHEboHqq9qV1dil7OHbd5xNhpLTu1ChV0Zi/Lij0dbITt44gRwT\n7RrlvBTT5kJI1+XbMOLkk3izppafuxO3cPQ6OlCRdMYn4sh6JPAYnPo2RIij5hBB\n01eWS7JpFoteUVD9ije7ItPIZkuKpPClQICZgBJHAip5vmhkCTZt4lWqy43mhN0b\nTSe7t1it4gfClyfPK3WlM65k3oAr3hFb/X3M+L3sx1B+d2P8uInUUEIg0TvDJ5s3\nrAJUSOw9Iwqi5GLWlEggk4en4tb9srpSBlIlO+dKbc86nIreLn1Z9AyVX6UeY6q6\njwhfPFs6tZas/46LtUXbRAXcT8qpi5XOnX1wjhvhcXU6VIxZgFBTTYY4yZv1/BQf\nj7lteaZvh21YHvukEEf/+epy9LNMX0LOQTTAKwITIxp2vFnZGqOTltdqeV2XzQRl\n8WptQiiSi5Db2ENJzmOC4YU9wF/bRd5Jf44KuFX2P9JXlv2OZqQsA4/Udq5jkqtN\nwY6HGgT3A4UhNAMZp+WGmpsmZWGpaUG294cDat7kCWxMmp4XEv6BcyRG6/vy35gr\nGVPrJ7INkx9C8Al8RJNHeMxdqOU1J5GUay0CmBYikkuq3O97+wU=\n=syUF\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/daca51bf80e7168cefaf226262c5bcb3d9cc6148",
          "sha": "daca51bf80e7168cefaf226262c5bcb3d9cc6148",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/daca51bf80e7168cefaf226262c5bcb3d9cc6148"
        }
      ],
      "message": "kernel: Introduce initial kernel C header API\n\nAs a first step, implement the equivalent of what was implemented in the\nnow deprecated libbitcoinconsensus header. Also add a test binary to\nexercise the header and library.\n\nUnlike the deprecated libbitcoinconsensus the kernel library can now use\nthe hardware-accelerated sha256 implementations thanks for its\nstatically-initialzed context. The functions kept around for\nbackwards-compatibility in the libbitcoinconsensus header are not ported\nover. As a new header, it should not be burdened by previous\nimplementations. Also add a new error code for handling invalid flag\ncombinations, which would otherwise cause a crash.\n\nThe macros used in the new C header were adapted from the libsecp256k1\nheader.\n\nTo make use of the C header from C++ code, a C++ header is also\nintroduced for wrapping the C header. This makes it safer and easier to\nuse from C++ code.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:48:59Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-28T08:32:52Z"
      },
      "sha": "b41eaedf910b665c2f702f9e95d7fadd6ab87a7a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZmNDk3OWIyMmRlNTVlZWI0YzFiMWZhZDhkMjQ3MDJmOTI5Y2Q3ODc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff4979b22de55eeb4c1b1fad8d24702f929cd787",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ff4979b22de55eeb4c1b1fad8d24702f929cd787",
      "tree": {
        "sha": "6a134c05dd9dc8987d0c73778935d2f79071af2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6a134c05dd9dc8987d0c73778935d2f79071af2f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 6a134c05dd9dc8987d0c73778935d2f79071af2f\nparent b41eaedf910b665c2f702f9e95d7fadd6ab87a7a\nauthor TheCharlatan <seb.kung@gmail.com> 1716992025 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460146 +0200\n\nkernel: Add logging to kernel library C header\n\nExposing logging in the kernel library allows users to follow what is\ngoing on when using it. Users of the C header can use\n`kernel_logging_connection_create(...)` to pass a callback function to\nBitcoin Core's internal logger. Additionally the level and severity can\nbe globally configured.\n\nBy default, the logger buffers messages until\n`kernel_loggin_connection_create(...)` is called. If the user does not\nwant any logging messages, it is recommended that\n`kernel_disable_logging()` is called, which permanently disables the\nlogging and any buffering of messages.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjIACgkQm3m0VpHb\nQXM/hhAAhZRCOk4jwAtnWNd8JXNZki17Y+eux3crY3wEqNFSjiZXfRiExugOUS6D\n7CduqydkbJ67Q1Qt9xxh1uoZSOJKNausUNV42N8HX3s6o4YzIeC5paHfn9oWL/xu\n7MCpU4TEkSL9iBmV86datSdroNsyUKNhAjVyXuGa+1Ee1+8FD6nBYQYKru0kT2GD\nC03By/BpT8Ts8N2gjBZRc8MIkToKCLfl7B/Wo9g8U0cOLHX/5QMCdcPyUv9OJGmp\n8gN4tkWC91FCOCGyhTowslf56wdO3eOKfTd7mkIWr+8KzrOFBDA27s2LOmZRTwfC\n0fNQRbuU4FfDw8PQjo8P6fK4UjWiO9NdS8CngulSGCh5Cm3q4Ec7Sl7ooLAHSXho\ngITP9LCATjj0GQt5wKcVbUndWOdFqFQyky8emnVy/1iUUSn9ieBJbetwlRfEbs0O\nGCFA2KZn7V6aUwvEe1aC83Dp2CeyeJHl2z2FFL4H2ePm4u97OB9afgaONDQRs8jh\neiEoE71CG+JgTBM0EoCfMVx7lhqRP7kF336+cmeLwUoKdjl//Ue6nRehekvAX3xV\n3IkUgBkoNeg+l+qvh/zGGEojhR2zL46pcFoGOimT6N2VORkwWKVSoxtkBOP97n0X\n3CgREkxJcBVByPyXfNW2zDq/sJDmy0Iz6Y35DuGvXxjNwJ3oqls=\n=GMql\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b41eaedf910b665c2f702f9e95d7fadd6ab87a7a",
          "sha": "b41eaedf910b665c2f702f9e95d7fadd6ab87a7a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b41eaedf910b665c2f702f9e95d7fadd6ab87a7a"
        }
      ],
      "message": "kernel: Add logging to kernel library C header\n\nExposing logging in the kernel library allows users to follow what is\ngoing on when using it. Users of the C header can use\n`kernel_logging_connection_create(...)` to pass a callback function to\nBitcoin Core's internal logger. Additionally the level and severity can\nbe globally configured.\n\nBy default, the logger buffers messages until\n`kernel_loggin_connection_create(...)` is called. If the user does not\nwant any logging messages, it is recommended that\n`kernel_disable_logging()` is called, which permanently disables the\nlogging and any buffering of messages.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:06Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-29T14:13:45Z"
      },
      "sha": "ff4979b22de55eeb4c1b1fad8d24702f929cd787"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM3NTI2NzIwNjBmYzA1ZjA3YWE5ZmY0ZDA3MjZmOTE4OWRlMDI5ZGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c752672060fc05f07aa9ff4d0726f9189de029de",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c752672060fc05f07aa9ff4d0726f9189de029de",
      "tree": {
        "sha": "9d541bcc28ad6ce28c1570b1475ae430fb4c3279",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9d541bcc28ad6ce28c1570b1475ae430fb4c3279"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9d541bcc28ad6ce28c1570b1475ae430fb4c3279\nparent ff4979b22de55eeb4c1b1fad8d24702f929cd787\nauthor TheCharlatan <seb.kung@gmail.com> 1717418147 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460148 +0200\n\nkernel: Add kernel library context object\n\nThe context introduced here holds the objects that will be required for\nrunning validation tasks, such as the chosen chain parameters, callbacks\nfor validation events, and an interrupt utility. These will be used in a\nfew commits, once the chainstate manager is introduced.\n\nThis commit also introduces conventions for defining option objects. A\ncommon pattern throughout the C header will be:\n```\noptions = object_option_create();\nobject = object_create(options);\n```\nThis allows for more consistent usage of a \"builder pattern\" for\nobjects where options can be configured independently from\ninstantiation.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjQACgkQm3m0VpHb\nQXOIxA/+LAbQlAE/DAUc7Av7LBZ+0iUBySAx8/srrl5oWoUTVBPUCW+Rw3koqOcg\nDuLi5qmGBdUKwi2r2OBj87VO80RGOReFgqSO2h5F9Jr6cDo6SL5VUy0gHC2QMTtt\nnLytryXVA1JTJWmZiiZ6Dg/0hwxi3+NL170JrycgfaOoW2IHopoeQTfkhi9v7FID\naAQhyyZZx6LY7uDbT3t/apHc59KdtYRms3QLKJ+sQ6JES4iOgo4unYYDxuQJiD7J\nSMyMup4aF15Vz6Ze1fujB81+QRNQNdt/YGUVn7oZVzlMIfNSSqvGNN/Hevn0egRd\ngsjrV91WjCzjHLeF34HwIym9Wnknba8McBUquct0JTG67xH2wrPt7u/nsMiy5dmD\n14wVsu+c4eK64KDYJNDa0E+bifaEdFE3ppcX919qXRKiXiCB9pxbrVo02TOM3NEQ\nNFn0OuZM5hHlP9nitS+XxBHfIhh5pLOgl5VVUiukWuQs0ZQWV6KzC6v8e//9fN7k\nE1fhZlg6NeTa+N3Ukt4tYBGMf8fSKR4Eo0EgHQ84cMAMfr8L1claMU2u2sDArqVy\nMrwZud+LA6FnV9nk1GhRS8vD5J2gxYqGCEoceElT86HA0Ynik5kASXbL+d+1l92D\nk3RlSLEPsYmkvOLmvQwCg2tokOuEszKGfhuHmP+HrHKu5Bs3YDk=\n=nfJh\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff4979b22de55eeb4c1b1fad8d24702f929cd787",
          "sha": "ff4979b22de55eeb4c1b1fad8d24702f929cd787",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ff4979b22de55eeb4c1b1fad8d24702f929cd787"
        }
      ],
      "message": "kernel: Add kernel library context object\n\nThe context introduced here holds the objects that will be required for\nrunning validation tasks, such as the chosen chain parameters, callbacks\nfor validation events, and an interrupt utility. These will be used in a\nfew commits, once the chainstate manager is introduced.\n\nThis commit also introduces conventions for defining option objects. A\ncommon pattern throughout the C header will be:\n```\noptions = object_option_create();\nobject = object_create(options);\n```\nThis allows for more consistent usage of a \"builder pattern\" for\nobjects where options can be configured independently from\ninstantiation.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:08Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-03T12:35:47Z"
      },
      "sha": "c752672060fc05f07aa9ff4d0726f9189de029de"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUyMWI1ZDkxOGMwMDExOTBjNGM5N2QzYTE4N2VjMzJjYTJkNzJmNjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/521b5d918c001190c4c97d3a187ec32ca2d72f68",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/521b5d918c001190c4c97d3a187ec32ca2d72f68",
      "tree": {
        "sha": "e9da9ae44eec5ac24da38a7ec048f27addfb5c29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e9da9ae44eec5ac24da38a7ec048f27addfb5c29"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e9da9ae44eec5ac24da38a7ec048f27addfb5c29\nparent c752672060fc05f07aa9ff4d0726f9189de029de\nauthor TheCharlatan <seb.kung@gmail.com> 1717418695 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460150 +0200\n\nkernel: Add chain params context option to C header\n\nAs a first option, add the chainparams. For now these can only be\ninstantiated with default values. In future they may be expanded to take\ntheir own options for regtest and signet configurations.\n\nThis commit also introduces a unique pattern for setting the option\nvalues when calling the `*_set(...)` function.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjYACgkQm3m0VpHb\nQXMABg//dxyaCZo/BQ71NFE0jCZeqldmi2J+XS6QBLXopZItOtH3gw+rxq4jhoBn\nfTNq+s9cRtDIFiwN93m2jktDc3j4y2P16f8v4853u/6SYCG/UbGJGYRS6zVF0zfY\njwBUCr7mNC226fupONoeI3M+weJrbZmSIV29b8CpC4z/ri/YLU+UycCvd+r5/fhp\nipwaggG1isa0N2P+k2iP7PZ3OmZIML+7F2Cko7ga6dwb3SWfbdn+MskXQ9B3gVcF\nwP30xHBfOWRFvL8VFUX/3vZ9tJzPkkpjw9Fz2vmHT+HqRDmgRZO0Fc1XV7zwc092\nivIt8lxLTEIAodCMIh9at0aDEbTcWgXbK3vYHoiPmllnRrc6WrUoJsE8Yhpe4kNZ\nn78TwLUpa7dPSyonSK6SZMaEj1B+Hxnl7W1dYntqxZsy4IB3STgMdoXEL0RaSVls\n0jG5bGhFSp40luxJq+7dSIkyGb2hEikdqopzObFnMMhoCIaeQb813F6vo6rij9Op\nk8N17zO9qe2G89HfuYWf40ICjbXa6vjV7LIuyHMSsskFTVfUaZRSgNDVRkUJrW++\nBmgJvnMM4ELD0UAnrzJFfSEGokl3aHdWEdexai3/Eh8RgT3UhPUP/MVp3HrAV7Hr\ngH7gtCHok2+YiKPPlc6L6K1nxCdC4twgtuzYgFBTJ6EbyV4fUUE=\n=+8Os\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c752672060fc05f07aa9ff4d0726f9189de029de",
          "sha": "c752672060fc05f07aa9ff4d0726f9189de029de",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c752672060fc05f07aa9ff4d0726f9189de029de"
        }
      ],
      "message": "kernel: Add chain params context option to C header\n\nAs a first option, add the chainparams. For now these can only be\ninstantiated with default values. In future they may be expanded to take\ntheir own options for regtest and signet configurations.\n\nThis commit also introduces a unique pattern for setting the option\nvalues when calling the `*_set(...)` function.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:10Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-03T12:44:55Z"
      },
      "sha": "521b5d918c001190c4c97d3a187ec32ca2d72f68"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdmYjM1NTA0YzMwYjkzOWY3ZmI1ODBmNzU4M2I1ZGU1YjQyNmM4ZmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7fb35504c30b939f7fb580f7583b5de5b426c8fc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7fb35504c30b939f7fb580f7583b5de5b426c8fc",
      "tree": {
        "sha": "e3658b7a22f08785e45e3787e09fa7c567854ea5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e3658b7a22f08785e45e3787e09fa7c567854ea5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e3658b7a22f08785e45e3787e09fa7c567854ea5\nparent 521b5d918c001190c4c97d3a187ec32ca2d72f68\nauthor TheCharlatan <seb.kung@gmail.com> 1717419089 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460151 +0200\n\nkernel: Add notifications context option to C header\n\nThe notifications are used for notifying on connected blocks and on\nwarning and fatal error conditions.\n\nThe user of the C header may define callbacks that gets passed to the\ninternal notification object in the\n`kernel_NotificationInterfaceCallbacks` struct. Each of the callbacks\ntake a `user_data` argument that gets populated from the `user_data`\nvalue in the struct. It can be used to recreate the structure containing\nthe callbacks on the user's side, or to give the callbacks additional\ncontextual information.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjcACgkQm3m0VpHb\nQXMdiQ//TGjyv/qRVyRdQ55CaNUHdvtQCikdK2PXxvAvZ3ZPzIoBivu48EbcDB2B\nP04+ZJ+yWfSjWywNWMNAw44bP2J3LtaJjcjIY9o84XEB57jRC5zeNx8aODoKNbba\nbPxNlXGpms0L7acpiO8AY/3dlIl+guHd18ibQC8G/gf4uN9t+aL/6P86rl52zexY\nw2jT+XS9YdFRg6kOGWgE0Uz46vK2o+JU+pmaMETWnps/8ujyb0TN/aiLzasZ1yxb\nBZCu8BVbe7HT+9bXytRvRM03X+V+aYcyNnAPBbdZyvu/JCGbXavn8ccw1S999t/9\nCExOYAMSEVbv9dwLMblmZlcaqZ3xMQiyZ2QG7RHKUVmivKlKT+Kfug2MbA3ml737\nqKSNugzSZrFtsB5W9XtIhSSFVbxKwxVcUJrOdftnBIUiRO2JLs3fz1nkt4tcSniX\njRjoJVfNfEd3Vup4203ILr1rs1my4iyvvxkaihM3rKjZlaFXh+uNFhDEBVn1Ajx/\nzzId7jV3vWMoztpnZZne2+fVqTkf4+YFlT3YLHjEBGCyXnn15lvX12dtrFPJK52I\n67NXkSj/VRwqw6OizVd+P1hordZUJ8wn4t+cnud6jjfiqUgsDLrzq41HZ/awazun\ni4eS9KnmAbK1uOE5Lu/8KWPPUDXQj2V1hZIJYzbDVdpx0mSEtb4=\n=aTJp\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/521b5d918c001190c4c97d3a187ec32ca2d72f68",
          "sha": "521b5d918c001190c4c97d3a187ec32ca2d72f68",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/521b5d918c001190c4c97d3a187ec32ca2d72f68"
        }
      ],
      "message": "kernel: Add notifications context option to C header\n\nThe notifications are used for notifying on connected blocks and on\nwarning and fatal error conditions.\n\nThe user of the C header may define callbacks that gets passed to the\ninternal notification object in the\n`kernel_NotificationInterfaceCallbacks` struct. Each of the callbacks\ntake a `user_data` argument that gets populated from the `user_data`\nvalue in the struct. It can be used to recreate the structure containing\nthe callbacks on the user's side, or to give the callbacks additional\ncontextual information.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:11Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-03T12:51:29Z"
      },
      "sha": "7fb35504c30b939f7fb580f7583b5de5b426c8fc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJkMDA2NDY5NThiZDNjN2FlNzYxMzgxY2UzZjExMTgxNTg4MDg0NzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd00646958bd3c7ae761381ce3f1118158808474",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bd00646958bd3c7ae761381ce3f1118158808474",
      "tree": {
        "sha": "dae150e5916765edacdbb20ee96503d0e482d2d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dae150e5916765edacdbb20ee96503d0e482d2d7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dae150e5916765edacdbb20ee96503d0e482d2d7\nparent 7fb35504c30b939f7fb580f7583b5de5b426c8fc\nauthor TheCharlatan <seb.kung@gmail.com> 1716922728 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460153 +0200\n\nkernel: Add chainstate manager object to C header\n\nThis is the main driver class for anything validation related, so expose\nit here.\n\nCreating the chainstate manager options will currently also trigger the\ncreation of their respectively configured directories.\n\nThe chainstate manager and block manager options are consolidated into a\nsingle object. The kernel might eventually introduce a separate block\nmanager object for the purposes of being a light-weight block store\nreader.\n\nThe chainstate manager will associate with the context with which it was\ncreated for the duration of its lifetime. It is only valid if that\ncontext remains in memory too.\n\nThe tests now also create dedicated temporary directories. This is\nsimilar to the behaviour in the existing unit test framework.\n\nCo-authored-by: stickies-v <stickies-v@protonmail.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjkACgkQm3m0VpHb\nQXPdMxAAzs3jdQeK/roZPRzplQv3lOgF2gDMX2TnTwwyO35c9DhFdWYD9mmO54jO\nsOcW/j3YpnSEw0PW7qiB8LsSOPW+t8wAQmt+PpU7Uf1P+E9NXR1AmB37UlhV2dHJ\nfdMbrLjknq+Uf0xN1f167xI6/d7+z1DsEfpvYkAg3C8NK/h+JgpPEGDRFGS25ANe\nfgVHVnFujGontkole8AJQ+xsOuEbufGeOd35D2WgwZk9W5kU7A7KcCH1Fb3EpavC\n7h/ftsFFtrpTT0W+hrE183KSXZdo3k1uVDUY1mYMrhLu//TveS69Eo1BVOIuAqDh\nMMMKyYiFzED1utZnl3YmTNZgPDER8ubJ4re2iWZL1YRBLzu76I5CRC/Tl3aFHy0/\nnDiDBO5OoYGNKQGBpLjyNugg3forBEcUrpIeXOCwsmJo/koVGRzawhn/UihYb8Be\nwGZeFg7wYwQL9D1572wD+eN75SyAuZ6id/lWTwPS4EGIz/jzF+zb5Tm6LP0xDpYJ\n0585KViySiEttvsFrARtG6Ddb8/6lN+1KdcR/rzBaZYoQ149/3WgPpVP93QCbIU2\nSSdt+nnoPz+B+5+jfZFZoHWiNZwbFq8olt99/ExNUTjOGHSinkJzopbsXHAHjETv\nxaQ4cPmGZQuwUwNXmfI4nUdDo+RfKyk7jaPUqum2sJZ5CZnChNY=\n=MGXw\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7fb35504c30b939f7fb580f7583b5de5b426c8fc",
          "sha": "7fb35504c30b939f7fb580f7583b5de5b426c8fc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7fb35504c30b939f7fb580f7583b5de5b426c8fc"
        }
      ],
      "message": "kernel: Add chainstate manager object to C header\n\nThis is the main driver class for anything validation related, so expose\nit here.\n\nCreating the chainstate manager options will currently also trigger the\ncreation of their respectively configured directories.\n\nThe chainstate manager and block manager options are consolidated into a\nsingle object. The kernel might eventually introduce a separate block\nmanager object for the purposes of being a light-weight block store\nreader.\n\nThe chainstate manager will associate with the context with which it was\ncreated for the duration of its lifetime. It is only valid if that\ncontext remains in memory too.\n\nThe tests now also create dedicated temporary directories. This is\nsimilar to the behaviour in the existing unit test framework.\n\nCo-authored-by: stickies-v <stickies-v@protonmail.com>",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:13Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-28T18:58:48Z"
      },
      "sha": "bd00646958bd3c7ae761381ce3f1118158808474"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk1NmE3NjM0MWRjYzlkNjRhNjhkZmY2NzQxNGVmYzdmY2E1YzI0NDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/956a76341dcc9d64a68dff67414efc7fca5c2440",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/956a76341dcc9d64a68dff67414efc7fca5c2440",
      "tree": {
        "sha": "9ee2effbba4db398bf431bd31def13671243de3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9ee2effbba4db398bf431bd31def13671243de3d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9ee2effbba4db398bf431bd31def13671243de3d\nparent bd00646958bd3c7ae761381ce3f1118158808474\nauthor TheCharlatan <seb.kung@gmail.com> 1731861408 +0100\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460154 +0200\n\nkernel: Add chainstate manager option for setting worker threads\n\nRe-use the same pattern used for the context options. This allows users\nto set the number of threads used in the validation thread pool.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjoACgkQm3m0VpHb\nQXNliQ/9ESXid5Z9zpEdBdAho4QOMj7rE6NsD6mxKYFRghltTYGTDGUtuIGTzbo7\nXiRXUB7FWvdEMNRNrqjZ0p6oovhT1PC9OfnznndKOurEIBbUvW7l+svH+FsPxWwo\nAN5M/zk95Ic1Qs5N+hsB9WyoAMXV5P4bAryq7Iqu3N8CrXAabL8K/lcHfXxmJ68x\nTm0vmz88bQDsrfRNV4foIIwjAu7mDsmjIdlzz+y6PLA0vgZrnQOFju0hqCcq6Bvg\nkI4mfh0y/Is5uP4Q98jwLfZ9Rqoe/pNHsp6p1ZmD4bd01IEfTPgitvm91uXYNyWp\nIqmtnkVbOApOEWcOhmvgwZkXc2o2ld+5VONJyZBKXcDUc4ktyDtyEj3lkr/0bK12\nXhPZ/3WjmDj+iU1juIXiB6k7vB0Un64yng4Vz4I2O0H+EzwUpKZP1Q5vS785ov1v\nbX6516tJD7poAHgMaUO1xL67OKcNqQOUBee5t47YmP1fOudnRDmtCtCwaQUz7hFB\nyrKFlRzpSutdz3ciBy8m9vDVUsVGdisgLunnuTK2i5mUY4bDiCOx12eATN7xPS7j\nGfAe3OvHEF1PGCwg5CCx0SkY+/KVL5BK7NVoIvid/hvSAUjJT9Q7fgo3OTISLl7E\ncM8diOSfcmokc8Q/rHvxEMerWFnqgyMsQNOt5fEHwQGTu/wYUhk=\n=yQha\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd00646958bd3c7ae761381ce3f1118158808474",
          "sha": "bd00646958bd3c7ae761381ce3f1118158808474",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bd00646958bd3c7ae761381ce3f1118158808474"
        }
      ],
      "message": "kernel: Add chainstate manager option for setting worker threads\n\nRe-use the same pattern used for the context options. This allows users\nto set the number of threads used in the validation thread pool.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:14Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-11-17T16:36:48Z"
      },
      "sha": "956a76341dcc9d64a68dff67414efc7fca5c2440"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYyZTY1MTQ5ZDViNTdhM2I1MTgzNTQyY2E5OTE4ODQ1MmE2NmYyZTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f2e65149d5b57a3b5183542ca99188452a66f2e8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f2e65149d5b57a3b5183542ca99188452a66f2e8",
      "tree": {
        "sha": "180e2ac55fca4e803b87490587c1a9fdb0589f51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/180e2ac55fca4e803b87490587c1a9fdb0589f51"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 180e2ac55fca4e803b87490587c1a9fdb0589f51\nparent 956a76341dcc9d64a68dff67414efc7fca5c2440\nauthor TheCharlatan <seb.kung@gmail.com> 1716982085 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460155 +0200\n\nkernel: Add chainstate loading when instantiating a ChainstateManager\n\nThe library will now internally load the chainstate when a new\nChainstateManager is instantiated.\n\nOptions for controlling details of loading the chainstate will be added\nover the next few commits.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiMjsACgkQm3m0VpHb\nQXNddQ/9Fq19uWqE8yGOxoAgYYwImNBd8TtYoi5P8bpYhbXGl/nIoTcQj1RtjZPD\n3D32UsQRo013HMoXzDv3KXfkgpZOggIDfD22dmWd7imoSI3c0ngLNAgDY5fK6Qqn\nuV59FMR6aQqw7vZlTj3qJ7+/niXttFSANUKxqa1oBHoW7djaAt/4lQJRQyZW/c6I\ngibRGRgUVX0mZ+hxKpf2oSkrFebxRrwVZMooa7OtpY0pFYYwAUXmMtA1gMCsUKTa\ngLECcT1/MeH0cA+YjCFOydVMF3AJRwBQ+Egh9ADYOdtSDMYRyPiOS5hexlyzQrVG\nkkUjEKViHfD0R8cFzqJZMeHhDkKE61TdsVjoRzkQLFWy2ba186C90NWLk8GoF1KU\nU6Vv1JKVp6pPoP7A2aS3bg/rowFIixK+7dR/uxB1SLo6BfE6b64hRjF+ULIFpfnx\nR7IlIRlrjWUvYChsayRxdOHid3qqZTSsI7Yy92dR/VmJYwfYn7VoCk0dcP2gpGM0\n0VoFjZwqq0mkfs2G0RB5l0pz0uC1Ur3W7tOj9S28ySTmdpNCVzDZkWC/6wlipCfH\nTpmJ7PbCIqN8VICHDaQitGlDlT6RndHVUf7p3mLh6zJJO66iTVw7pQRclwUH0kFG\n9PTb7OBq31jv89kYQQ07ykzneUqGsEKqYgjovf5yQ/Jg1TX0fmI=\n=87ZN\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/956a76341dcc9d64a68dff67414efc7fca5c2440",
          "sha": "956a76341dcc9d64a68dff67414efc7fca5c2440",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/956a76341dcc9d64a68dff67414efc7fca5c2440"
        }
      ],
      "message": "kernel: Add chainstate loading when instantiating a ChainstateManager\n\nThe library will now internally load the chainstate when a new\nChainstateManager is instantiated.\n\nOptions for controlling details of loading the chainstate will be added\nover the next few commits.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T19:49:15Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-29T11:28:05Z"
      },
      "sha": "f2e65149d5b57a3b5183542ca99188452a66f2e8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUyZGUzM2UxNzhhOGM3MmJlMmQ4Y2FmMDVlOTNhMDU3YTU1ZTNhNTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52de33e178a8c72be2d8caf05e93a057a55e3a54",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/52de33e178a8c72be2d8caf05e93a057a55e3a54",
      "tree": {
        "sha": "e4b03e1b4c4ff341f1812fd031b2d5f9f53168a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e4b03e1b4c4ff341f1812fd031b2d5f9f53168a9"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e4b03e1b4c4ff341f1812fd031b2d5f9f53168a9\nparent f2e65149d5b57a3b5183542ca99188452a66f2e8\nauthor TheCharlatan <seb.kung@gmail.com> 1718657423 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460824 +0200\n\nkernel: Add block validation to C header\n\nThe added function allows the user process and validate a given block\nwith the chainstate manager. The *_process_block(...) function does some\npreliminary checks on the block before passing it to\n`ProcessNewBlock(...)`. These are similar to the checks in the\n`submitblock()` rpc.\n\nRicher processing of the block validation result will be made available\nin the following commits through the validation interface.\n\nThe commits also adds a utility for deserializing a `CBlock`\n(`kernel_block_create()`) that may then be passed to the library for\nprocessing.\n\nThe tests exercise the function for both mainnet and regtest. The\ncommit also adds the data of 206 regtest blocks (some blocks also\ncontain transactions).\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNNkACgkQm3m0VpHb\nQXNrHBAAshOnnOh5yd3mxOWpjLnuCCN3pUmkAA8tw5ms8Om4rpvnzAm342kUM7+r\nNYYvnvWOOJuUi3mXEGSMnSvWQTKxzSsrCvMrnTUp8AapqbUD9OqvpvejLT/37jXT\nwbGYGRYU1rR8noMwM8Jhq3ZiyAQifsLpa2Q5QTUdWlDZtTgE3DhFircu2+WDmaEY\n4DBpvnkZWiQiquH62wWuupIjn0OZKJVRRcjuQzjaQR/oLHbmsAnvkEuNHYroWiGq\n+3ueN6yXezHBpuDFCx+zFbaweawB37K+ilH89/EZuiIRarRpDZhI8UXa3WqSSKfL\nyGIvEjYiyOid3a57B8x5p87TteguMJuu9hjKJWvn6FZcABqz+1IixtLw1BiVH/MP\nboNTScAAZM1UBCSTs+hms+m/dZPN/KSZ4UCx1mPA/AMwOSAL6KsBYWTyWRiZMvpj\np4SPAHQ5ZEkaeqKLGOf8TzHOlzMKrycfbOfLbFEkCZsJliGIEpA4siZ3So2I6F/l\nzE/TOH+q66umGEJ98uME1mP0GSJh5V1J8C8IDQvPrE8+EsgE6j4Dk1dFSIoT+CN1\nP87D76amsYBhgAbf7crua5BayFg7HfJSi+zGmCVzTybL+LgCVCPSl/XZ22yAs3ZN\nENp23Sl6oCZ1Yfnhn8FpeKjCWK4683MlMU8wJzf5YqE0a5oo6Ko=\n=YIkR\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f2e65149d5b57a3b5183542ca99188452a66f2e8",
          "sha": "f2e65149d5b57a3b5183542ca99188452a66f2e8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f2e65149d5b57a3b5183542ca99188452a66f2e8"
        }
      ],
      "message": "kernel: Add block validation to C header\n\nThe added function allows the user process and validate a given block\nwith the chainstate manager. The *_process_block(...) function does some\npreliminary checks on the block before passing it to\n`ProcessNewBlock(...)`. These are similar to the checks in the\n`submitblock()` rpc.\n\nRicher processing of the block validation result will be made available\nin the following commits through the validation interface.\n\nThe commits also adds a utility for deserializing a `CBlock`\n(`kernel_block_create()`) that may then be passed to the library for\nprocessing.\n\nThe tests exercise the function for both mainnet and regtest. The\ncommit also adds the data of 206 regtest blocks (some blocks also\ncontain transactions).",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:24Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-17T20:50:23Z"
      },
      "sha": "52de33e178a8c72be2d8caf05e93a057a55e3a54"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI2ZmVlZWQ1MmEyNzViZWJlMDlmMDMzYzRiOGYzNzdlYmY3ODlkMDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26feeed52a275bebe09f033c4b8f377ebf789d02",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/26feeed52a275bebe09f033c4b8f377ebf789d02",
      "tree": {
        "sha": "29105e59ba088f3c1ecb924f1885c0f3bcc968f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/29105e59ba088f3c1ecb924f1885c0f3bcc968f0"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 29105e59ba088f3c1ecb924f1885c0f3bcc968f0\nparent 52de33e178a8c72be2d8caf05e93a057a55e3a54\nauthor TheCharlatan <seb.kung@gmail.com> 1718657447 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460830 +0200\n\nkernel: Add options for reindexing in C header\n\nAdds options for wiping the chainstate and block tree indexes to the\nchainstate load options. In combination and once the\n`*_import_blocks(...)` function is added in a later commit, this\ntriggers a reindex. For now, it just wipes the existing data.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNN4ACgkQm3m0VpHb\nQXOGHg/+Mr/i/pvSB9DYwfNbNORH5v5ckw0EyEZxg9BlKJVk6Ge+j1NNFeK2JKTw\nK0BVFQpj9DCAZBT5mhYM5+kENrpDOwk++jwqHHv2T3v366+T0+peXOEHQYQh0HAw\nkwUMHoCyxbnbHGzh7nNhXV9yv0957TCYJev3OnjHsAYeRdlLb32CLCHUGeQZa3Vn\nc7vV+cJfsAMb7H2RDEbiDWv4HUD+QamHn8/tahHOgyrV5MGlsGNKH6EV3Wtdafm/\nY4a7Mv1iI2VFxPqn1z/+F+Ye52XC/xyx8GxzmsDSETbqp2WACDZz0xxmSFJ7Z9xK\nmCrf96RMNHe1LFzvDGlnYySzAEwAF4ARZECtP3GwYcD+x2+h+g/7xqm7dT3nMPpt\nkAAZlS0cDNXC9g3KvDhYHFC0EgA/c+YTeuDrEUe1JMTpRuYHRH6JvFKi0JSMnOQ1\n+v6nQRNr3sH774XaYWEun1aRtFneggkYthrEls0+ZozsxnkZ8Yk9mA10uiwFVE4u\n+VZ7s+uKOxknetQOptQpFe5ohJ76SPVUMDLILY0Tu4fvhQHhlc58Rn09WDbfi7VY\n94T5mjk3UNFKljElWL7LlQrqoQ1+j1wrWjNDpw8TEtmNBzYgLyAZ1l+/l8HEvWpe\nhpLmegOIKuy7goyqeL2qTjFgwMlMP2cQVxWiAnEPRKamVidQDCQ=\n=yret\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52de33e178a8c72be2d8caf05e93a057a55e3a54",
          "sha": "52de33e178a8c72be2d8caf05e93a057a55e3a54",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/52de33e178a8c72be2d8caf05e93a057a55e3a54"
        }
      ],
      "message": "kernel: Add options for reindexing in C header\n\nAdds options for wiping the chainstate and block tree indexes to the\nchainstate load options. In combination and once the\n`*_import_blocks(...)` function is added in a later commit, this\ntriggers a reindex. For now, it just wipes the existing data.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:30Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-17T20:50:47Z"
      },
      "sha": "26feeed52a275bebe09f033c4b8f377ebf789d02"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNjNjI2ZWZmMWY0NGY0M2ZhYTlkYTgzOGQ2YzlhN2Y3MTQwZDFjM2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c626eff1f44f43faa9da838d6c9a7f7140d1c3e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3c626eff1f44f43faa9da838d6c9a7f7140d1c3e",
      "tree": {
        "sha": "1abddf17ea8406686099bada44c1792550fc2d96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1abddf17ea8406686099bada44c1792550fc2d96"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1abddf17ea8406686099bada44c1792550fc2d96\nparent 26feeed52a275bebe09f033c4b8f377ebf789d02\nauthor TheCharlatan <seb.kung@gmail.com> 1719083290 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460833 +0200\n\nkernel: Add chainstate load options for in-memory dbs in C header\n\nThis allows a user to run the kernel without creating on-disk files for\nthe block tree and chainstate indexes. This is potentially useful in\nscenarios where the user needs to do some ephemeral validation\noperations.\n\nOne specific use case is when linearizing the blocks on disk. The block\nfiles store blocks out of order, so a program may utilize the library\nand its header to read the blocks with one chainstate manager, and then\nwrite them back in order, and without orphans, with another chainstate\nmaanger. To save disk resources and if the indexes are not required once\ndone, it may be beneficial to keep the indexes in memory for the\nchainstate manager that writes the blocks back again.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOEACgkQm3m0VpHb\nQXMG6g/8DYhR8neOvxiZchESaXZWEPKvo5hraleUbUIngmotC+Rw3pIefAylyucu\njneZDW7VO9VEMZfZjqQbsvnIJ6zp/r56yZi/ftWBZQXObgnn7Aawh1mkCytVtiJA\nBh3c9NBm9pdV0HOnhbvkAAnbIbifSI2F/1TvBAPFwfNOp2aO332LC50OxWMKVLND\nizwM2kuDZLvJyStORnb1ZKGV1O5tpW0fi205kpu9WeoYOedKL+Vs1dZlq6RZJ/FG\njZOgBg9+sQWQ7+UYulFRnLsOlOA5RcI3ju3VbTPRFY2hnlpC4PxLyDTAWP+ULFvS\n/TMIssmsME2K5gwi+DXrlKQ3d5BTRIF46usUXPFlYwAfJ6hE8g6Gh1FoX+ML7HX0\n8W+RPL/dIwQ4I6vaeg3RgLnRy9jtikG/h3Up2M94iGFyFTlAaEG5FUzBOrBUKFRc\nHUwOtmMDSsfKffiCg1QuR5RKDxfFx8tdsL2Rh7IntV4jCsklS/ChNuhTIO0GI4/R\nGzTuKFvoHUVwDtjGFkaCm00R0UN2CKtM/1GRINlc5/UcTTnWMCFIRf2VfhmLsCff\nCQ2zYex4VU35KxIB3c+gOs4EsG0rnC44QL2zoDZHGnNpIGfzuywW0ISwjWP/00L5\nN7zPSNGt/GmpIj9P0bwXhXor44T3OWGi4fx5qlNikgGPSGB3WbE=\n=3jlQ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26feeed52a275bebe09f033c4b8f377ebf789d02",
          "sha": "26feeed52a275bebe09f033c4b8f377ebf789d02",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/26feeed52a275bebe09f033c4b8f377ebf789d02"
        }
      ],
      "message": "kernel: Add chainstate load options for in-memory dbs in C header\n\nThis allows a user to run the kernel without creating on-disk files for\nthe block tree and chainstate indexes. This is potentially useful in\nscenarios where the user needs to do some ephemeral validation\noperations.\n\nOne specific use case is when linearizing the blocks on disk. The block\nfiles store blocks out of order, so a program may utilize the library\nand its header to read the blocks with one chainstate manager, and then\nwrite them back in order, and without orphans, with another chainstate\nmaanger. To save disk resources and if the indexes are not required once\ndone, it may be beneficial to keep the indexes in memory for the\nchainstate manager that writes the blocks back again.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:33Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-22T19:08:10Z"
      },
      "sha": "3c626eff1f44f43faa9da838d6c9a7f7140d1c3e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBhOTU2OWQ4NzdjMmQ1YTY4M2M3OGQ0ZTU2ODRiYjhjYzMyNTdmMDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a9569d877c2d5a683c78d4e5684bb8cc3257f02",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0a9569d877c2d5a683c78d4e5684bb8cc3257f02",
      "tree": {
        "sha": "c9700dfb70203d5a1bd9fbdf30e9d600878e1703",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c9700dfb70203d5a1bd9fbdf30e9d600878e1703"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree c9700dfb70203d5a1bd9fbdf30e9d600878e1703\nparent 3c626eff1f44f43faa9da838d6c9a7f7140d1c3e\nauthor TheCharlatan <seb.kung@gmail.com> 1717060948 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460834 +0200\n\nkernel: Add import blocks function to C header\n\nThe `kernel_import_blocks` function is used to both trigger a reindex,\nif the indexes were previously wiped through the chainstate load\noptions, or import the block data of a single block file.\n\nThe behaviour of the import can be verified through the test logs.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOIACgkQm3m0VpHb\nQXNDtQ//fkoLaLtstSxn0MH/u9zyzUzW9phmniMoi6zfCab/NciZZUlZvAEz/X8g\nBZzpUaOWKozq4vCiK4nCnHcmv2ZCdb+EHeCh+MMvynNDwbFgYa0EGio7OagANQBu\nOY7wy9bZXUttA8a3jxvVyA+RZIPrgF6aD2IXDhWxis93QjpfNirQsriRuYnCBr3p\ntMFXRuM5QKbsBHRx4OB9fArLRiA3RPD9ZtQ5ZjR2nXaf8pl5aaN9+Orc1hvwJ8dO\n8jsHUpQXH35ZZX+xh96HszvZ0CFUUZXjc3SoGRZTa8UpYqw+MGJ1GgjUo13MwmRw\nGcj0Wgy03xtcAVpZuya2T3F62H98JRC4bEe8Xqx8MvkvtW72Phm8R7TD1LtF2UrA\nLp01OXKTmzM6zhaerumTUYGl4+A3zv/SJJiRWg8xkzhciOkuHwf8h72+NV0+gm6P\nwtSy5UZU1L0yZ5Yu/Z1ZZdRvOV9Yb273PLdXsd3ZiAlECqT7ueqBEwH/KTka3pqZ\n5KaO4CM1vph2RLT80p80tTIl5835rLl1OX4hkFNYFaUTbI7np73OmpXteIlVIX1b\nL9FOcfOsow7Zz/T50Hf+FZs5lnOmnOOc0ohcHS5WvSHZ9PPxtbreqhB8t8MCdJvo\nXevWeDtwbqvwoZerf98h941/Bnu2rYWEbKaXy5uyoYenGrDojvg=\n=HuFK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c626eff1f44f43faa9da838d6c9a7f7140d1c3e",
          "sha": "3c626eff1f44f43faa9da838d6c9a7f7140d1c3e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3c626eff1f44f43faa9da838d6c9a7f7140d1c3e"
        }
      ],
      "message": "kernel: Add import blocks function to C header\n\nThe `kernel_import_blocks` function is used to both trigger a reindex,\nif the indexes were previously wiped through the chainstate load\noptions, or import the block data of a single block file.\n\nThe behaviour of the import can be verified through the test logs.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:34Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-30T09:22:28Z"
      },
      "sha": "0a9569d877c2d5a683c78d4e5684bb8cc3257f02"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY3ZDFkMTNjZGRhZTQ3YWU2OTkwM2NjMzI1MzVmMzgxYmM0NTY1YWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f7d1d13cddae47ae69903cc32535f381bc4565ad",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f7d1d13cddae47ae69903cc32535f381bc4565ad",
      "tree": {
        "sha": "ec3e31aa9b19ff9fa6e5ba7986d99e923ec849be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ec3e31aa9b19ff9fa6e5ba7986d99e923ec849be"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ec3e31aa9b19ff9fa6e5ba7986d99e923ec849be\nparent 0a9569d877c2d5a683c78d4e5684bb8cc3257f02\nauthor TheCharlatan <seb.kung@gmail.com> 1717575640 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460835 +0200\n\nkernel: Add interrupt function to C header\n\nCalling interrupt can halt long-running functions associated with\nobjects that were created through the passed-in context.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOMACgkQm3m0VpHb\nQXMA1hAAnT7tVJ8U0P710RjGGjNsEaZpjAqP8vy2tWO7/bWg+PI/DSeGU71ka24v\nZilbfew6MUuO329sdVkCJrQ2aBpy0VczG0TUlkhf+pVzPMx3+IRZZMRiTs70ltyI\nkdWbmJuNzrfL1r3cs+WoHcQjM23JsnAXARGY1fN/fdOCue8cokWmSIC0H3LJZHcc\npxzzQkn0BK4yjdyN/fijGBf83evbLZp6LQjhYYt3UAzbFP+HvZWLihV0umKz5ELB\n4zaxMJGGcjlY3B3TpLdk2B49ttnhQaxeI3YSBLJtkqUAz8pGptBq9nPzyvJGPEBW\nLq7l9aBiJw6u2FLhyjdJZARbrokzaHxdi0vw9Ge5c91GAAkHtJA6Czjj/2G/yy21\nM+a5aa31poPMJbHg+LOsu5BiSLULG1B0y9WeYlh3+Tb61IZeP9KNXRCEGoZbSdLF\nY1CRfb2SgZtpMk9sutBMt+XDJDHSUrLB3smkEqDRKDIi4y4um7IT1LbS20X+mZx/\n+Jo23kRXGRRX6D6PcbCQjbsr6R8E57Ydq6xxM/nyBQFQUUAtMW79bkAPpbczXNqX\nMvR0oIvth93zY7nGRcG3Hj8tdufmsuF+utGNkXDZoaEEBkVIZ+Xu39fittgLL0wo\nFNjpfzEizdrR/PBBMD4L2QTYtMNaA1Qler/XrgOPFV32ARbni6M=\n=jVva\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0a9569d877c2d5a683c78d4e5684bb8cc3257f02",
          "sha": "0a9569d877c2d5a683c78d4e5684bb8cc3257f02",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0a9569d877c2d5a683c78d4e5684bb8cc3257f02"
        }
      ],
      "message": "kernel: Add interrupt function to C header\n\nCalling interrupt can halt long-running functions associated with\nobjects that were created through the passed-in context.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:35Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-05T08:20:40Z"
      },
      "sha": "f7d1d13cddae47ae69903cc32535f381bc4565ad"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQyMjJmMDk0YWQzZDBlNjk4MGQ1ODk1OWNjMDkyODI0YzRmNjFkNDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4222f094ad3d0e6980d58959cc092824c4f61d44",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4222f094ad3d0e6980d58959cc092824c4f61d44",
      "tree": {
        "sha": "d98e82e41d3ebe3fb23fdc00d6053de7f0ee3776",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d98e82e41d3ebe3fb23fdc00d6053de7f0ee3776"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d98e82e41d3ebe3fb23fdc00d6053de7f0ee3776\nparent f7d1d13cddae47ae69903cc32535f381bc4565ad\nauthor TheCharlatan <seb.kung@gmail.com> 1717102788 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460837 +0200\n\nkernel: Add validation interface to C header\n\nThis adds the infrastructure required to process validation events. For\nnow the external validation interface only has support for the\n`BlockChecked` callback, but support for the other internal validation\ninterface methods can be added in the future.\n\nThe validation interface follows an architecture for defining its\ncallbacks and ownership that is similar to the notifications.\n\nThe task runner is created internally with a context, which itself\ninternally creates a unique ValidationSignals object. When the user\ncreates a new chainstate manager the validation signals are internally\npassed to the chainstate manager through the context.\n\nThe callbacks block any further validation execution when they are\ncalled. It is up to the user to either multiplex them, or use them\notherwise in a multithreaded mechanism to make processing the validation\nevents non-blocking.\n\nA validation interface can register for validation events with a\ncontext. Internally the passed in validation interface is registerd with\nthe validation signals of a context.\n\nThe BlockChecked callback introduces a seperate type for a non-owned\nblock. Since a library-internal object owns this data, the user needs to\nbe explicitly prevented from deleting it. In a later commit a utility\nwill be added to copy its data.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOUACgkQm3m0VpHb\nQXOz3A/9F7LsyLqNnx1wKKgbrzGBKrYf4rOeUfEGOLigArJ+zIgbNk2+UOyRADMi\nerJ8mrBs17jS2zlTIA+BLj1oFtC/9vqPiUy5PAndtLgp4LHOfYeLOGxDVOouU/Um\ny6NbyZl/G+ARqPcjlorHm8Tt379JZkn70Cbo7A0I9HbDcY65z2cL4crE9LCkQjAz\nkopqV+PApJ0yho3C0v8P86uZaJ51fEehFyZdO4fEAaA7SiomOMcdjZtodrt/eJCE\nh5OmEnYbIfL49TDVuGIB4iEZlLdenkPZDzdqqnStu7wLpElXJW5Y1Iz4Faai8k5S\nHOQleAmoFOTnI8nPSQpGNRn6+CYUdcFza3fo+SLgivIs2RtlHCqufARQBHqOy0Ox\nyAQhh2U9Fsbn5ONm4Ttt9JJdtKmEh/+bsu2/fUFnq+vFsj0B5aCTNfhgCaHcm1qV\nQKSSHbpeKZrNaBt/u5t9PGeKlMXceJoiYcEgh4XSpt8RLYMnFOrYd5z11ft+xGRT\n9f36Z3A1TEsqEnnYzPO/3+bt5wH/qpXkzkZ3pzlDCP2U3jMyU8yyEWIRofB/Z96B\ntUM/iVpHtOOGrgrAf7kUzunQ945v/u5Wq5lkkg4Q7lh6cp35HUK+xjEZ/vSgFBEt\nkYIPARh+VGkP7zD1czY8CVjj6/EXwTOHHEN484CQY5aEF5sHbsk=\n=O4db\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f7d1d13cddae47ae69903cc32535f381bc4565ad",
          "sha": "f7d1d13cddae47ae69903cc32535f381bc4565ad",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f7d1d13cddae47ae69903cc32535f381bc4565ad"
        }
      ],
      "message": "kernel: Add validation interface to C header\n\nThis adds the infrastructure required to process validation events. For\nnow the external validation interface only has support for the\n`BlockChecked` callback, but support for the other internal validation\ninterface methods can be added in the future.\n\nThe validation interface follows an architecture for defining its\ncallbacks and ownership that is similar to the notifications.\n\nThe task runner is created internally with a context, which itself\ninternally creates a unique ValidationSignals object. When the user\ncreates a new chainstate manager the validation signals are internally\npassed to the chainstate manager through the context.\n\nThe callbacks block any further validation execution when they are\ncalled. It is up to the user to either multiplex them, or use them\notherwise in a multithreaded mechanism to make processing the validation\nevents non-blocking.\n\nA validation interface can register for validation events with a\ncontext. Internally the passed in validation interface is registerd with\nthe validation signals of a context.\n\nThe BlockChecked callback introduces a seperate type for a non-owned\nblock. Since a library-internal object owns this data, the user needs to\nbe explicitly prevented from deleting it. In a later commit a utility\nwill be added to copy its data.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:37Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-30T20:59:48Z"
      },
      "sha": "4222f094ad3d0e6980d58959cc092824c4f61d44"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNhZWYxYTk5YjgyZmI2NmE2OGJhOGEwMTZjZTNlMGRkYjdjMjk3MDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/caef1a99b82fb66a68ba8a016ce3e0ddb7c29705",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/caef1a99b82fb66a68ba8a016ce3e0ddb7c29705",
      "tree": {
        "sha": "c066e21b5ca9c6c65856ba8a297170642da6b2f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c066e21b5ca9c6c65856ba8a297170642da6b2f4"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree c066e21b5ca9c6c65856ba8a297170642da6b2f4\nparent 4222f094ad3d0e6980d58959cc092824c4f61d44\nauthor TheCharlatan <seb.kung@gmail.com> 1717155240 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460838 +0200\n\nkernel: Add functions for the block validation state to C header\n\nThese allow for the interpretation of the data in a `BlockChecked`\nvalidation interface callback. This is useful to get richer information\nin case a block failed to validate.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOYACgkQm3m0VpHb\nQXP49hAApBw4c1bMyW/0GYCA82P46AS4p02k/OmArjvsrAMsiWa+XPQLvG3dkjXG\nl1Uj0w36um4Z4sDQbdnpZ/gcX6qwK5JW13Q6FCUuCTJEqaC+PRod1IQpClNeq30U\nIX9FjkIqw0IGrz7q88JEGu1JgtkSScA50952qdmcYx4ji1+NmDskISQTbH3eNohM\ngacguvKvjOsiH+Wy/CEGP50QI/LrZZXNu4Xjye3BHoP982zxfI/SaXSSdBaqKUYn\nyMLYcSyFiD4jeoLlFCDFogqwVOusnznN1PkL742Z8cnt0bksgQAtAjEd/BylOHKl\nr8ZchD6c+okZleBHzFEAbt0RCVAl/MF0+crGHCSrdQQEGA5zNF7QEfa6fn8Ft4iS\nedA9gTi7Tmwt1ed/19SyUNOTqipveH0ZhCwn581TZo5+VgD8si/wjvuSK9sS8YeZ\nF5A0GlG7USu7/BjB/iFY/QWWag112nYT5cMYYHpR8AYfZdx6BQNHp5OFOUdO9h76\nUnVOIK/7ap6MZ4V59UXIyB7Trh2kXeHViLa1TPeOeQjEmsA0l9x9LKaENXzqgVUD\nPPok7rtBE8XlguMoxlt4sLNGbF1iz4NqgOOAEJ3wnbCG11dpIjZUQZK7seOA+/FO\n/crnd6Kmw/Poh1HveVEZeB+X8p3q4Riaxkh2QHbKP7oIivYS9mc=\n=ZcrX\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4222f094ad3d0e6980d58959cc092824c4f61d44",
          "sha": "4222f094ad3d0e6980d58959cc092824c4f61d44",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4222f094ad3d0e6980d58959cc092824c4f61d44"
        }
      ],
      "message": "kernel: Add functions for the block validation state to C header\n\nThese allow for the interpretation of the data in a `BlockChecked`\nvalidation interface callback. This is useful to get richer information\nin case a block failed to validate.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:38Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-05-31T11:34:00Z"
      },
      "sha": "caef1a99b82fb66a68ba8a016ce3e0ddb7c29705"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU3YTQwZjljYjBiYTk3N2FiNjBlODQzZDhmOWZjNDVlNzM2YzA2Yjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57a40f9cb0ba977ab60e843d8f9fc45e736c06b8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/57a40f9cb0ba977ab60e843d8f9fc45e736c06b8",
      "tree": {
        "sha": "2150336db02f7f1a38e716f3dead99344347f9e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2150336db02f7f1a38e716f3dead99344347f9e7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2150336db02f7f1a38e716f3dead99344347f9e7\nparent caef1a99b82fb66a68ba8a016ce3e0ddb7c29705\nauthor TheCharlatan <seb.kung@gmail.com> 1717235572 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460839 +0200\n\nkernel: Add function for copying block data to C header\n\nThis adds functions for copying serialized block data into a user-owned\nvariable-sized byte array.\n\nUse it in the tests for verifying the implementation of the validation\ninterface's `BlockChecked` method.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOcACgkQm3m0VpHb\nQXPFeg//RZsHgggvUgfHDHBUET1E3wIIwdvP5STHDkKs1KzKg0CqiFnKrFGFHP7t\nDipW3aDl6srH1h4kxbPn95li9qwouNeGDwE9Nc/zaH/CAmL+XreFg1DVGGlwDqbg\nQuf9vmPF0XhUsO5RFrrJWfrf8+TU/5Jrspi7/84zwhAfxd06c//Y/xjXZbJo4ndy\nQRfidjmFU3ydVBy8owMFk2gcFPIdonZMQxUCAO/t7y/hzJOT2K8GH2+OmpPv8TOj\n3jAWOCaeWx6uO0tOAeBL8KIukLf3C9rOZ4pJkJR195/bt2A0Cx4aFwAF4wp1NHLG\nvNMMtjiIEbdgdf0lsQNcGVy3bxqaNz3a1wpJOCfZfKk0Zr/IGLIW6LhzRVrci2GV\nK8tEXT+Eiw76eghUxesGcyMrCzUBLLL08vl+tmM8PlfoLJ3IiBIeVpQQ0z1hTz7i\n91wl30D06sag+D2drYq67VWteDDDgOa0tl0j38Emo4w6Kh6q3aJO/w3V0g5zR8Xc\nbLpypn2EfGxQ2XanqHypKqTHlIQ5NV4S26JLoU23u10SAgvgUG3zINt9KiOdS7iI\nyyRC5B+vRATrdRuzuPeZcrwWm6RHRIfTfrVe6pnQMfajX9Xf8sXaCiRkx7wNmLUI\n2SDfl2ieInIe5RZBPyA3Z/a3l+7se5u3uxlul1wg84bf4neAZF8=\n=bmTd\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/caef1a99b82fb66a68ba8a016ce3e0ddb7c29705",
          "sha": "caef1a99b82fb66a68ba8a016ce3e0ddb7c29705",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/caef1a99b82fb66a68ba8a016ce3e0ddb7c29705"
        }
      ],
      "message": "kernel: Add function for copying block data to C header\n\nThis adds functions for copying serialized block data into a user-owned\nvariable-sized byte array.\n\nUse it in the tests for verifying the implementation of the validation\ninterface's `BlockChecked` method.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:39Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-01T09:52:52Z"
      },
      "sha": "57a40f9cb0ba977ab60e843d8f9fc45e736c06b8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY5YTA4NzRkMDU1NmFhM2FjZmFlMzgyMTEwYWVlN2Y1NzhhMWQ3YzA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9a0874d0556aa3acfae382110aee7f578a1d7c0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f9a0874d0556aa3acfae382110aee7f578a1d7c0",
      "tree": {
        "sha": "fea17ddcf35fc94c2e926df6c488bdeccacc4126",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fea17ddcf35fc94c2e926df6c488bdeccacc4126"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fea17ddcf35fc94c2e926df6c488bdeccacc4126\nparent 57a40f9cb0ba977ab60e843d8f9fc45e736c06b8\nauthor TheCharlatan <seb.kung@gmail.com> 1717239811 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755460841 +0200\n\nkernel: Add functions to read block from disk to C header\n\nThis adds functions for reading a block from disk with a retrieved block\ntree entry. External services that wish to build their own index, or\nanalyze blocks can use this to retrieve block data.\n\nThe block tree can now be traversed from the tip backwards. This is\nguaranteed to work, since the chainstate maintains an internal block\ntree index in memory and every block (besides the genesis) has an\nancestor.\n\nThe user can use this function to iterate through all blocks in the\nchain (starting from the tip). The tip is retrieved from a separate\n`Chain` object, which allows distinguishing whether entries are\ncurrently in the best chain. Once the block tree entry for the genesis\nblock is reached a nullptr is returned if the user attempts to get the\nprevious entry.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiNOkACgkQm3m0VpHb\nQXOY8xAAvEGwfcdiwMfw+kzkXZYqtSOfzAAQi8T4wNXgTf1aLsYZDq5WRToMWOM4\n2WO8eWGe2MXqGNym5Iw+o56jFXXg+3wDIl7KhOdubnd3JaFustAT1OasGLlKdkc5\nODJCKCoqJJuHRpctoYgEtnzMRInEFLU8Lkhz5lejmR7IWX8NSZPr+Xg++cSLMwRg\nf3J3Kecp8uozkSTjBxr2EoXUmWHetxx+RjXoswzy50bYbLZEuz4rQG+zyIz1gnbV\nZUleHkSw9vr3czq6nauj2eORm3rBnEnDwUk2BkMvRWSc91HcMVz30vZsVjTQ0iz7\njiz20DcVVQbviB7i2BMVlgF5mS0mbR5V2vCBnLcfDmSBVowWNPOQsY82ccta+9PR\nJuCbIz7ZLbjEnmVlXOtHY0WD8BodSqTIUUq7rGQYf6DsJjsJO9NEGAr2Rs3EUt6H\nJKUxYHtvljzAdts4kgN7zR/IreTClm/86Y/PRts5pBAWnNoxlaPEqmsNRSmXeM+n\nr3NlY7kbY56exu15/th6lQvgNpkSF7SlCyl3kMk036pOI31tv0n67G3/1ysqou4V\n3lQwfeAdbd1jsBTidDi44glkg0pQ7RbrH+Na0Mx81AXS2FXpn+4PCZjum5al2C6M\n4uQpFOY3lRIYthhfnVKuiBAw16NCLX2AskLCLppoFlWMtEGaf7k=\n=nDnE\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57a40f9cb0ba977ab60e843d8f9fc45e736c06b8",
          "sha": "57a40f9cb0ba977ab60e843d8f9fc45e736c06b8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/57a40f9cb0ba977ab60e843d8f9fc45e736c06b8"
        }
      ],
      "message": "kernel: Add functions to read block from disk to C header\n\nThis adds functions for reading a block from disk with a retrieved block\ntree entry. External services that wish to build their own index, or\nanalyze blocks can use this to retrieve block data.\n\nThe block tree can now be traversed from the tip backwards. This is\nguaranteed to work, since the chainstate maintains an internal block\ntree index in memory and every block (besides the genesis) has an\nancestor.\n\nThe user can use this function to iterate through all blocks in the\nchain (starting from the tip). The tip is retrieved from a separate\n`Chain` object, which allows distinguishing whether entries are\ncurrently in the best chain. Once the block tree entry for the genesis\nblock is reached a nullptr is returned if the user attempts to get the\nprevious entry.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:00:41Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-01T11:03:31Z"
      },
      "sha": "f9a0874d0556aa3acfae382110aee7f578a1d7c0"
    },
    {
      "event": "commented",
      "id": 3194634175,
      "node_id": "IC_kwDOABII586-aj-_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3194634175",
      "actor": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-17T20:31:32Z",
      "updated_at": "2025-08-17T20:31:32Z",
      "author_association": "NONE",
      "body": "I noticed that `btck_script_pubkey_to_bytes()` and `btck_block_to_bytes()` have similar names but perform different operations.\r\n\r\n- `btck_script_pubkey_to_bytes()` extracts raw script data and is infallible\r\n- `btck_block_to_bytes()` performs bitcoin consensus encoding with witness data and is fallible\r\n\r\nI wonder if we could rename to:\r\n\r\n```\r\n// Keep as-is (raw data extraction)\r\nbtck_script_pubkey_to_bytes()\r\n\r\n// Option 1 (as used in rust-bitcoin)\r\nbtck_block_consensus_encode()\r\n\r\n// Option 2 (general)\r\nbtck_block_serialize()\r\n```\r\nThe same applies to `transaction` and `block_pointer`.\r\n\r\nCurious to hear your thoughts.",
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3194634175",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkxMDc5MzFlYWMxODEyNThjZWZlM2Y3OWM4ZGVhZTliNzM1YTA2MjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9107931eac181258cefe3f79c8deae9b735a0621",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9107931eac181258cefe3f79c8deae9b735a0621",
      "tree": {
        "sha": "655804832c7aee29cb1c8b79cff83b5bcdbb0e12",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/655804832c7aee29cb1c8b79cff83b5bcdbb0e12"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 655804832c7aee29cb1c8b79cff83b5bcdbb0e12\nparent f9a0874d0556aa3acfae382110aee7f578a1d7c0\nauthor TheCharlatan <seb.kung@gmail.com> 1717246076 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462708 +0200\n\nkernel: Add function to read block undo data from disk to C header\n\nThis adds functions for reading the undo data from disk with a retrieved\nblock tree entry. The undo data of a block contains all the spent\nscript pubkeys of all the transactions in a block. For ease of\nunderstanding the undo data is renamed to spent outputs with seperate\ndata structures exposed for a block's and a transaction's spent outputs.\n\nIn normal operations undo data is used during re-orgs. This data might\nalso be useful for building external indexes, or to scan for silent\npayment transactions.\n\nInternally the block undo data contains a vector of transaction undo\ndata which contains a vector of the coins consumed. The coins are all\nint the order of the transaction inputs of the consuming transactions.\nEach coin can be used to retrieve a transaction output and in turn a\nscript pubkey and amount.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPDQACgkQm3m0VpHb\nQXP9+BAAx3kSv3jkasL8CnfWYDKmOsCRxpwruRPOSWOrCz4Aihr9HnG8frjqddEt\n91c3EDNvSX7CD8blXaAC+sE5TN1vTXZIWSc9SaRZwPjNy/68Wf/rgfmVMAtvNklC\nmnmuCtwKetFZP29eH+mH747DxQCEZmgpRSomGvSceWpeEDt/fTNDXzbEz/bHaC85\nMwYL3v2uVm92m+N4sco1QjdcNh8vckvy+aeKnNV7GzcRlcNSr9jXn+gPegV07TL4\nFKsrYGdYSHsZOPlMGs4dY0SF6jufD1Yi5w1yPLUu5EuT2milH7wYYHIAdwX8zqET\nPWvXMa9dkK8V5afD7I1eWo2bCO15VIszbqgdKdsvLn3F0rMMKLp+9tm37XP+rEaE\nYLQEFGSa6ZEQA988pXC70I8elRH9hRrO/bOr1mgVUbhndmklOzlA8kgB8o2fErk5\nDed0JIZhoG4Tf+IcdJNubiemwd3URtAFHe/OM3Fk50nx3KLQLlj6qjcOZAVSD1KT\nOK4w6RlpZDBlyD1YjXVHrD82rBQU8vthn/zLoyHL+FjXPeuzFI0AVmGJgq3/EVoP\nw0NKitaji7GQQTRbRnOH8y24q5bkz9eRThopJgNQjnHDkD1vDOpdteN0dMzFvLwR\nILUIV2++z193zQTBeF9AyE1U+5WL1N2w4u7jC3ZxgCQINfxUAeI=\n=E5M1\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9a0874d0556aa3acfae382110aee7f578a1d7c0",
          "sha": "f9a0874d0556aa3acfae382110aee7f578a1d7c0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f9a0874d0556aa3acfae382110aee7f578a1d7c0"
        }
      ],
      "message": "kernel: Add function to read block undo data from disk to C header\n\nThis adds functions for reading the undo data from disk with a retrieved\nblock tree entry. The undo data of a block contains all the spent\nscript pubkeys of all the transactions in a block. For ease of\nunderstanding the undo data is renamed to spent outputs with seperate\ndata structures exposed for a block's and a transaction's spent outputs.\n\nIn normal operations undo data is used during re-orgs. This data might\nalso be useful for building external indexes, or to scan for silent\npayment transactions.\n\nInternally the block undo data contains a vector of transaction undo\ndata which contains a vector of the coins consumed. The coins are all\nint the order of the transaction inputs of the consuming transactions.\nEach coin can be used to retrieve a transaction output and in turn a\nscript pubkey and amount.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:31:48Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-01T12:47:56Z"
      },
      "sha": "9107931eac181258cefe3f79c8deae9b735a0621"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUzZDFmNGQ0MWUyMDdiMmViMWRiN2JhZmE3OTFmMTI4MjQ0NDFhMTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/53d1f4d41e207b2eb1db7bafa791f12824441a15",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/53d1f4d41e207b2eb1db7bafa791f12824441a15",
      "tree": {
        "sha": "093279a49c0d9c81a0f1c0ea2351f6295eeb9f8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/093279a49c0d9c81a0f1c0ea2351f6295eeb9f8c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 093279a49c0d9c81a0f1c0ea2351f6295eeb9f8c\nparent 9107931eac181258cefe3f79c8deae9b735a0621\nauthor TheCharlatan <seb.kung@gmail.com> 1717617940 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462752 +0200\n\nkernel: Add block index utility functions to C header\n\nAdds further functions useful for traversing the block index and\nretrieving block information.\n\nThis includes getting the block height and hash.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPGAACgkQm3m0VpHb\nQXMwkQ/8D33pSR7mw+byowHK0CmaU2tGhZVa0d93oLPsIT2p+jbJm2jWwyPc3xU1\n4NCX63YN5x77I5Er45/WhAeEqwjJ4ZGZ7tduuasT3InaD552Lv0PNvBH99Lf2To5\nKjrOigibB+d+E5eM/mcgNLZhqqsyGbg13tLFpTYcNNqUqWSrherbDcTLbE5eNKvj\nedkzZZYqyLpSI6xUK0LMPMyS72BAIFDpTMA9I0KL7uiWrREwDTjuRme8zAGCBulH\n179OMZimi6X06wxavvW/SriuXEkHwtlq0iPyozsO1sPWkbmdNm0AIpdOCo3ozU+T\n6yKnS8V5sE1sKQ9frw0w+Ka4v58Jq+0PTn2dFGFw+Kez0BTOIsBoZaA5m5LY018a\noR/UWfJT8/yC7GeaIzBQdNoUlrSglpbdGuSxiSBGniUxQ4Lguk6JWWRXRaeu92Cz\nfHnEoIVSBbsgjJURjLBUTBMQhZHNQgn3/zx/GcmioS9Z/ZUagZhuvtEdS7ACEaOt\nzWxaTOk7pnOQz5m+7Z114GLJifXLAIC1hDHDVYcbslWN8TQJ1v8ROVEA8WTRAe63\nQIFDZASjq6j2mKWRih8QH8S/ZXhT2Odt2boQWmkX0cLYXdlXDAGS3cUhovmbJ1c6\nm9XO9D8KLbz2nCyT/6uqQmtD8Khi0mVFK68jGZe6sBSePTdKVl4=\n=C7ZE\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9107931eac181258cefe3f79c8deae9b735a0621",
          "sha": "9107931eac181258cefe3f79c8deae9b735a0621",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9107931eac181258cefe3f79c8deae9b735a0621"
        }
      ],
      "message": "kernel: Add block index utility functions to C header\n\nAdds further functions useful for traversing the block index and\nretrieving block information.\n\nThis includes getting the block height and hash.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:32:32Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-05T20:05:40Z"
      },
      "sha": "53d1f4d41e207b2eb1db7bafa791f12824441a15"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNmZDYwY2NlMjBkMjI4NGNiMDZjMjgzM2E0OTlmYjJhMjY1OTg5MGE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cfd60cce20d2284cb06c2833a499fb2a2659890a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cfd60cce20d2284cb06c2833a499fb2a2659890a",
      "tree": {
        "sha": "7f4122759e3cf96b37ab8264aabb327df2b8d462",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f4122759e3cf96b37ab8264aabb327df2b8d462"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7f4122759e3cf96b37ab8264aabb327df2b8d462\nparent 53d1f4d41e207b2eb1db7bafa791f12824441a15\nauthor TheCharlatan <seb.kung@gmail.com> 1731852715 +0100\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462754 +0200\n\nkernel: Add functions to get the block hash from a block\n\nThis is useful for a host block processing feature where having an\nidentifier for the block is needed. Without this, external users need to\nserialize the block and calculate the hash externally, which is less\nefficient.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPGIACgkQm3m0VpHb\nQXPGIhAAwNuBMD844BzgaPE33RXO41AMjtvSovDtDL5PHsDf5x5Pi7Pf6cHZ9F5n\nQecLGQmR3tKlA7QnyEXVyDoPjHavTzeFLgArw1lodpAg+elPsvAHkslxFNeH1V4+\nOZNGpDmEZOs9Q2Rt22wOiLoPeMmxPL1HF1LWteBek86fCLXKOmPCnlphglExjUT5\nwOU3jec6NVR3H+4DiicYQZ1KbigbRxS7bWFLbpl1pKaaafuEpswccXoKz0qxznpK\nOpi4L+qXIlm+UtnBiMR+umybZecRngjQ3loXWpPrHe+1kAHqAjG0m2rl85JtmiUD\nnTaFHHZEPfojdltUn+aylfrhrpJDg8U2GxrjyFHNIcyWiKXBJoP5wYpvalZ7qeWj\nNCisBxueshAosgptNgDrEfVcoqd2LvnRhpOi4dNU4UEsz36vK6/fPCzHwK1xjvMP\nVxOLYAD0I0zFezqRmj6QqatO+esm4YQCLaH98YgnDvzZtJgkX+badV/ZrN03G+E5\nTiKoZBJq0Yq7zzvtAmibzY6qLmp1Xf7vVJP3SoG6YEHGAvs3wC+eLh1kLr/XjXIa\ne3XIaLzhQR0JPPJDTE9u+UYugbJjSp4J+tPhgpC3S5R+cG3O3ck6esiqr9mc9Mlc\nkevfUWSqfTaRI09tVov4Z3X9/QOAiU8EmkEU6lazSJSo6jjaMTg=\n=XjZi\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/53d1f4d41e207b2eb1db7bafa791f12824441a15",
          "sha": "53d1f4d41e207b2eb1db7bafa791f12824441a15",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/53d1f4d41e207b2eb1db7bafa791f12824441a15"
        }
      ],
      "message": "kernel: Add functions to get the block hash from a block\n\nThis is useful for a host block processing feature where having an\nidentifier for the block is needed. Without this, external users need to\nserialize the block and calculate the hash externally, which is less\nefficient.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:32:34Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-11-17T14:11:55Z"
      },
      "sha": "cfd60cce20d2284cb06c2833a499fb2a2659890a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhkOWEwZDA4NGU2NTM4OWRkOGY2NmVjZjNjMDBhYjE4NjRhOGQzOGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e",
      "tree": {
        "sha": "e8ee1d57a40673b1f52fbe8174b8edd48017d893",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8ee1d57a40673b1f52fbe8174b8edd48017d893"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e8ee1d57a40673b1f52fbe8174b8edd48017d893\nparent cfd60cce20d2284cb06c2833a499fb2a2659890a\nauthor TheCharlatan <seb.kung@gmail.com> 1718382788 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462757 +0200\n\nkernel: Add pure kernel bitcoin-chainstate\n\nThis showcases a re-implementation of bitcoin-chainstate only using the\nkernel C++ API header.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPGUACgkQm3m0VpHb\nQXPdvhAAz/qqr6AwdfhrcHxilyVo/Q9+pen2JBNYgEuP6/79V6EZEWb/twuI4LA6\np/tGGZ7EOk4pKQEQXQZ3okcr4/bRr9hI55Lq0Tc4Phy1efR2S6h75pl1uVwRY3BF\nVjYmbanqWIHaK4mHRehtubxaSDCTzUmvBCfJQgQM7uE2pPD1omPv8qrEV9MP11Vy\nKSjLHgr/++EWOfbhhzoV+iMbTtxe/8uXiFEFBiF0OHtorjQ6LN6I/3JHuE4W/En0\n6riMrw1Tix8RmOdckeDPjBZyRBEOwp0xrHBJyyKV3HgJezkbhFMFlQaOXGwicHHp\nWRCaY+I7HnnsXhCwBwvxST/5jtLIxBJEy5poOLHZvrgxhQemuH+ccOGhz1m8+G0Y\nA+WdkW5HflRZv5q6dyWU7NigVrRkoUfC40qNzhsp2HSEL/i2uhJmcijKWPGrpXXM\nLAnTR7gBv3dMIX8KWZegKBFLp1FFFI/j1mOhE1uxDPWHUD4Ov7tin6CUeVgTFHlS\n6ac/egKm86uo5TaMq3g6+yGrdd8KDaunmRutNcDJEtOnJjUJep3MMY1ooKeB6bLX\nKIDOdMP7aWS1h/HMxLvoB4Vx1iR7Y1g0Lpje30Slvt0jHes/MZ+tfedlbLBlFNll\ncqflcrNXjjLdRYPkZGXw4zj4rxY3BBe4dHgaJ3veUI6zXJiPMcs=\n=OVuY\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cfd60cce20d2284cb06c2833a499fb2a2659890a",
          "sha": "cfd60cce20d2284cb06c2833a499fb2a2659890a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cfd60cce20d2284cb06c2833a499fb2a2659890a"
        }
      ],
      "message": "kernel: Add pure kernel bitcoin-chainstate\n\nThis showcases a re-implementation of bitcoin-chainstate only using the\nkernel C++ API header.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:32:37Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2024-06-14T16:33:08Z"
      },
      "sha": "8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3Yjk1ZTg4MmQyNTVkZmI3YTlkNDY2MmJiZjQ1YzI0ZjAwMDEzNDY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97b95e882d255dfb7a9d4662bbf45c24f0001346",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/97b95e882d255dfb7a9d4662bbf45c24f0001346",
      "tree": {
        "sha": "46f43922b2db140563d36211aa0e03bdcb2c5b28",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/46f43922b2db140563d36211aa0e03bdcb2c5b28"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 46f43922b2db140563d36211aa0e03bdcb2c5b28\nparent 8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e\nauthor TheCharlatan <seb.kung@gmail.com> 1753712804 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462758 +0200\n\nkernel: Allowing reducing exports\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPGYACgkQm3m0VpHb\nQXNuWw/8DTdCy5eMFc4Vfk4gmYLBT3aCn6b8m5KrNeeSyc3DuCCamc75+j0OoYnb\njsr6cJwjSgcmhz+uc5xrFPRTTaCbr7+oln5zxNNaTByLCw/cgGtVCf98vw1UHekl\n8EO2RC//YqXZESEdIMstCi1zSO8Q6phAEIrAQDBIbt+mrI8FqUxSYqIj0KIrj66P\n1EVAfJemyr7x1Jjm7P2SHAfCGUd2vHMFUKeVkEWU4kNlrs3pasX0rVQp1GMlQH6b\nPcfhSf6/AnUMvyZcVKHwOKLsEOhrO0HckYAOSe8vKfnS2XK9j0+XmZ98RKGt2q8I\n7GuyeZyVjHCslJ1bBKd46FjQawDnkwaFUzq/+cdCeNrnk8UJAvmzhCaGMubDDGl7\n6Ys67vmDaZ53EnHtJ6GzJmYWKtcr7F21aOq+HTbI5WMFKVyZLc+rGREl1A5vw2lu\nHHrLHHtrJQdxiRICZ/yMjyRdxdjfAcLPy1CHXfE79teSJFORNGH/GPZWYQSNMlbT\n8VFAmPibD4QfyQ8LFozu1LlBfIO5TqV085bqoIuTVyjS7kXoWETBi9bvIawWj0t6\nSKYIJzX4ImTjgA5vEqMsoj2s+nrqLR4Qv3m2CtDaTGKBRKpqXYq+iS8ShECUm5lq\nQgS00cfyPB8R7TYmSMjC4n5hszpiWgwN+Z+Q6QRt1IZwZLioalg=\n=IaM4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e",
          "sha": "8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8d9a0d084e65389dd8f66ecf3c00ab1864a8d38e"
        }
      ],
      "message": "kernel: Allowing reducing exports",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:32:38Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-07-28T14:26:44Z"
      },
      "sha": "97b95e882d255dfb7a9d4662bbf45c24f0001346"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDExZWUzNjg4OTczMzQ0YmRjNDI2YmQ3NDUzOTk3ODk5NGYwZGVhOGE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11ee3688973344bdc426bd74539978994f0dea8a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/11ee3688973344bdc426bd74539978994f0dea8a",
      "tree": {
        "sha": "7beb83b95ee529bf96a99417bc39172d09205357",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7beb83b95ee529bf96a99417bc39172d09205357"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7beb83b95ee529bf96a99417bc39172d09205357\nparent 97b95e882d255dfb7a9d4662bbf45c24f0001346\nauthor TheCharlatan <seb.kung@gmail.com> 1742987368 +0100\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462759 +0200\n\nkernel: Add Purpose section to header documentation\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPGcACgkQm3m0VpHb\nQXP17A/9F5ZHCtmgew2py98/SegaksePGkKNOKHw+hhXax6r/lU/zF/UmOV8j3Y6\nXCVCARg8KsczLM8q9SKYMl/GkTV0yz4PIzzrtd4n9nT0sUggPx07ai79SIDUw4u6\n95Qbrto52nCc3BhrdEuOEfu7+gfX8Qgez3lap8Q5vJZ3rVS7H1EqhmKYVAmoLDQd\nDscs6HrAck6kEJyGgmfiA71l+Z0i0CQaOxc2NZ+yHVkiwMb0zC+pcH/0bgsg58nv\nAiTb8WiNnK7tFLLQ/zk4y1xTQIyWprkyspCZ439TdBejkdSIYyxHU/ZaQzio3ZDp\neyWmX7dBESL5B02JUhpXm3H9xKoADAqDPyJbJ6EddWWwwaqKwfWFchrVeKRrXFNv\nUXXdChKrG6hY5KYppt7xX6BPJS6zXMsNbnUgtI0yf3YqOFkbOupga790sIPBHhkq\nsPxFafUy9PHmHpCv7NaT/FETxTOdeOxtxLvYAD+qB3ySmdbzzYsH8ymIRvM4QeR9\nMRwwcgY3Qc+57ftQnJWl7CQq3KmR0p+LsgY6GTpfCp0EOUOvMjEqmwA7Y1IXA/Cp\nAfNybmFWhst4tWUxebRJYA9Dm3HD2QwXls45mVlYQWlYGRS9XCZEET9EvJakr5ug\nqpZWRCWLoFf6N5BlVp3X4UQ/60kWi074EGT7DJZFrjY08f2AhoI=\n=QgXG\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97b95e882d255dfb7a9d4662bbf45c24f0001346",
          "sha": "97b95e882d255dfb7a9d4662bbf45c24f0001346",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/97b95e882d255dfb7a9d4662bbf45c24f0001346"
        }
      ],
      "message": "kernel: Add Purpose section to header documentation",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:32:39Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-03-26T11:09:28Z"
      },
      "sha": "11ee3688973344bdc426bd74539978994f0dea8a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdiY2IxMjJlNmU1NTMzOWYyNTIzOGE0NDQzM2NjNWFhZGM0NTI2ZjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "tree": {
        "sha": "9c20b0843322ad88921d16349db2187288f2afaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c20b0843322ad88921d16349db2187288f2afaa"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9c20b0843322ad88921d16349db2187288f2afaa\nparent 11ee3688973344bdc426bd74539978994f0dea8a\nauthor TheCharlatan <seb.kung@gmail.com> 1744123897 +0200\ncommitter TheCharlatan <seb.kung@gmail.com> 1755462760 +0200\n\nkernel: Fix bitcoin-chainstate for windows\n\nAnd turn it on in the CI.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE8s/Eq9C5nYN+67fQm3m0VpHbQXMFAmiiPGgACgkQm3m0VpHb\nQXMDKQ/8DOB3SR5YdIVkGQOCmZhyJZwMS825/qj/8S3lhtnAHtA3OxvWBgc+RxRM\nWzyHPVSzLXx8VfeaiLqn/asyagJ5dl+Grz5emzY9t9O54DuEeVEu/c+cA5IGuSpU\n6kk6rnK9dOVYbDwmwUc9D4KKrHiBeJpryEPM8VYZpP3V39JAY9OtWwc8ifK4BFDh\nk2uSzRx7wnxorxciixQMiT+jTPIfURQ9Y74ecaqAVMmc5HTjrOyKIXnTGXVk5G00\n5fSuDEnq9Voo3sLJ1M/kP1yHOnnR6rChITTWXQpfssRInXgSGxecITykGeIL46Vk\njJgnH7sLwHzW5YZgDEuvoKf2aor4YNL85W+9YPDLh/XX//YjqNbvckQjq9PZIE7x\nf5dCM0TzkkFhLGN88o8LzK2rNCXYbAUzJKP7cR0rsJu+N+Cii0mv4kfyncg0cplg\nw8vPUawklwiW3yYw3PHeIGyUuUyFGxYhT+eyAZ0CAxQPvzKvhzsEvbmyAEB6gmaP\ngUXLMiVF5Ei2vQ/MYVtSxC5vebJLJrHxjHTrZWnxc2oZ07KaFegHNbvS9B8S2f2O\ndOt+xgvqo4JGTQZ+dRwBV3p8hjr42vnDR/FiL2V+jhRW1M5IYp9hL4vyc2kDCV3r\nSpZ/SILu+A3S6rH0FURAXyT8nTCmD9yJEtoJotXIQUutGG+wV8c=\n=t3k5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/11ee3688973344bdc426bd74539978994f0dea8a",
          "sha": "11ee3688973344bdc426bd74539978994f0dea8a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/11ee3688973344bdc426bd74539978994f0dea8a"
        }
      ],
      "message": "kernel: Fix bitcoin-chainstate for windows\n\nAnd turn it on in the CI.",
      "committer": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-08-17T20:32:40Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-04-08T14:51:37Z"
      },
      "sha": "7bcb122e6e55339f25238a44433cc5aadc4526f1"
    },
    {
      "event": "commented",
      "id": 3194639884,
      "node_id": "IC_kwDOABII586-alYM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3194639884",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-17T20:43:09Z",
      "updated_at": "2025-08-17T20:43:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3194634175\r\n\r\n> Curious to hear your thoughts.\r\n\r\nYeah, I noticed this too. I was considering adding consensus encoding for the script pubkey too, but that is unusual for a good reason: It adds a varint length prefix. Depending on the external tooling interfacing with this, that might be a bit annoying to deal with. Since you are looking at rust-bitcoin, afaict they also don't offer \"consensus encoding\" for their `ScriptBuf`, which is the equivalent type to our `ScriptPubkey`. Marking things that are serialized with \"consensus\" encoding seems sensible though. I'll keep as is for now though, since it was also requested that we have a common naming scheme for all our serialization functions, but will elicit feedback from other reviewers.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3194639884",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19192740107,
      "node_id": "HRFPE_lADOABII586SDdapzwAAAAR3-fkL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19192740107",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "commit_url": "https://api.github.com/repos/TheCharlatan/bitcoin/commits/7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "created_at": "2025-08-17T21:24:29Z"
    },
    {
      "event": "commented",
      "id": 3194661011,
      "node_id": "IC_kwDOABII586-aqiT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3194661011",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-17T21:24:35Z",
      "updated_at": "2025-08-17T21:24:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "Updated 7bcb122e6e55339f25238a44433cc5aadc4526f1 -> 7bcb122e6e55339f25238a44433cc5aadc4526f1 ([kernelApi_57](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_57) -> [kernelApi_58](https://github.com/TheCharlatan/bitcoin/tree/kernelApi_58), [compare](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_57..kernelApi_58))\r\n\r\n* Use `size_t` for communicating container sizes and indices.\r\n* Replace bounds check in `btck_chain_get_by_height` with assertion.\r\n* Add Iterator and Range types to allow iteration through the wrapper types, as well as using `std::ranges` and `std:views`.",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-3194661011",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30595"
    },
    {
      "event": "reviewed",
      "id": 3128316327,
      "node_id": "PRR_kwDOABII5866dlGn",
      "url": null,
      "actor": null,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-18T13:12:09Z",
      "author_association": "NONE",
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-3128316327",
      "submitted_at": "2025-08-18T13:12:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1754989437",
      "pull_request_review_id": 2297633388,
      "id": 1754989437,
      "node_id": "PRRC_kwDOABII585omwN9",
      "diff_hunk": "@@ -0,0 +1,141 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ */\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_TX_SIZE_MISMATCH, //!< The provided tx_to_len argument does not match the actual size of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_TX_DESERIALIZE, //!< The provided tx could not be de-serialized.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * A helper struct for a single transaction output.\n+ */\n+typedef struct {\n+    int64_t value;\n+    const unsigned char* script_pubkey;\n+    size_t script_pubkey_len;\n+} kernel_TransactionOutput;\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 108,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "63a83b8dad279beaa2f9f6ac2677c56c300300fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit / meta discussion: even though it'll make things more verbose, I think it might be worth referring to flags with their full name to make it easier for users to find them? I.e. \"If the witness flag is set\" would become \"if kernel_SCRIPT_FLAGS_VERIFY_WITNESS is set in `flags`\".\r\n\r\n",
      "created_at": "2024-09-11T15:36:58Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1754989437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1754989437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757015877",
      "pull_request_review_id": 2297633388,
      "id": 1757015877,
      "node_id": "PRRC_kwDOABII585oue9F",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 34,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I like that we're using this guard. Do you see a downside to making it variadic?\r\n\r\n(Should be a pretty trivial rebase with e.g. `for i in {1..3}; do sed -i -E \"s/BITCOINKERNEL_ARG_NONNULL\\(([^)]+)\\) BITCOINKERNEL_ARG_NONNULL\\(([0-9]+)\\)/BITCOINKERNEL_ARG_NONNULL(\\1, \\2)/\" ./src/kernel/bitcoinkernel.h; done`)",
      "created_at": "2024-09-12T14:43:52Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1757015877",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757015877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757049107",
      "pull_request_review_id": 2297633388,
      "id": 1757049107,
      "node_id": "PRRC_kwDOABII585ounET",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 53,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there any benefit to documenting the built-in static constant kernel context in the header documentation? If I understand correctly, that's an implementation detail and not relevant to the user? If so, I think we should\r\n- only talk about the non-static context in `bitcoinkernel.h`, so that its meaning is unambiguous to the user\r\n- consistently refer to the static context as \"static context\" wherever it is documented, as to not make me question everything whenever I come across an unqualified context reference\r\n\r\nIf there is merit to documenting the static context in the header, I think it should be more of a footnote than the very first item in the documentation?",
      "created_at": "2024-09-12T14:59:08Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1757049107",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757049107"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 46,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757065221",
      "pull_request_review_id": 2297633388,
      "id": 1757065221,
      "node_id": "PRRC_kwDOABII585ourAF",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 44,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is there benefit to this stand-alone Context documentation, since we already have (and could expand on/merge with) the `kernel_Context` documentation? I think perhaps a more useful alternative would be to start the documentation with a minimal example on how to use the kernel (or a non-code \"getting started\" guide), which would inevitably include/reference the `kernel_Context`, providing users a good starting point on which documentation to read first?",
      "created_at": "2024-09-12T15:04:45Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1757065221",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757065221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757105125",
      "pull_request_review_id": 2297633388,
      "id": 1757105125,
      "node_id": "PRRC_kwDOABII585ou0vl",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 77,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I find this phrasing a bit confusing. Is this a correct replacement?\r\n\r\n```suggestion\r\n * A function that takes pointer arguments makes no assumptions on their lifetime. Once the function\r\n * returns the user can safely de-allocate the memory owned by those pointers.\r\n```",
      "created_at": "2024-09-12T15:25:15Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1757105125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757105125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 76,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757108471",
      "pull_request_review_id": 2297633388,
      "id": 1757108471,
      "node_id": "PRRC_kwDOABII585ou1j3",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 80,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1) What's \"it\"?\r\n\r\n2) I think adopting and sticking to a clear definition of MUST, MAY, SHOULD, ... would be appropriate here? E.g. in this case, I think they \"MUST\" not be de-allocated by the user, rather than \"SHOULD\"?",
      "created_at": "2024-09-12T15:27:07Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1757108471",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1757108471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848821020",
      "pull_request_review_id": 2297633388,
      "id": 1848821020,
      "node_id": "PRRC_kwDOABII585uMsUc",
      "diff_hunk": "@@ -0,0 +1,1186 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. Their content and\n+ * scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    kernel_BlockManagerOptions* block_manager_options,\n+    const kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 746,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What's the point of the `context` parameter - it seems unused, and inconsistent with the other `_destroy` functions?",
      "created_at": "2024-11-19T18:01:27Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1848821020",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848821020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 752,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848822043",
      "pull_request_review_id": 2297633388,
      "id": 1848822043,
      "node_id": "PRRC_kwDOABII585uMskb",
      "diff_hunk": "@@ -0,0 +1,1186 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. Their content and\n+ * scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    kernel_BlockManagerOptions* block_manager_options,\n+    const kernel_Context* context",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 740,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: this is the only place where `context` is not the first option, would be nice for consistency?",
      "created_at": "2024-11-19T18:02:22Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1848822043",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848822043"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 740,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848935049",
      "pull_request_review_id": 2297633388,
      "id": 1848935049,
      "node_id": "PRRC_kwDOABII585uNIKJ",
      "diff_hunk": "@@ -0,0 +1,1186 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. Their content and\n+ * scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 622,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "There are a few places, like here, where we expose modifier functions that are (quasi) required to be ran before initializing another object. An alternative approach would be to extend the `kernel_context_options_create` to take a (nullable) `kernel_ChainParameters*`, and remove these ~unsafe modifiers altogether? I think that would have the benefit of:\r\n- removing a whole category of bugs where users set options at the wrong time (i.e. too late), silently leading to buggy behaviour\r\n- making it easier to see which options can (should) be set, without having to first have read the entire documentation\r\n\r\nThis concern also applies to e.g.:\r\n- `kernel_context_options_set_notifications`\r\n- `kernel_validation_interface_register`",
      "created_at": "2024-11-19T19:18:01Z",
      "updated_at": "2024-11-19T19:19:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1848935049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1848935049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 676,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849036598",
      "pull_request_review_id": 2446622041,
      "id": 1849036598,
      "node_id": "PRRC_kwDOABII585uNg82",
      "diff_hunk": "@@ -0,0 +1,1186 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. Their content and\n+ * scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    kernel_BlockManagerOptions* block_manager_options,\n+    const kernel_Context* context",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 740,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "in_reply_to_id": 1848822043,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I think it is good to get these little things right.",
      "created_at": "2024-11-19T20:47:29Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849036598",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849036598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 740,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849037936",
      "pull_request_review_id": 2446622041,
      "id": 1849037936,
      "node_id": "PRRC_kwDOABII585uNhRw",
      "diff_hunk": "@@ -0,0 +1,1186 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. Their content and\n+ * scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    kernel_BlockManagerOptions* block_manager_options,\n+    const kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 746,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "in_reply_to_id": 1848821020,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Similarly to how the context is passed to the other chainman related functions, it is there to guarantee that it is still around when destroying the chainman. The reason for this is that there may be error notification callbacks issued during destruction.",
      "created_at": "2024-11-19T20:48:48Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849037936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849037936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 752,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849046061",
      "pull_request_review_id": 2446622041,
      "id": 1849046061,
      "node_id": "PRRC_kwDOABII585uNjQt",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 44,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757065221,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I did not think that much about order here, but I do think having this section on the context is a good idea. The key is that the user is not required to instantiate the context for using some parts of the library (and I think this is important enough to not just make it a footnote). The user-instantiated context is only really required when interacting with the \"stateful\" endpoints. Besides, it may be relevant to know what the library is instantiating internally in case there is some sort of conflict.\r\n\r\nThere is an exception here with the validation interface, and I've taken several attempts to come up with a nice way to tie it into the option pattern as well. I'll take a stab at it again soon.",
      "created_at": "2024-11-19T20:56:30Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849046061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849046061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849053726",
      "pull_request_review_id": 2446622041,
      "id": 1849053726,
      "node_id": "PRRC_kwDOABII585uNlIe",
      "diff_hunk": "@@ -0,0 +1,1186 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. Their content and\n+ * scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 622,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f1b3ab751bfe374095427796af00f6fdd50ec3e5",
      "in_reply_to_id": 1848935049,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this is good the way it is now. The options get instantiated empty and may be populated by the user. The actual object only gets configured once by the options during its instantion. It can't be changed later on, so there is no concern that users could set something at the wrong time. Having to set options as arguments in their creation function is not a clear win in my eyes either. There are use-cases, for example using the kernel only as a data reader, where the notifications are useless. Likewise defaulting to mainnet seems sane to me too. It also does not integrate well with the \"builder pattern\" which is common in a bunch of other languages.",
      "created_at": "2024-11-19T21:04:02Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849053726",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849053726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 676,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849071009",
      "pull_request_review_id": 2446622041,
      "id": 1849071009,
      "node_id": "PRRC_kwDOABII585uNpWh",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 34,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757015877,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When I apply this to the first commit I get:\r\n```\r\nIn file included from /home/drgrid/bitcoin/src/test/kernel/test_kernel.cpp:5:\r\n/home/drgrid/bitcoin/src/kernel/bitcoinkernel.h:201:32: error: too many arguments provided to function-like macro invocation\r\n  201 | ) BITCOINKERNEL_ARG_NONNULL(1, 3);\r\n      |                                ^\r\n/home/drgrid/bitcoin/src/kernel/bitcoinkernel.h:34:9: note: macro 'BITCOINKERNEL_ARG_NONNULL' defined here\r\n   34 | #define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\r\n      |         ^\r\n/home/drgrid/bitcoin/src/kernel/bitcoinkernel.h:201:3: error: expected function body after function declarator\r\n  201 | ) BITCOINKERNEL_ARG_NONNULL(1, 3);\r\n      |   ^\r\n```\r\nWhich makes sense, because the macro only expects one argument. I'm not sure how safe it is to make it take a string or a list instead.",
      "created_at": "2024-11-19T21:20:48Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849071009",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849071009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849072061",
      "pull_request_review_id": 2446622041,
      "id": 1849072061,
      "node_id": "PRRC_kwDOABII585uNpm9",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of it. They should not be de-allocated by the user.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 80,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757108471,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Improved this a bit and good point with the more precise language.",
      "created_at": "2024-11-19T21:21:51Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849072061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849072061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849072214",
      "pull_request_review_id": 2446622041,
      "id": 1849072214,
      "node_id": "PRRC_kwDOABII585uNppW",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * Pointer arguments make no assumptions on their lifetime. Once the function\n+ * returns the user can safely de-allocate the passed in arguments.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 77,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757105125,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, taken.",
      "created_at": "2024-11-19T21:22:00Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849072214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849072214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 76,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849075583",
      "pull_request_review_id": 2446622041,
      "id": 1849075583,
      "node_id": "PRRC_kwDOABII585uNqd_",
      "diff_hunk": "@@ -0,0 +1,141 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ */\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_TX_SIZE_MISMATCH, //!< The provided tx_to_len argument does not match the actual size of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_TX_DESERIALIZE, //!< The provided tx could not be de-serialized.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * A helper struct for a single transaction output.\n+ */\n+typedef struct {\n+    int64_t value;\n+    const unsigned char* script_pubkey;\n+    size_t script_pubkey_len;\n+} kernel_TransactionOutput;\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the witness flag is set the",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 108,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "63a83b8dad279beaa2f9f6ac2677c56c300300fe",
      "in_reply_to_id": 1754989437,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, I added your suggestion.",
      "created_at": "2024-11-19T21:25:25Z",
      "updated_at": "2024-11-19T21:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849075583",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849075583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 496,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849082933",
      "pull_request_review_id": 2446696897,
      "id": 1849082933,
      "node_id": "PRRC_kwDOABII585uNsQ1",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This context\n+ * offers only limited functionality. It detects and self-checks the correct\n+ * sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for otherwise\n+ * \"context-free\" operations.\n+ *\n+ * The user can create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 53,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757049107,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See my [comment](https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849046061).",
      "created_at": "2024-11-19T21:32:31Z",
      "updated_at": "2024-11-19T21:32:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849082933",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849082933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 46,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849132153",
      "pull_request_review_id": 2446777235,
      "id": 1849132153,
      "node_id": "PRRC_kwDOABII585uN4R5",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 34,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757015877,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sorry, I forgot to include the diff which updates the macro (and 1 instance to show it compiles):\r\n\r\n<details>\r\n<summary>git diff on 6c9121f790</summary>\r\n\r\n```diff\r\ndiff --git a/src/kernel/bitcoinkernel.h b/src/kernel/bitcoinkernel.h\r\nindex 9e6bf127db..67248349e2 100644\r\n--- a/src/kernel/bitcoinkernel.h\r\n+++ b/src/kernel/bitcoinkernel.h\r\n@@ -31,9 +31,9 @@\r\n #define BITCOINKERNEL_WARN_UNUSED_RESULT\r\n #endif\r\n #if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\r\n-#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\r\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\r\n #else\r\n-#define BITCOINKERNEL_ARG_NONNULL(_x)\r\n+#define BITCOINKERNEL_ARG_NONNULL(...)\r\n #endif\r\n \r\n #ifdef __cplusplus\r\n@@ -522,7 +522,7 @@ bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\r\n     unsigned int input_index,\r\n     unsigned int flags,\r\n     kernel_ScriptVerifyStatus* status\r\n-) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\r\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\r\n \r\n /**\r\n  * @brief This disables the global internal logger. No log messages will be\r\n\r\n```\r\n</details>\r\n\r\nBased on https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html, variadic macros should be standard for C99, and GCC documents accepting multiple indexes: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html",
      "created_at": "2024-11-19T22:25:32Z",
      "updated_at": "2024-11-19T22:28:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1849132153",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1849132153"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1850657572",
      "pull_request_review_id": 2448664774,
      "id": 1850657572,
      "node_id": "PRRC_kwDOABII585uTssk",
      "diff_hunk": "@@ -0,0 +1,1190 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of the callback. They must not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1) BITCOINKERNEL_ARG_NONNULL(2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 717,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "6c9121f7907262b2bf065a7ceeb8bca620060a7f",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: according to the `worker_threads_num`, 0 is accepted too:\r\n> Zero means no parallel verification.\r\n\r\n```suggestion\r\n *                           used for validation. The number must not be negative. When set to zero, no parallel verification is done.\r\n```",
      "created_at": "2024-11-20T16:42:13Z",
      "updated_at": "2024-11-25T21:41:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1850657572",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1850657572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 718,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1850697300",
      "pull_request_review_id": 2449240449,
      "id": 1850697300,
      "node_id": "PRRC_kwDOABII585uT2ZU",
      "diff_hunk": "@@ -0,0 +1,1145 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(_x) __attribute__((__nonnull__(_x)))",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 34,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "33c71843e3fde0b795687a8626220f02f7243662",
      "in_reply_to_id": 1757015877,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, decided to take this. I was a bit careful here, because I lifted the check from secp, which also does not use variadic args: https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L174. But thinking a bit more about it, I could not come up with a good reason not to, so took your suggestion.",
      "created_at": "2024-11-20T17:06:26Z",
      "updated_at": "2024-11-20T17:06:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1850697300",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1850697300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852510169",
      "pull_request_review_id": 2448664774,
      "id": 1852510169,
      "node_id": "PRRC_kwDOABII585uaw_Z",
      "diff_hunk": "@@ -0,0 +1,1190 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of the callback. They must not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    kernel_BlockManagerOptions* block_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+/**\n+ * @brief Creates a new validation interface for consuming events issued by the\n+ * chainstate manager. The interface should be created and registered before the\n+ * chainstate manager is created to avoid missing validation events.\n+ *\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ * @return                                   A validation interface. This should remain in memory for as\n+ *                                           long as the user expects to receive validation events.\n+ */\n+kernel_ValidationInterface* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_validation_interface_create(\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks);\n+\n+/**\n+ * @brief Register a validation interface with the internal task runner\n+ * associated with this context. This also registers it with the chainstate\n+ * manager if the chainstate manager is subsequently created with this context.\n+ *\n+ * @param[in] context              Non-null, will register the validation interface with this context.\n+ * @param[in] validation_interface Non-null.\n+ * @return                         True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_validation_interface_register(\n+    kernel_Context* context,\n+    kernel_ValidationInterface* validation_interface\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Unregister a validation interface from the internal task runner\n+ * associated with this context. This should be done before destroying the\n+ * kernel context it was previously registered with.\n+ *\n+ * @param[in] context              Non-null, will deregister the validation interface from this context.\n+ * @param[in] validation_interface Non-null.\n+ * @return                         True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_validation_interface_unregister(\n+    kernel_Context* context,\n+    kernel_ValidationInterface* validation_interface\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the validation interface. This should be done after unregistering it\n+ * if the validation interface was previously registered with a chainstate\n+ * manager.\n+ */\n+void kernel_validation_interface_destroy(kernel_ValidationInterface* validation_interface);\n+\n+/**\n+ * Create options for loading the chainstate.\n+ */\n+kernel_ChainstateLoadOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_load_options_create();\n+\n+/**\n+ * @brief Sets wipe block tree db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] wipe_block_tree_db      Set wipe block tree db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_block_tree_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_block_tree_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe chainstate db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] wipe_chainstate_db      Set wipe chainstate db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_chainstate_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] block_tree_db_in_memory Set block tree db in memory.\n+ */\n+void kernel_chainstate_load_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_db_in_memory Set chainstate db in memory.\n+ */\n+void kernel_chainstate_load_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate load options\n+ */\n+void kernel_chainstate_load_options_destroy(kernel_ChainstateLoadOptions* chainstate_load_options);\n+\n+/**\n+ * @brief This function must be called to initialize the chainstate manager\n+ * before doing validation tasks or interacting with its indexes.\n+ *\n+ * @param[in] context                 Non-null.\n+ * @param[in] chainstate_load_options Non-null, created by kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_manager      Non-null, will load the chainstate(s) and initialize indexes.\n+ * @return                            True on success, false on error.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_load_chainstate(\n+    const kernel_Context* context,\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief May be called after kernel_chainstate_manager_load_chainstate to\n+ * initialize the chainstate manager. Triggers the start of a reindex if the\n+ * option was previously set for the chainstate and block manager. Can also\n+ * import an array of existing block files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+void kernel_block_destroy(kernel_Block* block);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_by_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain, or null on error.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_by_height(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The next block index in the currently active chain, or null on error.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_next_block_index(\n+    const kernel_Context* context,\n+    kernel_BlockIndex* block_index,\n+    kernel_ChainstateManager* chainstate_manager",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1048,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "97fe2b25af31ca612c1f8d9f3de739fa3dee3902",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: for the other `block_index` getters, `chainstate_manager` is the second argument - would keep that consistent",
      "created_at": "2024-11-21T16:51:03Z",
      "updated_at": "2024-11-25T21:41:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1852510169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852510169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1049,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852512769",
      "pull_request_review_id": 2448664774,
      "id": 1852512769,
      "node_id": "PRRC_kwDOABII585uaxoB",
      "diff_hunk": "@@ -0,0 +1,1190 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * ------ Context ------\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * ------ Error handling ------\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * ------ Pointer and argument conventions ------\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid for\n+ * the duration of the callback. They must not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding callbacks for reacting to events that may\n+ * be encountered during library operations.\n+ */\n+typedef struct kernel_Notifications kernel_Notifications;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    void* user_data;                                      //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    void* user_data;                         //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+/**\n+ * @brief Creates an object for holding the kernel notification callbacks.\n+ *\n+ * @param[in] callbacks Holds the callbacks that will be invoked by the kernel notifications.\n+ */\n+kernel_Notifications* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_notifications_create(\n+    kernel_NotificationInterfaceCallbacks callbacks);\n+\n+/**\n+ * Destroy the kernel notifications.\n+ */\n+void kernel_notifications_destroy(const kernel_Notifications* notifications);\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created with kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created with kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    const kernel_Notifications* notifications\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created with kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, directory containing the chainstate data. If the directory\n+ *                           does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, directory containing the block data. If the directory does\n+ *                             not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. The number should be greater than 0.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    kernel_BlockManagerOptions* block_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+/**\n+ * @brief Creates a new validation interface for consuming events issued by the\n+ * chainstate manager. The interface should be created and registered before the\n+ * chainstate manager is created to avoid missing validation events.\n+ *\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ * @return                                   A validation interface. This should remain in memory for as\n+ *                                           long as the user expects to receive validation events.\n+ */\n+kernel_ValidationInterface* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_validation_interface_create(\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks);\n+\n+/**\n+ * @brief Register a validation interface with the internal task runner\n+ * associated with this context. This also registers it with the chainstate\n+ * manager if the chainstate manager is subsequently created with this context.\n+ *\n+ * @param[in] context              Non-null, will register the validation interface with this context.\n+ * @param[in] validation_interface Non-null.\n+ * @return                         True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_validation_interface_register(\n+    kernel_Context* context,\n+    kernel_ValidationInterface* validation_interface\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Unregister a validation interface from the internal task runner\n+ * associated with this context. This should be done before destroying the\n+ * kernel context it was previously registered with.\n+ *\n+ * @param[in] context              Non-null, will deregister the validation interface from this context.\n+ * @param[in] validation_interface Non-null.\n+ * @return                         True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_validation_interface_unregister(\n+    kernel_Context* context,\n+    kernel_ValidationInterface* validation_interface\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the validation interface. This should be done after unregistering it\n+ * if the validation interface was previously registered with a chainstate\n+ * manager.\n+ */\n+void kernel_validation_interface_destroy(kernel_ValidationInterface* validation_interface);\n+\n+/**\n+ * Create options for loading the chainstate.\n+ */\n+kernel_ChainstateLoadOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_load_options_create();\n+\n+/**\n+ * @brief Sets wipe block tree db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] wipe_block_tree_db      Set wipe block tree db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_block_tree_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_block_tree_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe chainstate db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] wipe_chainstate_db      Set wipe chainstate db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_chainstate_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] block_tree_db_in_memory Set block tree db in memory.\n+ */\n+void kernel_chainstate_load_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created with kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_db_in_memory Set chainstate db in memory.\n+ */\n+void kernel_chainstate_load_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate load options\n+ */\n+void kernel_chainstate_load_options_destroy(kernel_ChainstateLoadOptions* chainstate_load_options);\n+\n+/**\n+ * @brief This function must be called to initialize the chainstate manager\n+ * before doing validation tasks or interacting with its indexes.\n+ *\n+ * @param[in] context                 Non-null.\n+ * @param[in] chainstate_load_options Non-null, created by kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_manager      Non-null, will load the chainstate(s) and initialize indexes.\n+ * @return                            True on success, false on error.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_load_chainstate(\n+    const kernel_Context* context,\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief May be called after kernel_chainstate_manager_load_chainstate to\n+ * initialize the chainstate manager. Triggers the start of a reindex if the\n+ * option was previously set for the chainstate and block manager. Can also\n+ * import an array of existing block files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+void kernel_block_destroy(kernel_Block* block);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_by_hash(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1014,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "97fe2b25af31ca612c1f8d9f3de739fa3dee3902",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: `from/by` naming inconsistency, I think my preference would lie with `from` (i.e. update to `kernel_get_block_index_from_hash` and `kernel_get_block_index_from_height`)\r\n\r\n(_technically_, could update `kernel_get_next_block_index` -> `kernel_get_block_index_from_previous` and `kernel_get_previous_block_index` -> `kernel_get_block_index_from_next`, but... `from_next` sounds weird?)",
      "created_at": "2024-11-21T16:52:39Z",
      "updated_at": "2024-11-25T21:41:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1852512769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1852512769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1015,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1857036990",
      "pull_request_review_id": 2448664774,
      "id": 1857036990,
      "node_id": "PRRC_kwDOABII585usCK-",
      "diff_hunk": "@@ -1,10 +1,1217 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/caches.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*) m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*) m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*) m_cbs.user_data, cast_kernel_warning(id), message.original.c_str());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*) m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*) m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+const KernelNotifications* cast_const_notifications(const kernel_Notifications* notifications)\n+{\n+    assert(notifications);\n+    return reinterpret_cast<const KernelNotifications*>(notifications);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManager::Options* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManager::Options*>(options);\n+}\n+\n+ChainstateManager::Options* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManager::Options*>(options);\n+}\n+\n+const node::BlockManager::Options* cast_const_block_manager_options(const kernel_BlockManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::BlockManager::Options*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+node::ChainstateLoadOptions* cast_chainstate_load_options(kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<node::ChainstateLoadOptions*>(options);\n+}\n+\n+const node::ChainstateLoadOptions* cast_const_chainstate_load_options(const kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::ChainstateLoadOptions*>(options);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+std::shared_ptr<KernelValidationInterface>* cast_validation_interface(kernel_ValidationInterface* interface)\n+{\n+    assert(interface);\n+    return reinterpret_cast<std::shared_ptr<KernelValidationInterface>*>(interface);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                         const int64_t amount_,\n+                         const kernel_Transaction* tx_to,\n+                         const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                         const unsigned int input_index,\n+                         const unsigned int flags,\n+                         kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 494,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it's confusing that this function can return `False` and have `status == kernel_SCRIPT_VERIFY_OK`. How about adding a `kernel_SCRIPT_VERIFY_ERROR` catch-all member for unspecified errors? Or alternatively, requiring the user to provide a nullptr and only setting it to `kernel_SCRIPT_VERIFY_OK` is that's actually so?",
      "created_at": "2024-11-25T17:38:59Z",
      "updated_at": "2024-11-25T21:41:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1857036990",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1857036990"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1857397944",
      "pull_request_review_id": 2459717939,
      "id": 1857397944,
      "node_id": "PRRC_kwDOABII585utaS4",
      "diff_hunk": "@@ -1,10 +1,1217 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/caches.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*) m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*) m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*) m_cbs.user_data, cast_kernel_warning(id), message.original.c_str());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*) m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*) m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+const KernelNotifications* cast_const_notifications(const kernel_Notifications* notifications)\n+{\n+    assert(notifications);\n+    return reinterpret_cast<const KernelNotifications*>(notifications);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManager::Options* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManager::Options*>(options);\n+}\n+\n+ChainstateManager::Options* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManager::Options*>(options);\n+}\n+\n+const node::BlockManager::Options* cast_const_block_manager_options(const kernel_BlockManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::BlockManager::Options*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+node::ChainstateLoadOptions* cast_chainstate_load_options(kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<node::ChainstateLoadOptions*>(options);\n+}\n+\n+const node::ChainstateLoadOptions* cast_const_chainstate_load_options(const kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::ChainstateLoadOptions*>(options);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+std::shared_ptr<KernelValidationInterface>* cast_validation_interface(kernel_ValidationInterface* interface)\n+{\n+    assert(interface);\n+    return reinterpret_cast<std::shared_ptr<KernelValidationInterface>*>(interface);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                         const int64_t amount_,\n+                         const kernel_Transaction* tx_to,\n+                         const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                         const unsigned int input_index,\n+                         const unsigned int flags,\n+                         kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 494,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "in_reply_to_id": 1857036990,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We discussed during the last workshop that ideally we don't have any status codes here at all. But the problem is annoying to tackle. You'd probably want to pass this function a script verify object that has already passed through the required pre-checks. But then you have to either copy the objects into this object, or give ownership up to that object, which I don't think is desirable. The alternative to that is having a function with the same signature that you can call to check the arguments. But then you're forced to check them here again. I'm coming around to the option of replacing the status codes with log messages, but then we're sacrificing a bit of responsiveness to the developer.\r\n\r\nEdit: I also think that because this is probably going to be the most low-level verification function we expose here, populating the `ScriptError_t` enum here and returning that instead might be much more interesting. I wanted to hold off on this a bit though, so did not do that yet.",
      "created_at": "2024-11-25T21:58:46Z",
      "updated_at": "2024-11-26T08:30:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1857397944",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1857397944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1858149291",
      "pull_request_review_id": 2460937615,
      "id": 1858149291,
      "node_id": "PRRC_kwDOABII585uwRur",
      "diff_hunk": "@@ -1,10 +1,1217 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/caches.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*) m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*) m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*) m_cbs.user_data, cast_kernel_warning(id), message.original.c_str());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*) m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*) m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+const KernelNotifications* cast_const_notifications(const kernel_Notifications* notifications)\n+{\n+    assert(notifications);\n+    return reinterpret_cast<const KernelNotifications*>(notifications);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManager::Options* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManager::Options*>(options);\n+}\n+\n+ChainstateManager::Options* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManager::Options*>(options);\n+}\n+\n+const node::BlockManager::Options* cast_const_block_manager_options(const kernel_BlockManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::BlockManager::Options*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+node::ChainstateLoadOptions* cast_chainstate_load_options(kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<node::ChainstateLoadOptions*>(options);\n+}\n+\n+const node::ChainstateLoadOptions* cast_const_chainstate_load_options(const kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::ChainstateLoadOptions*>(options);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+std::shared_ptr<KernelValidationInterface>* cast_validation_interface(kernel_ValidationInterface* interface)\n+{\n+    assert(interface);\n+    return reinterpret_cast<std::shared_ptr<KernelValidationInterface>*>(interface);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                         const int64_t amount_,\n+                         const kernel_Transaction* tx_to,\n+                         const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                         const unsigned int input_index,\n+                         const unsigned int flags,\n+                         kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 494,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "in_reply_to_id": 1857036990,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What do you think of doing something like this instead: https://github.com/TheCharlatan/bitcoin/commit/6323d7b072de5b13ab25aaa29e02332c44808b62",
      "created_at": "2024-11-26T09:44:35Z",
      "updated_at": "2024-11-26T09:44:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1858149291",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1858149291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1858493399",
      "pull_request_review_id": 2461460193,
      "id": 1858493399,
      "node_id": "PRRC_kwDOABII585uxlvX",
      "diff_hunk": "@@ -1,10 +1,1217 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/caches.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*) m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*) m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*) m_cbs.user_data, cast_kernel_warning(id), message.original.c_str());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*) m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*) m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+const KernelNotifications* cast_const_notifications(const kernel_Notifications* notifications)\n+{\n+    assert(notifications);\n+    return reinterpret_cast<const KernelNotifications*>(notifications);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManager::Options* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManager::Options*>(options);\n+}\n+\n+ChainstateManager::Options* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManager::Options*>(options);\n+}\n+\n+const node::BlockManager::Options* cast_const_block_manager_options(const kernel_BlockManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::BlockManager::Options*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+node::ChainstateLoadOptions* cast_chainstate_load_options(kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<node::ChainstateLoadOptions*>(options);\n+}\n+\n+const node::ChainstateLoadOptions* cast_const_chainstate_load_options(const kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::ChainstateLoadOptions*>(options);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+std::shared_ptr<KernelValidationInterface>* cast_validation_interface(kernel_ValidationInterface* interface)\n+{\n+    assert(interface);\n+    return reinterpret_cast<std::shared_ptr<KernelValidationInterface>*>(interface);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                         const int64_t amount_,\n+                         const kernel_Transaction* tx_to,\n+                         const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                         const unsigned int input_index,\n+                         const unsigned int flags,\n+                         kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 494,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "in_reply_to_id": 1857036990,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> You'd probably want to pass this function a script verify object that has already passed through the required pre-checks.\r\n\r\nI 100% agree with this approach. Adding extra types makes the API more cumbersome to use, but I think it does make it more safe, and the extra verbosity should be quite easy to hide in client libraries.\r\n\r\n> But then you're forced to check them here again.\r\n\r\nI think that can be avoided by having the prechecks function return a `ScriptPreChecksPassed*` (which references the object it verified, but doesn't copy it) and then requiring that as an extra argument (extra as a way to address lifetime issues) to the `kernel_verify_script` function? This doesn't prevent runtime issues (e.g. re-using `PreChecksPassed` pointers, which is easily verifiable at runtime) or segfaults, but at least it adds some compile-time checks to guide the user to using the API safely, and it can be done without any copies or changing ownership?\r\n\r\n> What do you think of doing something like this instead: https://github.com/TheCharlatan/bitcoin/commit/6323d7b072de5b13ab25aaa29e02332c44808b62\r\n\r\nI'm not convinced. I think not requiring the user to deal with status codes (or strings) is a good philosophy, but if it's optional anyway, then passing a bool to add a log entry feels like a much worse interface? And I think it's inferior to this approach:\r\n\r\n> The alternative to that is having a function with the same signature that you can call to check the arguments.",
      "created_at": "2024-11-26T12:57:00Z",
      "updated_at": "2024-11-26T12:57:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1858493399",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1858493399"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1858539457",
      "pull_request_review_id": 2461535738,
      "id": 1858539457,
      "node_id": "PRRC_kwDOABII585uxw_B",
      "diff_hunk": "@@ -1,10 +1,1217 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/caches.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*) m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*) m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*) m_cbs.user_data, cast_kernel_warning(id), message.original.c_str());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*) m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*) m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+const KernelNotifications* cast_const_notifications(const kernel_Notifications* notifications)\n+{\n+    assert(notifications);\n+    return reinterpret_cast<const KernelNotifications*>(notifications);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManager::Options* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManager::Options*>(options);\n+}\n+\n+ChainstateManager::Options* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManager::Options*>(options);\n+}\n+\n+const node::BlockManager::Options* cast_const_block_manager_options(const kernel_BlockManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::BlockManager::Options*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+node::ChainstateLoadOptions* cast_chainstate_load_options(kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<node::ChainstateLoadOptions*>(options);\n+}\n+\n+const node::ChainstateLoadOptions* cast_const_chainstate_load_options(const kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::ChainstateLoadOptions*>(options);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+std::shared_ptr<KernelValidationInterface>* cast_validation_interface(kernel_ValidationInterface* interface)\n+{\n+    assert(interface);\n+    return reinterpret_cast<std::shared_ptr<KernelValidationInterface>*>(interface);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                         const int64_t amount_,\n+                         const kernel_Transaction* tx_to,\n+                         const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                         const unsigned int input_index,\n+                         const unsigned int flags,\n+                         kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 494,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "in_reply_to_id": 1857036990,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll propose a pre-check function and object later today then :)",
      "created_at": "2024-11-26T13:25:01Z",
      "updated_at": "2024-11-26T13:25:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1858539457",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1858539457"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1862247416",
      "pull_request_review_id": 2468252755,
      "id": 1862247416,
      "node_id": "PRRC_kwDOABII585u_6P4",
      "diff_hunk": "@@ -1,10 +1,1217 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/caches.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*) m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*) m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*) m_cbs.user_data, cast_kernel_warning(id), message.original.c_str());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*) m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*) m_cbs.user_data, message.original.c_str());\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*) m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+const KernelNotifications* cast_const_notifications(const kernel_Notifications* notifications)\n+{\n+    assert(notifications);\n+    return reinterpret_cast<const KernelNotifications*>(notifications);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManager::Options* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManager::Options*>(options);\n+}\n+\n+ChainstateManager::Options* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManager::Options*>(options);\n+}\n+\n+const node::BlockManager::Options* cast_const_block_manager_options(const kernel_BlockManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::BlockManager::Options*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+node::ChainstateLoadOptions* cast_chainstate_load_options(kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<node::ChainstateLoadOptions*>(options);\n+}\n+\n+const node::ChainstateLoadOptions* cast_const_chainstate_load_options(const kernel_ChainstateLoadOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const node::ChainstateLoadOptions*>(options);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+std::shared_ptr<KernelValidationInterface>* cast_validation_interface(kernel_ValidationInterface* interface)\n+{\n+    assert(interface);\n+    return reinterpret_cast<std::shared_ptr<KernelValidationInterface>*>(interface);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                         const int64_t amount_,\n+                         const kernel_Transaction* tx_to,\n+                         const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                         const unsigned int input_index,\n+                         const unsigned int flags,\n+                         kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 494,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "34a8429ff3a870c0caaf4c4790becd86c5acde38",
      "in_reply_to_id": 1857036990,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, this is what I have now: https://github.com/TheCharlatan/bitcoin/compare/kernelApi_7..kernelApi_ScriptVerifyArgs , what do you think?\r\nEDIT: This also introduces the concept of a 'View' where you get a resource, but it is dependent on the lifetime of the resources it was created from.",
      "created_at": "2024-11-28T13:57:54Z",
      "updated_at": "2024-12-02T12:32:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1862247416",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1862247416"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 562,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1888513807",
      "pull_request_review_id": 2508874952,
      "id": 1888513807,
      "node_id": "PRRC_kwDOABII585wkG8P",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 264,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "9e203b460d8ab1d92949ab8714a9265c343a5eee",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "A general comment on the API: i'd prefer to pass (and receive) explicit lengths for strings instead of bare `char*`s.\r\n\r\nMy experience with wrapping C APIs in rust is that it's important to have a defined memory-range for strings and arrays. Relying on NUL-termination means that the memory size is effectively unrestricted, making it impossible to do some checks safely. This is (with lesser urgency) also true for other languages like Python that represent strings as pointer+length.\r\n\r\nAs we internally use C++ strings and not C string APIs this seems straightforward to offer.",
      "created_at": "2024-12-17T13:23:56Z",
      "updated_at": "2024-12-17T13:26:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1888513807",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1888513807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1888529353",
      "pull_request_review_id": 2508900589,
      "id": 1888529353,
      "node_id": "PRRC_kwDOABII585wkKvJ",
      "diff_hunk": "@@ -0,0 +1,1142 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 264,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "9e203b460d8ab1d92949ab8714a9265c343a5eee",
      "in_reply_to_id": 1888513807,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Mmh, thanks for this. It should be easy to add a length parameter here.",
      "created_at": "2024-12-17T13:34:45Z",
      "updated_at": "2024-12-17T13:34:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1888529353",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1888529353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1890734754",
      "pull_request_review_id": 2512695597,
      "id": 1890734754,
      "node_id": "PRRC_kwDOABII585wslKi",
      "diff_hunk": "@@ -0,0 +1,1271 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, path string of the directory containing the chainstate data.\n+ *                           If the directory does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. When set to 0 no parallel verification is done.\n+ *                           The value range is clamped internally between 0 and 15.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name BlockManagerOptions\n+ * Functions for working with block manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateLoadOptions\n+ * Functions for working with chainstate load options.\n+ */\n+///@{\n+\n+/**\n+ * Create options for loading the chainstate.\n+ */\n+kernel_ChainstateLoadOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_load_options_create();\n+\n+/**\n+ * @brief Sets wipe block tree db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] wipe_block_tree_db      Set wipe block tree db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_block_tree_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_block_tree_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe chainstate db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] wipe_chainstate_db      Set wipe chainstate db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_chainstate_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] block_tree_db_in_memory Set block tree db in memory.\n+ */\n+void kernel_chainstate_load_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_db_in_memory Set chainstate db in memory.\n+ */\n+void kernel_chainstate_load_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate load options\n+ */\n+void kernel_chainstate_load_options_destroy(kernel_ChainstateLoadOptions* chainstate_load_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by @ref kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    const kernel_BlockManagerOptions* block_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief This function must be called to initialize the chainstate manager\n+ * before doing validation tasks or interacting with its indexes.\n+ *\n+ * @param[in] context                 Non-null.\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_manager      Non-null, will load the chainstate(s) and initialize indexes.\n+ * @return                            True on success, false on error.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_load_chainstate(\n+    const kernel_Context* context,\n+    const kernel_ChainstateLoadOptions* chainstate_load_options,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 917,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When this function is called more than once, kernel crashes with an assertion error:\r\n\r\n```\r\nAssertion failed: (!m_ibd_chainstate), function InitializeChainstate, file validation.cpp, line 5655.\r\n```\r\n\r\nThe solutions I see atm:\r\n1. document that this function may only be called once for each chainman\r\n1. add a field to `kernel_ChainstateManager*` to keep track of it being loaded already, return false and log an error\r\n1. rework LoadChainstate logic to handle multiple calls gracefully\r\n1. remove `kernel_chainstate_manager_load_chainstate` altogether and load chainstate during `kernel_chainstate_manager_create`.\r\n\r\nI'm not sure if we really need a separate `*_load_chainstate` function, so if that's true, then option 4. would probably be preferable? I implemented it in https://github.com/TheCharlatan/bitcoin/compare/kernelApi...stickies-v:bitcoin:kernel/remove-load-chainstate, but in practice this probably should be a rebase instead of an extra commit. Options 1. and 2. seem easy enough to implement too, 3. is probably not the most sensible.",
      "created_at": "2024-12-18T19:26:37Z",
      "updated_at": "2024-12-18T19:26:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1890734754",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1890734754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 904,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1890897105",
      "pull_request_review_id": 2512963714,
      "id": 1890897105,
      "node_id": "PRRC_kwDOABII585wtMzR",
      "diff_hunk": "@@ -0,0 +1,1271 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, path string of the directory containing the chainstate data.\n+ *                           If the directory does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. When set to 0 no parallel verification is done.\n+ *                           The value range is clamped internally between 0 and 15.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name BlockManagerOptions\n+ * Functions for working with block manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateLoadOptions\n+ * Functions for working with chainstate load options.\n+ */\n+///@{\n+\n+/**\n+ * Create options for loading the chainstate.\n+ */\n+kernel_ChainstateLoadOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_load_options_create();\n+\n+/**\n+ * @brief Sets wipe block tree db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] wipe_block_tree_db      Set wipe block tree db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_block_tree_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_block_tree_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe chainstate db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] wipe_chainstate_db      Set wipe chainstate db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_chainstate_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] block_tree_db_in_memory Set block tree db in memory.\n+ */\n+void kernel_chainstate_load_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_db_in_memory Set chainstate db in memory.\n+ */\n+void kernel_chainstate_load_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate load options\n+ */\n+void kernel_chainstate_load_options_destroy(kernel_ChainstateLoadOptions* chainstate_load_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by @ref kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    const kernel_BlockManagerOptions* block_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief This function must be called to initialize the chainstate manager\n+ * before doing validation tasks or interacting with its indexes.\n+ *\n+ * @param[in] context                 Non-null.\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_manager      Non-null, will load the chainstate(s) and initialize indexes.\n+ * @return                            True on success, false on error.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_load_chainstate(\n+    const kernel_Context* context,\n+    const kernel_ChainstateLoadOptions* chainstate_load_options,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 917,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "in_reply_to_id": 1890734754,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> remove kernel_chainstate_manager_load_chainstate altogether and load chainstate during kernel_chainstate_manager_create.\r\n\r\nI would like this a lot, but I wanted to keep a separate chainstate load function in case we ever land a \"blocks-only read-only\" chainstate manager, where we don't need to load any chainstates. I feel like making this a no-op could work, the simplest thing to do would probably be adding something along the lines of:\r\n```\r\nif (chainman.GetAll().size() > 0) return true;\r\n```\r\nto `kernel_chainstate_manager_load_chainstate`. But then again it would move us closer to a correct by construction setup if we'd do the constructing and loading all at once.",
      "created_at": "2024-12-18T22:10:53Z",
      "updated_at": "2024-12-18T22:10:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1890897105",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1890897105"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 904,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891024389",
      "pull_request_review_id": 2513154038,
      "id": 1891024389,
      "node_id": "PRRC_kwDOABII585wtr4F",
      "diff_hunk": "@@ -0,0 +1,1271 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 433,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "~~i was wondering; these are trivially small structures, why don't we pass and return them by value instead of by pointer? this would avoid needing a special `kernel_byte_array_destroy` call to deallocate them~~\r\n\r\nedit: never mind, of course that's still necessary to deallocate the conents",
      "created_at": "2024-12-19T01:36:11Z",
      "updated_at": "2024-12-19T01:43:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1891024389",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891024389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891405387",
      "pull_request_review_id": 2513778436,
      "id": 1891405387,
      "node_id": "PRRC_kwDOABII585wvI5L",
      "diff_hunk": "@@ -0,0 +1,1271 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 433,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "in_reply_to_id": 1891024389,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> of course that's still necessary to deallocate the conents\r\n\r\nYes, I try to match every call to `new` with a corresponding place to `delete`.",
      "created_at": "2024-12-19T09:11:45Z",
      "updated_at": "2024-12-19T09:11:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1891405387",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891405387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 443,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891993661",
      "pull_request_review_id": 2514567528,
      "id": 1891993661,
      "node_id": "PRRC_kwDOABII585wxYg9",
      "diff_hunk": "@@ -0,0 +1,1271 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(_x)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager has an internal block manager that takes its own set\n+ * of parameters. It is initialized with default options.\n+ */\n+typedef struct kernel_BlockManagerOptions kernel_BlockManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding parameters used for loading the chainstate\n+ * of a chainstate manager.\n+ *\n+ * Is initialized with default parameters.\n+ */\n+typedef struct kernel_ChainstateLoadOptions kernel_ChainstateLoadOptions;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a validation interface.\n+ *\n+ * The validation interface can be registered with the internal task runner of an\n+ * existing context. It holds callbacks that will be triggered by certain\n+ * validation events. The callbacks registered with it will block further\n+ * validation progress when triggered.\n+ */\n+typedef struct kernel_ValidationInterface kernel_ValidationInterface;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context        Non-null, the created options will associate with this kernel context\n+ *                           for the duration of their lifetime. The same context needs to be used\n+ *                           when instantiating the chainstate manager.\n+ * @param[in] data_directory Non-null, path string of the directory containing the chainstate data.\n+ *                           If the directory does not exist yet, it will be created.\n+ * @return                   The allocated chainstate manager options, or null on error.\n+ */\n+kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads The number of worker threads that should be spawned in the thread pool\n+ *                           used for validation. When set to 0 no parallel verification is done.\n+ *                           The value range is clamped internally between 0 and 15.\n+ */\n+void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name BlockManagerOptions\n+ * Functions for working with block manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the block manager. The block manager is used\n+ * internally by the chainstate manager for block storage and indexing.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated block manager options, or null on error.\n+ */\n+kernel_BlockManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_manager_options_create(\n+    const kernel_Context* context,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the block manager options.\n+ */\n+void kernel_block_manager_options_destroy(kernel_BlockManagerOptions* block_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateLoadOptions\n+ * Functions for working with chainstate load options.\n+ */\n+///@{\n+\n+/**\n+ * Create options for loading the chainstate.\n+ */\n+kernel_ChainstateLoadOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_load_options_create();\n+\n+/**\n+ * @brief Sets wipe block tree db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] wipe_block_tree_db      Set wipe block tree db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_block_tree_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_block_tree_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe chainstate db in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] wipe_chainstate_db      Set wipe chainstate db.\n+ */\n+void kernel_chainstate_load_options_set_wipe_chainstate_db(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] block_tree_db_in_memory Set block tree db in memory.\n+ */\n+void kernel_chainstate_load_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the chainstate load options.\n+ *\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_db_in_memory Set chainstate db in memory.\n+ */\n+void kernel_chainstate_load_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateLoadOptions* chainstate_load_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate load options\n+ */\n+void kernel_chainstate_load_options_destroy(kernel_ChainstateLoadOptions* chainstate_load_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain. It is only\n+ * valid for as long as the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_manager_options      Non-null, created by @ref kernel_block_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    const kernel_BlockManagerOptions* block_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief This function must be called to initialize the chainstate manager\n+ * before doing validation tasks or interacting with its indexes.\n+ *\n+ * @param[in] context                 Non-null.\n+ * @param[in] chainstate_load_options Non-null, created by @ref kernel_chainstate_load_options_create.\n+ * @param[in] chainstate_manager      Non-null, will load the chainstate(s) and initialize indexes.\n+ * @return                            True on success, false on error.\n+ */\n+bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_load_chainstate(\n+    const kernel_Context* context,\n+    const kernel_ChainstateLoadOptions* chainstate_load_options,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 917,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "20eec64b5e417cac8c68100826c0adf2152a49eb",
      "in_reply_to_id": 1890734754,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for [updating](https://github.com/bitcoin/bitcoin/pull/30595#issuecomment-2553418201) to option 4. Just to summarize what we talked about offline: \r\n\r\n> but I wanted to keep a separate chainstate load function in case we ever land a \"blocks-only read-only\" chainstate manager\r\n\r\nThat makes sense with the current code organization, but I think we should aim to shift towards a more intuitive API over time. Operations that don't require any chainstate (such as blocks-only read-only) probably shouldn't use the chainman in the first place.\r\n\r\n> But then again it would move us closer to a correct by construction setup\r\n\r\nI think that is a worthwhile design goal for the API.",
      "created_at": "2024-12-19T13:05:15Z",
      "updated_at": "2024-12-19T13:05:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1891993661",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891993661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 904,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 922,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916637752",
      "pull_request_review_id": 2552730240,
      "id": 1916637752,
      "node_id": "PRRC_kwDOABII585yPZI4",
      "diff_hunk": "@@ -0,0 +1,200 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <sstream>\n+\n+std::vector<unsigned char> hex_string_to_char_vec(const std::string& hex)\n+{\n+    std::vector<unsigned char> bytes;\n+\n+    for (size_t i{0}; i < hex.length(); i += 2) {\n+        std::string byteString{hex.substr(i, 2)};\n+        unsigned char byte = (char)std::strtol(byteString.c_str(), nullptr, 16);",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 17,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i would really prefer not to bring back use of `strtol` in C++ code; it has some known issues with locale-dependence (especially on Linux). what about:\r\n\r\n```c++\r\n#include <charconv>\r\n...\r\nstd::vector<unsigned char> hex_string_to_char_vec(const std::string& hex)\r\n{\r\n    std::vector<unsigned char> bytes;\r\n\r\n    for (size_t i{0}; i < hex.length(); i += 2) {\r\n        unsigned int val{0};\r\n        auto [p, ec] = std::from_chars(hex.data() + i, hex.data() + i + 2, val, 16);\r\n        if (ec == std::errc{} && p == hex.data() + i + 2) {\r\n            bytes.push_back(val);\r\n        }\r\n    }\r\n\r\n    return bytes;\r\n}\r\n```\r\n`from_chars` is  guaranteed to be locale-independent so doesn't need an exception in the linter either. Same for the other use.",
      "created_at": "2025-01-15T13:18:20Z",
      "updated_at": "2025-01-15T13:23:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1916637752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916637752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916639299",
      "pull_request_review_id": 2552732729,
      "id": 1916639299,
      "node_id": "PRRC_kwDOABII585yPZhD",
      "diff_hunk": "@@ -0,0 +1,200 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <sstream>",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 9,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "f157b0cbc7d90075858a6522d13a7bc4f0b25a5f",
      "in_reply_to_id": null,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "missing `#include <vector>`",
      "created_at": "2025-01-15T13:19:28Z",
      "updated_at": "2025-01-15T13:19:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1916639299",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916639299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935834281",
      "pull_request_review_id": 2584276519,
      "id": 1935834281,
      "node_id": "PRRC_kwDOABII585zYnyp",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <charconv>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+std::vector<unsigned char> hex_string_to_char_vec(std::string_view hex)\n+{\n+    std::vector<unsigned char> bytes;\n+    bytes.reserve(hex.length() / 2);\n+\n+    for (size_t i{0}; i < hex.length(); i += 2) {\n+        unsigned char byte;\n+        auto [ptr, ec] = std::from_chars(hex.data() + i, hex.data() + i + 2, byte, 16);\n+        if (ec == std::errc{} && ptr == hex.data() + i + 2) {\n+            bytes.push_back(byte);\n+        }\n+    }\n+    return bytes;\n+}\n+\n+class KernelLog\n+{\n+public:\n+    void LogMessage(std::string_view message)\n+    {\n+        std::cout << \"kernel: \" << message;\n+    }\n+};\n+\n+class TestValidationInterface : public ValidationInterface<TestValidationInterface>\n+{\n+public:\n+    TestValidationInterface() : ValidationInterface() {}\n+\n+    std::optional<std::string> m_expected_valid_block = std::nullopt;\n+\n+    void BlockChecked(const UnownedBlock block, const BlockValidationState state) override\n+    {\n+        auto mode{state.ValidationMode()};\n+        switch (mode) {\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_VALID: {\n+            std::cout << \"Valid block\" << std::endl;\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID: {\n+            std::cout << \"Invalid block: \";\n+            auto result{state.BlockValidationResult()};\n+            switch (result) {\n+            case kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET:\n+                std::cout << \"initial value. Block has not yet been rejected\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK:\n+                std::cout << \"the block header may be on a too-little-work chain\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS:\n+                std::cout << \"invalid by consensus rules (excluding any below reasons)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID:\n+                std::cout << \"this block was cached as being invalid and we didn't store the reason why\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER:\n+                std::cout << \"invalid proof of work or time too old\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MUTATED:\n+                std::cout << \"the block's data didn't match the data committed to by the PoW\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV:\n+                std::cout << \"We don't have the previous block the checked one is built on\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV:\n+                std::cout << \"A block this one builds on is invalid\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE:\n+                std::cout << \"block timestamp was > 2 hours in the future (or our clock is bad)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT:\n+                std::cout << \"the block failed to meet one of our checkpoints\" << std::endl;\n+                break;\n+            }\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR: {\n+            std::cout << \"Internal error\" << std::endl;\n+            return;\n+        }\n+        }\n+    }\n+};\n+\n+class TestKernelNotifications : public KernelNotifications<TestKernelNotifications>\n+{\n+public:\n+    void BlockTipHandler(kernel_SynchronizationState state, const kernel_BlockIndex* index) override\n+    {\n+        std::cout << \"Block tip changed\" << std::endl;\n+    }\n+\n+    void ProgressHandler(std::string_view title, int progress_percent, bool resume_possible) override\n+    {\n+        std::cout << \"Made progress: \" << title << \" \" << progress_percent << \"%\" << std::endl;\n+    }\n+\n+    void WarningSetHandler(kernel_Warning warning, std::string_view message) override\n+    {\n+        std::cout << message << std::endl;\n+    }\n+\n+    void WarningUnsetHandler(kernel_Warning warning) override\n+    {\n+        std::cout << \"Warning unset: \" << warning << std::endl;\n+    }\n+\n+    void FlushErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+\n+    void FatalErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+};\n+\n+int main(int argc, char* argv[])\n+{\n+    // SETUP: Argument parsing and handling\n+    if (argc != 2) {\n+        std::cerr\n+            << \"Usage: \" << argv[0] << \" DATADIR\" << std::endl\n+            << \"Display DATADIR information, and process hex-encoded blocks on standard input.\" << std::endl\n+            << std::endl\n+            << \"IMPORTANT: THIS EXECUTABLE IS EXPERIMENTAL, FOR TESTING ONLY, AND EXPECTED TO\" << std::endl\n+            << \"           BREAK IN FUTURE VERSIONS. DO NOT USE ON YOUR ACTUAL DATADIR.\" << std::endl;\n+        return 1;\n+    }\n+    std::filesystem::path abs_datadir{std::filesystem::absolute(argv[1])};\n+    std::filesystem::create_directories(abs_datadir);\n+\n+    kernel_LoggingOptions logging_options = {\n+        .log_timestamps = true,\n+        .log_time_micros = false,\n+        .log_threadnames = false,\n+        .log_sourcelocations = false,\n+        .always_print_category_levels = true,\n+    };\n+\n+    Logger logger{std::make_unique<KernelLog>(KernelLog{}), logging_options};\n+\n+    ContextOptions options{};\n+    ChainParams params{kernel_ChainType::kernel_CHAIN_TYPE_REGTEST};\n+    options.SetChainParams(params);\n+\n+    TestKernelNotifications notifications{};\n+    options.SetNotifications(notifications);\n+    TestValidationInterface validation_interface{};\n+    options.SetValidationInterface(validation_interface);\n+\n+    Context context{options};\n+    assert(context);\n+\n+    ChainstateManagerOptions chainman_opts{context, abs_datadir};",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The implicit `std::filesystem::__cxx11::path` to `const std::string&` conversion doesn't seem to cross-compile for `x86_64-w64-mingw32`:\r\n\r\n<details>\r\n\r\n```\r\n[100%] Building CXX object src/kernel/CMakeFiles/kernel-bitcoin-chainstate.dir/bitcoin-chainstate.cpp.obj\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoin-chainstate.cpp: In function â€˜int main(int, char**)â€™:\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoin-chainstate.cpp:164:64: error: no matching function for call to â€˜ChainstateManagerOptions::ChainstateManagerOptions(<brace-enclosed initializer list>)â€™\r\n  164 |     ChainstateManagerOptions chainman_opts{context, abs_datadir};\r\n      |                                                                ^\r\nIn file included from /home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoin-chainstate.cpp:1:\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:396:5: note: candidate: â€˜ChainstateManagerOptions::ChainstateManagerOptions(const Context&, const std::string&)â€™\r\n  396 |     ChainstateManagerOptions(const Context& context, const std::string& data_dir) noexcept\r\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:396:73: note:   no known conversion for argument 2 from â€˜std::filesystem::__cxx11::pathâ€™ to â€˜const std::string&â€™ {aka â€˜const std::__cxx11::basic_string<char>&â€™}\r\n  396 |     ChainstateManagerOptions(const Context& context, const std::string& data_dir) noexcept\r\n      |                                                      ~~~~~~~~~~~~~~~~~~~^~~~~~~~\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:383:7: note: candidate: â€˜ChainstateManagerOptions::ChainstateManagerOptions(ChainstateManagerOptions&&)â€™\r\n  383 | class ChainstateManagerOptions\r\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:383:7: note:   candidate expects 1 argument, 2 provided\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoin-chainstate.cpp:167:70: error: no matching function for call to â€˜BlockManagerOptions::BlockManagerOptions(<brace-enclosed initializer list>)â€™\r\n  167 |     BlockManagerOptions blockman_opts{context, abs_datadir / \"blocks\"};\r\n      |                                                                      ^\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:425:5: note: candidate: â€˜BlockManagerOptions::BlockManagerOptions(const Context&, const std::string&)â€™\r\n  425 |     BlockManagerOptions(const Context& context, const std::string& data_dir) noexcept\r\n      |     ^~~~~~~~~~~~~~~~~~~\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:425:68: note:   no known conversion for argument 2 from â€˜std::filesystem::__cxx11::pathâ€™ to â€˜const std::string&â€™ {aka â€˜const std::__cxx11::basic_string<char>&â€™}\r\n  425 |     BlockManagerOptions(const Context& context, const std::string& data_dir) noexcept\r\n      |                                                 ~~~~~~~~~~~~~~~~~~~^~~~~~~~\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:412:7: note: candidate: â€˜BlockManagerOptions::BlockManagerOptions(BlockManagerOptions&&)â€™\r\n  412 | class BlockManagerOptions\r\n      |       ^~~~~~~~~~~~~~~~~~~\r\n/home/runner/work/py-bitcoinkernel/py-bitcoinkernel/depend/bitcoin/src/kernel/bitcoinkernel_wrapper.h:412:7: note:   candidate expects 1 argument, 2 provided\r\ngmake[5]: *** [src/kernel/CMakeFiles/kernel-bitcoin-chainstate.dir/build.make:80: src/kernel/CMakeFiles/kernel-bitcoin-chainstate.dir/bitcoin-chainstate.cpp.obj] Error 1\r\ngmake[4]: *** [CMakeFiles/Makefile2:1168: src/kernel/CMakeFiles/kernel-bitcoin-chainstate.dir/all] Error 2\r\ngmake[3]: *** [Makefile:136: all] Error 2\r\ngmake[2]: *** [CMakeFiles/bitcoin_core.dir/build.make:86: bitcoin_core-prefix/src/bitcoin_core-stamp/bitcoin_core-build] Error 2\r\ngmake[1]: *** [CMakeFiles/Makefile2:122: CMakeFiles/bitcoin_core.dir/all] Error 2\r\ngmake: *** [Makefile:136: all] Error 2\r\n```\r\n</details>\r\n\r\nRan into this in one of my py-bitcoinkernel [CI runs](https://github.com/stickies-v/py-bitcoinkernel/actions/runs/13055462943/job/36425292411?pr=20). Slightly older HEAD, but at first glance still relevant, just wanted to dump here already until I have time to investigate further - sorry if it's irrelevant.",
      "created_at": "2025-01-30T15:39:49Z",
      "updated_at": "2025-01-30T21:25:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1935834281",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935834281"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935842536",
      "pull_request_review_id": 2584290045,
      "id": 1935842536,
      "node_id": "PRRC_kwDOABII585zYpzo",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <charconv>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+std::vector<unsigned char> hex_string_to_char_vec(std::string_view hex)\n+{\n+    std::vector<unsigned char> bytes;\n+    bytes.reserve(hex.length() / 2);\n+\n+    for (size_t i{0}; i < hex.length(); i += 2) {\n+        unsigned char byte;\n+        auto [ptr, ec] = std::from_chars(hex.data() + i, hex.data() + i + 2, byte, 16);\n+        if (ec == std::errc{} && ptr == hex.data() + i + 2) {\n+            bytes.push_back(byte);\n+        }\n+    }\n+    return bytes;\n+}\n+\n+class KernelLog\n+{\n+public:\n+    void LogMessage(std::string_view message)\n+    {\n+        std::cout << \"kernel: \" << message;\n+    }\n+};\n+\n+class TestValidationInterface : public ValidationInterface<TestValidationInterface>\n+{\n+public:\n+    TestValidationInterface() : ValidationInterface() {}\n+\n+    std::optional<std::string> m_expected_valid_block = std::nullopt;\n+\n+    void BlockChecked(const UnownedBlock block, const BlockValidationState state) override\n+    {\n+        auto mode{state.ValidationMode()};\n+        switch (mode) {\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_VALID: {\n+            std::cout << \"Valid block\" << std::endl;\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID: {\n+            std::cout << \"Invalid block: \";\n+            auto result{state.BlockValidationResult()};\n+            switch (result) {\n+            case kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET:\n+                std::cout << \"initial value. Block has not yet been rejected\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK:\n+                std::cout << \"the block header may be on a too-little-work chain\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS:\n+                std::cout << \"invalid by consensus rules (excluding any below reasons)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID:\n+                std::cout << \"this block was cached as being invalid and we didn't store the reason why\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER:\n+                std::cout << \"invalid proof of work or time too old\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MUTATED:\n+                std::cout << \"the block's data didn't match the data committed to by the PoW\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV:\n+                std::cout << \"We don't have the previous block the checked one is built on\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV:\n+                std::cout << \"A block this one builds on is invalid\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE:\n+                std::cout << \"block timestamp was > 2 hours in the future (or our clock is bad)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT:\n+                std::cout << \"the block failed to meet one of our checkpoints\" << std::endl;\n+                break;\n+            }\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR: {\n+            std::cout << \"Internal error\" << std::endl;\n+            return;\n+        }\n+        }\n+    }\n+};\n+\n+class TestKernelNotifications : public KernelNotifications<TestKernelNotifications>\n+{\n+public:\n+    void BlockTipHandler(kernel_SynchronizationState state, const kernel_BlockIndex* index) override\n+    {\n+        std::cout << \"Block tip changed\" << std::endl;\n+    }\n+\n+    void ProgressHandler(std::string_view title, int progress_percent, bool resume_possible) override\n+    {\n+        std::cout << \"Made progress: \" << title << \" \" << progress_percent << \"%\" << std::endl;\n+    }\n+\n+    void WarningSetHandler(kernel_Warning warning, std::string_view message) override\n+    {\n+        std::cout << message << std::endl;\n+    }\n+\n+    void WarningUnsetHandler(kernel_Warning warning) override\n+    {\n+        std::cout << \"Warning unset: \" << warning << std::endl;\n+    }\n+\n+    void FlushErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+\n+    void FatalErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+};\n+\n+int main(int argc, char* argv[])\n+{\n+    // SETUP: Argument parsing and handling\n+    if (argc != 2) {\n+        std::cerr\n+            << \"Usage: \" << argv[0] << \" DATADIR\" << std::endl\n+            << \"Display DATADIR information, and process hex-encoded blocks on standard input.\" << std::endl\n+            << std::endl\n+            << \"IMPORTANT: THIS EXECUTABLE IS EXPERIMENTAL, FOR TESTING ONLY, AND EXPECTED TO\" << std::endl\n+            << \"           BREAK IN FUTURE VERSIONS. DO NOT USE ON YOUR ACTUAL DATADIR.\" << std::endl;\n+        return 1;\n+    }\n+    std::filesystem::path abs_datadir{std::filesystem::absolute(argv[1])};\n+    std::filesystem::create_directories(abs_datadir);\n+\n+    kernel_LoggingOptions logging_options = {\n+        .log_timestamps = true,\n+        .log_time_micros = false,\n+        .log_threadnames = false,\n+        .log_sourcelocations = false,\n+        .always_print_category_levels = true,\n+    };\n+\n+    Logger logger{std::make_unique<KernelLog>(KernelLog{}), logging_options};\n+\n+    ContextOptions options{};\n+    ChainParams params{kernel_ChainType::kernel_CHAIN_TYPE_REGTEST};\n+    options.SetChainParams(params);\n+\n+    TestKernelNotifications notifications{};\n+    options.SetNotifications(notifications);\n+    TestValidationInterface validation_interface{};\n+    options.SetValidationInterface(validation_interface);\n+\n+    Context context{options};\n+    assert(context);\n+\n+    ChainstateManagerOptions chainman_opts{context, abs_datadir};",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "in_reply_to_id": 1935834281,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good catch, I will try add the tests and chainstate binary to the CI here too.",
      "created_at": "2025-01-30T15:44:34Z",
      "updated_at": "2025-01-30T15:44:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1935842536",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935842536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937145120",
      "pull_request_review_id": 2586451547,
      "id": 1937145120,
      "node_id": "PRRC_kwDOABII585zdn0g",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <charconv>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+std::vector<unsigned char> hex_string_to_char_vec(std::string_view hex)\n+{\n+    std::vector<unsigned char> bytes;\n+    bytes.reserve(hex.length() / 2);\n+\n+    for (size_t i{0}; i < hex.length(); i += 2) {\n+        unsigned char byte;\n+        auto [ptr, ec] = std::from_chars(hex.data() + i, hex.data() + i + 2, byte, 16);\n+        if (ec == std::errc{} && ptr == hex.data() + i + 2) {\n+            bytes.push_back(byte);\n+        }\n+    }\n+    return bytes;\n+}\n+\n+class KernelLog\n+{\n+public:\n+    void LogMessage(std::string_view message)\n+    {\n+        std::cout << \"kernel: \" << message;\n+    }\n+};\n+\n+class TestValidationInterface : public ValidationInterface<TestValidationInterface>\n+{\n+public:\n+    TestValidationInterface() : ValidationInterface() {}\n+\n+    std::optional<std::string> m_expected_valid_block = std::nullopt;\n+\n+    void BlockChecked(const UnownedBlock block, const BlockValidationState state) override\n+    {\n+        auto mode{state.ValidationMode()};\n+        switch (mode) {\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_VALID: {\n+            std::cout << \"Valid block\" << std::endl;\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID: {\n+            std::cout << \"Invalid block: \";\n+            auto result{state.BlockValidationResult()};\n+            switch (result) {\n+            case kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET:\n+                std::cout << \"initial value. Block has not yet been rejected\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK:\n+                std::cout << \"the block header may be on a too-little-work chain\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS:\n+                std::cout << \"invalid by consensus rules (excluding any below reasons)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID:\n+                std::cout << \"this block was cached as being invalid and we didn't store the reason why\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER:\n+                std::cout << \"invalid proof of work or time too old\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MUTATED:\n+                std::cout << \"the block's data didn't match the data committed to by the PoW\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV:\n+                std::cout << \"We don't have the previous block the checked one is built on\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV:\n+                std::cout << \"A block this one builds on is invalid\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE:\n+                std::cout << \"block timestamp was > 2 hours in the future (or our clock is bad)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT:\n+                std::cout << \"the block failed to meet one of our checkpoints\" << std::endl;\n+                break;\n+            }\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR: {\n+            std::cout << \"Internal error\" << std::endl;\n+            return;\n+        }\n+        }\n+    }\n+};\n+\n+class TestKernelNotifications : public KernelNotifications<TestKernelNotifications>\n+{\n+public:\n+    void BlockTipHandler(kernel_SynchronizationState state, const kernel_BlockIndex* index) override\n+    {\n+        std::cout << \"Block tip changed\" << std::endl;\n+    }\n+\n+    void ProgressHandler(std::string_view title, int progress_percent, bool resume_possible) override\n+    {\n+        std::cout << \"Made progress: \" << title << \" \" << progress_percent << \"%\" << std::endl;\n+    }\n+\n+    void WarningSetHandler(kernel_Warning warning, std::string_view message) override\n+    {\n+        std::cout << message << std::endl;\n+    }\n+\n+    void WarningUnsetHandler(kernel_Warning warning) override\n+    {\n+        std::cout << \"Warning unset: \" << warning << std::endl;\n+    }\n+\n+    void FlushErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+\n+    void FatalErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+};\n+\n+int main(int argc, char* argv[])\n+{\n+    // SETUP: Argument parsing and handling\n+    if (argc != 2) {\n+        std::cerr\n+            << \"Usage: \" << argv[0] << \" DATADIR\" << std::endl\n+            << \"Display DATADIR information, and process hex-encoded blocks on standard input.\" << std::endl\n+            << std::endl\n+            << \"IMPORTANT: THIS EXECUTABLE IS EXPERIMENTAL, FOR TESTING ONLY, AND EXPECTED TO\" << std::endl\n+            << \"           BREAK IN FUTURE VERSIONS. DO NOT USE ON YOUR ACTUAL DATADIR.\" << std::endl;\n+        return 1;\n+    }\n+    std::filesystem::path abs_datadir{std::filesystem::absolute(argv[1])};\n+    std::filesystem::create_directories(abs_datadir);\n+\n+    kernel_LoggingOptions logging_options = {\n+        .log_timestamps = true,\n+        .log_time_micros = false,\n+        .log_threadnames = false,\n+        .log_sourcelocations = false,\n+        .always_print_category_levels = true,\n+    };\n+\n+    Logger logger{std::make_unique<KernelLog>(KernelLog{}), logging_options};\n+\n+    ContextOptions options{};\n+    ChainParams params{kernel_ChainType::kernel_CHAIN_TYPE_REGTEST};\n+    options.SetChainParams(params);\n+\n+    TestKernelNotifications notifications{};\n+    options.SetNotifications(notifications);\n+    TestValidationInterface validation_interface{};\n+    options.SetValidationInterface(validation_interface);\n+\n+    Context context{options};\n+    assert(context);\n+\n+    ChainstateManagerOptions chainman_opts{context, abs_datadir};",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "in_reply_to_id": 1935834281,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I added it to the cross compiled windows job now, but it is going to take extra work (#31158) to add it to the native job too.",
      "created_at": "2025-01-31T12:22:01Z",
      "updated_at": "2025-01-31T12:22:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1937145120",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937145120"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938274204",
      "pull_request_review_id": 2588336382,
      "id": 1938274204,
      "node_id": "PRRC_kwDOABII585zh7ec",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <charconv>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+std::vector<unsigned char> hex_string_to_char_vec(std::string_view hex)\n+{\n+    std::vector<unsigned char> bytes;\n+    bytes.reserve(hex.length() / 2);\n+\n+    for (size_t i{0}; i < hex.length(); i += 2) {\n+        unsigned char byte;\n+        auto [ptr, ec] = std::from_chars(hex.data() + i, hex.data() + i + 2, byte, 16);\n+        if (ec == std::errc{} && ptr == hex.data() + i + 2) {\n+            bytes.push_back(byte);\n+        }\n+    }\n+    return bytes;\n+}\n+\n+class KernelLog\n+{\n+public:\n+    void LogMessage(std::string_view message)\n+    {\n+        std::cout << \"kernel: \" << message;\n+    }\n+};\n+\n+class TestValidationInterface : public ValidationInterface<TestValidationInterface>\n+{\n+public:\n+    TestValidationInterface() : ValidationInterface() {}\n+\n+    std::optional<std::string> m_expected_valid_block = std::nullopt;\n+\n+    void BlockChecked(const UnownedBlock block, const BlockValidationState state) override\n+    {\n+        auto mode{state.ValidationMode()};\n+        switch (mode) {\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_VALID: {\n+            std::cout << \"Valid block\" << std::endl;\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID: {\n+            std::cout << \"Invalid block: \";\n+            auto result{state.BlockValidationResult()};\n+            switch (result) {\n+            case kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET:\n+                std::cout << \"initial value. Block has not yet been rejected\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK:\n+                std::cout << \"the block header may be on a too-little-work chain\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS:\n+                std::cout << \"invalid by consensus rules (excluding any below reasons)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID:\n+                std::cout << \"this block was cached as being invalid and we didn't store the reason why\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER:\n+                std::cout << \"invalid proof of work or time too old\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MUTATED:\n+                std::cout << \"the block's data didn't match the data committed to by the PoW\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV:\n+                std::cout << \"We don't have the previous block the checked one is built on\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV:\n+                std::cout << \"A block this one builds on is invalid\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE:\n+                std::cout << \"block timestamp was > 2 hours in the future (or our clock is bad)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT:\n+                std::cout << \"the block failed to meet one of our checkpoints\" << std::endl;\n+                break;\n+            }\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR: {\n+            std::cout << \"Internal error\" << std::endl;\n+            return;\n+        }\n+        }\n+    }\n+};\n+\n+class TestKernelNotifications : public KernelNotifications<TestKernelNotifications>\n+{\n+public:\n+    void BlockTipHandler(kernel_SynchronizationState state, const kernel_BlockIndex* index) override\n+    {\n+        std::cout << \"Block tip changed\" << std::endl;\n+    }\n+\n+    void ProgressHandler(std::string_view title, int progress_percent, bool resume_possible) override\n+    {\n+        std::cout << \"Made progress: \" << title << \" \" << progress_percent << \"%\" << std::endl;\n+    }\n+\n+    void WarningSetHandler(kernel_Warning warning, std::string_view message) override\n+    {\n+        std::cout << message << std::endl;\n+    }\n+\n+    void WarningUnsetHandler(kernel_Warning warning) override\n+    {\n+        std::cout << \"Warning unset: \" << warning << std::endl;\n+    }\n+\n+    void FlushErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+\n+    void FatalErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+};\n+\n+int main(int argc, char* argv[])\n+{\n+    // SETUP: Argument parsing and handling\n+    if (argc != 2) {\n+        std::cerr\n+            << \"Usage: \" << argv[0] << \" DATADIR\" << std::endl\n+            << \"Display DATADIR information, and process hex-encoded blocks on standard input.\" << std::endl\n+            << std::endl\n+            << \"IMPORTANT: THIS EXECUTABLE IS EXPERIMENTAL, FOR TESTING ONLY, AND EXPECTED TO\" << std::endl\n+            << \"           BREAK IN FUTURE VERSIONS. DO NOT USE ON YOUR ACTUAL DATADIR.\" << std::endl;\n+        return 1;\n+    }\n+    std::filesystem::path abs_datadir{std::filesystem::absolute(argv[1])};\n+    std::filesystem::create_directories(abs_datadir);\n+\n+    kernel_LoggingOptions logging_options = {\n+        .log_timestamps = true,\n+        .log_time_micros = false,\n+        .log_threadnames = false,\n+        .log_sourcelocations = false,\n+        .always_print_category_levels = true,\n+    };\n+\n+    Logger logger{std::make_unique<KernelLog>(KernelLog{}), logging_options};\n+\n+    ContextOptions options{};\n+    ChainParams params{kernel_ChainType::kernel_CHAIN_TYPE_REGTEST};\n+    options.SetChainParams(params);\n+\n+    TestKernelNotifications notifications{};\n+    options.SetNotifications(notifications);\n+    TestValidationInterface validation_interface{};\n+    options.SetValidationInterface(validation_interface);\n+\n+    Context context{options};\n+    assert(context);\n+\n+    ChainstateManagerOptions chainman_opts{context, abs_datadir};",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "in_reply_to_id": 1935834281,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, added symbol exporting now, so we should have somewhat working windows support.",
      "created_at": "2025-02-01T13:13:59Z",
      "updated_at": "2025-02-01T13:13:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1938274204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938274204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938285967",
      "pull_request_review_id": 2588347929,
      "id": 1938285967,
      "node_id": "PRRC_kwDOABII585zh-WP",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#include <kernel/bitcoinkernel_wrapper.h>\n+\n+#include <cassert>\n+#include <charconv>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+std::vector<unsigned char> hex_string_to_char_vec(std::string_view hex)\n+{\n+    std::vector<unsigned char> bytes;\n+    bytes.reserve(hex.length() / 2);\n+\n+    for (size_t i{0}; i < hex.length(); i += 2) {\n+        unsigned char byte;\n+        auto [ptr, ec] = std::from_chars(hex.data() + i, hex.data() + i + 2, byte, 16);\n+        if (ec == std::errc{} && ptr == hex.data() + i + 2) {\n+            bytes.push_back(byte);\n+        }\n+    }\n+    return bytes;\n+}\n+\n+class KernelLog\n+{\n+public:\n+    void LogMessage(std::string_view message)\n+    {\n+        std::cout << \"kernel: \" << message;\n+    }\n+};\n+\n+class TestValidationInterface : public ValidationInterface<TestValidationInterface>\n+{\n+public:\n+    TestValidationInterface() : ValidationInterface() {}\n+\n+    std::optional<std::string> m_expected_valid_block = std::nullopt;\n+\n+    void BlockChecked(const UnownedBlock block, const BlockValidationState state) override\n+    {\n+        auto mode{state.ValidationMode()};\n+        switch (mode) {\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_VALID: {\n+            std::cout << \"Valid block\" << std::endl;\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID: {\n+            std::cout << \"Invalid block: \";\n+            auto result{state.BlockValidationResult()};\n+            switch (result) {\n+            case kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET:\n+                std::cout << \"initial value. Block has not yet been rejected\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK:\n+                std::cout << \"the block header may be on a too-little-work chain\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS:\n+                std::cout << \"invalid by consensus rules (excluding any below reasons)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID:\n+                std::cout << \"this block was cached as being invalid and we didn't store the reason why\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER:\n+                std::cout << \"invalid proof of work or time too old\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MUTATED:\n+                std::cout << \"the block's data didn't match the data committed to by the PoW\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV:\n+                std::cout << \"We don't have the previous block the checked one is built on\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV:\n+                std::cout << \"A block this one builds on is invalid\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE:\n+                std::cout << \"block timestamp was > 2 hours in the future (or our clock is bad)\" << std::endl;\n+                break;\n+            case kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT:\n+                std::cout << \"the block failed to meet one of our checkpoints\" << std::endl;\n+                break;\n+            }\n+            return;\n+        }\n+        case kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR: {\n+            std::cout << \"Internal error\" << std::endl;\n+            return;\n+        }\n+        }\n+    }\n+};\n+\n+class TestKernelNotifications : public KernelNotifications<TestKernelNotifications>\n+{\n+public:\n+    void BlockTipHandler(kernel_SynchronizationState state, const kernel_BlockIndex* index) override\n+    {\n+        std::cout << \"Block tip changed\" << std::endl;\n+    }\n+\n+    void ProgressHandler(std::string_view title, int progress_percent, bool resume_possible) override\n+    {\n+        std::cout << \"Made progress: \" << title << \" \" << progress_percent << \"%\" << std::endl;\n+    }\n+\n+    void WarningSetHandler(kernel_Warning warning, std::string_view message) override\n+    {\n+        std::cout << message << std::endl;\n+    }\n+\n+    void WarningUnsetHandler(kernel_Warning warning) override\n+    {\n+        std::cout << \"Warning unset: \" << warning << std::endl;\n+    }\n+\n+    void FlushErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+\n+    void FatalErrorHandler(std::string_view error) override\n+    {\n+        std::cout << error << std::endl;\n+    }\n+};\n+\n+int main(int argc, char* argv[])\n+{\n+    // SETUP: Argument parsing and handling\n+    if (argc != 2) {\n+        std::cerr\n+            << \"Usage: \" << argv[0] << \" DATADIR\" << std::endl\n+            << \"Display DATADIR information, and process hex-encoded blocks on standard input.\" << std::endl\n+            << std::endl\n+            << \"IMPORTANT: THIS EXECUTABLE IS EXPERIMENTAL, FOR TESTING ONLY, AND EXPECTED TO\" << std::endl\n+            << \"           BREAK IN FUTURE VERSIONS. DO NOT USE ON YOUR ACTUAL DATADIR.\" << std::endl;\n+        return 1;\n+    }\n+    std::filesystem::path abs_datadir{std::filesystem::absolute(argv[1])};\n+    std::filesystem::create_directories(abs_datadir);\n+\n+    kernel_LoggingOptions logging_options = {\n+        .log_timestamps = true,\n+        .log_time_micros = false,\n+        .log_threadnames = false,\n+        .log_sourcelocations = false,\n+        .always_print_category_levels = true,\n+    };\n+\n+    Logger logger{std::make_unique<KernelLog>(KernelLog{}), logging_options};\n+\n+    ContextOptions options{};\n+    ChainParams params{kernel_ChainType::kernel_CHAIN_TYPE_REGTEST};\n+    options.SetChainParams(params);\n+\n+    TestKernelNotifications notifications{};\n+    options.SetNotifications(notifications);\n+    TestValidationInterface validation_interface{};\n+    options.SetValidationInterface(validation_interface);\n+\n+    Context context{options};\n+    assert(context);\n+\n+    ChainstateManagerOptions chainman_opts{context, abs_datadir};",
      "path": "src/kernel/bitcoin-chainstate.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "01a43b24436e0aed7b8f79d3857630a4bf6a0545",
      "in_reply_to_id": 1935834281,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nice! Just to be clear: I only had issues with compiling the bitcoin-chainstate target, the bitcoinkernel library already was working fine (at least the functions covered with py-bitcoinkernel's test suite, which is not yet 100%) with the mingw32 cross-compiled binary.\r\n\r\n(But I suspect you're talking about \"somewhat working **native** windows support\", which I'm not using in my pipelines)",
      "created_at": "2025-02-01T14:39:55Z",
      "updated_at": "2025-02-01T14:39:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1938285967",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938285967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945424649",
      "pull_request_review_id": 2599912096,
      "id": 1945424649,
      "node_id": "PRRC_kwDOABII585z9NMJ",
      "diff_hunk": "@@ -211,6 +211,10 @@ function(add_all_test_targets)\n   endforeach()\n endfunction()\n \n+if (BUILD_KERNEL_TEST)\n+  add_subdirectory(kernel)\n+endif()\n+",
      "path": "src/test/CMakeLists.txt",
      "position": null,
      "original_position": 7,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "817865d57daa822370b0f67e1e079fdd25ab3130",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure if this is the best approach. `-DBUILD_KERNEL_LIB=ON -DBUILD_KERNEL_TEST=ON` should imo build the tests even if `-DBUILD_TESTS=OFF`. I think an approach where we update `src/CMakeLists.txt` with the below makes more sense (quick sketch)?\r\n\r\n```cmake\r\nif(BUILD_KERNEL_LIB)\r\n  add_subdirectory(kernel)\r\n  if (BUILD_KERNEL_TEST)\r\n    add_subdirectory(test/kernel)\r\n  endif()\r\nendif()\r\n```",
      "created_at": "2025-02-06T20:56:12Z",
      "updated_at": "2025-02-06T20:56:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1945424649",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945424649"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 214,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1957466889",
      "pull_request_review_id": 2619786584,
      "id": 1957466889,
      "node_id": "PRRC_kwDOABII5850rJMJ",
      "diff_hunk": "@@ -1,11 +1,1135 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "a604321c3e4bd50b52fa28e8567f6b068b2d2fb3",
      "in_reply_to_id": null,
      "user": {
        "login": "walterl",
        "id": 23798,
        "node_id": "MDQ6VXNlcjIzNzk4",
        "avatar_url": "https://avatars.githubusercontent.com/u/23798?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/walterl",
        "html_url": "https://github.com/walterl",
        "followers_url": "https://api.github.com/users/walterl/followers",
        "following_url": "https://api.github.com/users/walterl/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/walterl/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/walterl/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/walterl/subscriptions",
        "organizations_url": "https://api.github.com/users/walterl/orgs",
        "repos_url": "https://api.github.com/users/walterl/repos",
        "events_url": "https://api.github.com/users/walterl/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/walterl/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Isn't this supposed to return `kernel_UNKNOWN_NEW_RULES_ACTIVATED`?\r\n\r\n```suggestion\r\n        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\r\n```",
      "created_at": "2025-02-17T00:59:37Z",
      "updated_at": "2025-02-17T00:59:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1957466889",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1957466889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1958410398",
      "pull_request_review_id": 2621355378,
      "id": 1958410398,
      "node_id": "PRRC_kwDOABII5850uvie",
      "diff_hunk": "@@ -1,11 +1,1135 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 154,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "a604321c3e4bd50b52fa28e8567f6b068b2d2fb3",
      "in_reply_to_id": 1957466889,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed, I think I mixed this up at some point during a rebase. Thank!",
      "created_at": "2025-02-17T15:20:24Z",
      "updated_at": "2025-02-17T15:20:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1958410398",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1958410398"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1989793614",
      "pull_request_review_id": 2675490600,
      "id": 1989793614,
      "node_id": "PRRC_kwDOABII5852mddO",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 161,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this whole block is from a previous version and should now be removed?",
      "created_at": "2025-03-11T17:20:04Z",
      "updated_at": "2025-03-13T13:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1989793614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1989793614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 157,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991230564",
      "pull_request_review_id": 2675490600,
      "id": 1991230564,
      "node_id": "PRRC_kwDOABII5852r8Rk",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 641,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this shouldn't be `const`?\r\n\r\n```suggestion\r\nBITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\r\n```",
      "created_at": "2025-03-12T11:06:06Z",
      "updated_at": "2025-03-13T13:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991230564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991230564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 640,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991236489",
      "pull_request_review_id": 2675490600,
      "id": 1991236489,
      "node_id": "PRRC_kwDOABII5852r9uJ",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);\n+}\n+\n+bool kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().EnableCategory(log_category_to_string(category));\n+}\n+\n+bool kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().DisableCategory(log_category_to_string(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+const kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::Main().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet4().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::SigNet({}).release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::RegTest({}).release());\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_const_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{reinterpret_cast<const CChainParams*>(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // Copy the notifications, so the caller can free it again\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_CHECKPOINT:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_const_chainstate_manager_options(options);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 738,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I don't think it makes a functional difference, but it's a bit weird using the const cast here (+ for `ChainParameters`, `BlockUndo`)?",
      "created_at": "2025-03-12T11:09:57Z",
      "updated_at": "2025-03-13T13:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991236489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991236489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 734,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991274124",
      "pull_request_review_id": 2675490600,
      "id": 1991274124,
      "node_id": "PRRC_kwDOABII5852sG6M",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);\n+}\n+\n+bool kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().EnableCategory(log_category_to_string(category));\n+}\n+\n+bool kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().DisableCategory(log_category_to_string(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+const kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::Main().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet4().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::SigNet({}).release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::RegTest({}).release());\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_const_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{reinterpret_cast<const CChainParams*>(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 629,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This doesn't seem thread-safe (+ for ~all other setters). Since it seems we can't use std::atomic for most of these, adding a per-struct lock might be a good alternative?\r\n\r\nI can't think of a sane scenario where someone would _want_ to call the same setter from multiple threads, but... it's probably better to offer the guarantees anyway?",
      "created_at": "2025-03-12T11:27:57Z",
      "updated_at": "2025-03-13T13:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991274124",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991274124"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 649,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991290582",
      "pull_request_review_id": 2675490600,
      "id": 1991290582,
      "node_id": "PRRC_kwDOABII5852sK7W",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 164,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`kernel_context_destroy()` and `kernel_context_interrupt()` are the only places that take a non-`const` `kernel_Context`. I think we `kernel_Context`'s is no different to all other `*_destroy()` functions - in that they should never be called twice, regardless of the thread. And it seems to me that `kernel_context_interrupt()` is actually thread-safe. So, I think \"but functions taking...\" can be removed?\r\n\r\n(also nit: s/non-cost/non-const/)",
      "created_at": "2025-03-12T11:39:33Z",
      "updated_at": "2025-03-13T13:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1991290582",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1991290582"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 163,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1995386796",
      "pull_request_review_id": 2685229851,
      "id": 1995386796,
      "node_id": "PRRC_kwDOABII58527y-s",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 91,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This (+ in `log_category_to_string()` leads to runtime assertion errors for interpreted languages. It also means that `add_log_level_category()`, `enable_log_category()` and `disable_log_category()` are basically `void` instead of `bool` because they can only return `true` (or crash).\r\n\r\nE.g. in python:\r\n\r\n```\r\n>>> pbk.add_log_level_category(99, 20)\r\nAssertion failed: (false), function log_level_to_string, file bitcoinkernel.cpp, line 87.\r\nzsh: abort      python\r\n```",
      "created_at": "2025-03-14T11:31:34Z",
      "updated_at": "2025-03-14T18:41:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1995386796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1995386796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 88,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1995405051",
      "pull_request_review_id": 2685229851,
      "id": 1995405051,
      "node_id": "PRRC_kwDOABII585273b7",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 523,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This back-and-forth string conversion feels suboptimal. Perhaps an alternative approach would be to keep the integer values between `kernel_LogCategory` the same as `BCLog::LogFlags` and just define a kernel-specific bitfield that defines which `BCLog` flags are valid? I don't think the `kernel_LogCategory` enum values being non-continuous is a problem, since this might happen in the future anyway e.g. if certain components are moved out of kernel scope?",
      "created_at": "2025-03-14T11:43:11Z",
      "updated_at": "2025-03-14T18:41:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1995405051",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1995405051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1995880696",
      "pull_request_review_id": 2685229851,
      "id": 1995880696,
      "node_id": "PRRC_kwDOABII58529rj4",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 350,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since log levels are ordered, would it be prudent to reserve space for intermediate levels? E.g. if we decide we do want to add WARNING/ERROR later, we'd have to change existing log levels.",
      "created_at": "2025-03-14T16:27:18Z",
      "updated_at": "2025-03-14T18:41:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1995880696",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1995880696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 346,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996761714",
      "pull_request_review_id": 2687624148,
      "id": 1996761714,
      "node_id": "PRRC_kwDOABII5853BCpy",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once. Log messages will be buffered until\n+ * this function is called, or a logging connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not enable\n+ * the selected categories. Use `kernel_enable_log_category` to start logging\n+ * from a specific, or all categories.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ * @return             True on success.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ * @return             True on success.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * Disable a specific log category for the global internal logger.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ * @return             True on success.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API const kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 641,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1991230564,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It shouldn't be, but annoyingly this is not trivial to change. Since the functions constructing the params in our code only return const types, we have to carry that const into our API. I think the only alternative is copying the params, which I will push shortly.",
      "created_at": "2025-03-15T10:51:45Z",
      "updated_at": "2025-03-15T10:51:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1996761714",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996761714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 640,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996815658",
      "pull_request_review_id": 2687686722,
      "id": 1996815658,
      "node_id": "PRRC_kwDOABII5853BP0q",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 91,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1995386796,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> This (+ in log_category_to_string() leads to runtime assertion errors for interpreted languages\r\n\r\nI think the problem here is that the C enums are weakly typed, and if you use them in weakly typed languages you run into these problems. I think the function signature should already give enough of a hint on what the range of allowed values is. That said, I'll change this to instead return `std::nullopt` and then return false from there.\r\n\r\nEDIT: Changed my mind, rather added a function to the logger so we can always use the enums and don't need stringy \"types\".",
      "created_at": "2025-03-15T12:31:30Z",
      "updated_at": "2025-03-15T16:59:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1996815658",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996815658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 88,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996842801",
      "pull_request_review_id": 2687725971,
      "id": 1996842801,
      "node_id": "PRRC_kwDOABII5853BWcx",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 350,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1995880696,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think we need to rely on the order inside the enumeration here. That said, it could also just mirror the values in the `BCLog::Level`. I left out `Warning` and `Error` because you can't really control those right now.",
      "created_at": "2025-03-15T12:55:33Z",
      "updated_at": "2025-03-15T12:55:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1996842801",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996842801"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 346,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997117045",
      "pull_request_review_id": 2688107110,
      "id": 1997117045,
      "node_id": "PRRC_kwDOABII5853CZZ1",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);\n+}\n+\n+bool kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().EnableCategory(log_category_to_string(category));\n+}\n+\n+bool kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().DisableCategory(log_category_to_string(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+const kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::Main().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet4().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::SigNet({}).release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::RegTest({}).release());\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_const_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{reinterpret_cast<const CChainParams*>(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 629,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1991274124,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just noticed that the same is also true for the logger, but unlike the options, I can actually see multiple threads accessing it. I don't think we should fix that now though, to me it feels more important to have non-global logging objects first.",
      "created_at": "2025-03-15T17:35:45Z",
      "updated_at": "2025-03-17T17:20:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1997117045",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997117045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 649,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997340094",
      "pull_request_review_id": 2688353493,
      "id": 1997340094,
      "node_id": "PRRC_kwDOABII5853DP2-",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);\n+}\n+\n+bool kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().EnableCategory(log_category_to_string(category));\n+}\n+\n+bool kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().DisableCategory(log_category_to_string(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+const kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::Main().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet4().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::SigNet({}).release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::RegTest({}).release());\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_const_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{reinterpret_cast<const CChainParams*>(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // Copy the notifications, so the caller can free it again\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_CHECKPOINT:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CHECKPOINT;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_const_chainstate_manager_options(options);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 738,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1991236489,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-15T21:46:41Z",
      "updated_at": "2025-03-15T21:46:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1997340094",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997340094"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 734,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997340229",
      "pull_request_review_id": 2688353623,
      "id": 1997340229,
      "node_id": "PRRC_kwDOABII5853DP5F",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 523,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1995405051,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not quite sure what you meant with \"Perhaps an alternative approach would be to keep the integer values between kernel_LogCategory the same as BCLog::LogFlags and just define a kernel-specific bitfield that defines which BCLog flags are valid\". Does the current approach work for you?",
      "created_at": "2025-03-15T21:47:36Z",
      "updated_at": "2025-03-15T21:47:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1997340229",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997340229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1998587491",
      "pull_request_review_id": 2690213857,
      "id": 1998587491,
      "node_id": "PRRC_kwDOABII5853IAZj",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 523,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1995405051,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I meant have `kernel_LogCategory` be a subset of `BCLog::LogFlags`, instead of having to remap them. But I didn't realize that that would either require including logging.h in bitcoinkernel.h (impossible), or manually ensuring the enums are synced (bad).\r\n\r\nMy main gripe was the string re-conversion, which is now gone - so yes, current approach resolves my concern, thanks!",
      "created_at": "2025-03-17T12:05:29Z",
      "updated_at": "2025-03-17T12:05:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1998587491",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1998587491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 521,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1999116127",
      "pull_request_review_id": 2691176535,
      "id": 1999116127,
      "node_id": "PRRC_kwDOABII5853KBdf",
      "diff_hunk": "@@ -1,11 +1,1134 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+std::string log_level_to_string(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return \"info\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return \"debug\";\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return \"trace\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+std::string log_category_to_string(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return \"bench\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return \"blockstorage\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return \"coindb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return \"leveldb\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_LOCK: {\n+        return \"lock\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return \"mempool\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return \"prune\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return \"rand\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return \"reindex\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return \"validation\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return \"kernel\";\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return \"all\";\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    std::unique_ptr<const KernelNotifications> m_notifications;\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface;\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options && options->m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+        } else {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (options && options->m_chainparams) {\n+            m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+        } else {\n+            m_chainparams = CChainParams::Main();\n+        }\n+\n+        if (options && options->m_validation_interface) {\n+            m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+            m_signals->RegisterValidationInterface(m_validation_interface.get());\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    ChainstateManager::Options m_chainman_options;\n+    node::BlockManager::Options m_blockman_options;\n+    node::ChainstateLoadOptions m_chainstate_load_options;\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+bool kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level_)\n+{\n+    const auto level{log_level_to_string(level_)};\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        return LogInstance().SetLogLevel(level);\n+    }\n+\n+    return LogInstance().SetCategoryLogLevel(log_category_to_string(category), level);\n+}\n+\n+bool kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().EnableCategory(log_category_to_string(category));\n+}\n+\n+bool kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    return LogInstance().DisableCategory(log_category_to_string(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+const kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::Main().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::TestNet4().release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::SigNet({}).release());\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        return reinterpret_cast<const kernel_ChainParameters*>(CChainParams::RegTest({}).release());\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(const kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_const_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{reinterpret_cast<const CChainParams*>(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 629,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1991274124,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> to me it feels more important to have non-global logging objects first.\r\n\r\nAgreed. Updating the docs to reflect this might be good though, e.g.:\r\n\r\n>   * Not thread-safe. Logging is global. Multiple calls are allowed but\r\n> * must be synchronized and will override previous settings for all\r\n> * existing `kernel_LoggingConnection` instances.",
      "created_at": "2025-03-17T16:08:11Z",
      "updated_at": "2025-03-17T16:08:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r1999116127",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1999116127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 649,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2000864918",
      "pull_request_review_id": 2694197292,
      "id": 2000864918,
      "node_id": "PRRC_kwDOABII5853QsaW",
      "diff_hunk": "@@ -0,0 +1,1197 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing `kernelLoggingConnection instances.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 574,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "typo nit (+ in 2 other log functions)\r\n```suggestion\r\n * all existing `kernel_LoggingConnection instances.\r\n```",
      "created_at": "2025-03-18T11:47:08Z",
      "updated_at": "2025-03-20T19:03:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2000864918",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2000864918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 574,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006272875",
      "pull_request_review_id": 2694197292,
      "id": 2006272875,
      "node_id": "PRRC_kwDOABII5853lUtr",
      "diff_hunk": "@@ -1,11 +1,1158 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (!options) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+            m_chainparams = CChainParams::Main();\n+        } else {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 262,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The [latest force-push](https://github.com/TheCharlatan/bitcoin/compare/kernelApi_29..kernelApi_30) broke this logic by leaving `m_chainparams` and `m_notifications` uninitialized if `options` is non-nullptr, but the respective options members are nullptr.\r\n\r\nSuggested fix:\r\n\r\n<details>\r\n<summary>git diff on 2dc27e2860</summary>\r\n\r\n```diff\r\ndiff --git a/src/kernel/bitcoinkernel.cpp b/src/kernel/bitcoinkernel.cpp\r\nindex 0cb2d69cec..1e6c582357 100644\r\n--- a/src/kernel/bitcoinkernel.cpp\r\n+++ b/src/kernel/bitcoinkernel.cpp\r\n@@ -240,11 +240,7 @@ public:\r\n           m_interrupt{std::make_unique<util::SignalInterrupt>()},\r\n           m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\r\n     {\r\n-        if (!options) {\r\n-            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\r\n-                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\r\n-            m_chainparams = CChainParams::Main();\r\n-        } else {\r\n+        if (options) {\r\n             LOCK(options->m_mutex);\r\n             if (options->m_chainparams) {\r\n                 m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\r\n@@ -256,7 +252,13 @@ public:\r\n                 m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\r\n                 m_signals->RegisterValidationInterface(m_validation_interface.get());\r\n             }\r\n-\r\n+        }\r\n+        if (!m_notifications) {\r\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\r\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\r\n+        }\r\n+        if (!m_chainparams) {\r\n+            m_chainparams = CChainParams::Main();\r\n         }\r\n \r\n         if (!kernel::SanityChecks(*m_context)) {\r\n\r\n```\r\n</details>\r\n\r\nThis did not fail/break `test_kernel.cpp` because the test explicitly sets the options in `create_context()`:\r\n\r\n```cpp\r\n    options.SetChainParams(params);\r\n    options.SetNotifications(notifications);\r\n```\r\n\r\n`py-bitcoinkernel` does not automatically do that, which is causing segfaults for `kernel_chainstate_manager_create` in the test suite there.",
      "created_at": "2025-03-20T18:57:44Z",
      "updated_at": "2025-03-20T19:03:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2006272875",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006272875"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006290487",
      "pull_request_review_id": 2703841630,
      "id": 2006290487,
      "node_id": "PRRC_kwDOABII5853lZA3",
      "diff_hunk": "@@ -0,0 +1,1197 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing `kernelLoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 581,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is the rationale behind requiring to first add, and then {enable,disable} the category? An alternative would be a single `kernel_set_log_level_category`, which immediately \"enables\" (I think it's a strange term anyway) the category at the given level. \"Disabling\" would be achieved by calling `kernel_set_log_level_category` again with a higher (i.e. less granular) level, again taking effect immediately.\r\n\r\nI can't think of any use cases that require separating this in 3 functions? I think it would simultaneously be more intuitive and ergonomic, and probably also less code?",
      "created_at": "2025-03-20T19:10:59Z",
      "updated_at": "2025-03-20T19:10:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2006290487",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006290487"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 589,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006309594",
      "pull_request_review_id": 2703873713,
      "id": 2006309594,
      "node_id": "PRRC_kwDOABII5853ldra",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging().\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task\n+ * runner owned by the context. The task runner drives the execution of events\n+ * triggering validation interface callbacks. Multiple validation interfaces can\n+ * be registered with the context. The kernel will create an event for each of\n+ * the registered validation interfaces through the task runner.\n+ *\n+ * A constructed context can be safely used from multiple threads, but functions\n+ * taking it as a non-cost argument need exclusive access to it.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_CHECKPOINT,      //!< the block failed to meet one of our checkpoints\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_LOCK,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_INFO = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_TRACE,\n+} kernel_LogLevel;",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 350,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "29513955891e40e78466f2c666dfa13e9c1b2914",
      "in_reply_to_id": 1995880696,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I don't think we need to rely on the order inside the enumeration here\r\n\r\nI don't think it's required, but it is slightly convenient when they are? E.g. when implementing `py-bitcoinkernel`'s logging, being able to rely on the order of `kernel_LogLevel` helps the implementation a bit (and it is also how these level enums are usually implemented in most logging libraries, I think). As one example, I think using the same values as the python `logging` library could be sensible: https://docs.python.org/3/library/logging.html#logging-levels (with e.g. 5 for TRACE)\r\n\r\n> That said, it could also just mirror the values in the BCLog::Level\r\n\r\nThere is benefit in exposing them all, yes. It'll be essential if/when we updated the logging callback to expose a `kernel_Log` struct instead of a string (as per my comment [here](https://github.com/bitcoin/bitcoin/pull/30595#pullrequestreview-2685229851)), and a nice-to-have even for string-parsing as it helps inform which categories could appear in the log output (even if the enums don't encode their string representation).\r\n\r\nNone of this is crucial, just sharing my thoughts.\r\n",
      "created_at": "2025-03-20T19:23:54Z",
      "updated_at": "2025-03-20T19:23:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2006309594",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006309594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 346,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006471733",
      "pull_request_review_id": 2704140654,
      "id": 2006471733,
      "node_id": "PRRC_kwDOABII5853mFQ1",
      "diff_hunk": "@@ -1,11 +1,1158 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index));\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (!options) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+            m_chainparams = CChainParams::Main();\n+        } else {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 262,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "in_reply_to_id": 2006272875,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks! I also added a regression test. Sorry for not catching this earlier!",
      "created_at": "2025-03-20T21:20:43Z",
      "updated_at": "2025-03-20T21:20:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2006471733",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006471733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 243,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006477122",
      "pull_request_review_id": 2704152293,
      "id": 2006477122,
      "node_id": "PRRC_kwDOABII5853mGlC",
      "diff_hunk": "@@ -0,0 +1,1197 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing `kernelLoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 581,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "2dc27e2860b97c2bffa5f18706917b21858e5594",
      "in_reply_to_id": 2006290487,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This should just mirror the internal code at the moment, but I agree that it is not really useful to split this up. Will see if I can consolidate this.",
      "created_at": "2025-03-20T21:25:30Z",
      "updated_at": "2025-03-20T21:25:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2006477122",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2006477122"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 589,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2173853678",
      "pull_request_review_id": 2969368786,
      "id": 2173853678,
      "node_id": "PRRC_kwDOABII586Bkl_u",
      "diff_hunk": "@@ -149,3 +149,5 @@ install(TARGETS bitcoinkernel\n     DESTINATION ${CMAKE_INSTALL_LIBDIR}\n     COMPONENT libbitcoinkernel\n )\n+\n+install(FILES bitcoinkernel.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT Kernel)",
      "path": "src/kernel/CMakeLists.txt",
      "position": null,
      "original_position": 5,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "d9e030d56343bb452d86169f77ddfb64f7160235",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think `COMPONENT Kernel` should become `COMPONENT libbitcoinkernel`. Noticed when running `cmake --install build --component libbitcoinkernel` the header file wasn't being installed.",
      "created_at": "2025-06-29T18:29:15Z",
      "updated_at": "2025-06-29T18:29:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2173853678",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2173853678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203431643",
      "pull_request_review_id": 3014202096,
      "id": 2203431643,
      "node_id": "PRRC_kwDOABII586DVbLb",
      "diff_hunk": "@@ -1,11 +1,1180 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::Main());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet4());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::SigNet({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        CChainParams* params = new CChainParams(*CChainParams::RegTest({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{cast_const_chain_params(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // Copy the notifications, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    LOCK(options->m_mutex);\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_chainstate_manager_options(options);\n+    }\n+}\n+\n+bool kernel_chainstate_manager_options_set_wipe_dbs(kernel_ChainstateManagerOptions* chainman_opts_, bool wipe_block_tree_db, bool wipe_chainstate_db)\n+{\n+    if (wipe_block_tree_db && !wipe_chainstate_db) {\n+        LogError(\"Wiping the block tree db without also wiping the chainstate db is currently unsupported.\");\n+        return false;\n+    }\n+    auto opts{cast_chainstate_manager_options(chainman_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.wipe_data = wipe_block_tree_db;\n+    opts->m_chainstate_load_options.wipe_chainstate_db = wipe_chainstate_db;\n+    return true;\n+}\n+\n+void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool block_tree_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.memory_only = block_tree_db_in_memory;\n+}\n+\n+void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool chainstate_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainstate_load_options.coins_db_in_memory = chainstate_db_in_memory;\n+}\n+\n+kernel_ChainstateManager* kernel_chainstate_manager_create(\n+    const kernel_Context* context_,\n+    const kernel_ChainstateManagerOptions* chainman_opts_)\n+{\n+    auto chainman_opts{cast_const_chainstate_manager_options(chainman_opts_)};\n+    auto context{cast_const_context(context_)};\n+\n+    ChainstateManager* chainman;\n+\n+    try {\n+        LOCK(chainman_opts->m_mutex);\n+        chainman = new ChainstateManager{*context->m_interrupt, chainman_opts->m_chainman_options, chainman_opts->m_blockman_options};\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    try {\n+        const auto chainstate_load_opts{WITH_LOCK(chainman_opts->m_mutex, return chainman_opts->m_chainstate_load_options)};\n+\n+        kernel::CacheSizes cache_sizes{DEFAULT_KERNEL_CACHE};\n+        auto [status, chainstate_err]{node::LoadChainstate(*chainman, cache_sizes, chainstate_load_opts)};\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to load chain state from your data directory: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+        std::tie(status, chainstate_err) = node::VerifyLoadedChainstate(*chainman, chainstate_load_opts);\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to verify loaded chain state from your datadir: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+\n+        for (Chainstate* chainstate : WITH_LOCK(chainman->GetMutex(), return chainman->GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n+                LogError(\"Failed to connect best block: %s\", state.ToString());\n+                kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+                return nullptr;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to load chainstate: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_ChainstateManager*>(chainman);\n+}\n+\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainman_, const kernel_Context* context_)\n+{\n+    if (!chainman_) return;\n+\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    {\n+        LOCK(chainman->GetMutex());\n+        for (Chainstate* chainstate : chainman->GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n+        }\n+    }\n+\n+    delete chainman;\n+    return;\n+}\n+\n+bool kernel_import_blocks(const kernel_Context* context_,\n+                          kernel_ChainstateManager* chainman_,\n+                          const char** block_file_paths,\n+                          size_t* block_file_paths_lens,\n+                          size_t block_file_paths_len)\n+{\n+    try {\n+        auto chainman{cast_chainstate_manager(chainman_)};\n+        std::vector<fs::path> import_files;\n+        import_files.reserve(block_file_paths_len);\n+        for (uint32_t i = 0; i < block_file_paths_len; i++) {\n+            if (block_file_paths[i] != nullptr) {\n+                import_files.emplace_back(std::string{block_file_paths[i], block_file_paths_lens[i]}.c_str());\n+            }\n+        }\n+        node::ImportBlocks(*chainman, import_files);\n+        chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to import blocks: %s\", e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+kernel_Block* kernel_block_create(const unsigned char* raw_block, size_t raw_block_length)\n+{\n+    auto block{new CBlock()};\n+\n+    DataStream stream{std::span{raw_block, raw_block_length}};\n+\n+    try {\n+        stream >> TX_WITH_WITNESS(*block);\n+    } catch (const std::exception&) {\n+        delete block;\n+        LogDebug(BCLog::KERNEL, \"Block decode failed.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_Block*>(new std::shared_ptr<CBlock>(block));\n+}\n+\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array)\n+{\n+    if (byte_array && byte_array->data) delete[] byte_array->data;\n+    if (byte_array) delete byte_array;\n+}\n+\n+kernel_ByteArray* kernel_copy_block_data(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(**block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_ByteArray* kernel_copy_block_pointer_data(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(*block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_BlockHash* kernel_block_get_hash(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+    auto hash{(*block)->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+kernel_BlockHash* kernel_block_pointer_get_hash(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    auto hash{block->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+void kernel_block_destroy(kernel_Block* block)\n+{\n+    if (block) {\n+        delete cast_cblocksharedpointer(block);\n+    }\n+}\n+\n+kernel_BlockIndex* kernel_get_block_index_from_tip(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Tip()));\n+}\n+\n+kernel_BlockIndex* kernel_get_block_index_from_genesis(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Genesis()));\n+}\n+\n+kernel_BlockIndex* kernel_get_block_index_from_hash(const kernel_Context* context_, kernel_ChainstateManager* chainman_, kernel_BlockHash* block_hash)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto hash = uint256{std::span<const unsigned char>{(*block_hash).hash, 32}};\n+    auto block_index = WITH_LOCK(chainman->GetMutex(), return chainman->m_blockman.LookupBlockIndex(hash));\n+    if (!block_index) {\n+        LogDebug(BCLog::KERNEL, \"A block with the given hash is not indexed.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index);\n+}\n+\n+kernel_BlockIndex* kernel_get_block_index_from_height(const kernel_Context* context_, kernel_ChainstateManager* chainman_, int height)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    LOCK(chainman->GetMutex());\n+\n+    if (height < 0 || height > chainman->ActiveChain().Height()) {\n+        LogDebug(BCLog::KERNEL, \"Block height is out of range.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(chainman->ActiveChain()[height]);\n+}\n+\n+kernel_BlockIndex* kernel_get_next_block_index(const kernel_Context* context_, kernel_ChainstateManager* chainman_, const kernel_BlockIndex* block_index_)\n+{\n+    const auto block_index{cast_const_block_index(block_index_)};\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto next_block_index{WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Next(block_index))};\n+\n+    if (!next_block_index) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the tip of the current chain, it does not have a next.\");\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(next_block_index);\n+}\n+\n+kernel_BlockIndex* kernel_get_previous_block_index(const kernel_BlockIndex* block_index_)\n+{\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    if (!block_index->pprev) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the genesis, it has no previous.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index->pprev);\n+}\n+\n+kernel_Block* kernel_read_block_from_disk(const kernel_Context* context_,\n+                                          kernel_ChainstateManager* chainman_,\n+                                          const kernel_BlockIndex* block_index_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    auto block{new std::shared_ptr<CBlock>(new CBlock{})};\n+    if (!chainman->m_blockman.ReadBlock(**block, *block_index)) {\n+        LogError(\"Failed to read block.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Block*>(block);\n+}\n+\n+kernel_BlockUndo* kernel_read_block_undo_from_disk(const kernel_Context* context_,\n+                                                   kernel_ChainstateManager* chainman_,\n+                                                   const kernel_BlockIndex* block_index_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    const auto block_index{cast_const_block_index(block_index_)};\n+\n+    if (block_index->nHeight < 1) {\n+        LogDebug(BCLog::KERNEL, \"The genesis block does not have undo data.\");\n+        return nullptr;\n+    }\n+    auto block_undo{new CBlockUndo{}};\n+    if (!chainman->m_blockman.ReadBlockUndo(*block_undo, *block_index)) {\n+        LogError(\"Failed to read block undo data.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockUndo*>(block_undo);\n+}\n+\n+void kernel_block_index_destroy(kernel_BlockIndex* block_index)\n+{\n+    // This is just a dummy function. The user does not control block index memory.\n+    return;\n+}\n+\n+uint64_t kernel_block_undo_size(const kernel_BlockUndo* block_undo_)\n+{\n+    const auto block_undo{cast_const_block_undo(block_undo_)};\n+    return block_undo->vtxundo.size();\n+}\n+\n+void kernel_block_undo_destroy(kernel_BlockUndo* block_undo)\n+{\n+    if (block_undo) {\n+        delete cast_block_undo(block_undo);\n+    }\n+}\n+\n+uint64_t kernel_get_transaction_undo_size(const kernel_BlockUndo* block_undo_, uint64_t transaction_undo_index)\n+{\n+    const auto block_undo{cast_const_block_undo(block_undo_)};\n+    return block_undo->vtxundo[transaction_undo_index].vprevout.size();\n+}",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 1093,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could we check and return zero if `transaction_undo_index` is out of bounds here as well? (and then update the documentation in the header file that zero return value is indicative of out of bounds error)",
      "created_at": "2025-07-13T15:45:41Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203431643",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203431643"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 1087,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1056,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203432158",
      "pull_request_review_id": 3014202096,
      "id": 2203432158,
      "node_id": "PRRC_kwDOABII586DVbTe",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 82,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Might be good to include that returning zero could also be indicative of an error.",
      "created_at": "2025-07-13T15:48:06Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203432158",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203432158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 81,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203435973",
      "pull_request_review_id": 3014202096,
      "id": 2203435973,
      "node_id": "PRRC_kwDOABII586DVcPF",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_height(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The next block index in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_next_block_index(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the previous block index in the chain, or null if the current\n+ * block index entry is the genesis block.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The previous block index, or null on error or if the current block index is the genesis block.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_previous_block_index(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the height of a certain block index.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The block height.\n+ */\n+BITCOINKERNEL_API int32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_height(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+\n+/**\n+ * @brief Destroy the block index.\n+ */\n+BITCOINKERNEL_API void kernel_block_index_destroy(kernel_BlockIndex* block_index);\n+\n+///@}\n+\n+/** @name BlockUndo\n+ * Functions for working with block undo data.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block undo data the passed in block index points to from\n+ * disk and returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block undo data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockUndo* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_undo_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the number of transactions whose undo data is contained in\n+ * block undo.\n+ *\n+ * @param[in] block_undo Non-null.\n+ * @return               The number of transaction undo data in the block undo.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_size(\n+    const kernel_BlockUndo* block_undo\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the number of previous transaction outputs contained in the\n+ * transaction undo data.\n+ *\n+ * @param[in] block_undo             Non-null, the block undo data from which tx_undo was retrieved from.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @return                           The number of previous transaction outputs in the transaction.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_transaction_undo_size(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the block height of the block that contains the output at\n+ * output_index within the transaction undo data at the provided index of the\n+ * block undo data.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the targeted transaction output within the transaction\n+ *                                   undo data.\n+ * @return                           The block height of the output, or 0 if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API uint32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_undo_output_height_by_index(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index,\n+    uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return a transaction output contained in the transaction undo data of\n+ * a block undo data at a certain index.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the to be retrieved transaction output within the\n+ *                                   transaction undo data.\n+ * @return                           A transaction output pointer, or null if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_undo_output_by_index(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index,\n+    uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1187,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In the corresponding [commit](https://github.com/bitcoin/bitcoin/commit/d031c5871e47112a93b25a0612123a5b3eaf2a33) description it is included that _the returned `kernel_TransactionOutput` is entirely owned by the user\r\nand ..._ . It would be nice to also include the explanation here.",
      "created_at": "2025-07-13T16:01:12Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203435973",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203435973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 1173,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203438688",
      "pull_request_review_id": 3014202096,
      "id": 2203438688,
      "node_id": "PRRC_kwDOABII586DVc5g",
      "diff_hunk": "@@ -1,11 +1,1180 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::Main());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet4());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::SigNet({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        CChainParams* params = new CChainParams(*CChainParams::RegTest({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{cast_const_chain_params(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // Copy the notifications, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 660,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think the comment does not apply here.",
      "created_at": "2025-07-13T16:12:18Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203438688",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203438688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 652,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 681,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203460324",
      "pull_request_review_id": 3014202096,
      "id": 2203460324,
      "node_id": "PRRC_kwDOABII586DViLk",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 589,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was thinking why this is not named `kernel_set_log_level_category` as it **sets** the log level for a category. But perhaps we cannot since the name is already taken in `logging.h` for a different purpose. ",
      "created_at": "2025-07-13T16:36:57Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203460324",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203460324"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 589,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203462548",
      "pull_request_review_id": 3014202096,
      "id": 2203462548,
      "node_id": "PRRC_kwDOABII586DViuU",
      "diff_hunk": "@@ -1,11 +1,1180 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_copy_script_pubkey_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_add_log_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_enable_log_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_disable_log_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_disable_logging()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // We are not buffering if we have a connection, so check that it is not the\n+    // last available connection.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 603,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Might be worth making the doc a bit more explicit to say sth like \"switch back to buffering logs if no connections remain\" since `DisconnectTestLogger()` doesn't clearly indicate this behavior from its name.",
      "created_at": "2025-07-13T16:45:57Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203462548",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203462548"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 597,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 631,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203475130",
      "pull_request_review_id": 3014202096,
      "id": 2203475130,
      "node_id": "PRRC_kwDOABII586DVly6",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1019,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```suggestion\r\n * @return                       The block index of the current tip, or null if no active chain exists.\r\n```",
      "created_at": "2025-07-13T17:37:51Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203475130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203475130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1019,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203475273",
      "pull_request_review_id": 3014202096,
      "id": 2203475273,
      "node_id": "PRRC_kwDOABII586DVl1J",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_height(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The next block index in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_next_block_index(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the previous block index in the chain, or null if the current\n+ * block index entry is the genesis block.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The previous block index, or null on error or if the current block index is the genesis block.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_previous_block_index(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the height of a certain block index.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The block height.\n+ */\n+BITCOINKERNEL_API int32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_height(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+\n+/**\n+ * @brief Destroy the block index.\n+ */\n+BITCOINKERNEL_API void kernel_block_index_destroy(kernel_BlockIndex* block_index);\n+\n+///@}\n+\n+/** @name BlockUndo\n+ * Functions for working with block undo data.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block undo data the passed in block index points to from\n+ * disk and returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block undo data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockUndo* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_undo_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the number of transactions whose undo data is contained in\n+ * block undo.\n+ *\n+ * @param[in] block_undo Non-null.\n+ * @return               The number of transaction undo data in the block undo.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_size(\n+    const kernel_BlockUndo* block_undo\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the number of previous transaction outputs contained in the\n+ * transaction undo data.\n+ *\n+ * @param[in] block_undo             Non-null, the block undo data from which tx_undo was retrieved from.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @return                           The number of previous transaction outputs in the transaction.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_transaction_undo_size(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the block height of the block that contains the output at\n+ * output_index within the transaction undo data at the provided index of the\n+ * block undo data.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the targeted transaction output within the transaction\n+ *                                   undo data.\n+ * @return                           The block height of the output, or 0 if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API uint32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_undo_output_height_by_index(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index,\n+    uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return a transaction output contained in the transaction undo data of\n+ * a block undo data at a certain index.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the to be retrieved transaction output within the\n+ *                                   transaction undo data.\n+ * @return                           A transaction output pointer, or null if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_undo_output_by_index(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index,\n+    uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block undo data.\n+ */\n+BITCOINKERNEL_API void kernel_block_undo_destroy(kernel_BlockUndo* block_undo);\n+\n+///@}\n+\n+/** @name BlockHash\n+ * Functions for working with block hashes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Return the block hash associated with a block index.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return    The block hash.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1205,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```suggestion\r\n * @return    The block hash, or null if the block index has no associated hash.\r\n```",
      "created_at": "2025-07-13T17:38:29Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203475273",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203475273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1205,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203479560",
      "pull_request_review_id": 3014202096,
      "id": 2203479560,
      "node_id": "PRRC_kwDOABII586DVm4I",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1044,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Null reason could be more explicit:\r\n```suggestion\r\n * @return                       The block index of the block with the passed in hash, or null if block hash not found.\r\n```",
      "created_at": "2025-07-13T17:55:49Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203479560",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203479560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1044,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203479761",
      "pull_request_review_id": 3014202096,
      "id": 2203479761,
      "node_id": "PRRC_kwDOABII586DVm7R",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain, or null on error.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1059,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Null reason could be more explicit:\r\n```suggestion\r\n * @return                       The block index at a certain height in the currently active chain, or null if height is out of bounds.\r\n```",
      "created_at": "2025-07-13T17:56:27Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203479761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203479761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1059,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203480066",
      "pull_request_review_id": 3014202096,
      "id": 2203480066,
      "node_id": "PRRC_kwDOABII586DVnAC",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_height(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The next block index in the currently active chain, or null on error.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1075,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Null reason could be more explicit:\r\n```suggestion\r\n * @return                       The next block index in the currently active chain, or null if block is tip of chain.\r\n```",
      "created_at": "2025-07-13T17:57:39Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203480066",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203480066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1075,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203480783",
      "pull_request_review_id": 3014202096,
      "id": 2203480783,
      "node_id": "PRRC_kwDOABII586DVnLP",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 461,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As far as I understand from the implementation, there is no case we return null on error for this. Also for `kernel_copy_block_data` and `kernel_copy_block_pointer_data` functions.",
      "created_at": "2025-07-13T18:00:37Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203480783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203480783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 461,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203482913",
      "pull_request_review_id": 3014202096,
      "id": 2203482913,
      "node_id": "PRRC_kwDOABII586DVnsh",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 310,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In the corresponding [commit](https://github.com/bitcoin/bitcoin/commit/e5870b8253f81496f39ae035226ca9e1944ed667) description it is stated that _the callbacks block any further validation execution when they are called. It is up to the user to ..._ . Would be nice to also mention this blocking nature in the header file docs. ",
      "created_at": "2025-07-13T18:10:55Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203482913",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203482913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": 300,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203488049",
      "pull_request_review_id": 3014202096,
      "id": 2203488049,
      "node_id": "PRRC_kwDOABII586DVo8x",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_block_pointer_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_get_validation_mode_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_get_block_validation_result_from_block_validation_state(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_block_index_from_height(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The next block index in the currently active chain, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_next_block_index(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the previous block index in the chain, or null if the current\n+ * block index entry is the genesis block.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The previous block index, or null on error or if the current block index is the genesis block.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_previous_block_index(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the height of a certain block index.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The block height.\n+ */\n+BITCOINKERNEL_API int32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_height(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+\n+/**\n+ * @brief Destroy the block index.\n+ */\n+BITCOINKERNEL_API void kernel_block_index_destroy(kernel_BlockIndex* block_index);\n+\n+///@}\n+\n+/** @name BlockUndo\n+ * Functions for working with block undo data.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block undo data the passed in block index points to from\n+ * disk and returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block undo data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockUndo* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_undo_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the number of transactions whose undo data is contained in\n+ * block undo.\n+ *\n+ * @param[in] block_undo Non-null.\n+ * @return               The number of transaction undo data in the block undo.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_size(\n+    const kernel_BlockUndo* block_undo\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the number of previous transaction outputs contained in the\n+ * transaction undo data.\n+ *\n+ * @param[in] block_undo             Non-null, the block undo data from which tx_undo was retrieved from.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @return                           The number of previous transaction outputs in the transaction.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_transaction_undo_size(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the block height of the block that contains the output at\n+ * output_index within the transaction undo data at the provided index of the\n+ * block undo data.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the targeted transaction output within the transaction\n+ *                                   undo data.\n+ * @return                           The block height of the output, or 0 if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API uint32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_undo_output_height_by_index(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index,\n+    uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return a transaction output contained in the transaction undo data of\n+ * a block undo data at a certain index.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the to be retrieved transaction output within the\n+ *                                   transaction undo data.\n+ * @return                           A transaction output pointer, or null if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_get_undo_output_by_index(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1183,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In the corresponding [commit](https://github.com/bitcoin/bitcoin/commit/d031c5871e47112a93b25a0612123a5b3eaf2a33) there is a mention of `kernel_ERROR_OUT_OF_BOUNDS` which should be removed I think.",
      "created_at": "2025-07-13T18:32:58Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203488049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203488049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203492012",
      "pull_request_review_id": 3014202096,
      "id": 2203492012,
      "node_id": "PRRC_kwDOABII586DVp6s",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 924,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In the corresponding [commit](https://github.com/bitcoin/bitcoin/commit/f2faf17904841a4bbcedda6a9f0ba82a543ec305) description:\r\n\r\nutility for serializing a `CBlock` (`kernel_block_create()`) -> utility for **deserializing**",
      "created_at": "2025-07-13T18:50:27Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203492012",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203492012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 920,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203492384",
      "pull_request_review_id": 3014202096,
      "id": 2203492384,
      "node_id": "PRRC_kwDOABII586DVqAg",
      "diff_hunk": "@@ -0,0 +1,1222 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 4) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_copy_script_pubkey_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_copy_script_pubkey_from_output(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_get_transaction_output_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_disable_logging();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_add_log_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_enable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_disable_log_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_read_block_from_disk(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/** @name ByteArray",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 938,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "690a5dac223ed18a65c9d9e6c535466cc3ad4511",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n/**\r\n```",
      "created_at": "2025-07-13T18:51:12Z",
      "updated_at": "2025-07-13T18:56:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2203492384",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2203492384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 938,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2213740015",
      "pull_request_review_id": 3030139760,
      "id": 2213740015,
      "node_id": "PRRC_kwDOABII586D8v3v",
      "diff_hunk": "@@ -0,0 +1,1228 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 133,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: couple of naming mismatches after latest force pushes:\r\n\r\n<details>\r\n<summary>git diff on 1ffc1c9d94</summary>\r\n\r\n```diff\r\ndiff --git a/src/kernel/bitcoinkernel.h b/src/kernel/bitcoinkernel.h\r\nindex b72c001d1b..ec4db4e7c7 100644\r\n--- a/src/kernel/bitcoinkernel.h\r\n+++ b/src/kernel/bitcoinkernel.h\r\n@@ -130,7 +130,7 @@ typedef struct kernel_TransactionOutput kernel_TransactionOutput;\r\n  *\r\n  * Messages that were logged before a connection is created are buffered in a\r\n  * 1MB buffer. Logging can alternatively be permanently disabled by calling\r\n- * kernel_disable_logging(). Functions changing the logging settings are global\r\n+ * kernel_logging_disable(). Functions changing the logging settings are global\r\n  * (and not thread safe) and change the settings for all existing\r\n  * kernel_LoggingConnection instances.\r\n  */\r\n@@ -576,7 +576,7 @@ BITCOINKERNEL_API void kernel_logging_disable();\r\n \r\n /**\r\n  * @brief Set the log level of the global internal logger. This does not\r\n- * enable the selected categories. Use `kernel_enable_log_category` to start\r\n+ * enable the selected categories. Use `kernel_logging_enable_category` to start\r\n  * logging from a specific, or all categories. This function is not thread\r\n  * safe. Mutiple calls from different threads are allowed but must be\r\n  * synchronized. This changes a global setting and will override settings for\r\n@@ -786,7 +786,7 @@ BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\r\n \r\n /**\r\n  * @brief Sets wipe db in the options. In combination with calling\r\n- * @ref kernel_import_blocks this triggers either a full reindex,\r\n+ * @ref kernel_chainstate_manager_import_blocks this triggers either a full reindex,\r\n  * or a reindex of just the chainstate database.\r\n  *\r\n  * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\r\n\r\n```\r\n</details>\r\n",
      "created_at": "2025-07-17T16:00:24Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2213740015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2213740015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2213968769",
      "pull_request_review_id": 3030139760,
      "id": 2213968769,
      "node_id": "PRRC_kwDOABII586D9nuB",
      "diff_hunk": "@@ -0,0 +1,646 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_WRAPPER_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_WRAPPER_H\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <span>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+\n+class Transaction\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_Transaction* ptr) const\n+        {\n+            kernel_transaction_destroy(ptr);\n+        }\n+    };\n+\n+public:\n+    std::unique_ptr<kernel_Transaction, Deleter> m_transaction;\n+\n+    Transaction(std::span<const unsigned char> raw_transaction) noexcept\n+        : m_transaction{kernel_transaction_create(raw_transaction.data(), raw_transaction.size())}\n+    {\n+    }\n+\n+    /** Check whether this Transaction object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_transaction}; }\n+};\n+\n+class ScriptPubkey\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_ScriptPubkey* ptr) const\n+        {\n+            kernel_script_pubkey_destroy(ptr);\n+        }\n+    };\n+\n+public:\n+    std::unique_ptr<kernel_ScriptPubkey, Deleter> m_script_pubkey;\n+\n+    ScriptPubkey(std::span<const unsigned char> script_pubkey) noexcept\n+        : m_script_pubkey{kernel_script_pubkey_create(script_pubkey.data(), script_pubkey.size())}\n+    {\n+    }\n+\n+    ScriptPubkey(kernel_ScriptPubkey* script_pubkey) noexcept\n+        : m_script_pubkey{script_pubkey}\n+    {\n+    }\n+\n+    std::vector<unsigned char> GetScriptPubkeyData() const noexcept\n+    {\n+        auto serialized_data{kernel_script_pubkey_copy_data(m_script_pubkey.get())};\n+        std::vector<unsigned char> vec{serialized_data->data, serialized_data->data + serialized_data->size};\n+        kernel_byte_array_destroy(serialized_data);\n+        return vec;\n+    }\n+\n+    /** Check whether this ScriptPubkey object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_script_pubkey}; }\n+};\n+\n+class TransactionOutput\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_TransactionOutput* ptr) const\n+        {\n+            kernel_transaction_output_destroy(ptr);\n+        }\n+    };\n+\n+public:\n+    std::unique_ptr<kernel_TransactionOutput, Deleter> m_transaction_output;\n+\n+    TransactionOutput(const ScriptPubkey& script_pubkey, int64_t amount) noexcept\n+        : m_transaction_output{kernel_transaction_output_create(script_pubkey.m_script_pubkey.get(), amount)}\n+    {\n+    }\n+\n+    TransactionOutput(kernel_TransactionOutput* output) noexcept\n+        : m_transaction_output{output}\n+    {\n+    }\n+\n+    /** Check whether this TransactionOutput object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_transaction_output}; }\n+\n+    ScriptPubkey GetScriptPubkey() noexcept\n+    {\n+        return kernel_transaction_output_copy_script_pubkey(m_transaction_output.get());\n+    }\n+\n+    int64_t GetOutputAmount() noexcept\n+    {\n+        return kernel_transaction_output_get_amount(m_transaction_output.get());\n+    }\n+};\n+\n+int verify_script(const ScriptPubkey& script_pubkey,\n+                  int64_t amount,\n+                  const Transaction& tx_to,\n+                  const std::span<const TransactionOutput> spent_outputs,\n+                  unsigned int input_index,\n+                  unsigned int flags,\n+                  kernel_ScriptVerifyStatus& status) noexcept\n+{\n+    const kernel_TransactionOutput** spent_outputs_ptr = nullptr;\n+    std::vector<const kernel_TransactionOutput*> raw_spent_outputs;\n+    if (spent_outputs.size() > 0) {\n+        raw_spent_outputs.reserve(spent_outputs.size());\n+\n+        for (const auto& output : spent_outputs) {\n+            raw_spent_outputs.push_back(output.m_transaction_output.get());\n+        }\n+        spent_outputs_ptr = raw_spent_outputs.data();\n+    }\n+    return kernel_verify_script(\n+        script_pubkey.m_script_pubkey.get(),\n+        amount,\n+        tx_to.m_transaction.get(),\n+        spent_outputs_ptr, spent_outputs.size(),\n+        input_index,\n+        flags,\n+        &status);\n+}\n+\n+template <typename T>\n+concept Log = requires(T a, std::string_view message) {\n+    { a.LogMessage(message) } -> std::same_as<void>;\n+};\n+\n+template <Log T>\n+class Logger\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_LoggingConnection* ptr) const\n+        {\n+            kernel_logging_connection_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<T> m_log;\n+    std::unique_ptr<kernel_LoggingConnection, Deleter> m_connection;\n+\n+public:\n+    Logger(std::unique_ptr<T> log, const kernel_LoggingOptions& logging_options) noexcept\n+        : m_log{std::move(log)},\n+          m_connection{kernel_logging_connection_create(\n+              [](void* user_data, const char* message, size_t message_len) { static_cast<T*>(user_data)->LogMessage({message, message_len}); },\n+              m_log.get(),\n+              logging_options)}\n+    {\n+    }\n+\n+    /** Check whether this Logger object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_connection}; }\n+};\n+\n+template <typename T>\n+class KernelNotifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks MakeCallbacks()\n+    {\n+        return kernel_NotificationInterfaceCallbacks{\n+            .user_data = this,\n+            .block_tip = [](void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress) {\n+                static_cast<T*>(user_data)->BlockTipHandler(state, index, verification_progress);\n+            },\n+            .header_tip = [](void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync) {\n+                static_cast<T*>(user_data)->HeaderTipHandler(state, height, timestamp, presync);\n+            },\n+            .progress = [](void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible) {\n+                static_cast<T*>(user_data)->ProgressHandler({title, title_len}, progress_percent, resume_possible);\n+            },\n+            .warning_set = [](void* user_data, kernel_Warning warning, const char* message, size_t message_len) {\n+                static_cast<T*>(user_data)->WarningSetHandler(warning, {message, message_len});\n+            },\n+            .warning_unset = [](void* user_data, kernel_Warning warning) { static_cast<T*>(user_data)->WarningUnsetHandler(warning); },\n+            .flush_error = [](void* user_data, const char* error, size_t error_len) { static_cast<T*>(user_data)->FlushErrorHandler({error, error_len}); },\n+            .fatal_error = [](void* user_data, const char* error, size_t error_len) { static_cast<T*>(user_data)->FatalErrorHandler({error, error_len}); },\n+        };\n+    }\n+\n+    const kernel_NotificationInterfaceCallbacks m_notifications;\n+\n+public:\n+    KernelNotifications() : m_notifications{MakeCallbacks()} {}\n+\n+    virtual ~KernelNotifications() = default;\n+\n+    virtual void BlockTipHandler(kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress) {}\n+\n+    virtual void HeaderTipHandler(kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync) {}\n+\n+    virtual void ProgressHandler(std::string_view title, int progress_percent, bool resume_possible) {}\n+\n+    virtual void WarningSetHandler(kernel_Warning warning, std::string_view message) {}\n+\n+    virtual void WarningUnsetHandler(kernel_Warning warning) {}\n+\n+    virtual void FlushErrorHandler(std::string_view error) {}\n+\n+    virtual void FatalErrorHandler(std::string_view error) {}\n+\n+    friend class ContextOptions;\n+};\n+\n+struct BlockHashDeleter {\n+    void operator()(kernel_BlockHash* ptr) const\n+    {\n+        kernel_block_hash_destroy(ptr);\n+    }\n+};\n+\n+class UnownedBlock\n+{\n+private:\n+    const kernel_BlockPointer* m_block;\n+\n+public:\n+    UnownedBlock(const kernel_BlockPointer* block) noexcept : m_block{block} {}\n+\n+    UnownedBlock(const UnownedBlock&) = delete;\n+    UnownedBlock& operator=(const UnownedBlock&) = delete;\n+    UnownedBlock(UnownedBlock&&) = delete;\n+    UnownedBlock& operator=(UnownedBlock&&) = delete;\n+\n+    std::unique_ptr<kernel_BlockHash, BlockHashDeleter> GetHash() const noexcept\n+    {\n+        return std::unique_ptr<kernel_BlockHash, BlockHashDeleter>(kernel_block_pointer_get_hash(m_block));\n+    }\n+\n+    std::vector<unsigned char> GetBlockData() const noexcept\n+    {\n+        auto serialized_block{kernel_block_pointer_copy_data(m_block)};\n+        std::vector<unsigned char> vec{serialized_block->data, serialized_block->data + serialized_block->size};\n+        kernel_byte_array_destroy(serialized_block);\n+        return vec;\n+    }\n+};\n+\n+class BlockValidationState\n+{\n+private:\n+    const kernel_BlockValidationState* m_state;\n+\n+public:\n+    BlockValidationState(const kernel_BlockValidationState* state) noexcept : m_state{state} {}\n+\n+    BlockValidationState(const BlockValidationState&) = delete;\n+    BlockValidationState& operator=(const BlockValidationState&) = delete;\n+    BlockValidationState(BlockValidationState&&) = delete;\n+    BlockValidationState& operator=(BlockValidationState&&) = delete;\n+\n+    kernel_ValidationMode ValidationMode() const noexcept\n+    {\n+        return kernel_block_validation_state_get_validation_mode(m_state);\n+    }\n+\n+    kernel_BlockValidationResult BlockValidationResult() const noexcept\n+    {\n+        return kernel_block_validation_state_get_block_validation_result(m_state);\n+    }\n+};\n+\n+template <typename T>\n+class ValidationInterface\n+{\n+private:\n+    const kernel_ValidationInterfaceCallbacks m_validation_interface;\n+\n+public:\n+    ValidationInterface() noexcept : m_validation_interface{kernel_ValidationInterfaceCallbacks{\n+                                .user_data = this,\n+                                .block_checked = [](void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state) {\n+                                    static_cast<T*>(user_data)->BlockChecked(UnownedBlock{block}, BlockValidationState{state});\n+                                },\n+                            }}\n+    {\n+    }\n+\n+    virtual ~ValidationInterface() = default;\n+\n+    virtual void BlockChecked(UnownedBlock block, const BlockValidationState state) {}\n+\n+    friend class ContextOptions;\n+};\n+\n+class ChainParams\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_ChainParameters* ptr) const\n+        {\n+            kernel_chain_parameters_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<kernel_ChainParameters, Deleter> m_chain_params;\n+\n+public:\n+    ChainParams(kernel_ChainType chain_type) noexcept : m_chain_params{kernel_chain_parameters_create(chain_type)} {}\n+\n+    friend class ContextOptions;\n+};\n+\n+class ContextOptions\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_ContextOptions* ptr) const\n+        {\n+            kernel_context_options_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<kernel_ContextOptions, Deleter> m_options;\n+\n+public:\n+    ContextOptions() noexcept : m_options{kernel_context_options_create()} {}\n+\n+    void SetChainParams(ChainParams& chain_params) const noexcept\n+    {\n+        kernel_context_options_set_chainparams(m_options.get(), chain_params.m_chain_params.get());\n+    }\n+\n+    template <typename T>\n+    void SetNotifications(KernelNotifications<T>& notifications) const noexcept\n+    {\n+        kernel_context_options_set_notifications(m_options.get(), notifications.m_notifications);\n+    }\n+\n+    template <typename T>\n+    void SetValidationInterface(ValidationInterface<T>& validation_interface) const noexcept\n+    {\n+        kernel_context_options_set_validation_interface(m_options.get(), validation_interface.m_validation_interface);\n+    }\n+\n+    friend class Context;\n+};\n+\n+class Context\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_Context* ptr) const\n+        {\n+            kernel_context_destroy(ptr);\n+        }\n+    };\n+\n+public:\n+    std::unique_ptr<kernel_Context, Deleter> m_context;\n+\n+    Context(ContextOptions& opts) noexcept\n+        : m_context{kernel_context_create(opts.m_options.get())}\n+    {\n+    }\n+\n+    Context() noexcept\n+        : m_context{kernel_context_create(ContextOptions{}.m_options.get())}\n+    {\n+    }\n+\n+    /** Check whether this Context object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_context}; }\n+};\n+\n+class ChainstateManagerOptions\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_ChainstateManagerOptions* ptr) const\n+        {\n+            kernel_chainstate_manager_options_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<kernel_ChainstateManagerOptions, Deleter> m_options;\n+\n+public:\n+    ChainstateManagerOptions(const Context& context, const std::string& data_dir, const std::string& blocks_dir) noexcept\n+        : m_options{kernel_chainstate_manager_options_create(context.m_context.get(), data_dir.c_str(), data_dir.length(), blocks_dir.c_str(), blocks_dir.length())}\n+    {\n+    }\n+\n+    void SetWorkerThreads(int worker_threads) const noexcept\n+    {\n+        kernel_chainstate_manager_options_set_worker_threads_num(m_options.get(), worker_threads);\n+    }\n+\n+    bool SetWipeDbs(bool wipe_block_tree, bool wipe_chainstate) const noexcept\n+    {\n+        return kernel_chainstate_manager_options_set_wipe_dbs(m_options.get(), wipe_block_tree, wipe_chainstate);\n+    }\n+\n+    void SetBlockTreeDbInMemory(bool block_tree_db_in_memory) const noexcept\n+    {\n+        kernel_chainstate_manager_options_set_block_tree_db_in_memory(m_options.get(), block_tree_db_in_memory);\n+    }\n+\n+    void SetChainstateDbInMemory(bool chainstate_db_in_memory) const noexcept\n+    {\n+        kernel_chainstate_manager_options_set_chainstate_db_in_memory(m_options.get(), chainstate_db_in_memory);\n+    }\n+\n+    /** Check whether this ChainstateManagerOptions object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_options}; }\n+\n+    friend class ChainMan;\n+};\n+\n+class Block\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_Block* ptr) const\n+        {\n+            kernel_block_destroy(ptr);\n+        }\n+    };\n+\n+    std::unique_ptr<kernel_Block, Deleter> m_block;\n+\n+public:\n+    Block(const std::span<const unsigned char> raw_block) noexcept\n+        : m_block{kernel_block_create(raw_block.data(), raw_block.size())}\n+    {\n+    }\n+\n+    /** Check whether this Block object is valid. */\n+    explicit operator bool() const noexcept { return bool{m_block}; }\n+\n+    Block(kernel_Block* block) noexcept : m_block{block} {}\n+\n+    std::unique_ptr<kernel_BlockHash, BlockHashDeleter> GetHash() const noexcept\n+    {\n+        return std::unique_ptr<kernel_BlockHash, BlockHashDeleter>(kernel_block_get_hash(m_block.get()));\n+    }\n+\n+    std::vector<unsigned char> GetBlockData() const noexcept\n+    {\n+        auto serialized_block{kernel_block_copy_data(m_block.get())};\n+        std::vector<unsigned char> vec{serialized_block->data, serialized_block->data + serialized_block->size};\n+        kernel_byte_array_destroy(serialized_block);\n+        return vec;\n+    }\n+\n+    friend class ChainMan;\n+};\n+\n+class BlockUndo\n+{\n+private:\n+    struct Deleter {\n+        void operator()(kernel_BlockUndo* ptr) const\n+        {\n+            kernel_block_undo_destroy(ptr);\n+        }\n+    };\n+\n+    const std::unique_ptr<kernel_BlockUndo, Deleter> m_block_undo;",
      "path": "src/kernel/bitcoinkernel_wrapper.h",
      "position": null,
      "original_position": 476,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should this be const? It's not moveable as-is. If intentional, brief docstring would be good?\r\n```suggestion\r\n    std::unique_ptr<kernel_BlockUndo, Deleter> m_block_undo;\r\n```",
      "created_at": "2025-07-17T18:02:46Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2213968769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2213968769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 476,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2214073393",
      "pull_request_review_id": 3030139760,
      "id": 2214073393,
      "node_id": "PRRC_kwDOABII586D-BQx",
      "diff_hunk": "@@ -1,270 +1,222 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-//\n-// The bitcoin-chainstate executable serves to surface the dependencies required\n-// by a program wishing to use Bitcoin Core's consensus engine as it is right\n-// now.\n-//\n-// DEVELOPER NOTE: Since this is a \"demo-only\", experimental, etc. executable,\n-//                 it may diverge from Bitcoin Core's coding style.\n-//\n-// It is part of the libbitcoinkernel project.\n-\n-#include <kernel/chainparams.h>\n-#include <kernel/chainstatemanager_opts.h>\n-#include <kernel/checks.h>\n-#include <kernel/context.h>\n-#include <kernel/warning.h>\n-\n-#include <consensus/validation.h>\n-#include <core_io.h>\n-#include <kernel/caches.h>\n-#include <logging.h>\n-#include <node/blockstorage.h>\n-#include <node/chainstate.h>\n-#include <random.h>\n-#include <script/sigcache.h>\n-#include <util/chaintype.h>\n-#include <util/fs.h>\n-#include <util/signalinterrupt.h>\n-#include <util/task_runner.h>\n-#include <util/translation.h>\n-#include <validation.h>\n-#include <validationinterface.h>\n+#include <kernel/bitcoinkernel_wrapper.h>\n \n #include <cassert>\n-#include <cstdint>\n-#include <functional>\n-#include <iosfwd>\n-#include <memory>\n+#include <charconv>\n+#include <filesystem>\n+#include <iostream>\n+#include <optional>\n #include <string>\n+#include <string_view>\n+#include <vector>\n \n-int main(int argc, char* argv[])\n+#ifdef WIN32\n+#include <windows.h>",
      "path": "src/bitcoin-chainstate.cpp",
      "position": 53,
      "original_position": 52,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "clang-format sorts this alphabetically, but `windows.h` needs to be included before `shellapi.h` otherwise we get [build errors](https://github.com/stickies-v/bitcoin/actions/runs/16352515776/job/46202676758#step:10:953) like:\r\n\r\n```\r\nC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\shellapi.h(68,1): error C2146: syntax error: missing ';' before identifier 'DECLSPEC_IMPORT' [D:\\a\\bitcoin\\bitcoin\\build\\src\\bitcoin-chainstate.vcxproj]\r\n  (compiling source file '../../src/bitcoin-chainstate.cpp')\r\n  \r\nC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\shellapi.h(79,16): error C2065: 'HDROP': undeclared identifier [D:\\a\\bitcoin\\bitcoin\\build\\src\\bitcoin-chainstate.vcxproj]\r\n  (compiling source file '../../src/bitcoin-chainstate.cpp')\r\n  \r\nC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\shellapi.h(82,1): error C2086: 'int EXTERN_C': redefinition [D:\\a\\bitcoin\\bitcoin\\build\\src\\bitcoin-chainstate.vcxproj]\r\n  (compiling source file '../../src/bitcoin-chainstate.cpp')\r\n      C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.20348.0\\um\\shellapi.h(68,1):\r\n      see declaration of 'EXTERN_C'\r\n```\r\n\r\nCould be useful to exclude this from clang-format?\r\n\r\n```cpp\r\n#ifdef WIN32\r\n// clang-format off\r\n#include <windows.h>\r\n// clang-format on\r\n#include <codecvt>\r\n#include <locale>\r\n#include <shellapi.h>\r\n#endif\r\n```",
      "created_at": "2025-07-17T19:00:18Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2214073393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2214073393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2216084200",
      "pull_request_review_id": 3030139760,
      "id": 2216084200,
      "node_id": "PRRC_kwDOABII586EFsLo",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_script_pubkey_copy_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_logging_set_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_logging_enable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // Switch back to buffering by calling DisconnectTestLogger if the\n+    // connection that was just removed was the last one.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::Main());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet4());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::SigNet({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        CChainParams* params = new CChainParams(*CChainParams::RegTest({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{cast_const_chain_params(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // The KernelNotifications are copy-initialized, so the caller can free them again.\n+    LOCK(options->m_mutex);\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    LOCK(options->m_mutex);\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_block_validation_state_get_validation_mode(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_block_validation_state_get_block_validation_result(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_chainstate_manager_options(options);\n+    }\n+}\n+\n+bool kernel_chainstate_manager_options_set_wipe_dbs(kernel_ChainstateManagerOptions* chainman_opts_, bool wipe_block_tree_db, bool wipe_chainstate_db)\n+{\n+    if (wipe_block_tree_db && !wipe_chainstate_db) {\n+        LogError(\"Wiping the block tree db without also wiping the chainstate db is currently unsupported.\");\n+        return false;\n+    }\n+    auto opts{cast_chainstate_manager_options(chainman_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.wipe_data = wipe_block_tree_db;\n+    opts->m_chainstate_load_options.wipe_chainstate_db = wipe_chainstate_db;\n+    return true;\n+}\n+\n+void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool block_tree_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.memory_only = block_tree_db_in_memory;\n+}\n+\n+void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool chainstate_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainstate_load_options.coins_db_in_memory = chainstate_db_in_memory;\n+}\n+\n+kernel_ChainstateManager* kernel_chainstate_manager_create(\n+    const kernel_Context* context_,\n+    const kernel_ChainstateManagerOptions* chainman_opts_)\n+{\n+    auto chainman_opts{cast_const_chainstate_manager_options(chainman_opts_)};\n+    auto context{cast_const_context(context_)};\n+\n+    ChainstateManager* chainman;\n+\n+    try {\n+        LOCK(chainman_opts->m_mutex);\n+        chainman = new ChainstateManager{*context->m_interrupt, chainman_opts->m_chainman_options, chainman_opts->m_blockman_options};\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    try {\n+        const auto chainstate_load_opts{WITH_LOCK(chainman_opts->m_mutex, return chainman_opts->m_chainstate_load_options)};\n+\n+        kernel::CacheSizes cache_sizes{DEFAULT_KERNEL_CACHE};\n+        auto [status, chainstate_err]{node::LoadChainstate(*chainman, cache_sizes, chainstate_load_opts)};\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to load chain state from your data directory: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+        std::tie(status, chainstate_err) = node::VerifyLoadedChainstate(*chainman, chainstate_load_opts);\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to verify loaded chain state from your datadir: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+\n+        for (Chainstate* chainstate : WITH_LOCK(chainman->GetMutex(), return chainman->GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n+                LogError(\"Failed to connect best block: %s\", state.ToString());\n+                kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+                return nullptr;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to load chainstate: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_ChainstateManager*>(chainman);\n+}\n+\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainman_, const kernel_Context* context_)\n+{\n+    if (!chainman_) return;\n+\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    {\n+        LOCK(chainman->GetMutex());\n+        for (Chainstate* chainstate : chainman->GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n+        }\n+    }\n+\n+    delete chainman;\n+    return;\n+}\n+\n+bool kernel_chainstate_manager_import_blocks(const kernel_Context* context_,\n+                          kernel_ChainstateManager* chainman_,\n+                          const char** block_file_paths,\n+                          size_t* block_file_paths_lens,\n+                          size_t block_file_paths_len)\n+{\n+    try {\n+        auto chainman{cast_chainstate_manager(chainman_)};\n+        std::vector<fs::path> import_files;\n+        import_files.reserve(block_file_paths_len);\n+        for (uint32_t i = 0; i < block_file_paths_len; i++) {\n+            if (block_file_paths[i] != nullptr) {\n+                import_files.emplace_back(std::string{block_file_paths[i], block_file_paths_lens[i]}.c_str());\n+            }\n+        }\n+        node::ImportBlocks(*chainman, import_files);\n+        chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to import blocks: %s\", e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+kernel_Block* kernel_block_create(const unsigned char* raw_block, size_t raw_block_length)\n+{\n+    auto block{new CBlock()};\n+\n+    DataStream stream{std::span{raw_block, raw_block_length}};\n+\n+    try {\n+        stream >> TX_WITH_WITNESS(*block);\n+    } catch (const std::exception&) {\n+        delete block;\n+        LogDebug(BCLog::KERNEL, \"Block decode failed.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_Block*>(new std::shared_ptr<CBlock>(block));\n+}\n+\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array)\n+{\n+    if (byte_array && byte_array->data) delete[] byte_array->data;\n+    if (byte_array) delete byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_copy_data(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(**block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_pointer_copy_data(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(*block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_BlockHash* kernel_block_get_hash(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+    auto hash{(*block)->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+kernel_BlockHash* kernel_block_pointer_get_hash(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    auto hash{block->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+void kernel_block_destroy(kernel_Block* block)\n+{\n+    if (block) {\n+        delete cast_cblocksharedpointer(block);\n+    }\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_tip(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Tip()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_genesis(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Genesis()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_hash(const kernel_Context* context_, kernel_ChainstateManager* chainman_, kernel_BlockHash* block_hash)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto hash = uint256{std::span<const unsigned char>{(*block_hash).hash, 32}};\n+    auto block_index = WITH_LOCK(chainman->GetMutex(), return chainman->m_blockman.LookupBlockIndex(hash));\n+    if (!block_index) {\n+        LogDebug(BCLog::KERNEL, \"A block with the given hash is not indexed.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_height(const kernel_Context* context_, kernel_ChainstateManager* chainman_, int height)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    LOCK(chainman->GetMutex());\n+\n+    if (height < 0 || height > chainman->ActiveChain().Height()) {\n+        LogDebug(BCLog::KERNEL, \"Block height is out of range.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(chainman->ActiveChain()[height]);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_next(const kernel_Context* context_, kernel_ChainstateManager* chainman_, const kernel_BlockIndex* block_index_)\n+{\n+    const auto block_index{cast_const_block_index(block_index_)};\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto next_block_index{WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Next(block_index))};\n+\n+    if (!next_block_index) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the tip of the current chain, it does not have a next.\");\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(next_block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_previous(const kernel_BlockIndex* block_index_)\n+{\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    if (!block_index->pprev) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the genesis, it has no previous.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index->pprev);\n+}\n+\n+kernel_Block* kernel_block_read(const kernel_Context* context_,\n+                                          kernel_ChainstateManager* chainman_,\n+                                          const kernel_BlockIndex* block_index_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    auto block{new std::shared_ptr<CBlock>(new CBlock{})};\n+    if (!chainman->m_blockman.ReadBlock(**block, *block_index)) {\n+        LogError(\"Failed to read block.\");",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 1045,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This looks like it leaks memory since we never deallocate `block` if `ReadBlock` fails. Perhaps using `std::unique_ptr` here is a better approach? This (+`kernel_block_undo_read`) seems like the most dangerous one, but perhaps good practice to do this in other places we allocate memory, e.g. [here](https://github.com/bitcoin/bitcoin/pull/30595/files#diff-cc28221ef8d0c7294dda4e3df9f70bb6c062006b387468380c2c2cc02b6762c3R421).",
      "created_at": "2025-07-18T13:45:06Z",
      "updated_at": "2025-07-28T16:33:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2216084200",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2216084200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1035,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2216251677",
      "pull_request_review_id": 3030139760,
      "id": 2216251677,
      "node_id": "PRRC_kwDOABII586EGVEd",
      "diff_hunk": "@@ -0,0 +1,1228 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier. Note that these callbacks block any further validation\n+ * execution when they are called.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_copy_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_transaction_output_copy_script_pubkey(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_transaction_output_get_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_logging_disable();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_logging_set_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_logging_enable_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_logging_disable_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_read(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_copy_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_copy_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": 1151,
      "original_position": 970,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since we use reference counting here, would it be useful to document that in the documentation?\r\n```suggestion\r\n * Destroy the block. Handle is invalidated immediately, block is destroyed as soon as no references remain.\r\n```",
      "created_at": "2025-07-18T14:49:12Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2216251677",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2216251677"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1151,
      "original_line": 1151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2219798945",
      "pull_request_review_id": 3030139760,
      "id": 2219798945,
      "node_id": "PRRC_kwDOABII586ET3Gh",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_script_pubkey_copy_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 510,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We should probably use `cast_transaction_output` here to make sure we're not miscasting anything?",
      "created_at": "2025-07-21T17:18:21Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2219798945",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2219798945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 508,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237111430",
      "pull_request_review_id": 3030139760,
      "id": 2237111430,
      "node_id": "PRRC_kwDOABII586FV5yG",
      "diff_hunk": "@@ -0,0 +1,1228 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier. Note that these callbacks block any further validation\n+ * execution when they are called.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_copy_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_transaction_output_copy_script_pubkey(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_transaction_output_get_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_logging_disable();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_logging_set_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_logging_enable_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_logging_disable_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_read(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_copy_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_copy_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void kernel_block_destroy(kernel_Block* block);\n+\n+///@}\n+\n+/** @name ByteArray\n+ * Functions for working with byte arrays.\n+ */\n+///@{\n+\n+/**\n+ * A helper function for destroying an existing byte array.\n+ */\n+BITCOINKERNEL_API void kernel_byte_array_destroy(kernel_ByteArray* byte_array);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_ValidationMode kernel_block_validation_state_get_validation_mode(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API kernel_BlockValidationResult kernel_block_validation_state_get_block_validation_result(\n+    const kernel_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name BlockIndex\n+ * Functions for working with block indexes.\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block index entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the current tip, or null if the chain is empty.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_tip(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the block index entry of the genesis block.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The block index of the genesis block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_genesis(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Retrieve a block index by its block hash.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block index of the block with the passed in hash, or null if\n+ *                               the block hash is not found.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_by_hash(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Retrieve a block index by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_height       Height in the chain of the to be retrieved block index.\n+ * @return                       The block index at a certain height in the currently active chain,\n+ *                               or null if the height is out of bounds.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_by_height(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The next block index in the currently active chain, or null if\n+ *                               the block_index is the chain tip.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_next(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the previous block index in the chain, or null if the current\n+ * block index entry is the genesis block.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The previous block index, or null on error or if the current block index is the genesis block.\n+ */\n+BITCOINKERNEL_API kernel_BlockIndex* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_previous(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the height of a certain block index.\n+ *\n+ * @param[in] block_index Non-null.\n+ * @return                The block height.\n+ */\n+BITCOINKERNEL_API int32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_index_get_height(\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+\n+/**\n+ * @brief Destroy the block index.\n+ */\n+BITCOINKERNEL_API void kernel_block_index_destroy(kernel_BlockIndex* block_index);\n+\n+///@}\n+\n+/** @name BlockUndo\n+ * Functions for working with block undo data.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block undo data the passed in block index points to from\n+ * disk and returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block undo data, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_BlockUndo* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_read(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the number of transactions whose undo data is contained in\n+ * block undo.\n+ *\n+ * @param[in] block_undo Non-null.\n+ * @return               The number of transaction undo data in the block undo.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_size(\n+    const kernel_BlockUndo* block_undo\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the number of previous transaction outputs contained in the\n+ * transaction undo data.\n+ *\n+ * @param[in] block_undo             Non-null, the block undo data from which tx_undo was retrieved from.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @return                           The number of previous transaction outputs in the transaction,\n+ *                                   or 0 if the provided index is out of bounds.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_get_transaction_undo_size(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Returns the block height of the block that contains the output at\n+ * output_index within the transaction undo data at the provided index of the\n+ * block undo data.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the targeted transaction output within the transaction\n+ *                                   undo data.\n+ * @return                           The block height of the output, or 0 if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API uint32_t BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_get_transaction_output_height_by_index(\n+    const kernel_BlockUndo* block_undo,\n+    uint64_t transaction_undo_index,\n+    uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return a transaction output contained in the transaction undo data\n+ * of a block undo data at a certain index. This value is copied from the\n+ * underlying data and thus owned entirely by the user.\n+ *\n+ * @param[in] block_undo             Non-null.\n+ * @param[in] transaction_undo_index The index of the transaction undo data within the block undo data.\n+ * @param[in] output_index           The index of the to be retrieved transaction output within the\n+ *                                   transaction undo data.\n+ * @return                           A transaction output pointer, or null if provided indices are out of bounds.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_undo_copy_transaction_output_by_index(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1189,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I would prefer to expose `kernel_TransactionUndo` and `kernel_Coin` handles so we can generalize iterating over these nested containers.\r\n\r\nUsing shared_ptr and aliasing constructors, we can do so without incurring any copies (but at the cost of allocating shared_ptr and incrementing the reference counter). In my view this is both more ergonomic (by exposing dedicated types) and performant (by avoiding the need for any `_copy` operations (except for the `kernel_ByteArray` ones).\r\n\r\nIf necessary, and in addition, we can still expose `_copy` functions in places where we need even more performance and the user prefers handling lifetimes themselves, but I think this can be done at a later stage and on a case-by-case basis.\r\n\r\nExample implementation: https://github.com/stickies-v/bitcoin/commits/kernel/add-txundo-coin/ (specifically the 4 \"fix: \" commits.",
      "created_at": "2025-07-28T16:08:48Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237111430",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237111430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237124698",
      "pull_request_review_id": 3030139760,
      "id": 2237124698,
      "node_id": "PRRC_kwDOABII586FV9Ba",
      "diff_hunk": "@@ -0,0 +1,1228 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 216,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We need `kernel_BlockPointer` because the validation interface gives us a non-owning reference. It would imo be a lot nicer if we could generalize this into `kernel_Block`, so I have opened #33078 to improve ownership semantics in the validation interface, after which `kernel_BlockPointer` can then be removed, e.g. as in https://github.com/stickies-v/bitcoin/commits/kernel/remove-blockpointer/",
      "created_at": "2025-07-28T16:12:14Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237124698",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237124698"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237140589",
      "pull_request_review_id": 3030139760,
      "id": 2237140589,
      "node_id": "PRRC_kwDOABII586FWA5t",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 377,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think the implementation would be a lot cleaner and safer if we didn't use `reinterpret_cast` (or only in rare, targeted cases) but instead just implement the `kernel_` structs in the .cpp file (keeping it hidden to the user). It does add minimal overhead by allocating a (usually trivial) struct, but in most cases that is infrequent and the cost negligible. If necessary, we could still re-introduce `reinterpret_cast` in places where we observe that it does affect performance, but I would strongly prefer it not to be the default.\r\n\r\nI think this change goes hand-in-hand with moving to using reference counting internally, where the `kernel_` structs would then just have a single `std::shared_ptr<>` member.\r\n\r\nSee e.g. https://github.com/stickies-v/bitcoin/commit/daed81c192760bf2e21985c05b42c76c08501e11 for an example.",
      "created_at": "2025-07-28T16:16:48Z",
      "updated_at": "2025-07-28T16:28:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237140589",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237140589"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237230747",
      "pull_request_review_id": 3063738679,
      "id": 2237230747,
      "node_id": "PRRC_kwDOABII586FWW6b",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_script_pubkey_copy_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_logging_set_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_logging_enable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // Switch back to buffering by calling DisconnectTestLogger if the\n+    // connection that was just removed was the last one.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::Main());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet4());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::SigNet({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        CChainParams* params = new CChainParams(*CChainParams::RegTest({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{cast_const_chain_params(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // The KernelNotifications are copy-initialized, so the caller can free them again.\n+    LOCK(options->m_mutex);\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    LOCK(options->m_mutex);\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_block_validation_state_get_validation_mode(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_block_validation_state_get_block_validation_result(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_chainstate_manager_options(options);\n+    }\n+}\n+\n+bool kernel_chainstate_manager_options_set_wipe_dbs(kernel_ChainstateManagerOptions* chainman_opts_, bool wipe_block_tree_db, bool wipe_chainstate_db)\n+{\n+    if (wipe_block_tree_db && !wipe_chainstate_db) {\n+        LogError(\"Wiping the block tree db without also wiping the chainstate db is currently unsupported.\");\n+        return false;\n+    }\n+    auto opts{cast_chainstate_manager_options(chainman_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.wipe_data = wipe_block_tree_db;\n+    opts->m_chainstate_load_options.wipe_chainstate_db = wipe_chainstate_db;\n+    return true;\n+}\n+\n+void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool block_tree_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.memory_only = block_tree_db_in_memory;\n+}\n+\n+void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool chainstate_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainstate_load_options.coins_db_in_memory = chainstate_db_in_memory;\n+}\n+\n+kernel_ChainstateManager* kernel_chainstate_manager_create(\n+    const kernel_Context* context_,\n+    const kernel_ChainstateManagerOptions* chainman_opts_)\n+{\n+    auto chainman_opts{cast_const_chainstate_manager_options(chainman_opts_)};\n+    auto context{cast_const_context(context_)};\n+\n+    ChainstateManager* chainman;\n+\n+    try {\n+        LOCK(chainman_opts->m_mutex);\n+        chainman = new ChainstateManager{*context->m_interrupt, chainman_opts->m_chainman_options, chainman_opts->m_blockman_options};\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    try {\n+        const auto chainstate_load_opts{WITH_LOCK(chainman_opts->m_mutex, return chainman_opts->m_chainstate_load_options)};\n+\n+        kernel::CacheSizes cache_sizes{DEFAULT_KERNEL_CACHE};\n+        auto [status, chainstate_err]{node::LoadChainstate(*chainman, cache_sizes, chainstate_load_opts)};\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to load chain state from your data directory: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+        std::tie(status, chainstate_err) = node::VerifyLoadedChainstate(*chainman, chainstate_load_opts);\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to verify loaded chain state from your datadir: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+\n+        for (Chainstate* chainstate : WITH_LOCK(chainman->GetMutex(), return chainman->GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n+                LogError(\"Failed to connect best block: %s\", state.ToString());\n+                kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+                return nullptr;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to load chainstate: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_ChainstateManager*>(chainman);\n+}\n+\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainman_, const kernel_Context* context_)\n+{\n+    if (!chainman_) return;\n+\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    {\n+        LOCK(chainman->GetMutex());\n+        for (Chainstate* chainstate : chainman->GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n+        }\n+    }\n+\n+    delete chainman;\n+    return;\n+}\n+\n+bool kernel_chainstate_manager_import_blocks(const kernel_Context* context_,\n+                          kernel_ChainstateManager* chainman_,\n+                          const char** block_file_paths,\n+                          size_t* block_file_paths_lens,\n+                          size_t block_file_paths_len)\n+{\n+    try {\n+        auto chainman{cast_chainstate_manager(chainman_)};\n+        std::vector<fs::path> import_files;\n+        import_files.reserve(block_file_paths_len);\n+        for (uint32_t i = 0; i < block_file_paths_len; i++) {\n+            if (block_file_paths[i] != nullptr) {\n+                import_files.emplace_back(std::string{block_file_paths[i], block_file_paths_lens[i]}.c_str());\n+            }\n+        }\n+        node::ImportBlocks(*chainman, import_files);\n+        chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to import blocks: %s\", e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+kernel_Block* kernel_block_create(const unsigned char* raw_block, size_t raw_block_length)\n+{\n+    auto block{new CBlock()};\n+\n+    DataStream stream{std::span{raw_block, raw_block_length}};\n+\n+    try {\n+        stream >> TX_WITH_WITNESS(*block);\n+    } catch (const std::exception&) {\n+        delete block;\n+        LogDebug(BCLog::KERNEL, \"Block decode failed.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_Block*>(new std::shared_ptr<CBlock>(block));\n+}\n+\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array)\n+{\n+    if (byte_array && byte_array->data) delete[] byte_array->data;\n+    if (byte_array) delete byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_copy_data(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(**block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_pointer_copy_data(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(*block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_BlockHash* kernel_block_get_hash(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+    auto hash{(*block)->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+kernel_BlockHash* kernel_block_pointer_get_hash(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    auto hash{block->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+void kernel_block_destroy(kernel_Block* block)\n+{\n+    if (block) {\n+        delete cast_cblocksharedpointer(block);\n+    }\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_tip(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Tip()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_genesis(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Genesis()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_hash(const kernel_Context* context_, kernel_ChainstateManager* chainman_, kernel_BlockHash* block_hash)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto hash = uint256{std::span<const unsigned char>{(*block_hash).hash, 32}};\n+    auto block_index = WITH_LOCK(chainman->GetMutex(), return chainman->m_blockman.LookupBlockIndex(hash));\n+    if (!block_index) {\n+        LogDebug(BCLog::KERNEL, \"A block with the given hash is not indexed.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_height(const kernel_Context* context_, kernel_ChainstateManager* chainman_, int height)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    LOCK(chainman->GetMutex());\n+\n+    if (height < 0 || height > chainman->ActiveChain().Height()) {\n+        LogDebug(BCLog::KERNEL, \"Block height is out of range.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(chainman->ActiveChain()[height]);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_next(const kernel_Context* context_, kernel_ChainstateManager* chainman_, const kernel_BlockIndex* block_index_)\n+{\n+    const auto block_index{cast_const_block_index(block_index_)};\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto next_block_index{WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Next(block_index))};\n+\n+    if (!next_block_index) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the tip of the current chain, it does not have a next.\");\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(next_block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_previous(const kernel_BlockIndex* block_index_)\n+{\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    if (!block_index->pprev) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the genesis, it has no previous.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index->pprev);\n+}\n+\n+kernel_Block* kernel_block_read(const kernel_Context* context_,\n+                                          kernel_ChainstateManager* chainman_,\n+                                          const kernel_BlockIndex* block_index_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    auto block{new std::shared_ptr<CBlock>(new CBlock{})};\n+    if (!chainman->m_blockman.ReadBlock(**block, *block_index)) {\n+        LogError(\"Failed to read block.\");",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 1045,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": 2216084200,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This should get de-allocated when the user calls `kernel_block_destroy`, no?",
      "created_at": "2025-07-28T16:42:10Z",
      "updated_at": "2025-07-28T16:42:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237230747",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237230747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1035,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237234545",
      "pull_request_review_id": 3063743379,
      "id": 2237234545,
      "node_id": "PRRC_kwDOABII586FWX1x",
      "diff_hunk": "@@ -0,0 +1,1228 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+#if defined(_WIN32)\n+#ifdef BITCOINKERNEL_BUILD\n+#define BITCOINKERNEL_API __declspec(dllexport)\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#elif defined(__GNUC__) && defined(BITCOINKERNEL_BUILD)\n+#define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+#else\n+#define BITCOINKERNEL_API\n+#endif\n+#endif\n+\n+#if !defined(BITCOINKERNEL_GNUC_PREREQ)\n+#if defined(__GNUC__) && defined(__GNUC_MINOR__)\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) \\\n+    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((_maj) << 16) + (_min))\n+#else\n+#define BITCOINKERNEL_GNUC_PREREQ(_maj, _min) 0\n+#endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+#define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__) && BITCOINKERNEL_GNUC_PREREQ(3, 4)\n+#define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+#define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct kernel_Transaction kernel_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct kernel_ScriptPubkey kernel_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct kernel_TransactionOutput kernel_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * kernel_disable_logging(). Functions changing the logging settings are global\n+ * (and not thread safe) and change the settings for all existing\n+ * kernel_LoggingConnection instances.\n+ */\n+typedef struct kernel_LoggingConnection kernel_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct kernel_ChainParameters kernel_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct kernel_ContextOptions kernel_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context needs to be kept in\n+ * memory for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct kernel_Context kernel_Context;\n+\n+/**\n+ * Opaque data structure for holding a block index pointer.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of the\n+ * chainstate manager. It is valid for the lifetime of the chainstate manager it\n+ * was retrieved from.\n+ */\n+typedef struct kernel_BlockIndex kernel_BlockIndex;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct kernel_ChainstateManagerOptions kernel_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * The chainstate manager is only valid for as long as the context with which it\n+ * was created remains in memory.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct kernel_ChainstateManager kernel_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct kernel_Block kernel_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct kernel_BlockPointer kernel_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct kernel_BlockValidationState kernel_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding a block undo struct.\n+ *\n+ * It holds all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an entry\n+ * for each transaction in a block (in order of the actual transactions of the\n+ * block and minus the coinbase transaction). Each entry is in turn a vector of\n+ * all the previous outputs of a transaction (in order of their corresponding\n+ * inputs).\n+ */\n+typedef struct kernel_BlockUndo kernel_BlockUndo;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    kernel_INIT_REINDEX,\n+    kernel_INIT_DOWNLOAD,\n+    kernel_POST_INIT\n+} kernel_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    kernel_UNKNOWN_NEW_RULES_ACTIVATED,\n+    kernel_LARGE_WORK_INVALID_CHAIN\n+} kernel_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*kernel_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*kernel_NotifyBlockTip)(void* user_data, kernel_SynchronizationState state, const kernel_BlockIndex* index, double verification_progress);\n+typedef void (*kernel_NotifyHeaderTip)(void* user_data, kernel_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*kernel_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*kernel_NotifyWarningSet)(void* user_data, kernel_Warning warning, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyWarningUnset)(void* user_data, kernel_Warning warning);\n+typedef void (*kernel_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*kernel_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*kernel_ValidationInterfaceBlockChecked)(void* user_data, const kernel_BlockPointer* block, const kernel_BlockValidationState* state);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    kernel_VALIDATION_STATE_VALID = 0,\n+    kernel_VALIDATION_STATE_INVALID,\n+    kernel_VALIDATION_STATE_ERROR,\n+} kernel_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    kernel_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    kernel_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    kernel_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    kernel_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    kernel_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    kernel_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    kernel_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    kernel_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    kernel_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} kernel_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier. Note that these callbacks block any further validation\n+ * execution when they are called.\n+ */\n+typedef struct {\n+    const void* user_data;                                //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                          //!< interface callbacks.\n+    kernel_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                          //!< result of its validation.\n+} kernel_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                   //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    kernel_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block index.\n+    kernel_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    kernel_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    kernel_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    kernel_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    kernel_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    kernel_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} kernel_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    kernel_LOG_ALL = 0,\n+    kernel_LOG_BENCH,\n+    kernel_LOG_BLOCKSTORAGE,\n+    kernel_LOG_COINDB,\n+    kernel_LOG_LEVELDB,\n+    kernel_LOG_MEMPOOL,\n+    kernel_LOG_PRUNE,\n+    kernel_LOG_RAND,\n+    kernel_LOG_REINDEX,\n+    kernel_LOG_VALIDATION,\n+    kernel_LOG_KERNEL,\n+} kernel_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    kernel_LOG_TRACE = 0,\n+    kernel_LOG_DEBUG,\n+    kernel_LOG_INFO,\n+} kernel_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} kernel_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    kernel_SCRIPT_VERIFY_OK = 0,\n+    kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX, //!< The provided input index is out of range of the actual number of inputs of the transaction.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+    kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH, //!< The number of spent outputs does not match the number of inputs of the tx.\n+} kernel_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    kernel_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    kernel_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    kernel_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    kernel_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    kernel_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    kernel_SCRIPT_FLAGS_VERIFY_ALL                 = kernel_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     kernel_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} kernel_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    kernel_CHAIN_TYPE_MAINNET = 0,\n+    kernel_CHAIN_TYPE_TESTNET,\n+    kernel_CHAIN_TYPE_TESTNET_4,\n+    kernel_CHAIN_TYPE_SIGNET,\n+    kernel_CHAIN_TYPE_REGTEST,\n+} kernel_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} kernel_BlockHash;\n+\n+/**\n+ * Convenience struct for holding serialized data.\n+ */\n+typedef struct {\n+    unsigned char* data;\n+    size_t size;\n+} kernel_ByteArray;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_transaction_create(\n+    const unsigned char* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_destroy(kernel_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_create(\n+    const unsigned char* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey data into the returned byte array.\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The serialized script pubkey data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_script_pubkey_copy_data(\n+        const kernel_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API kernel_TransactionOutput* kernel_transaction_output_create(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies the script pubkey of an output in the returned script pubkey\n+ * opaque object.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The data for the output's script pubkey.\n+ */\n+BITCOINKERNEL_API kernel_ScriptPubkey* kernel_transaction_output_copy_script_pubkey(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Gets the amount associated with this transaction output\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t kernel_transaction_output_get_amount(kernel_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void kernel_transaction_output_destroy(kernel_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Script\n+ * Functions for working with scripts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `kernel_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of kernel_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to kernel_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_verify_script(\n+    const kernel_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const kernel_Transaction* tx_to,\n+    const kernel_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    kernel_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void kernel_logging_disable();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use `kernel_enable_log_category` to start\n+ * logging from a specific, or all categories. This function is not thread\n+ * safe. Mutiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void kernel_logging_set_level_category(const kernel_LogCategory category, kernel_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void kernel_logging_enable_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Mutiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref kernel_LoggingConnection instances.\n+ *\n+ * @param[in] category If kernel_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void kernel_logging_disable_category(const kernel_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_logging_connection_create(\n+    kernel_LogCallback callback,\n+    const void* user_data,\n+    const kernel_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void kernel_logging_connection_destroy(kernel_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API kernel_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chain_parameters_create(\n+    const kernel_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API kernel_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_chainparams(\n+    kernel_ContextOptions* context_options,\n+    const kernel_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref kernel_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_notifications(\n+    kernel_ContextOptions* context_options,\n+    kernel_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with kernel_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_set_validation_interface(\n+    kernel_ContextOptions* context_options,\n+    kernel_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void kernel_context_options_destroy(kernel_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref kernel_context_options_create.\n+ * @return                    The allocated kernel context, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Context* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_create(\n+    const kernel_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_context_interrupt(\n+    kernel_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void kernel_context_destroy(kernel_Context* context);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options will associate with this kernel context\n+ *                             for the duration of their lifetime. The same context needs to be used\n+ *                             when instantiating the chainstate manager.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_options_create(\n+    const kernel_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_worker_threads_num(\n+        kernel_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref kernel_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_options_set_wipe_dbs(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes. It is only valid for as long as\n+ * the passed in context also remains in memory.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref kernel_chainstate_manager_options_create.\n+ * @param[in] context                    Non-null, the created chainstate manager will associate with this\n+ *                                       kernel context for the duration of its lifetime. The same context\n+ *                                       needs to be used for later interactions with the chainstate manager.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_create(\n+    const kernel_Context* context,\n+    const kernel_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief May be called once the kernel_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] context              Non-null.\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool kernel_chainstate_manager_import_blocks(const kernel_Context* context,\n+                          kernel_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT kernel_chainstate_manager_process_block(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    kernel_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainstate_manager, const kernel_Context* context);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] context            Non-null.\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_index        Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_read(\n+    const kernel_Context* context,\n+    kernel_ChainstateManager* chainstate_manager,\n+    const kernel_BlockIndex* block_index\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API kernel_Block* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_create(\n+    const unsigned char* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_get_hash(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API kernel_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_get_hash(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_copy_data(\n+    kernel_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copies block data into the returned byte array.\n+ *\n+ * @param[in] block  Non-null.\n+ * @return           Allocated byte array holding the block data.\n+ */\n+BITCOINKERNEL_API kernel_ByteArray* BITCOINKERNEL_WARN_UNUSED_RESULT kernel_block_pointer_copy_data(\n+    const kernel_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the block.",
      "path": "src/kernel/bitcoinkernel.h",
      "position": 1151,
      "original_position": 970,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": 2216251677,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This was not relevant so far, since nothing could increment the reference count permanently. Will add once we have something that would exercise that case.",
      "created_at": "2025-07-28T16:43:23Z",
      "updated_at": "2025-07-28T16:43:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237234545",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237234545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1151,
      "original_line": 1151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237265558",
      "pull_request_review_id": 3063781091,
      "id": 2237265558,
      "node_id": "PRRC_kwDOABII586FWfaW",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_script_pubkey_copy_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_logging_set_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_logging_enable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // Switch back to buffering by calling DisconnectTestLogger if the\n+    // connection that was just removed was the last one.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::Main());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet4());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::SigNet({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        CChainParams* params = new CChainParams(*CChainParams::RegTest({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{cast_const_chain_params(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // The KernelNotifications are copy-initialized, so the caller can free them again.\n+    LOCK(options->m_mutex);\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    LOCK(options->m_mutex);\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_block_validation_state_get_validation_mode(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_block_validation_state_get_block_validation_result(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_chainstate_manager_options(options);\n+    }\n+}\n+\n+bool kernel_chainstate_manager_options_set_wipe_dbs(kernel_ChainstateManagerOptions* chainman_opts_, bool wipe_block_tree_db, bool wipe_chainstate_db)\n+{\n+    if (wipe_block_tree_db && !wipe_chainstate_db) {\n+        LogError(\"Wiping the block tree db without also wiping the chainstate db is currently unsupported.\");\n+        return false;\n+    }\n+    auto opts{cast_chainstate_manager_options(chainman_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.wipe_data = wipe_block_tree_db;\n+    opts->m_chainstate_load_options.wipe_chainstate_db = wipe_chainstate_db;\n+    return true;\n+}\n+\n+void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool block_tree_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.memory_only = block_tree_db_in_memory;\n+}\n+\n+void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool chainstate_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainstate_load_options.coins_db_in_memory = chainstate_db_in_memory;\n+}\n+\n+kernel_ChainstateManager* kernel_chainstate_manager_create(\n+    const kernel_Context* context_,\n+    const kernel_ChainstateManagerOptions* chainman_opts_)\n+{\n+    auto chainman_opts{cast_const_chainstate_manager_options(chainman_opts_)};\n+    auto context{cast_const_context(context_)};\n+\n+    ChainstateManager* chainman;\n+\n+    try {\n+        LOCK(chainman_opts->m_mutex);\n+        chainman = new ChainstateManager{*context->m_interrupt, chainman_opts->m_chainman_options, chainman_opts->m_blockman_options};\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    try {\n+        const auto chainstate_load_opts{WITH_LOCK(chainman_opts->m_mutex, return chainman_opts->m_chainstate_load_options)};\n+\n+        kernel::CacheSizes cache_sizes{DEFAULT_KERNEL_CACHE};\n+        auto [status, chainstate_err]{node::LoadChainstate(*chainman, cache_sizes, chainstate_load_opts)};\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to load chain state from your data directory: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+        std::tie(status, chainstate_err) = node::VerifyLoadedChainstate(*chainman, chainstate_load_opts);\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to verify loaded chain state from your datadir: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+\n+        for (Chainstate* chainstate : WITH_LOCK(chainman->GetMutex(), return chainman->GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n+                LogError(\"Failed to connect best block: %s\", state.ToString());\n+                kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+                return nullptr;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to load chainstate: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_ChainstateManager*>(chainman);\n+}\n+\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainman_, const kernel_Context* context_)\n+{\n+    if (!chainman_) return;\n+\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    {\n+        LOCK(chainman->GetMutex());\n+        for (Chainstate* chainstate : chainman->GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n+        }\n+    }\n+\n+    delete chainman;\n+    return;\n+}\n+\n+bool kernel_chainstate_manager_import_blocks(const kernel_Context* context_,\n+                          kernel_ChainstateManager* chainman_,\n+                          const char** block_file_paths,\n+                          size_t* block_file_paths_lens,\n+                          size_t block_file_paths_len)\n+{\n+    try {\n+        auto chainman{cast_chainstate_manager(chainman_)};\n+        std::vector<fs::path> import_files;\n+        import_files.reserve(block_file_paths_len);\n+        for (uint32_t i = 0; i < block_file_paths_len; i++) {\n+            if (block_file_paths[i] != nullptr) {\n+                import_files.emplace_back(std::string{block_file_paths[i], block_file_paths_lens[i]}.c_str());\n+            }\n+        }\n+        node::ImportBlocks(*chainman, import_files);\n+        chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to import blocks: %s\", e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+kernel_Block* kernel_block_create(const unsigned char* raw_block, size_t raw_block_length)\n+{\n+    auto block{new CBlock()};\n+\n+    DataStream stream{std::span{raw_block, raw_block_length}};\n+\n+    try {\n+        stream >> TX_WITH_WITNESS(*block);\n+    } catch (const std::exception&) {\n+        delete block;\n+        LogDebug(BCLog::KERNEL, \"Block decode failed.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_Block*>(new std::shared_ptr<CBlock>(block));\n+}\n+\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array)\n+{\n+    if (byte_array && byte_array->data) delete[] byte_array->data;\n+    if (byte_array) delete byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_copy_data(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(**block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_pointer_copy_data(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(*block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_BlockHash* kernel_block_get_hash(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+    auto hash{(*block)->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+kernel_BlockHash* kernel_block_pointer_get_hash(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    auto hash{block->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+void kernel_block_destroy(kernel_Block* block)\n+{\n+    if (block) {\n+        delete cast_cblocksharedpointer(block);\n+    }\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_tip(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Tip()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_genesis(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Genesis()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_hash(const kernel_Context* context_, kernel_ChainstateManager* chainman_, kernel_BlockHash* block_hash)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto hash = uint256{std::span<const unsigned char>{(*block_hash).hash, 32}};\n+    auto block_index = WITH_LOCK(chainman->GetMutex(), return chainman->m_blockman.LookupBlockIndex(hash));\n+    if (!block_index) {\n+        LogDebug(BCLog::KERNEL, \"A block with the given hash is not indexed.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_height(const kernel_Context* context_, kernel_ChainstateManager* chainman_, int height)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    LOCK(chainman->GetMutex());\n+\n+    if (height < 0 || height > chainman->ActiveChain().Height()) {\n+        LogDebug(BCLog::KERNEL, \"Block height is out of range.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(chainman->ActiveChain()[height]);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_next(const kernel_Context* context_, kernel_ChainstateManager* chainman_, const kernel_BlockIndex* block_index_)\n+{\n+    const auto block_index{cast_const_block_index(block_index_)};\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto next_block_index{WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Next(block_index))};\n+\n+    if (!next_block_index) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the tip of the current chain, it does not have a next.\");\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(next_block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_previous(const kernel_BlockIndex* block_index_)\n+{\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    if (!block_index->pprev) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the genesis, it has no previous.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index->pprev);\n+}\n+\n+kernel_Block* kernel_block_read(const kernel_Context* context_,\n+                                          kernel_ChainstateManager* chainman_,\n+                                          const kernel_BlockIndex* block_index_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    auto block{new std::shared_ptr<CBlock>(new CBlock{})};\n+    if (!chainman->m_blockman.ReadBlock(**block, *block_index)) {\n+        LogError(\"Failed to read block.\");",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 1045,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": 2216084200,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "They can't call `kernel_block_destroy`, we return `nullptr`. The failure branch needs to include `delete block` (or alternatively, as suggested, just instantiate `block` as a `std::unique_ptr` and then promote it to `shared_ptr` if reading succeeds.",
      "created_at": "2025-07-28T16:53:17Z",
      "updated_at": "2025-07-28T16:53:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237265558",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237265558"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1035,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237313429",
      "pull_request_review_id": 3063841085,
      "id": 2237313429,
      "node_id": "PRRC_kwDOABII586FWrGV",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<std::shared_ptr<CBlock>*>(block);\n+}\n+\n+const BlockValidationState* cast_block_validation_state(const kernel_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const kernel_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const kernel_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+const CBlockUndo* cast_const_block_undo(const kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<const CBlockUndo*>(undo);\n+}\n+\n+CBlockUndo* cast_block_undo(kernel_BlockUndo* undo)\n+{\n+    assert(undo);\n+    return reinterpret_cast<CBlockUndo*>(undo);\n+}\n+\n+\n+} // namespace\n+\n+kernel_Transaction* kernel_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx = new CTransaction{deserialize, TX_WITH_WITNESS, stream};\n+        return reinterpret_cast<kernel_Transaction*>(tx);\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_transaction_destroy(kernel_Transaction* transaction)\n+{\n+    if (transaction) {\n+        delete cast_transaction(transaction);\n+    }\n+}\n+\n+kernel_ScriptPubkey* kernel_script_pubkey_create(const unsigned char* script_pubkey_, size_t script_pubkey_len)\n+{\n+    auto script_pubkey = new CScript(script_pubkey_, script_pubkey_ + script_pubkey_len);\n+    return reinterpret_cast<kernel_ScriptPubkey*>(script_pubkey);\n+}\n+\n+kernel_ByteArray* kernel_script_pubkey_copy_data(const kernel_ScriptPubkey* script_pubkey_)\n+{\n+    auto script_pubkey{cast_script_pubkey(script_pubkey_)};\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[script_pubkey->size()],\n+        .size = script_pubkey->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+void kernel_script_pubkey_destroy(kernel_ScriptPubkey* script_pubkey)\n+{\n+    if (script_pubkey) {\n+        delete cast_script_pubkey(script_pubkey);\n+    }\n+}\n+\n+kernel_TransactionOutput* kernel_transaction_output_create(const kernel_ScriptPubkey* script_pubkey_, int64_t amount)\n+{\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+    const CAmount& value{amount};\n+    auto tx_out{new CTxOut(value, script_pubkey)};\n+    return reinterpret_cast<kernel_TransactionOutput*>(tx_out);\n+}\n+\n+void kernel_transaction_output_destroy(kernel_TransactionOutput* output)\n+{\n+    if (output) {\n+        delete cast_transaction_output(output);\n+    }\n+}\n+\n+bool kernel_verify_script(const kernel_ScriptPubkey* script_pubkey_,\n+                          const int64_t amount_,\n+                          const kernel_Transaction* tx_to,\n+                          const kernel_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          kernel_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+    const auto& script_pubkey{*cast_script_pubkey(script_pubkey_)};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*cast_transaction(tx_to)};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        if (spent_outputs_len != tx.vin.size()) {\n+            if (status) *status = kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH;\n+            return false;\n+        }\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*reinterpret_cast<const CTxOut*>(spent_outputs_[i])};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    if (input_index >= tx.vin.size()) {\n+        if (status) *status = kernel_SCRIPT_VERIFY_ERROR_TX_INPUT_INDEX;\n+        return false;\n+    }\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & kernel_SCRIPT_FLAGS_VERIFY_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    return VerifyScript(tx.vin[input_index].scriptSig,\n+                        script_pubkey,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+}\n+\n+void kernel_logging_set_level_category(const kernel_LogCategory category, const kernel_LogLevel level)\n+{\n+    if (category == kernel_LogCategory::kernel_LOG_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void kernel_logging_enable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable_category(const kernel_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void kernel_logging_disable()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+kernel_LoggingConnection* kernel_logging_connection_create(kernel_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const kernel_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception&) {\n+        LogError(\"Logger start failed.\");\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    auto heap_connection{new std::list<std::function<void(const std::string&)>>::iterator(connection)};\n+    return reinterpret_cast<kernel_LoggingConnection*>(heap_connection);\n+}\n+\n+void kernel_logging_connection_destroy(kernel_LoggingConnection* connection_)\n+{\n+    auto connection{reinterpret_cast<std::list<std::function<void(const std::string&)>>::iterator*>(connection_)};\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection);\n+    delete connection;\n+\n+    // Switch back to buffering by calling DisconnectTestLogger if the\n+    // connection that was just removed was the last one.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+}\n+\n+kernel_ChainParameters* kernel_chain_parameters_create(const kernel_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case kernel_ChainType::kernel_CHAIN_TYPE_MAINNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::Main());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_TESTNET_4: {\n+        CChainParams* params = new CChainParams(*CChainParams::TestNet4());\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_SIGNET: {\n+        CChainParams* params = new CChainParams(*CChainParams::SigNet({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    case kernel_ChainType::kernel_CHAIN_TYPE_REGTEST: {\n+        CChainParams* params = new CChainParams(*CChainParams::RegTest({}));\n+        return reinterpret_cast<kernel_ChainParameters*>(params);\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+void kernel_chain_parameters_destroy(kernel_ChainParameters* chain_parameters)\n+{\n+    if (chain_parameters) {\n+        delete cast_chain_params(chain_parameters);\n+    }\n+}\n+\n+kernel_ContextOptions* kernel_context_options_create()\n+{\n+    return reinterpret_cast<kernel_ContextOptions*>(new ContextOptions{});\n+}\n+\n+void kernel_context_options_set_chainparams(kernel_ContextOptions* options_, const kernel_ChainParameters* chain_parameters)\n+{\n+    auto options{cast_context_options(options_)};\n+    auto chain_params{cast_const_chain_params(chain_parameters)};\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_mutex);\n+    options->m_chainparams = std::make_unique<const CChainParams>(*chain_params);\n+}\n+\n+void kernel_context_options_set_notifications(kernel_ContextOptions* options_, kernel_NotificationInterfaceCallbacks notifications)\n+{\n+    auto options{cast_context_options(options_)};\n+    // The KernelNotifications are copy-initialized, so the caller can free them again.\n+    LOCK(options->m_mutex);\n+    options->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void kernel_context_options_set_validation_interface(kernel_ContextOptions* options_, kernel_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    auto options{cast_context_options(options_)};\n+    LOCK(options->m_mutex);\n+    options->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void kernel_context_options_destroy(kernel_ContextOptions* options)\n+{\n+    if (options) {\n+        delete cast_context_options(options);\n+    }\n+}\n+\n+kernel_Context* kernel_context_create(const kernel_ContextOptions* options_)\n+{\n+    auto options{cast_const_context_options(options_)};\n+    bool sane{true};\n+    auto context{new Context{options, sane}};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        delete context;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_Context*>(context);\n+}\n+\n+bool kernel_context_interrupt(kernel_Context* context_)\n+{\n+    auto& context{*cast_context(context_)};\n+    return (*context.m_interrupt)();\n+}\n+\n+void kernel_context_destroy(kernel_Context* context)\n+{\n+    if (context) {\n+        delete cast_context(context);\n+    }\n+}\n+\n+kernel_ValidationMode kernel_block_validation_state_get_validation_mode(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_VALID;\n+    if (block_validation_state.IsInvalid()) return kernel_ValidationMode::kernel_VALIDATION_STATE_INVALID;\n+    return kernel_ValidationMode::kernel_VALIDATION_STATE_ERROR;\n+}\n+\n+kernel_BlockValidationResult kernel_block_validation_state_get_block_validation_result(const kernel_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return kernel_BlockValidationResult::kernel_BLOCK_RESULT_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return kernel_BlockValidationResult::kernel_BLOCK_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return kernel_BlockValidationResult::kernel_BLOCK_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return kernel_BlockValidationResult::kernel_BLOCK_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return kernel_BlockValidationResult::kernel_BLOCK_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_ChainstateManagerOptions* kernel_chainstate_manager_options_create(const kernel_Context* context_, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto context{cast_const_context(context_)};\n+        return reinterpret_cast<kernel_ChainstateManagerOptions*>(new ChainstateManagerOptions(context, abs_data_dir, abs_blocks_dir));\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void kernel_chainstate_manager_options_set_worker_threads_num(kernel_ChainstateManagerOptions* opts_, int worker_threads)\n+{\n+    auto opts{cast_chainstate_manager_options(opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void kernel_chainstate_manager_options_destroy(kernel_ChainstateManagerOptions* options)\n+{\n+    if (options) {\n+        delete cast_chainstate_manager_options(options);\n+    }\n+}\n+\n+bool kernel_chainstate_manager_options_set_wipe_dbs(kernel_ChainstateManagerOptions* chainman_opts_, bool wipe_block_tree_db, bool wipe_chainstate_db)\n+{\n+    if (wipe_block_tree_db && !wipe_chainstate_db) {\n+        LogError(\"Wiping the block tree db without also wiping the chainstate db is currently unsupported.\");\n+        return false;\n+    }\n+    auto opts{cast_chainstate_manager_options(chainman_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.wipe_data = wipe_block_tree_db;\n+    opts->m_chainstate_load_options.wipe_chainstate_db = wipe_chainstate_db;\n+    return true;\n+}\n+\n+void kernel_chainstate_manager_options_set_block_tree_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool block_tree_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_blockman_options.block_tree_db_params.memory_only = block_tree_db_in_memory;\n+}\n+\n+void kernel_chainstate_manager_options_set_chainstate_db_in_memory(\n+    kernel_ChainstateManagerOptions* chainstate_load_opts_,\n+    bool chainstate_db_in_memory)\n+{\n+    auto opts{cast_chainstate_manager_options(chainstate_load_opts_)};\n+    LOCK(opts->m_mutex);\n+    opts->m_chainstate_load_options.coins_db_in_memory = chainstate_db_in_memory;\n+}\n+\n+kernel_ChainstateManager* kernel_chainstate_manager_create(\n+    const kernel_Context* context_,\n+    const kernel_ChainstateManagerOptions* chainman_opts_)\n+{\n+    auto chainman_opts{cast_const_chainstate_manager_options(chainman_opts_)};\n+    auto context{cast_const_context(context_)};\n+\n+    ChainstateManager* chainman;\n+\n+    try {\n+        LOCK(chainman_opts->m_mutex);\n+        chainman = new ChainstateManager{*context->m_interrupt, chainman_opts->m_chainman_options, chainman_opts->m_blockman_options};\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    try {\n+        const auto chainstate_load_opts{WITH_LOCK(chainman_opts->m_mutex, return chainman_opts->m_chainstate_load_options)};\n+\n+        kernel::CacheSizes cache_sizes{DEFAULT_KERNEL_CACHE};\n+        auto [status, chainstate_err]{node::LoadChainstate(*chainman, cache_sizes, chainstate_load_opts)};\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to load chain state from your data directory: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+        std::tie(status, chainstate_err) = node::VerifyLoadedChainstate(*chainman, chainstate_load_opts);\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to verify loaded chain state from your datadir: %s\", chainstate_err.original);\n+            kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+            return nullptr;\n+        }\n+\n+        for (Chainstate* chainstate : WITH_LOCK(chainman->GetMutex(), return chainman->GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n+                LogError(\"Failed to connect best block: %s\", state.ToString());\n+                kernel_chainstate_manager_destroy(reinterpret_cast<kernel_ChainstateManager*>(chainman), context_);\n+                return nullptr;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to load chainstate: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_ChainstateManager*>(chainman);\n+}\n+\n+void kernel_chainstate_manager_destroy(kernel_ChainstateManager* chainman_, const kernel_Context* context_)\n+{\n+    if (!chainman_) return;\n+\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    {\n+        LOCK(chainman->GetMutex());\n+        for (Chainstate* chainstate : chainman->GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n+        }\n+    }\n+\n+    delete chainman;\n+    return;\n+}\n+\n+bool kernel_chainstate_manager_import_blocks(const kernel_Context* context_,\n+                          kernel_ChainstateManager* chainman_,\n+                          const char** block_file_paths,\n+                          size_t* block_file_paths_lens,\n+                          size_t block_file_paths_len)\n+{\n+    try {\n+        auto chainman{cast_chainstate_manager(chainman_)};\n+        std::vector<fs::path> import_files;\n+        import_files.reserve(block_file_paths_len);\n+        for (uint32_t i = 0; i < block_file_paths_len; i++) {\n+            if (block_file_paths[i] != nullptr) {\n+                import_files.emplace_back(std::string{block_file_paths[i], block_file_paths_lens[i]}.c_str());\n+            }\n+        }\n+        node::ImportBlocks(*chainman, import_files);\n+        chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to import blocks: %s\", e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+kernel_Block* kernel_block_create(const unsigned char* raw_block, size_t raw_block_length)\n+{\n+    auto block{new CBlock()};\n+\n+    DataStream stream{std::span{raw_block, raw_block_length}};\n+\n+    try {\n+        stream >> TX_WITH_WITNESS(*block);\n+    } catch (const std::exception&) {\n+        delete block;\n+        LogDebug(BCLog::KERNEL, \"Block decode failed.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_Block*>(new std::shared_ptr<CBlock>(block));\n+}\n+\n+void kernel_byte_array_destroy(kernel_ByteArray* byte_array)\n+{\n+    if (byte_array && byte_array->data) delete[] byte_array->data;\n+    if (byte_array) delete byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_copy_data(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(**block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_ByteArray* kernel_block_pointer_copy_data(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+\n+    DataStream ss{};\n+    ss << TX_WITH_WITNESS(*block);\n+\n+    auto byte_array{new kernel_ByteArray{\n+        .data = new unsigned char[ss.size()],\n+        .size = ss.size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, ss.data(), byte_array->size);\n+\n+    return byte_array;\n+}\n+\n+kernel_BlockHash* kernel_block_get_hash(kernel_Block* block_)\n+{\n+    auto block{cast_cblocksharedpointer(block_)};\n+    auto hash{(*block)->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+kernel_BlockHash* kernel_block_pointer_get_hash(const kernel_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    auto hash{block->GetHash()};\n+    auto block_hash = new kernel_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+void kernel_block_destroy(kernel_Block* block)\n+{\n+    if (block) {\n+        delete cast_cblocksharedpointer(block);\n+    }\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_tip(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Tip()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_genesis(const kernel_Context* context_, kernel_ChainstateManager* chainman_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    return reinterpret_cast<kernel_BlockIndex*>(WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Genesis()));\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_hash(const kernel_Context* context_, kernel_ChainstateManager* chainman_, kernel_BlockHash* block_hash)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto hash = uint256{std::span<const unsigned char>{(*block_hash).hash, 32}};\n+    auto block_index = WITH_LOCK(chainman->GetMutex(), return chainman->m_blockman.LookupBlockIndex(hash));\n+    if (!block_index) {\n+        LogDebug(BCLog::KERNEL, \"A block with the given hash is not indexed.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_by_height(const kernel_Context* context_, kernel_ChainstateManager* chainman_, int height)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    LOCK(chainman->GetMutex());\n+\n+    if (height < 0 || height > chainman->ActiveChain().Height()) {\n+        LogDebug(BCLog::KERNEL, \"Block height is out of range.\");\n+        return nullptr;\n+    }\n+    return reinterpret_cast<kernel_BlockIndex*>(chainman->ActiveChain()[height]);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_next(const kernel_Context* context_, kernel_ChainstateManager* chainman_, const kernel_BlockIndex* block_index_)\n+{\n+    const auto block_index{cast_const_block_index(block_index_)};\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+\n+    auto next_block_index{WITH_LOCK(chainman->GetMutex(), return chainman->ActiveChain().Next(block_index))};\n+\n+    if (!next_block_index) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the tip of the current chain, it does not have a next.\");\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(next_block_index);\n+}\n+\n+kernel_BlockIndex* kernel_block_index_get_previous(const kernel_BlockIndex* block_index_)\n+{\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    if (!block_index->pprev) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the genesis, it has no previous.\");\n+        return nullptr;\n+    }\n+\n+    return reinterpret_cast<kernel_BlockIndex*>(block_index->pprev);\n+}\n+\n+kernel_Block* kernel_block_read(const kernel_Context* context_,\n+                                          kernel_ChainstateManager* chainman_,\n+                                          const kernel_BlockIndex* block_index_)\n+{\n+    auto chainman{cast_chainstate_manager(chainman_)};\n+    const CBlockIndex* block_index{cast_const_block_index(block_index_)};\n+\n+    auto block{new std::shared_ptr<CBlock>(new CBlock{})};\n+    if (!chainman->m_blockman.ReadBlock(**block, *block_index)) {\n+        LogError(\"Failed to read block.\");",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 1045,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": 2216084200,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right, there is also no test for this :(. Will fix and add a test.",
      "created_at": "2025-07-28T17:09:50Z",
      "updated_at": "2025-07-28T17:09:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237313429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237313429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1035,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237499919",
      "pull_request_review_id": 3064109250,
      "id": 2237499919,
      "node_id": "PRRC_kwDOABII586FXYoP",
      "diff_hunk": "@@ -1,11 +1,1184 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context kernel_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(kernel_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const kernel_LogLevel level)\n+{\n+    switch (level) {\n+    case kernel_LogLevel::kernel_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case kernel_LogLevel::kernel_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case kernel_LogLevel::kernel_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const kernel_LogCategory category)\n+{\n+    switch (category) {\n+    case kernel_LogCategory::kernel_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case kernel_LogCategory::kernel_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case kernel_LogCategory::kernel_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case kernel_LogCategory::kernel_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case kernel_LogCategory::kernel_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case kernel_LogCategory::kernel_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case kernel_LogCategory::kernel_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case kernel_LogCategory::kernel_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return kernel_SynchronizationState::kernel_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return kernel_SynchronizationState::kernel_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return kernel_SynchronizationState::kernel_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+kernel_Warning cast_kernel_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return kernel_Warning::kernel_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return kernel_Warning::kernel_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    kernel_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(kernel_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const kernel_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_kernel_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_kernel_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const kernel_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const kernel_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const kernel_BlockPointer*>(&block),\n+                                reinterpret_cast<const kernel_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(kernel_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const Context* context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const CTransaction* cast_transaction(const kernel_Transaction* transaction)\n+{\n+    assert(transaction);\n+    return reinterpret_cast<const CTransaction*>(transaction);\n+}\n+\n+const CScript* cast_script_pubkey(const kernel_ScriptPubkey* script_pubkey)\n+{\n+    assert(script_pubkey);\n+    return reinterpret_cast<const CScript*>(script_pubkey);\n+}\n+\n+const CTxOut* cast_transaction_output(const kernel_TransactionOutput* transaction_output)\n+{\n+    assert(transaction_output);\n+    return reinterpret_cast<const CTxOut*>(transaction_output);\n+}\n+\n+const ContextOptions* cast_const_context_options(const kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ContextOptions*>(options);\n+}\n+\n+ContextOptions* cast_context_options(kernel_ContextOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ContextOptions*>(options);\n+}\n+\n+const CChainParams* cast_const_chain_params(const kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<const CChainParams*>(chain_params);\n+}\n+\n+CChainParams* cast_chain_params(kernel_ChainParameters* chain_params)\n+{\n+    assert(chain_params);\n+    return reinterpret_cast<CChainParams*>(chain_params);\n+}\n+\n+Context* cast_context(kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<Context*>(context);\n+}\n+\n+const Context* cast_const_context(const kernel_Context* context)\n+{\n+    assert(context);\n+    return reinterpret_cast<const Context*>(context);\n+}\n+\n+const ChainstateManagerOptions* cast_const_chainstate_manager_options(const kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<const ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManagerOptions* cast_chainstate_manager_options(kernel_ChainstateManagerOptions* options)\n+{\n+    assert(options);\n+    return reinterpret_cast<ChainstateManagerOptions*>(options);\n+}\n+\n+ChainstateManager* cast_chainstate_manager(kernel_ChainstateManager* chainman)\n+{\n+    assert(chainman);\n+    return reinterpret_cast<ChainstateManager*>(chainman);\n+}\n+\n+std::shared_ptr<CBlock>* cast_cblocksharedpointer(kernel_Block* block)",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": null,
      "original_position": 377,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "1ffc1c9d94b16cdbfb92a26d0f0e75451efad4fe",
      "in_reply_to_id": 2237140589,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Concept ACK. I suggested the same thing :)",
      "created_at": "2025-07-28T18:16:21Z",
      "updated_at": "2025-07-28T18:16:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2237499919",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2237499919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269246976",
      "pull_request_review_id": 3109486218,
      "id": 2269246976,
      "node_id": "PRRC_kwDOABII586HQfYA",
      "diff_hunk": "@@ -1,11 +1,1172 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context btck_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(btck_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const btck_LogLevel level)\n+{\n+    switch (level) {\n+    case btck_LogLevel::btck_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case btck_LogLevel::btck_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case btck_LogLevel::btck_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const btck_LogCategory category)\n+{\n+    switch (category) {\n+    case btck_LogCategory::btck_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case btck_LogCategory::btck_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case btck_LogCategory::btck_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case btck_LogCategory::btck_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case btck_LogCategory::btck_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case btck_LogCategory::btck_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case btck_LogCategory::btck_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case btck_LogCategory::btck_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case btck_LogCategory::btck_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case btck_LogCategory::btck_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case btck_LogCategory::btck_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return btck_SynchronizationState::btck_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return btck_SynchronizationState::btck_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return btck_SynchronizationState::btck_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_Warning cast_btck_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return btck_Warning::btck_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return btck_Warning::btck_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    btck_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(btck_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const btck_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_btck_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_btck_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const btck_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const btck_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const btck_BlockPointer*>(&block),\n+                                reinterpret_cast<const btck_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(btck_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    std::shared_ptr<Context> m_context;\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const std::shared_ptr<Context>& context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_context{context},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const BlockValidationState* cast_block_validation_state(const btck_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const btck_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const btck_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+} // namespace\n+\n+struct btck_Transaction\n+{\n+    std::shared_ptr<const CTransaction> m_tx;\n+};\n+\n+struct btck_TransactionOutput\n+{\n+    const CTxOut* m_txout;\n+    bool m_owned;\n+};\n+\n+struct btck_ScriptPubkey\n+{\n+    const CScript* m_script;\n+    bool m_owned;\n+};\n+\n+struct btck_LoggingConnection\n+{\n+    std::unique_ptr<std::list<std::function<void(const std::string&)>>::iterator> m_connection;\n+};\n+\n+struct btck_ContextOptions\n+{\n+    std::unique_ptr<ContextOptions> m_opts;\n+};\n+\n+struct btck_Context\n+{\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_ChainParameters\n+{\n+    std::unique_ptr<const CChainParams> m_params;\n+};\n+\n+struct btck_ChainstateManagerOptions\n+{\n+    std::unique_ptr<ChainstateManagerOptions> m_opts;\n+};\n+\n+struct btck_ChainstateManager\n+{\n+    std::unique_ptr<ChainstateManager> m_chainman;\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_Block\n+{\n+    std::shared_ptr<CBlock> m_block;\n+};\n+\n+struct btck_BlockSpentOutputs\n+{\n+    std::shared_ptr<CBlockUndo> m_block_undo;\n+};\n+\n+struct btck_TransactionSpentOutputs\n+{\n+    const CTxUndo* m_tx_undo;\n+    bool m_owned;\n+};\n+\n+struct btck_Coin\n+{\n+    const Coin* m_coin;\n+    bool m_owned;\n+};\n+\n+btck_Transaction* btck_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx{std::make_shared<CTransaction>(deserialize, TX_WITH_WITNESS, stream)};\n+        return new btck_Transaction{std::move(tx)};\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+uint64_t btck_transaction_count_outputs(const btck_Transaction* transaction)\n+{\n+    return transaction->m_tx->vout.size();\n+}\n+\n+btck_TransactionOutput* btck_transaction_get_output_at(const btck_Transaction* transaction, uint64_t output_index)\n+{\n+    assert(output_index < transaction->m_tx->vout.size());\n+    return new btck_TransactionOutput{&transaction->m_tx->vout[output_index], false};\n+}\n+\n+btck_Transaction* btck_transaction_copy(const btck_Transaction* transaction)\n+{\n+    return new btck_Transaction{transaction->m_tx};\n+}\n+\n+void btck_transaction_destroy(btck_Transaction* transaction)\n+{\n+    if (!transaction) return;\n+    delete transaction;\n+    transaction = nullptr;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_create(const unsigned char* script_pubkey, size_t script_pubkey_len)\n+{\n+    return new btck_ScriptPubkey{new CScript(script_pubkey, script_pubkey + script_pubkey_len), true};\n+}\n+\n+btck_ByteArray* btck_script_pubkey_copy_data(const btck_ScriptPubkey* script_pubkey)\n+{\n+    auto byte_array{new btck_ByteArray{\n+        .data = new unsigned char[script_pubkey->m_script->size()],\n+        .size = script_pubkey->m_script->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->m_script->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_copy(const btck_ScriptPubkey* script_pubkey)\n+{\n+    return new btck_ScriptPubkey{new CScript(*script_pubkey->m_script), true};\n+}\n+\n+void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey)\n+{\n+    if (!script_pubkey) return;\n+    if (script_pubkey->m_owned) {\n+        delete script_pubkey->m_script;\n+    }\n+    delete script_pubkey;\n+    script_pubkey = nullptr;\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_create(const btck_ScriptPubkey* script_pubkey, int64_t amount)\n+{\n+    const CAmount& value{amount};\n+    return new btck_TransactionOutput{new CTxOut(value, *script_pubkey->m_script), true};\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_copy(const btck_TransactionOutput* output)\n+{\n+    return new btck_TransactionOutput{new CTxOut{*output->m_txout}, true};\n+}\n+\n+btck_ScriptPubkey* btck_transaction_output_get_script_pubkey(const btck_TransactionOutput* output)\n+{\n+    const auto* script_pubkey{&output->m_txout->scriptPubKey};\n+    return new btck_ScriptPubkey{script_pubkey, false};\n+}\n+\n+int64_t btck_transaction_output_get_amount(const btck_TransactionOutput* output)\n+{\n+    return output->m_txout->nValue;\n+}\n+\n+void btck_transaction_output_destroy(btck_TransactionOutput* output)\n+{\n+    if (!output) return;\n+    if (output->m_owned) {\n+        delete output->m_txout;\n+    }\n+    delete output;\n+    output = nullptr;\n+}\n+\n+bool btck_script_pubkey_verify(const btck_ScriptPubkey* script_pubkey,\n+                          const int64_t amount_,\n+                          const btck_Transaction* tx_to,\n+                          const btck_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          btck_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & btck_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*tx_to->m_tx};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        assert(spent_outputs_len == tx.vin.size());",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": 541,
      "original_position": 522,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "in_reply_to_id": null,
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What was the motivation to remove `kernel_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_MISMATCH`? ",
      "created_at": "2025-08-12T09:23:19Z",
      "updated_at": "2025-08-12T10:32:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2269246976",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269246976"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269587027",
      "pull_request_review_id": 3110066062,
      "id": 2269587027,
      "node_id": "PRRC_kwDOABII586HRyZT",
      "diff_hunk": "@@ -1,11 +1,1172 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context btck_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(btck_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const btck_LogLevel level)\n+{\n+    switch (level) {\n+    case btck_LogLevel::btck_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case btck_LogLevel::btck_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case btck_LogLevel::btck_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const btck_LogCategory category)\n+{\n+    switch (category) {\n+    case btck_LogCategory::btck_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case btck_LogCategory::btck_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case btck_LogCategory::btck_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case btck_LogCategory::btck_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case btck_LogCategory::btck_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case btck_LogCategory::btck_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case btck_LogCategory::btck_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case btck_LogCategory::btck_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case btck_LogCategory::btck_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case btck_LogCategory::btck_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case btck_LogCategory::btck_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return btck_SynchronizationState::btck_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return btck_SynchronizationState::btck_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return btck_SynchronizationState::btck_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_Warning cast_btck_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return btck_Warning::btck_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return btck_Warning::btck_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    btck_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(btck_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const btck_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_btck_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_btck_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const btck_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const btck_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const btck_BlockPointer*>(&block),\n+                                reinterpret_cast<const btck_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(btck_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    std::shared_ptr<Context> m_context;\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const std::shared_ptr<Context>& context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_context{context},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const BlockValidationState* cast_block_validation_state(const btck_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const btck_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const btck_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+} // namespace\n+\n+struct btck_Transaction\n+{\n+    std::shared_ptr<const CTransaction> m_tx;\n+};\n+\n+struct btck_TransactionOutput\n+{\n+    const CTxOut* m_txout;\n+    bool m_owned;\n+};\n+\n+struct btck_ScriptPubkey\n+{\n+    const CScript* m_script;\n+    bool m_owned;\n+};\n+\n+struct btck_LoggingConnection\n+{\n+    std::unique_ptr<std::list<std::function<void(const std::string&)>>::iterator> m_connection;\n+};\n+\n+struct btck_ContextOptions\n+{\n+    std::unique_ptr<ContextOptions> m_opts;\n+};\n+\n+struct btck_Context\n+{\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_ChainParameters\n+{\n+    std::unique_ptr<const CChainParams> m_params;\n+};\n+\n+struct btck_ChainstateManagerOptions\n+{\n+    std::unique_ptr<ChainstateManagerOptions> m_opts;\n+};\n+\n+struct btck_ChainstateManager\n+{\n+    std::unique_ptr<ChainstateManager> m_chainman;\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_Block\n+{\n+    std::shared_ptr<CBlock> m_block;\n+};\n+\n+struct btck_BlockSpentOutputs\n+{\n+    std::shared_ptr<CBlockUndo> m_block_undo;\n+};\n+\n+struct btck_TransactionSpentOutputs\n+{\n+    const CTxUndo* m_tx_undo;\n+    bool m_owned;\n+};\n+\n+struct btck_Coin\n+{\n+    const Coin* m_coin;\n+    bool m_owned;\n+};\n+\n+btck_Transaction* btck_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx{std::make_shared<CTransaction>(deserialize, TX_WITH_WITNESS, stream)};\n+        return new btck_Transaction{std::move(tx)};\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+uint64_t btck_transaction_count_outputs(const btck_Transaction* transaction)\n+{\n+    return transaction->m_tx->vout.size();\n+}\n+\n+btck_TransactionOutput* btck_transaction_get_output_at(const btck_Transaction* transaction, uint64_t output_index)\n+{\n+    assert(output_index < transaction->m_tx->vout.size());\n+    return new btck_TransactionOutput{&transaction->m_tx->vout[output_index], false};\n+}\n+\n+btck_Transaction* btck_transaction_copy(const btck_Transaction* transaction)\n+{\n+    return new btck_Transaction{transaction->m_tx};\n+}\n+\n+void btck_transaction_destroy(btck_Transaction* transaction)\n+{\n+    if (!transaction) return;\n+    delete transaction;\n+    transaction = nullptr;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_create(const unsigned char* script_pubkey, size_t script_pubkey_len)\n+{\n+    return new btck_ScriptPubkey{new CScript(script_pubkey, script_pubkey + script_pubkey_len), true};\n+}\n+\n+btck_ByteArray* btck_script_pubkey_copy_data(const btck_ScriptPubkey* script_pubkey)\n+{\n+    auto byte_array{new btck_ByteArray{\n+        .data = new unsigned char[script_pubkey->m_script->size()],\n+        .size = script_pubkey->m_script->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->m_script->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_copy(const btck_ScriptPubkey* script_pubkey)\n+{\n+    return new btck_ScriptPubkey{new CScript(*script_pubkey->m_script), true};\n+}\n+\n+void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey)\n+{\n+    if (!script_pubkey) return;\n+    if (script_pubkey->m_owned) {\n+        delete script_pubkey->m_script;\n+    }\n+    delete script_pubkey;\n+    script_pubkey = nullptr;\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_create(const btck_ScriptPubkey* script_pubkey, int64_t amount)\n+{\n+    const CAmount& value{amount};\n+    return new btck_TransactionOutput{new CTxOut(value, *script_pubkey->m_script), true};\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_copy(const btck_TransactionOutput* output)\n+{\n+    return new btck_TransactionOutput{new CTxOut{*output->m_txout}, true};\n+}\n+\n+btck_ScriptPubkey* btck_transaction_output_get_script_pubkey(const btck_TransactionOutput* output)\n+{\n+    const auto* script_pubkey{&output->m_txout->scriptPubKey};\n+    return new btck_ScriptPubkey{script_pubkey, false};\n+}\n+\n+int64_t btck_transaction_output_get_amount(const btck_TransactionOutput* output)\n+{\n+    return output->m_txout->nValue;\n+}\n+\n+void btck_transaction_output_destroy(btck_TransactionOutput* output)\n+{\n+    if (!output) return;\n+    if (output->m_owned) {\n+        delete output->m_txout;\n+    }\n+    delete output;\n+    output = nullptr;\n+}\n+\n+bool btck_script_pubkey_verify(const btck_ScriptPubkey* script_pubkey,\n+                          const int64_t amount_,\n+                          const btck_Transaction* tx_to,\n+                          const btck_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          btck_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & btck_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*tx_to->m_tx};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        assert(spent_outputs_len == tx.vin.size());",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": 541,
      "original_position": 522,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "in_reply_to_id": 2269246976,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The idea is that bad inputs which obviously arise from insufficient input sanitation or programming errors is not handled through returning errors, but rather enforced by contract. I think all potential size mismatches and out of bounds errors fall into this category.",
      "created_at": "2025-08-12T11:47:30Z",
      "updated_at": "2025-08-12T11:47:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2269587027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269587027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269696749",
      "pull_request_review_id": 3110396272,
      "id": 2269696749,
      "node_id": "PRRC_kwDOABII586HSNLt",
      "diff_hunk": "@@ -1,11 +1,1172 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context btck_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(btck_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const btck_LogLevel level)\n+{\n+    switch (level) {\n+    case btck_LogLevel::btck_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case btck_LogLevel::btck_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case btck_LogLevel::btck_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const btck_LogCategory category)\n+{\n+    switch (category) {\n+    case btck_LogCategory::btck_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case btck_LogCategory::btck_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case btck_LogCategory::btck_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case btck_LogCategory::btck_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case btck_LogCategory::btck_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case btck_LogCategory::btck_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case btck_LogCategory::btck_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case btck_LogCategory::btck_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case btck_LogCategory::btck_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case btck_LogCategory::btck_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case btck_LogCategory::btck_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return btck_SynchronizationState::btck_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return btck_SynchronizationState::btck_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return btck_SynchronizationState::btck_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_Warning cast_btck_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return btck_Warning::btck_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return btck_Warning::btck_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    btck_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(btck_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const btck_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_btck_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_btck_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const btck_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const btck_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const btck_BlockPointer*>(&block),\n+                                reinterpret_cast<const btck_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(btck_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    std::shared_ptr<Context> m_context;\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const std::shared_ptr<Context>& context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_context{context},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const BlockValidationState* cast_block_validation_state(const btck_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const btck_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const btck_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+} // namespace\n+\n+struct btck_Transaction\n+{\n+    std::shared_ptr<const CTransaction> m_tx;\n+};\n+\n+struct btck_TransactionOutput\n+{\n+    const CTxOut* m_txout;\n+    bool m_owned;\n+};\n+\n+struct btck_ScriptPubkey\n+{\n+    const CScript* m_script;\n+    bool m_owned;\n+};\n+\n+struct btck_LoggingConnection\n+{\n+    std::unique_ptr<std::list<std::function<void(const std::string&)>>::iterator> m_connection;\n+};\n+\n+struct btck_ContextOptions\n+{\n+    std::unique_ptr<ContextOptions> m_opts;\n+};\n+\n+struct btck_Context\n+{\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_ChainParameters\n+{\n+    std::unique_ptr<const CChainParams> m_params;\n+};\n+\n+struct btck_ChainstateManagerOptions\n+{\n+    std::unique_ptr<ChainstateManagerOptions> m_opts;\n+};\n+\n+struct btck_ChainstateManager\n+{\n+    std::unique_ptr<ChainstateManager> m_chainman;\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_Block\n+{\n+    std::shared_ptr<CBlock> m_block;\n+};\n+\n+struct btck_BlockSpentOutputs\n+{\n+    std::shared_ptr<CBlockUndo> m_block_undo;\n+};\n+\n+struct btck_TransactionSpentOutputs\n+{\n+    const CTxUndo* m_tx_undo;\n+    bool m_owned;\n+};\n+\n+struct btck_Coin\n+{\n+    const Coin* m_coin;\n+    bool m_owned;\n+};\n+\n+btck_Transaction* btck_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx{std::make_shared<CTransaction>(deserialize, TX_WITH_WITNESS, stream)};\n+        return new btck_Transaction{std::move(tx)};\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+uint64_t btck_transaction_count_outputs(const btck_Transaction* transaction)\n+{\n+    return transaction->m_tx->vout.size();\n+}\n+\n+btck_TransactionOutput* btck_transaction_get_output_at(const btck_Transaction* transaction, uint64_t output_index)\n+{\n+    assert(output_index < transaction->m_tx->vout.size());\n+    return new btck_TransactionOutput{&transaction->m_tx->vout[output_index], false};\n+}\n+\n+btck_Transaction* btck_transaction_copy(const btck_Transaction* transaction)\n+{\n+    return new btck_Transaction{transaction->m_tx};\n+}\n+\n+void btck_transaction_destroy(btck_Transaction* transaction)\n+{\n+    if (!transaction) return;\n+    delete transaction;\n+    transaction = nullptr;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_create(const unsigned char* script_pubkey, size_t script_pubkey_len)\n+{\n+    return new btck_ScriptPubkey{new CScript(script_pubkey, script_pubkey + script_pubkey_len), true};\n+}\n+\n+btck_ByteArray* btck_script_pubkey_copy_data(const btck_ScriptPubkey* script_pubkey)\n+{\n+    auto byte_array{new btck_ByteArray{\n+        .data = new unsigned char[script_pubkey->m_script->size()],\n+        .size = script_pubkey->m_script->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->m_script->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_copy(const btck_ScriptPubkey* script_pubkey)\n+{\n+    return new btck_ScriptPubkey{new CScript(*script_pubkey->m_script), true};\n+}\n+\n+void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey)\n+{\n+    if (!script_pubkey) return;\n+    if (script_pubkey->m_owned) {\n+        delete script_pubkey->m_script;\n+    }\n+    delete script_pubkey;\n+    script_pubkey = nullptr;\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_create(const btck_ScriptPubkey* script_pubkey, int64_t amount)\n+{\n+    const CAmount& value{amount};\n+    return new btck_TransactionOutput{new CTxOut(value, *script_pubkey->m_script), true};\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_copy(const btck_TransactionOutput* output)\n+{\n+    return new btck_TransactionOutput{new CTxOut{*output->m_txout}, true};\n+}\n+\n+btck_ScriptPubkey* btck_transaction_output_get_script_pubkey(const btck_TransactionOutput* output)\n+{\n+    const auto* script_pubkey{&output->m_txout->scriptPubKey};\n+    return new btck_ScriptPubkey{script_pubkey, false};\n+}\n+\n+int64_t btck_transaction_output_get_amount(const btck_TransactionOutput* output)\n+{\n+    return output->m_txout->nValue;\n+}\n+\n+void btck_transaction_output_destroy(btck_TransactionOutput* output)\n+{\n+    if (!output) return;\n+    if (output->m_owned) {\n+        delete output->m_txout;\n+    }\n+    delete output;\n+    output = nullptr;\n+}\n+\n+bool btck_script_pubkey_verify(const btck_ScriptPubkey* script_pubkey,\n+                          const int64_t amount_,\n+                          const btck_Transaction* tx_to,\n+                          const btck_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          btck_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & btck_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*tx_to->m_tx};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        assert(spent_outputs_len == tx.vin.size());",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": 541,
      "original_position": 522,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "in_reply_to_id": 2269246976,
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see what you mean about the contract enforcement approach. Two questions:\r\n1. Why not also assert on `input_index >= tx.vin.size()`?\r\n2. How can we move the spent_outputs validation to the wrappers with the existing API functions? Wouldn't we need something like `btck_transaction_count_inputs`? The fuzz tests won't let up.",
      "created_at": "2025-08-12T12:34:54Z",
      "updated_at": "2025-08-12T12:48:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2269696749",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269696749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269745172",
      "pull_request_review_id": 3110466951,
      "id": 2269745172,
      "node_id": "PRRC_kwDOABII586HSZAU",
      "diff_hunk": "@@ -1,11 +1,1172 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context btck_context_static{};\n+\n+namespace {\n+\n+/** Check that all specified flags are part of the libbitcoinkernel interface. */\n+bool verify_flags(unsigned int flags)\n+{\n+    return (flags & ~(btck_SCRIPT_FLAGS_VERIFY_ALL)) == 0;\n+}\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+BCLog::Level get_bclog_level(const btck_LogLevel level)\n+{\n+    switch (level) {\n+    case btck_LogLevel::btck_LOG_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case btck_LogLevel::btck_LOG_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case btck_LogLevel::btck_LOG_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(const btck_LogCategory category)\n+{\n+    switch (category) {\n+    case btck_LogCategory::btck_LOG_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case btck_LogCategory::btck_LOG_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case btck_LogCategory::btck_LOG_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case btck_LogCategory::btck_LOG_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case btck_LogCategory::btck_LOG_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case btck_LogCategory::btck_LOG_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case btck_LogCategory::btck_LOG_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case btck_LogCategory::btck_LOG_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case btck_LogCategory::btck_LOG_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case btck_LogCategory::btck_LOG_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case btck_LogCategory::btck_LOG_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return btck_SynchronizationState::btck_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return btck_SynchronizationState::btck_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return btck_SynchronizationState::btck_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_Warning cast_btck_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return btck_Warning::btck_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return btck_Warning::btck_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    btck_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(btck_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), reinterpret_cast<const btck_BlockIndex*>(&index), verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_btck_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_btck_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const btck_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const btck_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const btck_BlockPointer*>(&block),\n+                                reinterpret_cast<const btck_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(btck_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    std::shared_ptr<Context> m_context;\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const std::shared_ptr<Context>& context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_context{context},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const BlockValidationState* cast_block_validation_state(const btck_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const btck_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+const CBlockIndex* cast_const_block_index(const btck_BlockIndex* index)\n+{\n+    assert(index);\n+    return reinterpret_cast<const CBlockIndex*>(index);\n+}\n+\n+} // namespace\n+\n+struct btck_Transaction\n+{\n+    std::shared_ptr<const CTransaction> m_tx;\n+};\n+\n+struct btck_TransactionOutput\n+{\n+    const CTxOut* m_txout;\n+    bool m_owned;\n+};\n+\n+struct btck_ScriptPubkey\n+{\n+    const CScript* m_script;\n+    bool m_owned;\n+};\n+\n+struct btck_LoggingConnection\n+{\n+    std::unique_ptr<std::list<std::function<void(const std::string&)>>::iterator> m_connection;\n+};\n+\n+struct btck_ContextOptions\n+{\n+    std::unique_ptr<ContextOptions> m_opts;\n+};\n+\n+struct btck_Context\n+{\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_ChainParameters\n+{\n+    std::unique_ptr<const CChainParams> m_params;\n+};\n+\n+struct btck_ChainstateManagerOptions\n+{\n+    std::unique_ptr<ChainstateManagerOptions> m_opts;\n+};\n+\n+struct btck_ChainstateManager\n+{\n+    std::unique_ptr<ChainstateManager> m_chainman;\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_Block\n+{\n+    std::shared_ptr<CBlock> m_block;\n+};\n+\n+struct btck_BlockSpentOutputs\n+{\n+    std::shared_ptr<CBlockUndo> m_block_undo;\n+};\n+\n+struct btck_TransactionSpentOutputs\n+{\n+    const CTxUndo* m_tx_undo;\n+    bool m_owned;\n+};\n+\n+struct btck_Coin\n+{\n+    const Coin* m_coin;\n+    bool m_owned;\n+};\n+\n+btck_Transaction* btck_transaction_create(const unsigned char* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{raw_transaction, raw_transaction_len}};\n+        auto tx{std::make_shared<CTransaction>(deserialize, TX_WITH_WITNESS, stream)};\n+        return new btck_Transaction{std::move(tx)};\n+    } catch (const std::exception&) {\n+        return nullptr;\n+    }\n+}\n+\n+uint64_t btck_transaction_count_outputs(const btck_Transaction* transaction)\n+{\n+    return transaction->m_tx->vout.size();\n+}\n+\n+btck_TransactionOutput* btck_transaction_get_output_at(const btck_Transaction* transaction, uint64_t output_index)\n+{\n+    assert(output_index < transaction->m_tx->vout.size());\n+    return new btck_TransactionOutput{&transaction->m_tx->vout[output_index], false};\n+}\n+\n+btck_Transaction* btck_transaction_copy(const btck_Transaction* transaction)\n+{\n+    return new btck_Transaction{transaction->m_tx};\n+}\n+\n+void btck_transaction_destroy(btck_Transaction* transaction)\n+{\n+    if (!transaction) return;\n+    delete transaction;\n+    transaction = nullptr;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_create(const unsigned char* script_pubkey, size_t script_pubkey_len)\n+{\n+    return new btck_ScriptPubkey{new CScript(script_pubkey, script_pubkey + script_pubkey_len), true};\n+}\n+\n+btck_ByteArray* btck_script_pubkey_copy_data(const btck_ScriptPubkey* script_pubkey)\n+{\n+    auto byte_array{new btck_ByteArray{\n+        .data = new unsigned char[script_pubkey->m_script->size()],\n+        .size = script_pubkey->m_script->size(),\n+    }};\n+\n+    std::memcpy(byte_array->data, script_pubkey->m_script->data(), byte_array->size);\n+    return byte_array;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_copy(const btck_ScriptPubkey* script_pubkey)\n+{\n+    return new btck_ScriptPubkey{new CScript(*script_pubkey->m_script), true};\n+}\n+\n+void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey)\n+{\n+    if (!script_pubkey) return;\n+    if (script_pubkey->m_owned) {\n+        delete script_pubkey->m_script;\n+    }\n+    delete script_pubkey;\n+    script_pubkey = nullptr;\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_create(const btck_ScriptPubkey* script_pubkey, int64_t amount)\n+{\n+    const CAmount& value{amount};\n+    return new btck_TransactionOutput{new CTxOut(value, *script_pubkey->m_script), true};\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_copy(const btck_TransactionOutput* output)\n+{\n+    return new btck_TransactionOutput{new CTxOut{*output->m_txout}, true};\n+}\n+\n+btck_ScriptPubkey* btck_transaction_output_get_script_pubkey(const btck_TransactionOutput* output)\n+{\n+    const auto* script_pubkey{&output->m_txout->scriptPubKey};\n+    return new btck_ScriptPubkey{script_pubkey, false};\n+}\n+\n+int64_t btck_transaction_output_get_amount(const btck_TransactionOutput* output)\n+{\n+    return output->m_txout->nValue;\n+}\n+\n+void btck_transaction_output_destroy(btck_TransactionOutput* output)\n+{\n+    if (!output) return;\n+    if (output->m_owned) {\n+        delete output->m_txout;\n+    }\n+    delete output;\n+    output = nullptr;\n+}\n+\n+bool btck_script_pubkey_verify(const btck_ScriptPubkey* script_pubkey,\n+                          const int64_t amount_,\n+                          const btck_Transaction* tx_to,\n+                          const btck_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const unsigned int flags,\n+                          btck_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+\n+    if (!verify_flags(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS;\n+        return false;\n+    }\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION;\n+        return false;\n+    }\n+\n+    if (flags & btck_SCRIPT_FLAGS_VERIFY_TAPROOT && spent_outputs_ == nullptr) {\n+        if (status) *status = btck_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return false;\n+    }\n+\n+    const CTransaction& tx{*tx_to->m_tx};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        assert(spent_outputs_len == tx.vin.size());",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": 541,
      "original_position": 522,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "39c2c5afd75e5d455ac2699dcc1c65728e1a5bc5",
      "in_reply_to_id": 2269246976,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah I think adding that function makes sense, and then we can also get rid of the other error code.",
      "created_at": "2025-08-12T12:51:48Z",
      "updated_at": "2025-08-12T12:52:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2269745172",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2269745172"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 539,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2278842152",
      "pull_request_review_id": 3123663045,
      "id": 2278842152,
      "node_id": "PRRC_kwDOABII586H1F8o",
      "diff_hunk": "@@ -0,0 +1,1449 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+    #ifdef BITCOINKERNEL_BUILD\n+        #if defined(_WIN32)\n+            #define BITCOINKERNEL_API __declspec(dllexport)\n+        #elif !defined(_WIN32) && defined(__GNUC__)\n+            #define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+        #else\n+            #define BITCOINKERNEL_API\n+        #endif\n+    #else\n+        #if defined(_WIN32) && !defined(BITCOINKERNEL_STATIC)\n+            #define BITCOINKERNEL_API __declspec(dllimport)\n+        #else\n+            #define BITCOINKERNEL_API\n+        #endif\n+    #endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__)\n+    #define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+    #define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__)\n+    #define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+    #define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct btck_Transaction btck_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct btck_ScriptPubkey btck_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct btck_TransactionOutput btck_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * @ref btck_logging_disable. Functions changing the logging settings are\n+ * global (and not thread safe) and change the settings for all existing\n+ * btck_LoggingConnection instances.\n+ */\n+typedef struct btck_LoggingConnection btck_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct btck_ChainParameters btck_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct btck_ContextOptions btck_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context is kept in memory\n+ * for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct btck_Context btck_Context;\n+\n+/**\n+ * Opaque data structure for holding a block tree entry.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of\n+ * the chainstate manager. It is valid for the lifetime of the chainstate\n+ * manager it was retrieved from. The entry is part of a tree-like structure\n+ * that is maintained internally. Every entry, besides the genesis, points to a\n+ * single parent. Multiple entries may share a parent, thus forming a tree.\n+ * Each entry corresponds to a single block and may be used to retrieve its\n+ * data and validation status.\n+ */\n+typedef struct btck_BlockTreeEntry btck_BlockTreeEntry;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct btck_ChainstateManagerOptions btck_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct btck_ChainstateManager btck_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct btck_Block btck_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct btck_BlockPointer btck_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct btck_BlockValidationState btck_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding the currently known best-chain associated\n+ * with a chainstate.\n+ */\n+typedef struct btck_Chain btck_Chain;\n+\n+/**\n+ * Opaque data structure for holding a block's spent outputs.\n+ *\n+ * Contains all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an\n+ * entry for each transaction in a block (in order of the actual transactions\n+ * of the block and without the coinbase transaction). This is exposed through\n+ * @ref btck_TransactionSpentOutputs. Each btck_TransactionSpentOutputs is in\n+ * turn a vector of all the previous outputs of a transaction (in order of\n+ * their corresponding inputs).\n+ */\n+typedef struct btck_BlockSpentOutputs btck_BlockSpentOutputs;\n+\n+/**\n+ * Opaque data structure for holding a transaction's spent outputs.\n+ *\n+ * Holds the coins consumed by a certain transaction. Retrieved through the\n+ * @ref btck_BlockSpentOutputs. The coins are in the same order as the\n+ * transaction's inputs consuming them.\n+ */\n+typedef struct btck_TransactionSpentOutputs btck_TransactionSpentOutputs;\n+\n+/**\n+ * Opaque data structure for holding a coin.\n+ *\n+ * Holds information on the @ref btck_TransactionOutput held within,\n+ * including the height it was spent at and whether it is a coinbase output.\n+ */\n+typedef struct btck_Coin btck_Coin;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    btck_INIT_REINDEX,\n+    btck_INIT_DOWNLOAD,\n+    btck_POST_INIT\n+} btck_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    btck_UNKNOWN_NEW_RULES_ACTIVATED,\n+    btck_LARGE_WORK_INVALID_CHAIN\n+} btck_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*btck_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*btck_NotifyBlockTip)(void* user_data, btck_SynchronizationState state, btck_BlockTreeEntry* entry, double verification_progress);\n+typedef void (*btck_NotifyHeaderTip)(void* user_data, btck_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*btck_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*btck_NotifyWarningSet)(void* user_data, btck_Warning warning, const char* message, size_t message_len);\n+typedef void (*btck_NotifyWarningUnset)(void* user_data, btck_Warning warning);\n+typedef void (*btck_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*btck_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*btck_ValidationInterfaceBlockChecked)(void* user_data, const btck_BlockPointer* block, const btck_BlockValidationState* state);\n+\n+/**\n+ * Function signature for serializing data.\n+ */\n+typedef bool (*btck_WriteBytes)(const void* bytes, size_t size, void* userdata);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    btck_VALIDATION_STATE_VALID = 0,\n+    btck_VALIDATION_STATE_INVALID,\n+    btck_VALIDATION_STATE_ERROR,\n+} btck_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    btck_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    btck_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    btck_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    btck_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    btck_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    btck_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    btck_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    btck_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    btck_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} btck_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier. Note that these callbacks block any further validation\n+ * execution when they are called.\n+ */\n+typedef struct {\n+    const void* user_data;                              //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                        //!< interface callbacks.\n+    btck_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                        //!< result of its validation.\n+} btck_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                 //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    btck_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block entry.\n+    btck_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    btck_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    btck_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    btck_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    btck_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    btck_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} btck_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    btck_LOG_ALL = 0,\n+    btck_LOG_BENCH,\n+    btck_LOG_BLOCKSTORAGE,\n+    btck_LOG_COINDB,\n+    btck_LOG_LEVELDB,\n+    btck_LOG_MEMPOOL,\n+    btck_LOG_PRUNE,\n+    btck_LOG_RAND,\n+    btck_LOG_REINDEX,\n+    btck_LOG_VALIDATION,\n+    btck_LOG_KERNEL,\n+} btck_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    btck_LOG_TRACE = 0,\n+    btck_LOG_DEBUG,\n+    btck_LOG_INFO,\n+} btck_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} btck_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    btck_SCRIPT_VERIFY_OK = 0,\n+    btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    btck_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+} btck_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    btck_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    btck_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    btck_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    btck_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    btck_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    btck_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    btck_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    btck_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    btck_SCRIPT_FLAGS_VERIFY_ALL                 = btck_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} btck_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    btck_CHAIN_TYPE_MAINNET = 0,\n+    btck_CHAIN_TYPE_TESTNET,\n+    btck_CHAIN_TYPE_TESTNET_4,\n+    btck_CHAIN_TYPE_SIGNET,\n+    btck_CHAIN_TYPE_REGTEST,\n+} btck_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} btck_BlockHash;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_create(\n+    const void* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copy a transaction. Transactions are reference counted, so this just\n+ * increments the reference count.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @return                The copied transaction.\n+ */\n+BITCOINKERNEL_API btck_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_copy(\n+    const btck_Transaction* transaction\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Serializes the transaction through the passed in callback to bytes.\n+ * This is consensus serialization that is also used for the p2p network.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @param[in] writer      Non-null, callback to a write bytes function.\n+ * @param[in] user_data   Holds a user-defined opaque structure that will be\n+ *                        passed back through the writer callback.\n+ * @return                True on success.\n+ */\n+BITCOINKERNEL_API bool btck_transaction_to_bytes(\n+    const btck_Transaction* transaction,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the number of outputs of a transaction.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @return                The number of outputs.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_count_outputs(\n+    const btck_Transaction* transaction\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the transaction outputs at the provided index. The returned\n+ * transaction output is not owned and depends on the lifetime of the\n+ * transaction.\n+ *\n+ * @param[in] transaction  Non-null.\n+ * @param[in] output_index The index of the transaction to be retrieved.\n+ * @return                 The transaction output\n+ */\n+BITCOINKERNEL_API btck_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_get_output_at(\n+    const btck_Transaction* transaction, uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the number of inputs of a transaction.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @return                The number of inputs.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_count_inputs(\n+    const btck_Transaction* transaction\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void btck_transaction_destroy(btck_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey.\n+ */\n+BITCOINKERNEL_API btck_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT btck_script_pubkey_create(\n+    const void* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copy a script pubkey.\n+ *\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The copied script pubkey.\n+ */\n+BITCOINKERNEL_API btck_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT btck_script_pubkey_copy(\n+    const btck_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `btck_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of btck_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to btck_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT btck_script_pubkey_verify(\n+    const btck_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const btck_Transaction* tx_to,\n+    const btck_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    btck_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+/*\n+ * @brief Serializes the script pubkey through the passed in callback to bytes.\n+ *\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] writer        Non-null, callback to a write bytes function.\n+ * @param[in] user_data     Holds a user-defined opaque structure that will be\n+ *                          passed back through the writer callback.\n+ * @return                  True on success.\n+ */\n+BITCOINKERNEL_API bool btck_script_pubkey_to_bytes(\n+    const btck_ScriptPubkey* script_pubkey,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ *\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API btck_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_output_create(\n+    const btck_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the script pubkey of the output. The returned\n+ * script pubkey is not owned and depends on the lifetime of the\n+ * transaction output.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The script pubkey.\n+ */\n+BITCOINKERNEL_API btck_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_output_get_script_pubkey(\n+        const btck_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the amount in the output.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_output_get_amount(\n+    const btck_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ *  @brief Copy a transaction output.\n+ *\n+ *  @param[in] transaction_output Non-null.\n+ *  @return                       The copied transaction output.\n+ */\n+BITCOINKERNEL_API btck_TransactionOutput* btck_transaction_output_copy(\n+    const btck_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void btck_transaction_output_destroy(btck_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void btck_logging_disable();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use @ref btck_logging_enable_category to\n+ * start logging from a specific, or all categories. This function is not\n+ * thread safe. Multiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref btck_LoggingConnection instances.\n+ *\n+ * @param[in] category If btck_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void btck_logging_set_level_category(const btck_LogCategory category, btck_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Multiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref btck_LoggingConnection instances.\n+ *\n+ * @param[in] category If btck_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void btck_logging_enable_category(const btck_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Multiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref btck_LoggingConnection instances.\n+ *\n+ * @param[in] category If btck_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void btck_logging_disable_category(const btck_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API btck_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT btck_logging_connection_create(\n+    btck_LogCallback callback,\n+    const void* user_data,\n+    const btck_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void btck_logging_connection_destroy(btck_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API btck_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_parameters_create(\n+    const btck_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void btck_chain_parameters_destroy(btck_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API btck_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT btck_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref btck_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void btck_context_options_set_chainparams(\n+    btck_ContextOptions* context_options,\n+    const btck_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref btck_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void btck_context_options_set_notifications(\n+    btck_ContextOptions* context_options,\n+    btck_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with btck_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void btck_context_options_set_validation_interface(\n+    btck_ContextOptions* context_options,\n+    btck_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void btck_context_options_destroy(btck_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref btck_context_options_create.\n+ * @return                    The allocated context, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Context* BITCOINKERNEL_WARN_UNUSED_RESULT btck_context_create(\n+    const btck_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT btck_context_interrupt(\n+    btck_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void btck_context_destroy(btck_Context* context);\n+\n+///@}\n+\n+/** @name BlockTreeEntry\n+ * Functions for working with block tree entries.\n+ */\n+///@{\n+\n+/**\n+ * @brief Returns the previous block tree entry in the chain, or null if the current\n+ * block tree entry is the genesis block.\n+ *\n+ * @param[in] block_tree_entry Non-null.\n+ * @return                     The previous block tree entry, or null on error or if the current block tree entry is the genesis block.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_tree_entry_get_previous(\n+    const btck_BlockTreeEntry* block_tree_entry\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the height of a certain block tree entry.\n+ *\n+ * @param[in] block_tree_entry Non-null.\n+ * @return                     The block height.\n+ */\n+BITCOINKERNEL_API int32_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_tree_entry_get_height(\n+    const btck_BlockTreeEntry* block_tree_entry\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Destroy the block tree entry.\n+ */\n+BITCOINKERNEL_API void btck_block_tree_entry_destroy(btck_BlockTreeEntry* block_tree_entry);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options and through it the chainstate manager will\n+                               associate with this kernel context for the duration of their lifetimes.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API btck_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_options_create(\n+    const btck_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_set_worker_threads_num(\n+        btck_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref btck_chainstate_manager_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool btck_chainstate_manager_options_set_wipe_dbs(\n+    btck_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_set_block_tree_db_in_memory(\n+    btck_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_set_chainstate_db_in_memory(\n+    btck_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API btck_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_create(\n+    const btck_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief May be called once the btck_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool btck_chainstate_manager_import_blocks( btck_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_process_block(\n+    btck_ChainstateManager* chainstate_manager,\n+    const btck_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the best known currently active chain. Its lifetime is\n+ * dependent on the chainstate manager and state transitions within the\n+ * chainstate manager, e.g. when processing blocks, will also change the chain.\n+ * Data retrieved from this chain is only consistent up to the point when new\n+ * data is processed in the chainstate manager. It is the user's responsibility\n+ * to guard against these inconsistencies.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The chain.\n+ */\n+BITCOINKERNEL_API btck_Chain* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_get_active_chain(\n+    const btck_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Retrieve a block tree entry by its block hash.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block tree entry of the block with the passed in hash, or null if\n+ *                               the block hash is not found.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_get_block_tree_entry_by_hash(\n+    const btck_ChainstateManager* chainstate_manager,\n+    const btck_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_destroy(btck_ChainstateManager* chainstate_manager);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_tree_entry   Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Block* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_read(\n+    const btck_ChainstateManager* chainstate_manager,\n+    const btck_BlockTreeEntry* block_tree_entry\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Block* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_create(\n+    const void* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copy a block. Blocks are reference counted, so this just increments\n+ * the reference count.\n+ *\n+ * @param[in] block Non-null.\n+ * @return          The copied block.\n+ */\n+BITCOINKERNEL_API btck_Block* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_copy(\n+    const btck_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Count the number of transactions contained in a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return          The number of transactions in the block.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_count_transactions(\n+    const btck_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the transaction at the provided index. The returned transaction\n+ * is owned and does not depend on the lifetime of the block.\n+ *\n+ * @param[in] block             Non-null.\n+ * @param[in] transaction_index The index of the transaction to be retrieved.\n+ * @return                      The transaction.\n+ */\n+BITCOINKERNEL_API btck_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_get_transaction_at(\n+    const btck_Block* block, uint64_t transaction_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API btck_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_get_hash(\n+    const btck_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API btck_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_pointer_get_hash(\n+    const btck_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Serializes the block through the passed in callback to bytes.\n+ * This is consensus serialization that is also used for the p2p network.\n+ *\n+ * @param[in] block     Non-null.\n+ * @param[in] writer    Non-null, callback to a write bytes function.\n+ * @param[in] user_data Holds a user-defined opaque structure that will be\n+ *                      passed back through the writer callback.\n+ * @return              True on success.\n+ */\n+BITCOINKERNEL_API bool btck_block_to_bytes(\n+    const btck_Block* block,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/*\n+ * @brief Serializes the block pointer through the passed in callback to bytes.\n+ * This is consensus serialization that is also used for the p2p network.\n+ *\n+ * @param[in] block     Non-null.\n+ * @param[in] writer    Non-null, callback to a write bytes function.\n+ * @param[in] user_data Holds a user-defined opaque structure that will be\n+ *                      passed back through the writer callback.\n+ * @return              True on success.\n+ */\n+BITCOINKERNEL_API bool btck_block_pointer_to_bytes(\n+    const btck_BlockPointer* block,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void btck_block_destroy(btck_Block* block);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API btck_ValidationMode btck_block_validation_state_get_validation_mode(\n+    const btck_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(\n+    const btck_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name Chain\n+ * Functions for working with the chain\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block tree entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] chain Non-null.\n+ * @return          The block tree entry of the current tip, or null if the chain is empty.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_tip(\n+    const btck_Chain* chain\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Get the block tree entry of the genesis block.\n+ *\n+ * @param[in] chain Non-null.\n+ * @return          The block tree entry of the genesis block, or null if the chain is empty.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_genesis(\n+    const btck_Chain* chain\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Retrieve a block tree entry by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] chain        Non-null.\n+ * @param[in] block_height Height in the chain of the to be retrieved block tree entry.\n+ * @return                 The block tree entry at a certain height in the currently active chain,\n+ *                         or null if the height is out of bounds.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_by_height(\n+    const btck_Chain* chain,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] chain            Non-null.\n+ * @param[in] block_tree_entry Non-null.\n+ * @return                     The next block index in the currently active chain, or null if\n+ *                             the block_index is the chain tip, or not in the chain.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_next_block_index(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1239,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "ab06b85bc2c0f4733dd96f9694c0c3d972004a36",
      "in_reply_to_id": null,
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we rename this to `<>_block_tree_entry`?\r\n```suggestion\r\nBITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_next_block_tree_entry(\r\n```",
      "created_at": "2025-08-15T11:35:40Z",
      "updated_at": "2025-08-15T11:36:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2278842152",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2278842152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2278904242",
      "pull_request_review_id": 3123739659,
      "id": 2278904242,
      "node_id": "PRRC_kwDOABII586H1VGy",
      "diff_hunk": "@@ -0,0 +1,1449 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_KERNEL_BITCOINKERNEL_H\n+#define BITCOIN_KERNEL_BITCOINKERNEL_H\n+\n+#ifndef __cplusplus\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#else\n+#include <cstddef>\n+#include <cstdint>\n+#endif // __cplusplus\n+\n+#ifndef BITCOINKERNEL_API\n+    #ifdef BITCOINKERNEL_BUILD\n+        #if defined(_WIN32)\n+            #define BITCOINKERNEL_API __declspec(dllexport)\n+        #elif !defined(_WIN32) && defined(__GNUC__)\n+            #define BITCOINKERNEL_API __attribute__((visibility(\"default\")))\n+        #else\n+            #define BITCOINKERNEL_API\n+        #endif\n+    #else\n+        #if defined(_WIN32) && !defined(BITCOINKERNEL_STATIC)\n+            #define BITCOINKERNEL_API __declspec(dllimport)\n+        #else\n+            #define BITCOINKERNEL_API\n+        #endif\n+    #endif\n+#endif\n+\n+/* Warning attributes */\n+#if defined(__GNUC__)\n+    #define BITCOINKERNEL_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n+#else\n+    #define BITCOINKERNEL_WARN_UNUSED_RESULT\n+#endif\n+#if !defined(BITCOINKERNEL_BUILD) && defined(__GNUC__)\n+    #define BITCOINKERNEL_ARG_NONNULL(...) __attribute__((__nonnull__(__VA_ARGS__)))\n+#else\n+    #define BITCOINKERNEL_ARG_NONNULL(...)\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif // __cplusplus\n+\n+/**\n+ * @page remarks Remarks\n+ *\n+ * @section purpose Purpose\n+ *\n+ * This header currently exposes an API for interacting with parts of Bitcoin\n+ * Core's consensus code. Users can validate blocks, iterate the block index,\n+ * read block und undo data from disk, and validate scripts. The header is\n+ * unversioned and not stable yet. Users should expect breaking changes. It is\n+ * also not yet included in releases of Bitcoin Core.\n+ *\n+ * @section context Context\n+ *\n+ * The library provides a built-in static constant kernel context. This static\n+ * context offers only limited functionality. It detects and self-checks the\n+ * correct sha256 implementation, initializes the random number generator and\n+ * self-checks the secp256k1 static context. It is used internally for\n+ * otherwise \"context-free\" operations. This means that the user is not\n+ * required to initialize their own context before using the library.\n+ *\n+ * The user should create their own context for passing it to state-rich validation\n+ * functions and holding callbacks for kernel events.\n+ *\n+ * @section error Error handling\n+ *\n+ * Functions communicate an error through their return types, usually returning\n+ * a nullptr, 0, or false if an error is encountered. Additionally, verification\n+ * functions, e.g. for scripts, may communicate more detailed error information\n+ * through status code out parameters.\n+ *\n+ * Fine-grained validation information is communicated through the validation\n+ * interface.\n+ *\n+ * The kernel notifications issue callbacks for errors. These are usually\n+ * indicative of a system error. If such an error is issued, it is recommended\n+ * to halt and tear down the existing kernel objects. Remediating the error may\n+ * require system intervention by the user.\n+ *\n+ * @section pointer Pointer and argument conventions\n+ *\n+ * The user is responsible for de-allocating the memory owned by pointers\n+ * returned by functions. Typically pointers returned by *_create(...) functions\n+ * can be de-allocated by corresponding *_destroy(...) functions.\n+ *\n+ * A function that takes pointer arguments makes no assumptions on their\n+ * lifetime. Once the function returns the user can safely de-allocate the\n+ * passed in arguments.\n+ *\n+ * Pointers passed by callbacks are not owned by the user and are only valid\n+ * for the duration of the callback. They are always marked as `const` and must\n+ * not be de-allocated by the user.\n+ *\n+ * Array lengths follow the pointer argument they describe.\n+ */\n+\n+/**\n+ * Opaque data structure for holding a transaction.\n+ */\n+typedef struct btck_Transaction btck_Transaction;\n+\n+/**\n+ * Opaque data structure for holding a script pubkey.\n+ */\n+typedef struct btck_ScriptPubkey btck_ScriptPubkey;\n+\n+/**\n+ * Opaque data structure for holding a transaction output.\n+ */\n+typedef struct btck_TransactionOutput btck_TransactionOutput;\n+\n+/**\n+ * Opaque data structure for holding a logging connection.\n+ *\n+ * The logging connection can be used to manually stop logging.\n+ *\n+ * Messages that were logged before a connection is created are buffered in a\n+ * 1MB buffer. Logging can alternatively be permanently disabled by calling\n+ * @ref btck_logging_disable. Functions changing the logging settings are\n+ * global (and not thread safe) and change the settings for all existing\n+ * btck_LoggingConnection instances.\n+ */\n+typedef struct btck_LoggingConnection btck_LoggingConnection;\n+\n+/**\n+ * Opaque data structure for holding the chain parameters.\n+ *\n+ * These are eventually placed into a kernel context through the kernel context\n+ * options. The parameters describe the properties of a chain, and may be\n+ * instantiated for either mainnet, testnet, signet, or regtest.\n+ */\n+typedef struct btck_ChainParameters btck_ChainParameters;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new kernel context.\n+ *\n+ * Once a kernel context has been created from these options, they may be\n+ * destroyed. The options hold the notification callbacks as well as the\n+ * selected chain type until they are passed to the context. If no options are\n+ * configured, the context will be instantiated with no callbacks and for\n+ * mainnet. Their content and scope can be expanded over time.\n+ */\n+typedef struct btck_ContextOptions btck_ContextOptions;\n+\n+/**\n+ * Opaque data structure for holding a kernel context.\n+ *\n+ * The kernel context is used to initialize internal state and hold the chain\n+ * parameters and callbacks for handling error and validation events. Once other\n+ * validation objects are instantiated from it, the context is kept in memory\n+ * for the duration of their lifetimes.\n+ *\n+ * The processing of validation events is done through an internal task runner\n+ * owned by the context. It passes events through the registered validation\n+ * interface callbacks.\n+ *\n+ * A constructed context can be safely used from multiple threads.\n+ */\n+typedef struct btck_Context btck_Context;\n+\n+/**\n+ * Opaque data structure for holding a block tree entry.\n+ *\n+ * This is a pointer to an element in the block index currently in memory of\n+ * the chainstate manager. It is valid for the lifetime of the chainstate\n+ * manager it was retrieved from. The entry is part of a tree-like structure\n+ * that is maintained internally. Every entry, besides the genesis, points to a\n+ * single parent. Multiple entries may share a parent, thus forming a tree.\n+ * Each entry corresponds to a single block and may be used to retrieve its\n+ * data and validation status.\n+ */\n+typedef struct btck_BlockTreeEntry btck_BlockTreeEntry;\n+\n+/**\n+ * Opaque data structure for holding options for creating a new chainstate\n+ * manager.\n+ *\n+ * The chainstate manager options are used to set some parameters for the\n+ * chainstate manager. For now it just holds default options.\n+ */\n+typedef struct btck_ChainstateManagerOptions btck_ChainstateManagerOptions;\n+\n+/**\n+ * Opaque data structure for holding a chainstate manager.\n+ *\n+ * The chainstate manager is the central object for doing validation tasks as\n+ * well as retrieving data from the chain. Internally it is a complex data\n+ * structure with diverse functionality.\n+ *\n+ * Its functionality will be more and more exposed in the future.\n+ */\n+typedef struct btck_ChainstateManager btck_ChainstateManager;\n+\n+/**\n+ * Opaque data structure for holding a block.\n+ */\n+typedef struct btck_Block btck_Block;\n+\n+/**\n+ * Opaque data structure for holding a non-owned block. This is typically a\n+ * block available to the user through one of the validation callbacks.\n+ */\n+typedef struct btck_BlockPointer btck_BlockPointer;\n+\n+/**\n+ * Opaque data structure for holding the state of a block during validation.\n+ *\n+ * Contains information indicating whether validation was successful, and if not\n+ * which step during block validation failed.\n+ */\n+typedef struct btck_BlockValidationState btck_BlockValidationState;\n+\n+/**\n+ * Opaque data structure for holding the currently known best-chain associated\n+ * with a chainstate.\n+ */\n+typedef struct btck_Chain btck_Chain;\n+\n+/**\n+ * Opaque data structure for holding a block's spent outputs.\n+ *\n+ * Contains all the previous outputs consumed by all transactions in a specific\n+ * block. Internally it holds a nested vector. The top level vector has an\n+ * entry for each transaction in a block (in order of the actual transactions\n+ * of the block and without the coinbase transaction). This is exposed through\n+ * @ref btck_TransactionSpentOutputs. Each btck_TransactionSpentOutputs is in\n+ * turn a vector of all the previous outputs of a transaction (in order of\n+ * their corresponding inputs).\n+ */\n+typedef struct btck_BlockSpentOutputs btck_BlockSpentOutputs;\n+\n+/**\n+ * Opaque data structure for holding a transaction's spent outputs.\n+ *\n+ * Holds the coins consumed by a certain transaction. Retrieved through the\n+ * @ref btck_BlockSpentOutputs. The coins are in the same order as the\n+ * transaction's inputs consuming them.\n+ */\n+typedef struct btck_TransactionSpentOutputs btck_TransactionSpentOutputs;\n+\n+/**\n+ * Opaque data structure for holding a coin.\n+ *\n+ * Holds information on the @ref btck_TransactionOutput held within,\n+ * including the height it was spent at and whether it is a coinbase output.\n+ */\n+typedef struct btck_Coin btck_Coin;\n+\n+/** Current sync state passed to tip changed callbacks. */\n+typedef enum {\n+    btck_INIT_REINDEX,\n+    btck_INIT_DOWNLOAD,\n+    btck_POST_INIT\n+} btck_SynchronizationState;\n+\n+/** Possible warning types issued by validation. */\n+typedef enum {\n+    btck_UNKNOWN_NEW_RULES_ACTIVATED,\n+    btck_LARGE_WORK_INVALID_CHAIN\n+} btck_Warning;\n+\n+/** Callback function types */\n+\n+/**\n+ * Function signature for the global logging callback. All bitcoin kernel\n+ * internal logs will pass through this callback.\n+ */\n+typedef void (*btck_LogCallback)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the kernel notifications.\n+ */\n+typedef void (*btck_NotifyBlockTip)(void* user_data, btck_SynchronizationState state, btck_BlockTreeEntry* entry, double verification_progress);\n+typedef void (*btck_NotifyHeaderTip)(void* user_data, btck_SynchronizationState state, int64_t height, int64_t timestamp, bool presync);\n+typedef void (*btck_NotifyProgress)(void* user_data, const char* title, size_t title_len, int progress_percent, bool resume_possible);\n+typedef void (*btck_NotifyWarningSet)(void* user_data, btck_Warning warning, const char* message, size_t message_len);\n+typedef void (*btck_NotifyWarningUnset)(void* user_data, btck_Warning warning);\n+typedef void (*btck_NotifyFlushError)(void* user_data, const char* message, size_t message_len);\n+typedef void (*btck_NotifyFatalError)(void* user_data, const char* message, size_t message_len);\n+\n+/**\n+ * Function signatures for the validation interface.\n+ */\n+typedef void (*btck_ValidationInterfaceBlockChecked)(void* user_data, const btck_BlockPointer* block, const btck_BlockValidationState* state);\n+\n+/**\n+ * Function signature for serializing data.\n+ */\n+typedef bool (*btck_WriteBytes)(const void* bytes, size_t size, void* userdata);\n+\n+/**\n+ * Whether a validated data structure is valid, invalid, or an error was\n+ * encountered during processing.\n+ */\n+typedef enum {\n+    btck_VALIDATION_STATE_VALID = 0,\n+    btck_VALIDATION_STATE_INVALID,\n+    btck_VALIDATION_STATE_ERROR,\n+} btck_ValidationMode;\n+\n+/**\n+ * A granular \"reason\" why a block was invalid.\n+ */\n+typedef enum {\n+    btck_BLOCK_RESULT_UNSET = 0, //!< initial value. Block has not yet been rejected\n+    btck_BLOCK_CONSENSUS,        //!< invalid by consensus rules (excluding any below reasons)\n+    btck_BLOCK_CACHED_INVALID,  //!< this block was cached as being invalid and we didn't store the reason why\n+    btck_BLOCK_INVALID_HEADER,  //!< invalid proof of work or time too old\n+    btck_BLOCK_MUTATED,         //!< the block's data didn't match the data committed to by the PoW\n+    btck_BLOCK_MISSING_PREV,    //!< We don't have the previous block the checked one is built on\n+    btck_BLOCK_INVALID_PREV,    //!< A block this one builds on is invalid\n+    btck_BLOCK_TIME_FUTURE,     //!< block timestamp was > 2 hours in the future (or our clock is bad)\n+    btck_BLOCK_HEADER_LOW_WORK, //!< the block header may be on a too-little-work chain\n+} btck_BlockValidationResult;\n+\n+/**\n+ * Holds the validation interface callbacks. The user data pointer may be used\n+ * to point to user-defined structures to make processing the validation\n+ * callbacks easier. Note that these callbacks block any further validation\n+ * execution when they are called.\n+ */\n+typedef struct {\n+    const void* user_data;                              //!< Holds a user-defined opaque structure that is passed to the validation\n+                                                        //!< interface callbacks.\n+    btck_ValidationInterfaceBlockChecked block_checked; //!< Called when a new block has been checked. Contains the\n+                                                        //!< result of its validation.\n+} btck_ValidationInterfaceCallbacks;\n+\n+/**\n+ * A struct for holding the kernel notification callbacks. The user data\n+ * pointer may be used to point to user-defined structures to make processing\n+ * the notifications easier. Note that this makes it the user's responsibility\n+ * to ensure that the user_data outlives the kernel objects. Notifications can\n+ * occur even as kernel objects are deleted, so care has to be taken to ensure\n+ * safe unwinding.\n+ */\n+typedef struct {\n+    const void* user_data;                 //!< Holds a user-defined opaque structure that is passed to the notification callbacks.\n+    btck_NotifyBlockTip block_tip;         //!< The chain's tip was updated to the provided block entry.\n+    btck_NotifyHeaderTip header_tip;       //!< A new best block header was added.\n+    btck_NotifyProgress progress;          //!< Reports on current block synchronization progress.\n+    btck_NotifyWarningSet warning_set;     //!< A warning issued by the kernel library during validation.\n+    btck_NotifyWarningUnset warning_unset; //!< A previous condition leading to the issuance of a warning is no longer given.\n+    btck_NotifyFlushError flush_error;     //!< An error encountered when flushing data to disk.\n+    btck_NotifyFatalError fatal_error;     //!< A un-recoverable system error encountered by the library.\n+} btck_NotificationInterfaceCallbacks;\n+\n+/**\n+ * A collection of logging categories that may be encountered by kernel code.\n+ */\n+typedef enum {\n+    btck_LOG_ALL = 0,\n+    btck_LOG_BENCH,\n+    btck_LOG_BLOCKSTORAGE,\n+    btck_LOG_COINDB,\n+    btck_LOG_LEVELDB,\n+    btck_LOG_MEMPOOL,\n+    btck_LOG_PRUNE,\n+    btck_LOG_RAND,\n+    btck_LOG_REINDEX,\n+    btck_LOG_VALIDATION,\n+    btck_LOG_KERNEL,\n+} btck_LogCategory;\n+\n+/**\n+ * The level at which logs should be produced.\n+ */\n+typedef enum {\n+    btck_LOG_TRACE = 0,\n+    btck_LOG_DEBUG,\n+    btck_LOG_INFO,\n+} btck_LogLevel;\n+\n+/**\n+ * Options controlling the format of log messages.\n+ */\n+typedef struct {\n+    bool log_timestamps;               //!< Prepend a timestamp to log messages.\n+    bool log_time_micros;              //!< Log timestamps in microsecond precision.\n+    bool log_threadnames;              //!< Prepend the name of the thread to log messages.\n+    bool log_sourcelocations;          //!< Prepend the source location to log messages.\n+    bool always_print_category_levels; //!< Prepend the log category and level to log messages.\n+} btck_LoggingOptions;\n+\n+/**\n+ * A collection of status codes that may be issued by the script verify function.\n+ */\n+typedef enum {\n+    btck_SCRIPT_VERIFY_OK = 0,\n+    btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS, //!< The provided bitfield for the flags was invalid.\n+    btck_SCRIPT_VERIFY_ERROR_INVALID_FLAGS_COMBINATION, //!< The flags very combined in an invalid way.\n+    btck_SCRIPT_VERIFY_ERROR_SPENT_OUTPUTS_REQUIRED, //!< The taproot flag was set, so valid spent_outputs have to be provided.\n+} btck_ScriptVerifyStatus;\n+\n+/**\n+ * Script verification flags that may be composed with each other.\n+ */\n+typedef enum\n+{\n+    btck_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n+    btck_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), //!< evaluate P2SH (BIP16) subscripts\n+    btck_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), //!< enforce strict DER (BIP66) compliance\n+    btck_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), //!< enforce NULLDUMMY (BIP147)\n+    btck_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), //!< enable CHECKLOCKTIMEVERIFY (BIP65)\n+    btck_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), //!< enable CHECKSEQUENCEVERIFY (BIP112)\n+    btck_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), //!< enable WITNESS (BIP141)\n+\n+    btck_SCRIPT_FLAGS_VERIFY_TAPROOT             = (1U << 17), //!< enable TAPROOT (BIPs 341 & 342)\n+    btck_SCRIPT_FLAGS_VERIFY_ALL                 = btck_SCRIPT_FLAGS_VERIFY_P2SH |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_DERSIG |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_NULLDUMMY |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_WITNESS |\n+                                                     btck_SCRIPT_FLAGS_VERIFY_TAPROOT\n+} btck_ScriptFlags;\n+\n+/**\n+ * Chain type used for creating chain params.\n+ */\n+typedef enum {\n+    btck_CHAIN_TYPE_MAINNET = 0,\n+    btck_CHAIN_TYPE_TESTNET,\n+    btck_CHAIN_TYPE_TESTNET_4,\n+    btck_CHAIN_TYPE_SIGNET,\n+    btck_CHAIN_TYPE_REGTEST,\n+} btck_ChainType;\n+\n+/**\n+ * A type-safe block identifier.\n+ */\n+typedef struct {\n+    unsigned char hash[32];\n+} btck_BlockHash;\n+\n+/** @name Transaction\n+ * Functions for working with transactions.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new transaction from the serialized data.\n+ *\n+ * @param[in] raw_transaction     Non-null.\n+ * @param[in] raw_transaction_len Length of the serialized transaction.\n+ * @return                        The transaction, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_create(\n+    const void* raw_transaction, size_t raw_transaction_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copy a transaction. Transactions are reference counted, so this just\n+ * increments the reference count.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @return                The copied transaction.\n+ */\n+BITCOINKERNEL_API btck_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_copy(\n+    const btck_Transaction* transaction\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Serializes the transaction through the passed in callback to bytes.\n+ * This is consensus serialization that is also used for the p2p network.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @param[in] writer      Non-null, callback to a write bytes function.\n+ * @param[in] user_data   Holds a user-defined opaque structure that will be\n+ *                        passed back through the writer callback.\n+ * @return                True on success.\n+ */\n+BITCOINKERNEL_API bool btck_transaction_to_bytes(\n+    const btck_Transaction* transaction,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Get the number of outputs of a transaction.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @return                The number of outputs.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_count_outputs(\n+    const btck_Transaction* transaction\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the transaction outputs at the provided index. The returned\n+ * transaction output is not owned and depends on the lifetime of the\n+ * transaction.\n+ *\n+ * @param[in] transaction  Non-null.\n+ * @param[in] output_index The index of the transaction to be retrieved.\n+ * @return                 The transaction output\n+ */\n+BITCOINKERNEL_API btck_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_get_output_at(\n+    const btck_Transaction* transaction, uint64_t output_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the number of inputs of a transaction.\n+ *\n+ * @param[in] transaction Non-null.\n+ * @return                The number of inputs.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_count_inputs(\n+    const btck_Transaction* transaction\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction.\n+ */\n+BITCOINKERNEL_API void btck_transaction_destroy(btck_Transaction* transaction);\n+\n+///@}\n+\n+/** @name ScriptPubkey\n+ * Functions for working with script pubkeys.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a script pubkey from serialized data.\n+ * @param[in] script_pubkey     Non-null.\n+ * @param[in] script_pubkey_len Length of the script pubkey data.\n+ * @return                      The script pubkey.\n+ */\n+BITCOINKERNEL_API btck_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT btck_script_pubkey_create(\n+    const void* script_pubkey, size_t script_pubkey_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copy a script pubkey.\n+ *\n+ * @param[in] script_pubkey Non-null.\n+ * @return                  The copied script pubkey.\n+ */\n+BITCOINKERNEL_API btck_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT btck_script_pubkey_copy(\n+    const btck_ScriptPubkey* script_pubkey\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Verify if the input at input_index of tx_to spends the script pubkey\n+ * under the constraints specified by flags. If the\n+ * `btck_SCRIPT_FLAGS_VERIFY_WITNESS` flag is set in the flags bitfield, the\n+ * amount parameter is used. If the taproot flag is set, the spent outputs\n+ * parameter is used to validate taproot transactions.\n+ *\n+ * @param[in] script_pubkey     Non-null, script pubkey to be spent.\n+ * @param[in] amount            Amount of the script pubkey's associated output. May be zero if\n+ *                              the witness flag is not set.\n+ * @param[in] tx_to             Non-null, transaction spending the script_pubkey.\n+ * @param[in] spent_outputs     Nullable if the taproot flag is not set. Points to an array of\n+ *                              outputs spent by the transaction.\n+ * @param[in] spent_outputs_len Length of the spent_outputs array.\n+ * @param[in] input_index       Index of the input in tx_to spending the script_pubkey.\n+ * @param[in] flags             Bitfield of btck_ScriptFlags controlling validation constraints.\n+ * @param[out] status           Nullable, will be set to an error code if the operation fails.\n+ *                              Should be set to btck_SCRIPT_VERIFY_OK.\n+ * @return                      True if the script is valid.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT btck_script_pubkey_verify(\n+    const btck_ScriptPubkey* script_pubkey,\n+    int64_t amount,\n+    const btck_Transaction* tx_to,\n+    const btck_TransactionOutput** spent_outputs, size_t spent_outputs_len,\n+    unsigned int input_index,\n+    unsigned int flags,\n+    btck_ScriptVerifyStatus* status\n+) BITCOINKERNEL_ARG_NONNULL(1, 3);\n+\n+/*\n+ * @brief Serializes the script pubkey through the passed in callback to bytes.\n+ *\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] writer        Non-null, callback to a write bytes function.\n+ * @param[in] user_data     Holds a user-defined opaque structure that will be\n+ *                          passed back through the writer callback.\n+ * @return                  True on success.\n+ */\n+BITCOINKERNEL_API bool btck_script_pubkey_to_bytes(\n+    const btck_ScriptPubkey* script_pubkey,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the script pubkey.\n+ */\n+BITCOINKERNEL_API void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey);\n+\n+///@}\n+\n+/** @name TransactionOutput\n+ * Functions for working with transaction outputs.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a transaction output from a script pubkey and an amount.\n+ *\n+ * @param[in] script_pubkey Non-null.\n+ * @param[in] amount        The amount associated with the script pubkey for this output.\n+ * @return                  The transaction output.\n+ */\n+BITCOINKERNEL_API btck_TransactionOutput* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_output_create(\n+    const btck_ScriptPubkey* script_pubkey,\n+    int64_t amount\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the script pubkey of the output. The returned\n+ * script pubkey is not owned and depends on the lifetime of the\n+ * transaction output.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The script pubkey.\n+ */\n+BITCOINKERNEL_API btck_ScriptPubkey* BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_output_get_script_pubkey(\n+        const btck_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the amount in the output.\n+ *\n+ * @param[in] transaction_output Non-null.\n+ * @return                       The amount.\n+ */\n+BITCOINKERNEL_API int64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_transaction_output_get_amount(\n+    const btck_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ *  @brief Copy a transaction output.\n+ *\n+ *  @param[in] transaction_output Non-null.\n+ *  @return                       The copied transaction output.\n+ */\n+BITCOINKERNEL_API btck_TransactionOutput* btck_transaction_output_copy(\n+    const btck_TransactionOutput* transaction_output\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the transaction output.\n+ */\n+BITCOINKERNEL_API void btck_transaction_output_destroy(btck_TransactionOutput* transaction_output);\n+\n+///@}\n+\n+/** @name Logging\n+ * Logging-related functions.\n+ */\n+///@{\n+\n+/**\n+ * @brief This disables the global internal logger. No log messages will be\n+ * buffered internally anymore once this is called and the buffer is cleared.\n+ * This function should only be called once and is not thread or re-entry safe.\n+ * Log messages will be buffered until this function is called, or a logging\n+ * connection is created.\n+ */\n+BITCOINKERNEL_API void btck_logging_disable();\n+\n+/**\n+ * @brief Set the log level of the global internal logger. This does not\n+ * enable the selected categories. Use @ref btck_logging_enable_category to\n+ * start logging from a specific, or all categories. This function is not\n+ * thread safe. Multiple calls from different threads are allowed but must be\n+ * synchronized. This changes a global setting and will override settings for\n+ * all existing @ref btck_LoggingConnection instances.\n+ *\n+ * @param[in] category If btck_LOG_ALL is chosen, all messages at the specified level\n+ *                     will be logged. Otherwise only messages from the specified category\n+ *                     will be logged at the specified level and above.\n+ * @param[in] level    Log level at which the log category is set.\n+ */\n+BITCOINKERNEL_API void btck_logging_set_level_category(const btck_LogCategory category, btck_LogLevel level);\n+\n+/**\n+ * @brief Enable a specific log category for the global internal logger. This\n+ * function is not thread safe. Multiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref btck_LoggingConnection instances.\n+ *\n+ * @param[in] category If btck_LOG_ALL is chosen, all categories will be enabled.\n+ */\n+BITCOINKERNEL_API void btck_logging_enable_category(const btck_LogCategory category);\n+\n+/**\n+ * @brief Disable a specific log category for the global internal logger. This\n+ * function is not thread safe. Multiple calls from different threads are\n+ * allowed but must be synchronized. This changes a global setting and will\n+ * override settings for all existing @ref btck_LoggingConnection instances.\n+ *\n+ * @param[in] category If btck_LOG_ALL is chosen, all categories will be disabled.\n+ */\n+BITCOINKERNEL_API void btck_logging_disable_category(const btck_LogCategory category);\n+\n+/**\n+ * @brief Start logging messages through the provided callback. Log messages\n+ * produced before this function is first called are buffered and on calling this\n+ * function are logged immediately.\n+ *\n+ * @param[in] callback  Non-null, function through which messages will be logged.\n+ * @param[in] user_data Nullable, holds a user-defined opaque structure. Is passed back\n+ *                      to the user through the callback.\n+ * @param[in] options   Sets formatting options of the log messages.\n+ * @return              A new kernel logging connection, or null on error.\n+ */\n+BITCOINKERNEL_API btck_LoggingConnection* BITCOINKERNEL_WARN_UNUSED_RESULT btck_logging_connection_create(\n+    btck_LogCallback callback,\n+    const void* user_data,\n+    const btck_LoggingOptions options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Stop logging and destroy the logging connection.\n+ */\n+BITCOINKERNEL_API void btck_logging_connection_destroy(btck_LoggingConnection* logging_connection);\n+\n+///@}\n+\n+/** @name ChainParameters\n+ * Functions for working with chain parameters.\n+ */\n+///@{\n+\n+/**\n+ * @brief Creates a chain parameters struct with default parameters based on the\n+ * passed in chain type.\n+ *\n+ * @param[in] chain_type Controls the chain parameters type created.\n+ * @return               An allocated chain parameters opaque struct.\n+ */\n+BITCOINKERNEL_API btck_ChainParameters* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_parameters_create(\n+    const btck_ChainType chain_type);\n+\n+/**\n+ * Destroy the chain parameters.\n+ */\n+BITCOINKERNEL_API void btck_chain_parameters_destroy(btck_ChainParameters* chain_parameters);\n+\n+///@}\n+\n+/** @name ContextOptions\n+ * Functions for working with context options.\n+ */\n+///@{\n+\n+/**\n+ * Creates an empty context options.\n+ */\n+BITCOINKERNEL_API btck_ContextOptions* BITCOINKERNEL_WARN_UNUSED_RESULT btck_context_options_create();\n+\n+/**\n+ * @brief Sets the chain params for the context options. The context created\n+ * with the options will be configured for these chain parameters.\n+ *\n+ * @param[in] context_options  Non-null, previously created by @ref btck_context_options_create.\n+ * @param[in] chain_parameters Is set to the context options.\n+ */\n+BITCOINKERNEL_API void btck_context_options_set_chainparams(\n+    btck_ContextOptions* context_options,\n+    const btck_ChainParameters* chain_parameters\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the kernel notifications for the context options. The context\n+ * created with the options will be configured with these notifications.\n+ *\n+ * @param[in] context_options Non-null, previously created by @ref btck_context_options_create.\n+ * @param[in] notifications   Is set to the context options.\n+ */\n+BITCOINKERNEL_API void btck_context_options_set_notifications(\n+    btck_ContextOptions* context_options,\n+    btck_NotificationInterfaceCallbacks notifications\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Set the validation interface callbacks for the context options. The\n+ * context created with the options will be configured for these validation\n+ * interface callbacks. The callbacks will then be triggered from validation\n+ * events issued by the chainstate manager created from the same context.\n+ *\n+ * @param[in] context_options                Non-null, previously created with btck_context_options_create.\n+ * @param[in] validation_interface_callbacks The callbacks used for passing validation information to the\n+ *                                           user.\n+ */\n+BITCOINKERNEL_API void btck_context_options_set_validation_interface(\n+    btck_ContextOptions* context_options,\n+    btck_ValidationInterfaceCallbacks validation_interface_callbacks\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context options.\n+ */\n+BITCOINKERNEL_API void btck_context_options_destroy(btck_ContextOptions* context_options);\n+\n+///@}\n+\n+/** @name Context\n+ * Functions for working with contexts.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a new kernel context. If the options have not been previously\n+ * set, their corresponding fields will be initialized to default values; the\n+ * context will assume mainnet chain parameters and won't attempt to call the\n+ * kernel notification callbacks.\n+ *\n+ * @param[in] context_options Nullable, created by @ref btck_context_options_create.\n+ * @return                    The allocated context, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Context* BITCOINKERNEL_WARN_UNUSED_RESULT btck_context_create(\n+    const btck_ContextOptions* context_options);\n+\n+/**\n+ * @brief Interrupt can be used to halt long-running validation functions like\n+ * when reindexing, importing or processing blocks.\n+ *\n+ * @param[in] context  Non-null.\n+ * @return             True if the interrupt was successful.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT btck_context_interrupt(\n+    btck_Context* context\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the context.\n+ */\n+BITCOINKERNEL_API void btck_context_destroy(btck_Context* context);\n+\n+///@}\n+\n+/** @name BlockTreeEntry\n+ * Functions for working with block tree entries.\n+ */\n+///@{\n+\n+/**\n+ * @brief Returns the previous block tree entry in the chain, or null if the current\n+ * block tree entry is the genesis block.\n+ *\n+ * @param[in] block_tree_entry Non-null.\n+ * @return                     The previous block tree entry, or null on error or if the current block tree entry is the genesis block.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_tree_entry_get_previous(\n+    const btck_BlockTreeEntry* block_tree_entry\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the height of a certain block tree entry.\n+ *\n+ * @param[in] block_tree_entry Non-null.\n+ * @return                     The block height.\n+ */\n+BITCOINKERNEL_API int32_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_tree_entry_get_height(\n+    const btck_BlockTreeEntry* block_tree_entry\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Destroy the block tree entry.\n+ */\n+BITCOINKERNEL_API void btck_block_tree_entry_destroy(btck_BlockTreeEntry* block_tree_entry);\n+\n+///@}\n+\n+/** @name ChainstateManagerOptions\n+ * Functions for working with chainstate manager options.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create options for the chainstate manager.\n+ *\n+ * @param[in] context          Non-null, the created options and through it the chainstate manager will\n+                               associate with this kernel context for the duration of their lifetimes.\n+ * @param[in] data_directory   Non-null, path string of the directory containing the chainstate data.\n+ *                             If the directory does not exist yet, it will be created.\n+ * @param[in] blocks_directory Non-null, path string of the directory containing the block data. If\n+ *                             the directory does not exist yet, it will be created.\n+ * @return                     The allocated chainstate manager options, or null on error.\n+ */\n+BITCOINKERNEL_API btck_ChainstateManagerOptions* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_options_create(\n+    const btck_Context* context,\n+    const char* data_directory,\n+    size_t data_directory_len,\n+    const char* blocks_directory,\n+    size_t blocks_directory_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Set the number of available worker threads used during validation.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, options to be set.\n+ * @param[in] worker_threads             The number of worker threads that should be spawned in the thread pool\n+ *                                       used for validation. When set to 0 no parallel verification is done.\n+ *                                       The value range is clamped internally between 0 and 15.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_set_worker_threads_num(\n+        btck_ChainstateManagerOptions* chainstate_manager_options,\n+        int worker_threads\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets wipe db in the options. In combination with calling\n+ * @ref btck_chainstate_manager_import_blocks this triggers either a full reindex,\n+ * or a reindex of just the chainstate database.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @param[in] wipe_block_tree_db         Set wipe block tree db. Should only be True if wipe_chainstate_db is True too.\n+ * @param[in] wipe_chainstate_db         Set wipe chainstate db.\n+ * @return                               True if the set was successful, False if the set failed.\n+ */\n+BITCOINKERNEL_API bool btck_chainstate_manager_options_set_wipe_dbs(\n+    btck_ChainstateManagerOptions* chainstate_manager_options,\n+    bool wipe_block_tree_db,\n+    bool wipe_chainstate_db\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets block tree db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options   Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @param[in] block_tree_db_in_memory      Set block tree db in memory.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_set_block_tree_db_in_memory(\n+    btck_ChainstateManagerOptions* chainstate_manager_options,\n+    bool block_tree_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Sets chainstate db in memory in the options.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @param[in] chainstate_db_in_memory    Set chainstate db in memory.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_set_chainstate_db_in_memory(\n+    btck_ChainstateManagerOptions* chainstate_manager_options,\n+    bool chainstate_db_in_memory\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Destroy the chainstate manager options.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions* chainstate_manager_options);\n+\n+///@}\n+\n+/** @name ChainstateManager\n+ * Functions for chainstate management.\n+ */\n+///@{\n+\n+/**\n+ * @brief Create a chainstate manager. This is the main object for many\n+ * validation tasks as well as for retrieving data from the chain and\n+ * interacting with its chainstate and indexes.\n+ *\n+ * @param[in] chainstate_manager_options Non-null, created by @ref btck_chainstate_manager_options_create.\n+ * @return                               The allocated chainstate manager, or null on error.\n+ */\n+BITCOINKERNEL_API btck_ChainstateManager* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_create(\n+    const btck_ChainstateManagerOptions* chainstate_manager_options\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief May be called once the btck_ChainstateManager is instantiated.\n+ * Triggers the start of a reindex if the option was previously set for the\n+ * chainstate and block manager. Can also import an array of existing block\n+ * files selected by the user.\n+ *\n+ * @param[in] chainstate_manager   Non-null.\n+ * @param[in] block_file_paths     Nullable, array of block files described by their full filesystem paths.\n+ * @param[in] block_file_paths_len Length of the block_file_paths array.\n+ * @return                         True if the import blocks call was completed successfully.\n+ */\n+BITCOINKERNEL_API bool btck_chainstate_manager_import_blocks( btck_ChainstateManager* chainstate_manager,\n+                          const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Process and validate the passed in block with the chainstate\n+ * manager. More detailed validation information in case of a failure can also\n+ * be retrieved through a registered validation interface. If the block fails\n+ * to validate the `block_checked` callback's 'BlockValidationState' will\n+ * contain details.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block              Non-null, block to be validated.\n+ * @param[out] new_block         Nullable, will be set to true if this block was not processed before, and false otherwise.\n+ * @return                       True if processing the block was successful. Will also return true for valid, but duplicate blocks.\n+ */\n+BITCOINKERNEL_API bool BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_process_block(\n+    btck_ChainstateManager* chainstate_manager,\n+    const btck_Block* block,\n+    bool* new_block\n+) BITCOINKERNEL_ARG_NONNULL(1, 2, 3);\n+\n+/**\n+ * @brief Returns the best known currently active chain. Its lifetime is\n+ * dependent on the chainstate manager and state transitions within the\n+ * chainstate manager, e.g. when processing blocks, will also change the chain.\n+ * Data retrieved from this chain is only consistent up to the point when new\n+ * data is processed in the chainstate manager. It is the user's responsibility\n+ * to guard against these inconsistencies.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @return                       The chain.\n+ */\n+BITCOINKERNEL_API btck_Chain* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_get_active_chain(\n+    const btck_ChainstateManager* chainstate_manager\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Retrieve a block tree entry by its block hash.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_hash         Non-null.\n+ * @return                       The block tree entry of the block with the passed in hash, or null if\n+ *                               the block hash is not found.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chainstate_manager_get_block_tree_entry_by_hash(\n+    const btck_ChainstateManager* chainstate_manager,\n+    const btck_BlockHash* block_hash\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the chainstate manager.\n+ */\n+BITCOINKERNEL_API void btck_chainstate_manager_destroy(btck_ChainstateManager* chainstate_manager);\n+\n+///@}\n+\n+/** @name Block\n+ * Functions for working with blocks.\n+ */\n+///@{\n+\n+/**\n+ * @brief Reads the block the passed in block index points to from disk and\n+ * returns it.\n+ *\n+ * @param[in] chainstate_manager Non-null.\n+ * @param[in] block_tree_entry   Non-null.\n+ * @return                       The read out block, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Block* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_read(\n+    const btck_ChainstateManager* chainstate_manager,\n+    const btck_BlockTreeEntry* block_tree_entry\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * @brief Parse a serialized raw block into a new block object.\n+ *\n+ * @param[in] raw_block     Non-null, serialized block.\n+ * @param[in] raw_block_len Length of the serialized block.\n+ * @return                  The allocated block, or null on error.\n+ */\n+BITCOINKERNEL_API btck_Block* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_create(\n+    const void* raw_block, size_t raw_block_len\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Copy a block. Blocks are reference counted, so this just increments\n+ * the reference count.\n+ *\n+ * @param[in] block Non-null.\n+ * @return          The copied block.\n+ */\n+BITCOINKERNEL_API btck_Block* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_copy(\n+    const btck_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Count the number of transactions contained in a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return          The number of transactions in the block.\n+ */\n+BITCOINKERNEL_API uint64_t BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_count_transactions(\n+    const btck_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Get the transaction at the provided index. The returned transaction\n+ * is owned and does not depend on the lifetime of the block.\n+ *\n+ * @param[in] block             Non-null.\n+ * @param[in] transaction_index The index of the transaction to be retrieved.\n+ * @return                      The transaction.\n+ */\n+BITCOINKERNEL_API btck_Transaction* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_get_transaction_at(\n+    const btck_Block* block, uint64_t transaction_index\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API btck_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_get_hash(\n+    const btck_Block* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Calculate and return the hash of a block.\n+ *\n+ * @param[in] block Non-null.\n+ * @return    The block hash.\n+ */\n+BITCOINKERNEL_API btck_BlockHash* BITCOINKERNEL_WARN_UNUSED_RESULT btck_block_pointer_get_hash(\n+    const btck_BlockPointer* block\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Serializes the block through the passed in callback to bytes.\n+ * This is consensus serialization that is also used for the p2p network.\n+ *\n+ * @param[in] block     Non-null.\n+ * @param[in] writer    Non-null, callback to a write bytes function.\n+ * @param[in] user_data Holds a user-defined opaque structure that will be\n+ *                      passed back through the writer callback.\n+ * @return              True on success.\n+ */\n+BITCOINKERNEL_API bool btck_block_to_bytes(\n+    const btck_Block* block,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/*\n+ * @brief Serializes the block pointer through the passed in callback to bytes.\n+ * This is consensus serialization that is also used for the p2p network.\n+ *\n+ * @param[in] block     Non-null.\n+ * @param[in] writer    Non-null, callback to a write bytes function.\n+ * @param[in] user_data Holds a user-defined opaque structure that will be\n+ *                      passed back through the writer callback.\n+ * @return              True on success.\n+ */\n+BITCOINKERNEL_API bool btck_block_pointer_to_bytes(\n+    const btck_BlockPointer* block,\n+    btck_WriteBytes writer,\n+    void* user_data\n+) BITCOINKERNEL_ARG_NONNULL(1, 2);\n+\n+/**\n+ * Destroy the block.\n+ */\n+BITCOINKERNEL_API void btck_block_destroy(btck_Block* block);\n+\n+///@}\n+\n+/** @name BlockValidationState\n+ * Functions for working with block validation states.\n+ */\n+///@{\n+\n+/**\n+ * Returns the validation mode from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API btck_ValidationMode btck_block_validation_state_get_validation_mode(\n+    const btck_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * Returns the validation result from an opaque block validation state pointer.\n+ */\n+BITCOINKERNEL_API btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(\n+    const btck_BlockValidationState* block_validation_state\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+///@}\n+\n+/** @name Chain\n+ * Functions for working with the chain\n+ */\n+///@{\n+\n+/**\n+ * @brief Get the block tree entry of the current chain tip. Once returned,\n+ * there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] chain Non-null.\n+ * @return          The block tree entry of the current tip, or null if the chain is empty.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_tip(\n+    const btck_Chain* chain\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/*\n+ * @brief Get the block tree entry of the genesis block.\n+ *\n+ * @param[in] chain Non-null.\n+ * @return          The block tree entry of the genesis block, or null if the chain is empty.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_genesis(\n+    const btck_Chain* chain\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Retrieve a block tree entry by its height in the currently active chain.\n+ * Once retrieved there is no guarantee that it remains in the active chain.\n+ *\n+ * @param[in] chain        Non-null.\n+ * @param[in] block_height Height in the chain of the to be retrieved block tree entry.\n+ * @return                 The block tree entry at a certain height in the currently active chain,\n+ *                         or null if the height is out of bounds.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_by_height(\n+    const btck_Chain* chain,\n+    int block_height\n+) BITCOINKERNEL_ARG_NONNULL(1);\n+\n+/**\n+ * @brief Return the next block index in the currently active chain, or null if\n+ * the current block index is the tip, or is not in the currently active\n+ * chain.\n+ *\n+ * @param[in] chain            Non-null.\n+ * @param[in] block_tree_entry Non-null.\n+ * @return                     The next block index in the currently active chain, or null if\n+ *                             the block_index is the chain tip, or not in the chain.\n+ */\n+BITCOINKERNEL_API btck_BlockTreeEntry* BITCOINKERNEL_WARN_UNUSED_RESULT btck_chain_get_next_block_index(",
      "path": "src/kernel/bitcoinkernel.h",
      "position": null,
      "original_position": 1239,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "ab06b85bc2c0f4733dd96f9694c0c3d972004a36",
      "in_reply_to_id": 2278842152,
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes :)",
      "created_at": "2025-08-15T12:28:19Z",
      "updated_at": "2025-08-15T12:28:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2278904242",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2278904242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2282357987",
      "pull_request_review_id": 3128316327,
      "id": 2282357987,
      "node_id": "PRRC_kwDOABII586ICgTj",
      "diff_hunk": "@@ -1,11 +1,1179 @@\n-// Copyright (c) 2022 The Bitcoin Core developers\n+// Copyright (c) 2022-present The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#define BITCOINKERNEL_BUILD\n+\n+#include <kernel/bitcoinkernel.h>\n+\n+#include <chain.h>\n+#include <coins.h>\n+#include <consensus/amount.h>\n+#include <consensus/validation.h>\n+#include <kernel/caches.h>\n+#include <kernel/chainparams.h>\n+#include <kernel/checks.h>\n+#include <kernel/context.h>\n+#include <kernel/notifications_interface.h>\n+#include <kernel/warning.h>\n+#include <logging.h>\n+#include <node/blockstorage.h>\n+#include <node/chainstate.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <serialize.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n+#include <undo.h>\n+#include <util/fs.h>\n+#include <util/result.h>\n+#include <util/signalinterrupt.h>\n+#include <util/task_runner.h>\n #include <util/translation.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n \n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <exception>\n #include <functional>\n+#include <list>\n+#include <memory>\n+#include <span>\n #include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+using util::ImmediateTaskRunner;\n \n // Define G_TRANSLATION_FUN symbol in libbitcoinkernel library so users of the\n // library aren't required to export this symbol\n-extern const TranslateFn G_TRANSLATION_FUN{nullptr};\n+extern const std::function<std::string(const char*)> G_TRANSLATION_FUN{nullptr};\n+\n+static const kernel::Context btck_context_static{};\n+\n+struct btck_BlockTreeEntry {\n+    CBlockIndex* m_block_index;\n+};\n+\n+namespace {\n+\n+bool is_valid_flag_combination(unsigned int flags)\n+{\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK && ~flags & (SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)) return false;\n+    if (flags & SCRIPT_VERIFY_WITNESS && ~flags & SCRIPT_VERIFY_P2SH) return false;\n+    return true;\n+}\n+\n+class WriterStream\n+{\n+private:\n+    btck_WriteBytes m_writer;\n+    void* m_user_data;\n+\n+public:\n+    WriterStream(btck_WriteBytes writer, void* user_data)\n+        : m_writer{writer}, m_user_data{user_data} {}\n+\n+    //\n+    // Stream subset\n+    //\n+    void write(std::span<const std::byte> src)\n+    {\n+        if (m_writer(std::data(src), src.size(), m_user_data) != 0) {\n+            throw std::runtime_error(\"Failed to write serilization data\");\n+        }\n+    }\n+\n+    template <typename T>\n+    WriterStream& operator<<(const T& obj)\n+    {\n+        ::Serialize(*this, obj);\n+        return *this;\n+    }\n+};\n+\n+BCLog::Level get_bclog_level(btck_LogLevel level)\n+{\n+    switch (level) {\n+    case btck_LogLevel_INFO: {\n+        return BCLog::Level::Info;\n+    }\n+    case btck_LogLevel_DEBUG: {\n+        return BCLog::Level::Debug;\n+    }\n+    case btck_LogLevel_TRACE: {\n+        return BCLog::Level::Trace;\n+    }\n+    }\n+    assert(false);\n+}\n+\n+BCLog::LogFlags get_bclog_flag(btck_LogCategory category)\n+{\n+    switch (category) {\n+    case btck_LogCategory_BENCH: {\n+        return BCLog::LogFlags::BENCH;\n+    }\n+    case btck_LogCategory_BLOCKSTORAGE: {\n+        return BCLog::LogFlags::BLOCKSTORAGE;\n+    }\n+    case btck_LogCategory_COINDB: {\n+        return BCLog::LogFlags::COINDB;\n+    }\n+    case btck_LogCategory_LEVELDB: {\n+        return BCLog::LogFlags::LEVELDB;\n+    }\n+    case btck_LogCategory_MEMPOOL: {\n+        return BCLog::LogFlags::MEMPOOL;\n+    }\n+    case btck_LogCategory_PRUNE: {\n+        return BCLog::LogFlags::PRUNE;\n+    }\n+    case btck_LogCategory_RAND: {\n+        return BCLog::LogFlags::RAND;\n+    }\n+    case btck_LogCategory_REINDEX: {\n+        return BCLog::LogFlags::REINDEX;\n+    }\n+    case btck_LogCategory_VALIDATION: {\n+        return BCLog::LogFlags::VALIDATION;\n+    }\n+    case btck_LogCategory_KERNEL: {\n+        return BCLog::LogFlags::KERNEL;\n+    }\n+    case btck_LogCategory_ALL: {\n+        return BCLog::LogFlags::ALL;\n+    }\n+    }\n+    assert(false);\n+}\n+\n+btck_SynchronizationState cast_state(SynchronizationState state)\n+{\n+    switch (state) {\n+    case SynchronizationState::INIT_REINDEX:\n+        return btck_SynchronizationState_INIT_REINDEX;\n+    case SynchronizationState::INIT_DOWNLOAD:\n+        return btck_SynchronizationState_INIT_DOWNLOAD;\n+    case SynchronizationState::POST_INIT:\n+        return btck_SynchronizationState_POST_INIT;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_Warning cast_btck_warning(kernel::Warning warning)\n+{\n+    switch (warning) {\n+    case kernel::Warning::UNKNOWN_NEW_RULES_ACTIVATED:\n+        return btck_Warning_UNKNOWN_NEW_RULES_ACTIVATED;\n+    case kernel::Warning::LARGE_WORK_INVALID_CHAIN:\n+        return btck_Warning_LARGE_WORK_INVALID_CHAIN;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+class KernelNotifications : public kernel::Notifications\n+{\n+private:\n+    btck_NotificationInterfaceCallbacks m_cbs;\n+\n+public:\n+    KernelNotifications(btck_NotificationInterfaceCallbacks cbs)\n+        : m_cbs{cbs}\n+    {\n+    }\n+\n+    kernel::InterruptResult blockTip(SynchronizationState state, CBlockIndex& index, double verification_progress) override\n+    {\n+        if (m_cbs.block_tip) m_cbs.block_tip((void*)m_cbs.user_data, cast_state(state), new btck_BlockTreeEntry{&index}, verification_progress);\n+        return {};\n+    }\n+    void headerTip(SynchronizationState state, int64_t height, int64_t timestamp, bool presync) override\n+    {\n+        if (m_cbs.header_tip) m_cbs.header_tip((void*)m_cbs.user_data, cast_state(state), height, timestamp, presync ? 1 : 0);\n+    }\n+    void progress(const bilingual_str& title, int progress_percent, bool resume_possible) override\n+    {\n+        if (m_cbs.progress) m_cbs.progress((void*)m_cbs.user_data, title.original.c_str(), title.original.length(), progress_percent, resume_possible ? 1 : 0);\n+    }\n+    void warningSet(kernel::Warning id, const bilingual_str& message) override\n+    {\n+        if (m_cbs.warning_set) m_cbs.warning_set((void*)m_cbs.user_data, cast_btck_warning(id), message.original.c_str(), message.original.length());\n+    }\n+    void warningUnset(kernel::Warning id) override\n+    {\n+        if (m_cbs.warning_unset) m_cbs.warning_unset((void*)m_cbs.user_data, cast_btck_warning(id));\n+    }\n+    void flushError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.flush_error) m_cbs.flush_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+    void fatalError(const bilingual_str& message) override\n+    {\n+        if (m_cbs.fatal_error) m_cbs.fatal_error((void*)m_cbs.user_data, message.original.c_str(), message.original.length());\n+    }\n+};\n+\n+class KernelValidationInterface final : public CValidationInterface\n+{\n+public:\n+    const btck_ValidationInterfaceCallbacks m_cbs;\n+\n+    explicit KernelValidationInterface(const btck_ValidationInterfaceCallbacks vi_cbs) : m_cbs{vi_cbs} {}\n+\n+protected:\n+    void BlockChecked(const CBlock& block, const BlockValidationState& stateIn) override\n+    {\n+        if (m_cbs.block_checked) {\n+            m_cbs.block_checked((void*)m_cbs.user_data,\n+                                reinterpret_cast<const btck_BlockPointer*>(&block),\n+                                reinterpret_cast<const btck_BlockValidationState*>(&stateIn));\n+        }\n+    }\n+};\n+\n+struct ContextOptions {\n+    mutable Mutex m_mutex;\n+    std::unique_ptr<const CChainParams> m_chainparams GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelNotifications> m_notifications GUARDED_BY(m_mutex);\n+    std::unique_ptr<const KernelValidationInterface> m_validation_interface GUARDED_BY(m_mutex);\n+};\n+\n+class Context\n+{\n+public:\n+    std::unique_ptr<kernel::Context> m_context;\n+\n+    std::unique_ptr<KernelNotifications> m_notifications;\n+\n+    std::unique_ptr<util::SignalInterrupt> m_interrupt;\n+\n+    std::unique_ptr<ValidationSignals> m_signals;\n+\n+    std::unique_ptr<const CChainParams> m_chainparams;\n+\n+    std::unique_ptr<KernelValidationInterface> m_validation_interface;\n+\n+    Context(const ContextOptions* options, bool& sane)\n+        : m_context{std::make_unique<kernel::Context>()},\n+          m_interrupt{std::make_unique<util::SignalInterrupt>()},\n+          m_signals{std::make_unique<ValidationSignals>(std::make_unique<ImmediateTaskRunner>())}\n+    {\n+        if (options) {\n+            LOCK(options->m_mutex);\n+            if (options->m_chainparams) {\n+                m_chainparams = std::make_unique<const CChainParams>(*options->m_chainparams);\n+            }\n+            if (options->m_notifications) {\n+                m_notifications = std::make_unique<KernelNotifications>(*options->m_notifications);\n+            }\n+            if (options->m_validation_interface) {\n+                m_validation_interface = std::make_unique<KernelValidationInterface>(*options->m_validation_interface);\n+                m_signals->RegisterValidationInterface(m_validation_interface.get());\n+            }\n+        }\n+\n+        if (!m_chainparams) {\n+            m_chainparams = CChainParams::Main();\n+        }\n+        if (!m_notifications) {\n+            m_notifications = std::make_unique<KernelNotifications>(btck_NotificationInterfaceCallbacks{\n+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr});\n+        }\n+\n+        if (!kernel::SanityChecks(*m_context)) {\n+            sane = false;\n+        }\n+    }\n+\n+    ~Context()\n+    {\n+        m_signals->UnregisterValidationInterface(m_validation_interface.get());\n+    }\n+};\n+\n+//! Helper struct to wrap the ChainstateManager-related Options\n+struct ChainstateManagerOptions {\n+    mutable Mutex m_mutex;\n+    ChainstateManager::Options m_chainman_options GUARDED_BY(m_mutex);\n+    node::BlockManager::Options m_blockman_options GUARDED_BY(m_mutex);\n+    std::shared_ptr<Context> m_context;\n+    node::ChainstateLoadOptions m_chainstate_load_options GUARDED_BY(m_mutex);\n+\n+    ChainstateManagerOptions(const std::shared_ptr<Context>& context, const fs::path& data_dir, const fs::path& blocks_dir)\n+        : m_chainman_options{ChainstateManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .datadir = data_dir,\n+              .notifications = *context->m_notifications,\n+              .signals = context->m_signals.get()}},\n+          m_blockman_options{node::BlockManager::Options{\n+              .chainparams = *context->m_chainparams,\n+              .blocks_dir = blocks_dir,\n+              .notifications = *context->m_notifications,\n+              .block_tree_db_params = DBParams{\n+                  .path = data_dir / \"blocks\" / \"index\",\n+                  .cache_bytes = kernel::CacheSizes{DEFAULT_KERNEL_CACHE}.block_tree_db,\n+              }}},\n+          m_context{context},\n+          m_chainstate_load_options{node::ChainstateLoadOptions{}}\n+    {\n+    }\n+};\n+\n+const BlockValidationState* cast_block_validation_state(const btck_BlockValidationState* block_validation_state)\n+{\n+    assert(block_validation_state);\n+    return reinterpret_cast<const BlockValidationState*>(block_validation_state);\n+}\n+\n+const CBlock* cast_const_cblock(const btck_BlockPointer* block)\n+{\n+    assert(block);\n+    return reinterpret_cast<const CBlock*>(block);\n+}\n+\n+} // namespace\n+\n+struct btck_Transaction {\n+    std::shared_ptr<const CTransaction> m_tx;\n+};\n+\n+struct btck_TransactionOutput {\n+    const CTxOut* m_txout;\n+    bool m_owned;\n+};\n+\n+struct btck_ScriptPubkey {\n+    const CScript* m_script;\n+    bool m_owned;\n+};\n+\n+struct btck_LoggingConnection {\n+    std::unique_ptr<std::list<std::function<void(const std::string&)>>::iterator> m_connection;\n+};\n+\n+struct btck_ContextOptions {\n+    std::unique_ptr<ContextOptions> m_opts;\n+};\n+\n+struct btck_Context {\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_ChainParameters {\n+    std::unique_ptr<const CChainParams> m_params;\n+};\n+\n+struct btck_ChainstateManagerOptions {\n+    std::unique_ptr<ChainstateManagerOptions> m_opts;\n+};\n+\n+struct btck_ChainstateManager {\n+    std::unique_ptr<ChainstateManager> m_chainman;\n+    std::shared_ptr<Context> m_context;\n+};\n+\n+struct btck_Block {\n+    std::shared_ptr<CBlock> m_block;\n+};\n+\n+struct btck_Chain {\n+    const CChain* m_chain;\n+};\n+\n+struct btck_BlockSpentOutputs {\n+    std::shared_ptr<CBlockUndo> m_block_undo;\n+};\n+\n+struct btck_TransactionSpentOutputs {\n+    const CTxUndo* m_tx_undo;\n+    bool m_owned;\n+};\n+\n+struct btck_Coin {\n+    const Coin* m_coin;\n+    bool m_owned;\n+};\n+\n+btck_Transaction* btck_transaction_create(const void* raw_transaction, size_t raw_transaction_len)\n+{\n+    try {\n+        DataStream stream{std::span{reinterpret_cast<const std::byte*>(raw_transaction), raw_transaction_len}};\n+        auto tx{std::make_shared<CTransaction>(deserialize, TX_WITH_WITNESS, stream)};\n+        return new btck_Transaction{std::move(tx)};\n+    } catch (...) {\n+        return nullptr;\n+    }\n+}\n+\n+size_t btck_transaction_count_outputs(const btck_Transaction* transaction)\n+{\n+    return transaction->m_tx->vout.size();\n+}\n+\n+btck_TransactionOutput* btck_transaction_get_output_at(const btck_Transaction* transaction, size_t output_index)\n+{\n+    assert(output_index < transaction->m_tx->vout.size());\n+    return new btck_TransactionOutput{&transaction->m_tx->vout[output_index], false};\n+}\n+\n+size_t btck_transaction_count_inputs(const btck_Transaction* transaction)\n+{\n+    return transaction->m_tx->vin.size();\n+}\n+\n+btck_Transaction* btck_transaction_copy(const btck_Transaction* transaction)\n+{\n+    return new btck_Transaction{transaction->m_tx};\n+}\n+\n+int btck_transaction_to_bytes(const btck_Transaction* transaction, btck_WriteBytes writer, void* user_data)\n+{\n+    try {\n+        WriterStream ws{writer, user_data};\n+        ws << TX_WITH_WITNESS(*transaction->m_tx);\n+        return 0;\n+    } catch (...) {\n+        return -1;\n+    }\n+}\n+\n+void btck_transaction_destroy(btck_Transaction* transaction)\n+{\n+    if (!transaction) return;\n+    delete transaction;\n+    transaction = nullptr;\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_create(const void* script_pubkey, size_t script_pubkey_len)\n+{\n+    auto data = std::span{reinterpret_cast<const uint8_t*>(script_pubkey), script_pubkey_len};\n+    return new btck_ScriptPubkey{new CScript(data.begin(), data.end()), true};\n+}\n+\n+int btck_script_pubkey_to_bytes(const btck_ScriptPubkey* script_pubkey, btck_WriteBytes writer, void* user_data)\n+{\n+    return writer(script_pubkey->m_script->data(), script_pubkey->m_script->size(), user_data);\n+}\n+\n+btck_ScriptPubkey* btck_script_pubkey_copy(const btck_ScriptPubkey* script_pubkey)\n+{\n+    return new btck_ScriptPubkey{new CScript(*script_pubkey->m_script), true};\n+}\n+\n+void btck_script_pubkey_destroy(btck_ScriptPubkey* script_pubkey)\n+{\n+    if (!script_pubkey) return;\n+    if (script_pubkey->m_owned) {\n+        delete script_pubkey->m_script;\n+    }\n+    delete script_pubkey;\n+    script_pubkey = nullptr;\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_create(const btck_ScriptPubkey* script_pubkey, int64_t amount)\n+{\n+    const CAmount& value{amount};\n+    return new btck_TransactionOutput{new CTxOut(value, *script_pubkey->m_script), true};\n+}\n+\n+btck_TransactionOutput* btck_transaction_output_copy(const btck_TransactionOutput* output)\n+{\n+    return new btck_TransactionOutput{new CTxOut{*output->m_txout}, true};\n+}\n+\n+btck_ScriptPubkey* btck_transaction_output_get_script_pubkey(const btck_TransactionOutput* output)\n+{\n+    const auto* script_pubkey{&output->m_txout->scriptPubKey};\n+    return new btck_ScriptPubkey{script_pubkey, false};\n+}\n+\n+int64_t btck_transaction_output_get_amount(const btck_TransactionOutput* output)\n+{\n+    return output->m_txout->nValue;\n+}\n+\n+void btck_transaction_output_destroy(btck_TransactionOutput* output)\n+{\n+    if (!output) return;\n+    if (output->m_owned) {\n+        delete output->m_txout;\n+    }\n+    delete output;\n+    output = nullptr;\n+}\n+\n+int btck_script_pubkey_verify(const btck_ScriptPubkey* script_pubkey,\n+                          const int64_t amount_,\n+                          const btck_Transaction* tx_to,\n+                          const btck_TransactionOutput** spent_outputs_, size_t spent_outputs_len,\n+                          const unsigned int input_index,\n+                          const btck_ScriptVerificationFlags flags,\n+                          btck_ScriptVerifyStatus* status)\n+{\n+    const CAmount amount{amount_};\n+\n+    // Assert that all specified flags are part of the interface before continuing\n+    assert((flags & ~btck_ScriptVerificationFlags_ALL) == 0);\n+\n+    if (!is_valid_flag_combination(flags)) {\n+        if (status) *status = btck_ScriptVerifyStatus_ERROR_INVALID_FLAGS_COMBINATION;\n+        return 0;\n+    }\n+\n+    if (flags & btck_ScriptVerificationFlags_TAPROOT  && spent_outputs_ == nullptr) {\n+        if (status) *status = btck_ScriptVerifyStatus_ERROR_SPENT_OUTPUTS_REQUIRED;\n+        return 0;\n+    }\n+\n+    const CTransaction& tx{*tx_to->m_tx};\n+    std::vector<CTxOut> spent_outputs;\n+    if (spent_outputs_ != nullptr) {\n+        assert(spent_outputs_len == tx.vin.size());\n+        spent_outputs.reserve(spent_outputs_len);\n+        for (size_t i = 0; i < spent_outputs_len; i++) {\n+            const CTxOut& tx_out{*spent_outputs_[i]->m_txout};\n+            spent_outputs.push_back(tx_out);\n+        }\n+    }\n+\n+    assert(input_index < tx.vin.size());\n+    PrecomputedTransactionData txdata{tx};\n+\n+    if (spent_outputs_ != nullptr && flags & btck_ScriptVerificationFlags_TAPROOT) {\n+        txdata.Init(tx, std::move(spent_outputs));\n+    }\n+\n+    bool result = VerifyScript(tx.vin[input_index].scriptSig,\n+                        *script_pubkey->m_script,\n+                        &tx.vin[input_index].scriptWitness,\n+                        flags,\n+                        TransactionSignatureChecker(&tx, input_index, amount, txdata, MissingDataBehavior::FAIL),\n+                        nullptr);\n+    return result ? 1 : 0;\n+}\n+\n+void btck_logging_set_level_category(btck_LogCategory category, btck_LogLevel level)\n+{\n+    if (category == btck_LogCategory_ALL) {\n+        LogInstance().SetLogLevel(get_bclog_level(level));\n+    }\n+\n+    LogInstance().AddCategoryLogLevel(get_bclog_flag(category), get_bclog_level(level));\n+}\n+\n+void btck_logging_enable_category(btck_LogCategory category)\n+{\n+    LogInstance().EnableCategory(get_bclog_flag(category));\n+}\n+\n+void btck_logging_disable_category(btck_LogCategory category)\n+{\n+    LogInstance().DisableCategory(get_bclog_flag(category));\n+}\n+\n+void btck_logging_disable()\n+{\n+    LogInstance().DisableLogging();\n+}\n+\n+btck_LoggingConnection* btck_logging_connection_create(btck_LogCallback callback,\n+                                                           const void* user_data,\n+                                                           const btck_LoggingOptions options)\n+{\n+    LogInstance().m_log_timestamps = options.log_timestamps;\n+    LogInstance().m_log_time_micros = options.log_time_micros;\n+    LogInstance().m_log_threadnames = options.log_threadnames;\n+    LogInstance().m_log_sourcelocations = options.log_sourcelocations;\n+    LogInstance().m_always_print_category_level = options.always_print_category_levels;\n+\n+    auto connection{LogInstance().PushBackCallback([callback, user_data](const std::string& str) { callback((void*)user_data, str.c_str(), str.length()); })};\n+\n+    try {\n+        // Only start logging if we just added the connection.\n+        if (LogInstance().NumConnections() == 1 && !LogInstance().StartLogging()) {\n+            LogError(\"Logger start failed.\");\n+            LogInstance().DeleteCallback(connection);\n+            return nullptr;\n+        }\n+    } catch (std::exception& e) {\n+        LogError(\"Logger start failed: %s\", e.what());\n+        LogInstance().DeleteCallback(connection);\n+        return nullptr;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger connected.\");\n+\n+    return new btck_LoggingConnection{std::make_unique<std::list<std::function<void(const std::string&)>>::iterator>(connection)};\n+}\n+\n+void btck_logging_connection_destroy(btck_LoggingConnection* connection)\n+{\n+    if (!connection) {\n+        return;\n+    }\n+\n+    LogDebug(BCLog::KERNEL, \"Logger disconnected.\");\n+    LogInstance().DeleteCallback(*connection->m_connection);\n+    delete connection;\n+\n+    // Switch back to buffering by calling DisconnectTestLogger if the\n+    // connection that was just removed was the last one.\n+    if (!LogInstance().Enabled()) {\n+        LogInstance().DisconnectTestLogger();\n+    }\n+    connection = nullptr;\n+}\n+\n+btck_ChainParameters* btck_chain_parameters_create(const btck_ChainType chain_type)\n+{\n+    switch (chain_type) {\n+    case btck_ChainType_MAINNET: {\n+        return new btck_ChainParameters{CChainParams::Main()};\n+    }\n+    case btck_ChainType_TESTNET: {\n+        return new btck_ChainParameters{CChainParams::TestNet()};\n+    }\n+    case btck_ChainType_TESTNET_4: {\n+        return new btck_ChainParameters{CChainParams::TestNet4()};\n+    }\n+    case btck_ChainType_SIGNET: {\n+        return new btck_ChainParameters{CChainParams::SigNet({})};\n+    }\n+    case btck_ChainType_REGTEST: {\n+        return new btck_ChainParameters{CChainParams::RegTest({})};\n+    }\n+    }\n+    assert(false);\n+}\n+\n+void btck_chain_parameters_destroy(btck_ChainParameters* chain_parameters)\n+{\n+    if (!chain_parameters) return;\n+    delete chain_parameters;\n+    chain_parameters = nullptr;\n+}\n+\n+btck_ContextOptions* btck_context_options_create()\n+{\n+    return new btck_ContextOptions{std::make_unique<ContextOptions>()};\n+}\n+\n+void btck_context_options_set_chainparams(btck_ContextOptions* options, const btck_ChainParameters* chain_parameters)\n+{\n+    // Copy the chainparams, so the caller can free it again\n+    LOCK(options->m_opts->m_mutex);\n+    options->m_opts->m_chainparams = std::make_unique<const CChainParams>(*chain_parameters->m_params);\n+}\n+\n+void btck_context_options_set_notifications(btck_ContextOptions* options, btck_NotificationInterfaceCallbacks notifications)\n+{\n+    // The KernelNotifications are copy-initialized, so the caller can free them again.\n+    LOCK(options->m_opts->m_mutex);\n+    options->m_opts->m_notifications = std::make_unique<const KernelNotifications>(notifications);\n+}\n+\n+void btck_context_options_set_validation_interface(btck_ContextOptions* options, btck_ValidationInterfaceCallbacks vi_cbs)\n+{\n+    LOCK(options->m_opts->m_mutex);\n+    options->m_opts->m_validation_interface = std::make_unique<KernelValidationInterface>(KernelValidationInterface(vi_cbs));\n+}\n+\n+void btck_context_options_destroy(btck_ContextOptions* options)\n+{\n+    if (!options) return;\n+    delete options;\n+    options = nullptr;\n+}\n+\n+btck_Context* btck_context_create(const btck_ContextOptions* options)\n+{\n+    bool sane{true};\n+    auto context{std::make_shared<Context>(options->m_opts.get(), sane)};\n+    if (!sane) {\n+        LogError(\"Kernel context sanity check failed.\");\n+        return nullptr;\n+    }\n+    return new btck_Context{std::move(context)};\n+}\n+\n+int btck_context_interrupt(btck_Context* context)\n+{\n+    return (*context->m_context->m_interrupt)() ? 0 : -1;\n+}\n+\n+void btck_context_destroy(btck_Context* context)\n+{\n+    if (!context) return;\n+    delete context;\n+    context = nullptr;\n+}\n+\n+btck_BlockTreeEntry* btck_block_tree_entry_get_previous(const btck_BlockTreeEntry* entry)\n+{\n+    if (!entry->m_block_index->pprev) {\n+        LogInfo(\"Genesis block has no previous.\");\n+        return nullptr;\n+    }\n+\n+    return new btck_BlockTreeEntry{entry->m_block_index->pprev};\n+}\n+\n+void btck_block_tree_entry_destroy(btck_BlockTreeEntry* block_tree_entry)\n+{\n+    if (!block_tree_entry) return;\n+    delete block_tree_entry;\n+    block_tree_entry = nullptr;\n+}\n+\n+btck_ValidationMode btck_block_validation_state_get_validation_mode(const btck_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    if (block_validation_state.IsValid()) return btck_ValidationMode_VALID;\n+    if (block_validation_state.IsInvalid()) return btck_ValidationMode_INVALID;\n+    return btck_ValidationMode_INTERNAL_ERROR;\n+}\n+\n+btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(const btck_BlockValidationState* block_validation_state_)\n+{\n+    auto& block_validation_state = *cast_block_validation_state(block_validation_state_);\n+    switch (block_validation_state.GetResult()) {\n+    case BlockValidationResult::BLOCK_RESULT_UNSET:\n+        return btck_BlockValidationResult_UNSET;\n+    case BlockValidationResult::BLOCK_CONSENSUS:\n+        return btck_BlockValidationResult_CONSENSUS;\n+    case BlockValidationResult::BLOCK_CACHED_INVALID:\n+        return btck_BlockValidationResult_CACHED_INVALID;\n+    case BlockValidationResult::BLOCK_INVALID_HEADER:\n+        return btck_BlockValidationResult_INVALID_HEADER;\n+    case BlockValidationResult::BLOCK_MUTATED:\n+        return btck_BlockValidationResult_MUTATED;\n+    case BlockValidationResult::BLOCK_MISSING_PREV:\n+        return btck_BlockValidationResult_MISSING_PREV;\n+    case BlockValidationResult::BLOCK_INVALID_PREV:\n+        return btck_BlockValidationResult_INVALID_PREV;\n+    case BlockValidationResult::BLOCK_TIME_FUTURE:\n+        return btck_BlockValidationResult_TIME_FUTURE;\n+    case BlockValidationResult::BLOCK_HEADER_LOW_WORK:\n+        return btck_BlockValidationResult_HEADER_LOW_WORK;\n+    } // no default case, so the compiler can warn about missing cases\n+    assert(false);\n+}\n+\n+btck_ChainstateManagerOptions* btck_chainstate_manager_options_create(const btck_Context* context, const char* data_dir, size_t data_dir_len, const char* blocks_dir, size_t blocks_dir_len)\n+{\n+    try {\n+        fs::path abs_data_dir{fs::absolute(fs::PathFromString({data_dir, data_dir_len}))};\n+        fs::create_directories(abs_data_dir);\n+        fs::path abs_blocks_dir{fs::absolute(fs::PathFromString({blocks_dir, blocks_dir_len}))};\n+        fs::create_directories(abs_blocks_dir);\n+        auto chainman_opts{std::make_unique<ChainstateManagerOptions>(context->m_context, abs_data_dir, abs_blocks_dir)};\n+        return new btck_ChainstateManagerOptions{std::move(chainman_opts)};\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager options: %s\", e.what());\n+        return nullptr;\n+    }\n+}\n+\n+void btck_chainstate_manager_options_set_worker_threads_num(btck_ChainstateManagerOptions* opts, int worker_threads)\n+{\n+    LOCK(opts->m_opts->m_mutex);\n+    opts->m_opts->m_chainman_options.worker_threads_num = worker_threads;\n+}\n+\n+void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions* options)\n+{\n+    if (!options) return;\n+    delete options;\n+    options = nullptr;\n+}\n+\n+int btck_chainstate_manager_options_set_wipe_dbs(btck_ChainstateManagerOptions* chainman_opts, int wipe_block_tree_db, int wipe_chainstate_db)\n+{\n+    if (wipe_block_tree_db == 1 && wipe_chainstate_db != 1) {\n+        LogError(\"Wiping the block tree db without also wiping the chainstate db is currently unsupported.\");\n+        return -1;\n+    }\n+    LOCK(chainman_opts->m_opts->m_mutex);\n+    chainman_opts->m_opts->m_blockman_options.block_tree_db_params.wipe_data = wipe_block_tree_db == 1;\n+    chainman_opts->m_opts->m_chainstate_load_options.wipe_chainstate_db = wipe_chainstate_db == 1;\n+    return 0;\n+}\n+\n+void btck_chainstate_manager_options_set_block_tree_db_in_memory(\n+    btck_ChainstateManagerOptions* chainman_opts,\n+    int block_tree_db_in_memory)\n+{\n+    LOCK(chainman_opts->m_opts->m_mutex);\n+    chainman_opts->m_opts->m_blockman_options.block_tree_db_params.memory_only = block_tree_db_in_memory == 1;\n+}\n+\n+void btck_chainstate_manager_options_set_chainstate_db_in_memory(\n+    btck_ChainstateManagerOptions* chainman_opts,\n+    int chainstate_db_in_memory)\n+{\n+    LOCK(chainman_opts->m_opts->m_mutex);\n+    chainman_opts->m_opts->m_chainstate_load_options.coins_db_in_memory = chainstate_db_in_memory == 1;\n+}\n+\n+btck_ChainstateManager* btck_chainstate_manager_create(\n+    const btck_ChainstateManagerOptions* chainman_opts)\n+{\n+    std::unique_ptr<ChainstateManager> chainman;\n+    try {\n+        LOCK(chainman_opts->m_opts->m_mutex);\n+        auto& context{chainman_opts->m_opts->m_context};\n+        chainman = std::make_unique<ChainstateManager>(*context->m_interrupt, chainman_opts->m_opts->m_chainman_options, chainman_opts->m_opts->m_blockman_options);\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to create chainstate manager: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    try {\n+        const auto chainstate_load_opts{WITH_LOCK(chainman_opts->m_opts->m_mutex, return chainman_opts->m_opts->m_chainstate_load_options)};\n+\n+        kernel::CacheSizes cache_sizes{DEFAULT_KERNEL_CACHE};\n+        auto [status, chainstate_err]{node::LoadChainstate(*chainman, cache_sizes, chainstate_load_opts)};\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to load chain state from your data directory: %s\", chainstate_err.original);\n+            return nullptr;\n+        }\n+        std::tie(status, chainstate_err) = node::VerifyLoadedChainstate(*chainman, chainstate_load_opts);\n+        if (status != node::ChainstateLoadStatus::SUCCESS) {\n+            LogError(\"Failed to verify loaded chain state from your datadir: %s\", chainstate_err.original);\n+            return nullptr;\n+        }\n+\n+        for (Chainstate* chainstate : WITH_LOCK(chainman->GetMutex(), return chainman->GetAll())) {\n+            BlockValidationState state;\n+            if (!chainstate->ActivateBestChain(state, nullptr)) {\n+                LogError(\"Failed to connect best block: %s\", state.ToString());\n+                return nullptr;\n+            }\n+        }\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to load chainstate: %s\", e.what());\n+        return nullptr;\n+    }\n+\n+    return new btck_ChainstateManager{std::move(chainman), chainman_opts->m_opts->m_context};\n+}\n+\n+btck_BlockTreeEntry* btck_chainstate_manager_get_block_tree_entry_by_hash(const btck_ChainstateManager* chainman, const btck_BlockHash* block_hash)\n+{\n+    auto hash = uint256{std::span<const unsigned char>{(*block_hash).hash, 32}};\n+    auto block_index = WITH_LOCK(chainman->m_chainman->GetMutex(), return chainman->m_chainman->m_blockman.LookupBlockIndex(hash));\n+    if (!block_index) {\n+        LogDebug(BCLog::KERNEL, \"A block with the given hash is not indexed.\");\n+        return nullptr;\n+    }\n+    return new btck_BlockTreeEntry{block_index};\n+}\n+\n+void btck_chainstate_manager_destroy(btck_ChainstateManager* chainman)\n+{\n+    if (!chainman) return;\n+\n+    {\n+        LOCK(chainman->m_chainman->GetMutex());\n+        for (Chainstate* chainstate : chainman->m_chainman->GetAll()) {\n+            if (chainstate->CanFlushToDisk()) {\n+                chainstate->ForceFlushStateToDisk();\n+                chainstate->ResetCoinsViews();\n+            }\n+        }\n+    }\n+\n+    delete chainman;\n+    chainman = nullptr;\n+}\n+\n+int btck_chainstate_manager_import_blocks(btck_ChainstateManager* chainman, const char** block_file_paths, size_t* block_file_paths_lens, size_t block_file_paths_len)\n+{\n+    try {\n+        std::vector<fs::path> import_files;\n+        import_files.reserve(block_file_paths_len);\n+        for (uint32_t i = 0; i < block_file_paths_len; i++) {\n+            if (block_file_paths[i] != nullptr) {\n+                import_files.emplace_back(std::string{block_file_paths[i], block_file_paths_lens[i]}.c_str());\n+            }\n+        }\n+        node::ImportBlocks(*chainman->m_chainman, import_files);\n+        chainman->m_chainman->ActiveChainstate().ForceFlushStateToDisk();\n+    } catch (const std::exception& e) {\n+        LogError(\"Failed to import blocks: %s\", e.what());\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n+btck_Block* btck_block_create(const void* raw_block, size_t raw_block_length)\n+{\n+    auto block{std::make_shared<CBlock>()};\n+\n+    DataStream stream{std::span{reinterpret_cast<const std::byte*>(raw_block), raw_block_length}};\n+\n+    try {\n+        stream >> TX_WITH_WITNESS(*block);\n+    } catch (...) {\n+        LogDebug(BCLog::KERNEL, \"Block decode failed.\");\n+        return nullptr;\n+    }\n+\n+    return new btck_Block{std::move(block)};\n+}\n+\n+btck_Block* btck_block_copy(const btck_Block* block)\n+{\n+    return new btck_Block{block->m_block};\n+}\n+\n+size_t btck_block_count_transactions(const btck_Block* block)\n+{\n+    return block->m_block->vtx.size();\n+}\n+\n+btck_Transaction* btck_block_get_transaction_at(const btck_Block* block, size_t index)\n+{\n+    assert(index < block->m_block->vtx.size());\n+    return new btck_Transaction{block->m_block->vtx[index]};\n+}\n+\n+int btck_block_to_bytes(const btck_Block* block, btck_WriteBytes writer, void* user_data)\n+{\n+    try {\n+        WriterStream ws{writer, user_data};\n+        ws << TX_WITH_WITNESS(*block->m_block);\n+        return 0;\n+    } catch (...) {\n+        return -1;\n+    }\n+}\n+\n+int btck_block_pointer_to_bytes(const btck_BlockPointer* block_, btck_WriteBytes writer, void* user_data)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    try {\n+        WriterStream ws{writer, user_data};\n+        ws << TX_WITH_WITNESS(*block);\n+        return 0;\n+    } catch (...) {\n+        return -1;\n+    }\n+}\n+\n+btck_BlockHash* btck_block_get_hash(const btck_Block* block)\n+{\n+    auto hash{block->m_block->GetHash()};\n+    auto block_hash = new btck_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+btck_BlockHash* btck_block_pointer_get_hash(const btck_BlockPointer* block_)\n+{\n+    auto block{cast_const_cblock(block_)};\n+    auto hash{block->GetHash()};\n+    auto block_hash = new btck_BlockHash{};\n+    std::memcpy(block_hash->hash, hash.begin(), sizeof(hash));\n+    return block_hash;\n+}\n+\n+void btck_block_destroy(btck_Block* block)\n+{\n+    if (!block) return;\n+    delete block;\n+    block = nullptr;\n+}\n+\n+btck_Block* btck_block_read(const btck_ChainstateManager* chainman, const btck_BlockTreeEntry* entry)\n+{\n+    auto block{std::shared_ptr<CBlock>(new CBlock{})};\n+    if (!chainman->m_chainman->m_blockman.ReadBlock(*block, *entry->m_block_index)) {\n+        LogError(\"Failed to read block.\");\n+        return nullptr;\n+    }\n+    return new btck_Block{block};\n+}\n+\n+int32_t btck_block_tree_entry_get_height(const btck_BlockTreeEntry* entry)\n+{\n+    return entry->m_block_index->nHeight;\n+}\n+\n+btck_BlockHash* btck_block_tree_entry_get_block_hash(const btck_BlockTreeEntry* entry)\n+{\n+    if (entry->m_block_index->phashBlock == nullptr) {\n+        return nullptr;\n+    }\n+    auto block_hash = new btck_BlockHash{};\n+    std::memcpy(block_hash->hash, entry->m_block_index->phashBlock->begin(), sizeof(*entry->m_block_index->phashBlock));\n+    return block_hash;\n+}\n+\n+void btck_block_hash_destroy(btck_BlockHash* hash)\n+{\n+    if (hash) delete hash;\n+    hash = nullptr;\n+}\n+\n+btck_BlockSpentOutputs* btck_block_spent_outputs_read(const btck_ChainstateManager* chainman, const btck_BlockTreeEntry* entry)\n+{\n+    if (entry->m_block_index->nHeight < 1) {\n+        LogDebug(BCLog::KERNEL, \"The genesis block does not have any spent outputs.\");\n+        return nullptr;\n+    }\n+    auto block_undo{std::make_shared<CBlockUndo>()};\n+    if (!chainman->m_chainman->m_blockman.ReadBlockUndo(*block_undo, *entry->m_block_index)) {\n+        LogError(\"Failed to read block spent outputs data.\");\n+        return nullptr;\n+    }\n+    return new btck_BlockSpentOutputs{std::move(block_undo)};\n+}\n+\n+btck_BlockSpentOutputs* btck_block_spent_outputs_copy(const btck_BlockSpentOutputs* block_spent_outputs)\n+{\n+    return new btck_BlockSpentOutputs{block_spent_outputs->m_block_undo};\n+}\n+\n+size_t btck_block_spent_outputs_count(const btck_BlockSpentOutputs* block_spent_outputs)\n+{\n+    return block_spent_outputs->m_block_undo->vtxundo.size();\n+}\n+\n+btck_TransactionSpentOutputs* btck_block_spent_outputs_get_transaction_spent_outputs_at(const btck_BlockSpentOutputs* block_spent_outputs, size_t transaction_index)\n+{\n+    assert(transaction_index < block_spent_outputs->m_block_undo->vtxundo.size());\n+    const auto* tx_undo{&block_spent_outputs->m_block_undo->vtxundo.at(transaction_index)};\n+    return new btck_TransactionSpentOutputs{tx_undo, false};\n+}\n+\n+void btck_block_spent_outputs_destroy(btck_BlockSpentOutputs* block_spent_outputs)\n+{\n+    if (!block_spent_outputs) return;\n+    delete block_spent_outputs;\n+    block_spent_outputs = nullptr;\n+}\n+\n+btck_TransactionSpentOutputs* btck_transaction_spent_outputs_copy(const btck_TransactionSpentOutputs* transaction_spent_outputs)\n+{\n+    return new btck_TransactionSpentOutputs{new CTxUndo{*transaction_spent_outputs->m_tx_undo}, true};\n+}\n+\n+size_t btck_transaction_spent_outputs_count(const btck_TransactionSpentOutputs* transaction_spent_outputs)\n+{\n+    return transaction_spent_outputs->m_tx_undo->vprevout.size();\n+}\n+\n+void btck_transaction_spent_outputs_destroy(btck_TransactionSpentOutputs* transaction_spent_outputs)\n+{\n+    if (!transaction_spent_outputs) return;\n+    if (transaction_spent_outputs->m_owned) {\n+        delete transaction_spent_outputs->m_tx_undo;\n+    }\n+    delete transaction_spent_outputs;\n+    transaction_spent_outputs = nullptr;\n+}\n+\n+btck_Coin* btck_transaction_spent_outputs_get_coin_at(const btck_TransactionSpentOutputs* transaction_spent_outputs, size_t coin_index)\n+{\n+    assert(coin_index < transaction_spent_outputs->m_tx_undo->vprevout.size());\n+    const Coin* coin{&transaction_spent_outputs->m_tx_undo->vprevout.at(coin_index)};\n+    return new btck_Coin{coin, false};\n+}\n+\n+btck_Coin* btck_coin_copy(const btck_Coin* coin)\n+{\n+    return new btck_Coin{new Coin{*coin->m_coin}, true};\n+}\n+\n+uint32_t btck_coin_confirmation_height(const btck_Coin* coin)\n+{\n+    return coin->m_coin->nHeight;\n+}\n+\n+int btck_coin_is_coinbase(const btck_Coin* coin)\n+{\n+    return coin->m_coin->IsCoinBase() ? 1 : 0;\n+}\n+\n+btck_TransactionOutput* btck_coin_get_output(const btck_Coin* coin)\n+{\n+    const CTxOut* output{&coin->m_coin->out};\n+    return new btck_TransactionOutput{output, false};\n+}\n+\n+void btck_coin_destroy(btck_Coin* coin)\n+{\n+    if (!coin) return;\n+    if (coin->m_owned) {\n+        delete coin->m_coin;\n+    }\n+    delete coin;\n+    coin = nullptr;\n+}\n+\n+int btck_chainstate_manager_process_block(\n+    btck_ChainstateManager* chainman,\n+    const btck_Block* block,\n+    int* _new_block)\n+{\n+    bool new_block;\n+    auto result = chainman->m_chainman->ProcessNewBlock(block->m_block, /*force_processing=*/true, /*min_pow_checked=*/true, /*new_block=*/&new_block);\n+    if (_new_block) {\n+        *_new_block = new_block ? 1 : 0;\n+    }\n+    return result ? 0 : -1;\n+}\n+\n+btck_Chain* btck_chainstate_manager_get_active_chain(const btck_ChainstateManager* chainman)\n+{\n+    return new btck_Chain{&WITH_LOCK(chainman->m_chainman->GetMutex(), return chainman->m_chainman->ActiveChain())};\n+}\n+\n+btck_BlockTreeEntry* btck_chain_get_tip(const btck_Chain* chain)\n+{\n+    return new btck_BlockTreeEntry{chain->m_chain->Tip()};\n+}\n+\n+btck_BlockTreeEntry* btck_chain_get_genesis(const btck_Chain* chain)\n+{\n+    return new btck_BlockTreeEntry{chain->m_chain->Genesis()};\n+}\n+\n+btck_BlockTreeEntry* btck_chain_get_by_height(const btck_Chain* chain, int height)\n+{\n+    LOCK(::cs_main);\n+    assert(height >= 0 && height <= chain->m_chain->Height());\n+    return new btck_BlockTreeEntry{(*chain->m_chain)[height]};\n+}\n+\n+btck_BlockTreeEntry* btck_chain_get_next_block_tree_entry(const btck_Chain* chain, const btck_BlockTreeEntry* entry)\n+{\n+    auto next_block_index{chain->m_chain->Next(entry->m_block_index)};\n+\n+    if (!next_block_index) {\n+        LogTrace(BCLog::KERNEL, \"The block index is the tip of the current chain, it does not have a next.\");\n+    }",
      "path": "src/kernel/bitcoinkernel.cpp",
      "position": 1166,
      "original_position": 1166,
      "commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "original_commit_id": "7bcb122e6e55339f25238a44433cc5aadc4526f1",
      "in_reply_to_id": null,
      "user": {
        "login": "alexanderwiederin",
        "id": 37130778,
        "node_id": "MDQ6VXNlcjM3MTMwNzc4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37130778?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alexanderwiederin",
        "html_url": "https://github.com/alexanderwiederin",
        "followers_url": "https://api.github.com/users/alexanderwiederin/followers",
        "following_url": "https://api.github.com/users/alexanderwiederin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alexanderwiederin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alexanderwiederin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alexanderwiederin/subscriptions",
        "organizations_url": "https://api.github.com/users/alexanderwiederin/orgs",
        "repos_url": "https://api.github.com/users/alexanderwiederin/repos",
        "events_url": "https://api.github.com/users/alexanderwiederin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alexanderwiederin/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think we need to return a `nullptr` here instead of returning a `btck_BlockTreeEntry` wrapper with a null `m_block_index`. The current behavior causes segfaults when callers try to access the returned entry. What do you think?",
      "created_at": "2025-08-18T13:12:09Z",
      "updated_at": "2025-08-18T13:12:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2282357987",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2282357987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30595"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1164,
      "original_line": 1164,
      "side": "RIGHT"
    }
  ]
}