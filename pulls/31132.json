{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132",
    "id": 2138649533,
    "node_id": "PR_kwDOABII585_eTO9",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31132",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31132.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31132.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/942f3006fcc85be70fb174c99b73e7b9022cfcdb",
    "number": 31132,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "validation: fetch block inputs on parallel threads ~17% faster IBD",
    "user": {
      "login": "andrewtoth",
      "id": 237213,
      "node_id": "MDQ6VXNlcjIzNzIxMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/andrewtoth",
      "html_url": "https://github.com/andrewtoth",
      "followers_url": "https://api.github.com/users/andrewtoth/followers",
      "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
      "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
      "repos_url": "https://api.github.com/users/andrewtoth/repos",
      "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "When fetching inputs in ConnectBlock, each input is fetched from the cache in series. A cache miss means a round trip to the disk db to fetch the outpoint and insert it into the cache. Since the db is locked from being written during ConnectTip, we can fetch all block inputs missing from the cache on parallel threads before entering ConnectBlock. Using this strategy resulted in a ~17% faster IBD (or master was ~21% slower).\r\n\r\nDoing IBD with 16 vcores from a local peer with default settings, stopping at height 850k:\r\n\r\n|  | Mean [s] | Min [s] | Max [s] | Relative |\r\n|:---|---:|---:|---:|---:|\r\n| branch | 22187.488 Â± 50.159 | 22152.021 | 22222.956 | 1.00 |\r\n| master | 26865.884 Â± 33.498 | 26842.197 | 26889.570 | 1.21 |\r\n\r\n\r\nThis approach is heavily inspired by `CCheckQueue`, but we could not easily reuse it since it only checks for validity and doesn't allow us to store results in a queue. So, this PR creates a new `InputFetcher` that loops through all inputs of a block on the main thread and adds their outpoints to a queue to be fetched in parallel. Worker threads pull outpoints from the queue and fetch them from the db, and then push the results back onto another queue. Once the main thread has finished looping through the block inputs, it pulls results from the result queue and inserts them into the cache.\r\n\r\nThis PR uses number of cores to create the worker threads, but since the work on the threads is IO bound, it might benefit from using a multiple of the number of cores. However, that would result in more memory usage and lock contention, so the optimal number is still unknown.",
    "labels": [
      {
        "id": 118379652,
        "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
        "name": "Validation",
        "color": "6060aa",
        "default": false
      }
    ],
    "created_at": "2024-10-22T14:40:28Z",
    "updated_at": "2024-10-24T18:40:37Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "b649a85a55757215fe000095ec9e5776d632a0bb",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "andrewtoth:threaded-inputs",
      "ref": "threaded-inputs",
      "sha": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 156145027,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNTYxNDUwMjc=",
        "name": "bitcoin",
        "full_name": "andrewtoth/bitcoin",
        "owner": {
          "login": "andrewtoth",
          "id": 237213,
          "node_id": "MDQ6VXNlcjIzNzIxMw==",
          "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/andrewtoth",
          "html_url": "https://github.com/andrewtoth",
          "followers_url": "https://api.github.com/users/andrewtoth/followers",
          "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
          "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
          "repos_url": "https://api.github.com/users/andrewtoth/repos",
          "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/andrewtoth/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/andrewtoth/bitcoin",
        "archive_url": "https://api.github.com/repos/andrewtoth/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/andrewtoth/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/andrewtoth/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/andrewtoth/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/andrewtoth/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/andrewtoth/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/andrewtoth/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/andrewtoth/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/andrewtoth/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/andrewtoth/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/andrewtoth/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/andrewtoth/bitcoin/events",
        "forks_url": "https://api.github.com/repos/andrewtoth/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/andrewtoth/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/andrewtoth/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/andrewtoth/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/andrewtoth/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/andrewtoth/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/andrewtoth/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/andrewtoth/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/andrewtoth/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/andrewtoth/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/andrewtoth/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/andrewtoth/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/andrewtoth/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:andrewtoth/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/andrewtoth/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/andrewtoth/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/andrewtoth/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/andrewtoth/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/andrewtoth/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/andrewtoth/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/andrewtoth/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/andrewtoth/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/andrewtoth/bitcoin/hooks",
        "svn_url": "https://github.com/andrewtoth/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 264173,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-24T18:40:35Z",
        "created_at": "2018-11-05T01:43:59Z",
        "updated_at": "2022-12-23T04:16:30Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "74fb19317aec6d5156e12da6be63e59e0cc99770",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36269,
        "stargazers_count": 79020,
        "watchers_count": 79020,
        "size": 270101,
        "default_branch": "master",
        "open_issues_count": 650,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-10-24T17:53:22Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-10-24T18:23:45Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 249,
    "deletions": 3,
    "changed_files": 5,
    "commits": 2,
    "review_comments": 29,
    "comments": 6
  },
  "events": [
    {
      "event": "commented",
      "id": 2429478185,
      "node_id": "IC_kwDOABII586QzuUp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2429478185",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:40:31Z",
      "updated_at": "2024-10-23T12:44:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/31132).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/31132#pullrequestreview-2388117544) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30906](https://github.com/bitcoin/bitcoin/pull/30906) (refactor: prohibit direct flags access in CCoinsCacheEntry and remove invalid tests by l0rinc)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2429478185",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "labeled",
      "id": 14786916578,
      "node_id": "LE_lADOABII586bT0I_zwAAAANxXnDi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14786916578",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:40:34Z",
      "label": {
        "name": "Validation",
        "color": "6060aa"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14787017217,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxX_oB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787017217",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:45:41Z"
    },
    {
      "event": "commented",
      "id": 2429491813,
      "node_id": "IC_kwDOABII586Qzxpl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2429491813",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:45:47Z",
      "updated_at": "2024-10-22T14:45:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/31894441286</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2429491813",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "labeled",
      "id": 14787019013,
      "node_id": "LE_lADOABII586bT0I_zwAAAANxYAEF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787019013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:45:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "renamed",
      "id": 14787094471,
      "node_id": "RTE_lADOABII586bT0I_zwAAAANxYSfH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787094471",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:49:35Z",
      "rename": {
        "from": "validation: fetch block inputs parallel threads ~17% faster IBD",
        "to": "validation: fetch block inputs on parallel threads ~17% faster IBD"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14787303983,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxZFov",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14787303983",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T14:59:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14788613835,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxeFbL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14788613835",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T16:12:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14790893735,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAANxmyCn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14790893735",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T18:46:51Z"
    },
    {
      "event": "unlabeled",
      "id": 14792905981,
      "node_id": "UNLE_lADOABII586bT0I_zwAAAANxudT9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14792905981",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-22T21:09:47Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2431934694,
      "node_id": "IC_kwDOABII586Q9GDm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2431934694",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-23T12:16:54Z",
      "updated_at": "2024-10-23T12:16:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I will wait for some conceptual support before writing tests for `InputFetcher`.",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2431934694",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "reviewed",
      "id": 2388117544,
      "node_id": "PRR_kwDOABII586OV8go",
      "url": null,
      "actor": null,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nI'm still missing tests and benchmarks here and I think we need to find better default values for SSD and HDD parallelism, and I'd be interested in how coroutines would perform here instead of trying to find the best batching size manually.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#pullrequestreview-2388117544",
      "submitted_at": "2024-10-23T12:44:26Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
    },
    {
      "event": "reviewed",
      "id": 2388943653,
      "node_id": "PRR_kwDOABII586OZGMl",
      "url": null,
      "actor": null,
      "commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Cool idea.\r\n\r\nSince the inputs fetcher call is blocking, instead of creating a new set of worker threads, what do you think about re-using the existing script validation ones (or any other unused worker threads) by implementing a general-purpose thread pool shared among the validation checks? \r\nThe script validation checks and the inputs fetching mechanism are never done concurrently because you need the inputs in order to verify the scripts. So, they could share workers.\r\n\r\nThis should be benchmarked because it might add some overhead but, #26966 introduces such structure inside 401f21bfd72f32a28147677af542887518a4dbff, which we could pull off and use for validation.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#pullrequestreview-2388943653",
      "submitted_at": "2024-10-23T14:25:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
    },
    {
      "event": "commented",
      "id": 2432481201,
      "node_id": "IC_kwDOABII586Q_Lex",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2432481201",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-23T14:48:28Z",
      "updated_at": "2024-10-23T14:48:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "> implementing a general-purpose thread pool shared among the validation checks?\r\n\r\nNice, yes that would be great! That would simplify this PR a lot if it could just schedule tasks on worker threads and receive the responses, instead of implementing all the sync code itself.\r\n\r\n> https://github.com/bitcoin/bitcoin/pull/26966 introduces such structure inside https://github.com/bitcoin/bitcoin/commit/401f21bfd72f32a28147677af542887518a4dbff, which we could pull off and use for validation.\r\n\r\nConcept ACK!",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2432481201",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "commented",
      "id": 2436046062,
      "node_id": "IC_kwDOABII586RMxzu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2436046062",
      "actor": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-24T18:12:38Z",
      "updated_at": "2024-10-24T18:13:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "Finished benching on a HDD until 860k on Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz, CPU 8:\r\n\r\n```bash\r\nSummary\r\n  'COMMIT=f278ca4ec3f0a90c285e640f1a270869ca594d20 ./build/src/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=860000 -dbcache=10000 -printtoconsole=0' ran\r\n    1.02 times faster than 'COMMIT=e9e23b59f8eedb8dfae75aa660328299fba92b50 ./build/src/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=860000 -dbcache=10000 -printtoconsole=\r\n0'\r\n```\r\n\r\n> f278ca4ec3 coins: allow emplacing non-dirty coins internally (39993.343777768874 seconds = 11.1 hours)\r\n> e9e23b59f8 validation: fetch block inputs in parallel (40929.84310861388 seconds = 11.3 hours)\r\n\r\n-----\r\n\r\nSo likely on HDD we shouldn't use so many threads, apparently it slows down IBD.\r\nMaybe we could add a new config option (`iothreads` or `iothreadmultiplier` or something).\r\nThe defaults should likely depend on whether it's an SSD or HDD.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2436046062",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "commented",
      "id": 2436080216,
      "node_id": "IC_kwDOABII586RM6JY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2436080216",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-24T18:31:14Z",
      "updated_at": "2024-10-24T18:31:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "> So likely on HDD we shouldn't use so many threads, apparently it slows down IBD.\r\n\r\nI'm not sure we can conclude that from your benchmark. It used a very high dbcache setting, which makes the effect of this change less important. It also is syncing from untrusted network peers, so there is some variance which could also account for the 2% difference.",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#issuecomment-2436080216",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31132"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkyZmM3MTg1OTJiZTU1ODEyYjJjNzNhM2JmNTc1OTlmYzgxNDI1ZmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92fc718592be55812b2c73a3bf57599fc81425fa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/92fc718592be55812b2c73a3bf57599fc81425fa",
      "tree": {
        "sha": "5f66e15d14e84a9fa771a3f78a6c23be161f2966",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5f66e15d14e84a9fa771a3f78a6c23be161f2966"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5f66e15d14e84a9fa771a3f78a6c23be161f2966\nparent 74fb19317aec6d5156e12da6be63e59e0cc99770\nauthor Andrew Toth <andrewstoth@gmail.com> 1729599354 -0400\ncommitter Andrew Toth <andrewstoth@gmail.com> 1729794712 -0400\n\ncoins: allow emplacing non-dirty coins internally\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEISytpz6vNK/yCogaYAB6/Ik4sBgFAmcakpgACgkQYAB6/Ik4\nsBjpWxAAn6k7240IOdzHetXQbXK79H2gs/21hQAZXpsMpnfwjBbv6ZMeeYT3Cu9o\nzrk++IyCn6skdygd3aFerxgitUvWcfhTEkvwGQ8XXu3+tu+riy1fbBdV1zWnWyMi\nmKwPjEHpQohjnU4xF0/U4GRg+XyWpCT1+ch6QjVjEnHtUgxFbEXXv2t9g3FohIu7\n7oIgdyT2DMJJ6nROfhLAnaEzU9J4rcRb5SQM8pavcnqz59oblh/fph7GsRQ0+WOa\n6yJcooA8ROOOR8klG/3tKeGO62NxgcrI4yetswK2WN/oJqT8v3oURV6UZBwPcaIa\nw1XAehCrkjevRHa2Rov3yleow8bbt/8NSJTGXZnlo2Lw4H8rqar46+Cn0LfU1fnB\nIALmkB5OzB+jr6kkY57bPAiOYM7Gn7GMCAQ/Wo0osKEGSVY1xWAgjQ0leEzgpDm7\n3pPPB2XLL7AdU7YOVCpXGeU8RYjFJF3GkUdZLMl6cQZ0ScQclYOwCg/AIKCz612I\nsePzf4jCImyHogtfjn3f3INir5tT0aUJlGMwXrW3TE2TIQRi3ZBjRFjlLImxcw8n\nTFDRZ055Xh0f16gQ+oYzDcghDelzuVgiofDpdxUWKXlqmnQGqqoCusBznpdU0SLE\nUbyp9eHbOjk18vUjR1bC6iJw4c/nFF+X1UcNeMx4ClfQXcoY/tw=\n=VyrY\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/74fb19317aec6d5156e12da6be63e59e0cc99770",
          "sha": "74fb19317aec6d5156e12da6be63e59e0cc99770",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/74fb19317aec6d5156e12da6be63e59e0cc99770"
        }
      ],
      "message": "coins: allow emplacing non-dirty coins internally",
      "committer": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-24T18:31:52Z"
      },
      "author": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-22T12:15:54Z"
      },
      "sha": "92fc718592be55812b2c73a3bf57599fc81425fa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk0MmYzMDA2ZmNjODViZTcwZmIxNzRjOTliNzNlN2I5MDIyY2ZjZGI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "tree": {
        "sha": "dfc37eb4023eba36a048e89b67f995c56b5f5d5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dfc37eb4023eba36a048e89b67f995c56b5f5d5f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dfc37eb4023eba36a048e89b67f995c56b5f5d5f\nparent 92fc718592be55812b2c73a3bf57599fc81425fa\nauthor Andrew Toth <andrewstoth@gmail.com> 1729603682 -0400\ncommitter Andrew Toth <andrewstoth@gmail.com> 1729794712 -0400\n\nvalidation: fetch block inputs in parallel\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEISytpz6vNK/yCogaYAB6/Ik4sBgFAmcakpgACgkQYAB6/Ik4\nsBhGfBAAlAKls9FflwCYSi80tL1yhwGwZXrx1/XWdCaUlQGdsilJ4aIcsJqzwvHh\nHsHkP3ZElWj3FrfQCItuR+SNSWuNzRVpGG3VpJs14YiJlNhvdOTig9dUyktvIzCi\nwWQWEpMvxyiLPAFRtiS7wLfD0i93HAPoZzUHNv1BbeTJwxEun+gqecOfUa6IFxJL\nfrQ2e9048PFwxUCUesQmDFK1R2cIVWkbvO0D1X/qT8Drcjg/F8x7RYSd+QORgRoT\nfw/nwgwQGJJcPTWp0KwpaM3wfL7T4sT0uG+ght9QLvW3Z3bXXimnLKvk2rnnBKtS\ne7ZZk+HAsUmpqrBhDJti45itn2iq3rTsx7Q7MC4kA2dJVy4iuo3D6O5pDuRit0A+\naCr/+wSvGlLIWwpaavvtn/BUg1WCTK9rwKXrHAioG0httEZVQix+LLc+xHuQvo4j\nnnh0OY6vcyfIuaWs2VcnAJF9WTlrYas0K11wid5G5/zhtVL+eetIFv8kEU0tpZzt\nsaffxPITh1gPLqc3LNbw6WBE47fj66lFIFhB+L8BbKjBLvGG1YQkf9rjCAKx5aR+\ncL5h029h9nNX4cVzFiC5TodkXVDCnwwr2MHURZgIqzrk8Ebv8SCg114NnISsqPZ9\n8pen+oWMldla5qhvC2PkJ23z+RJbCC8IakfEOtG6U/4MRSsfgUU=\n=T4Ok\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92fc718592be55812b2c73a3bf57599fc81425fa",
          "sha": "92fc718592be55812b2c73a3bf57599fc81425fa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/92fc718592be55812b2c73a3bf57599fc81425fa"
        }
      ],
      "message": "validation: fetch block inputs in parallel",
      "committer": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-24T18:31:52Z"
      },
      "author": {
        "name": "Andrew Toth",
        "email": "andrewstoth@gmail.com",
        "date": "2024-10-22T13:28:02Z"
      },
      "sha": "942f3006fcc85be70fb174c99b73e7b9022cfcdb"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14856978808,
      "node_id": "HRFPE_lADOABII586bT0I_zwAAAAN1i4F4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14856978808",
      "actor": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-24T18:40:37Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812440117",
      "pull_request_review_id": 2388117544,
      "id": 1812440117,
      "node_id": "PRRC_kwDOABII585sB6Q1",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Q: Is this a leftover a hack for non-owning LevelDB threads, or is this really the best way to name threads in a cross-platform way?",
      "created_at": "2024-10-23T10:26:47Z",
      "updated_at": "2024-10-23T13:27:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812440117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812440117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812531761",
      "pull_request_review_id": 2388117544,
      "id": 1812531761,
      "node_id": "PRRC_kwDOABII585sCQox",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 189,
      "original_position": 189,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're mostly creating the buckets randomly here, so each thread will need access to basically all of the keys.\r\nSince we have an idea of how LevelDB works here (i.e. Sorted String Table), we could likely improve cache locality (would likely be most beneficial on HDDs) and minimize lock contention by splitting the reads by sorted transactions instead.",
      "created_at": "2024-10-23T11:29:06Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812531761",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812531761"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812534028",
      "pull_request_review_id": 2388117544,
      "id": 1812534028,
      "node_id": "PRRC_kwDOABII585sCRMM",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);",
      "path": "src/inputfetcher.h",
      "position": 73,
      "original_position": 73,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm wondering if we really need to (b)lock here or whether we could we create a [read-only snapshot](https://github.com/google/leveldb/blob/main/doc/index.md#snapshots) instead and avoid stalling?",
      "created_at": "2024-10-23T11:30:32Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812534028",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812534028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812548418",
      "pull_request_review_id": 2388117544,
      "id": 1812548418,
      "node_id": "PRRC_kwDOABII585sCUtC",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher",
      "path": "src/inputfetcher.h",
      "position": 29,
      "original_position": 29,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I know it's not trivial request, but can we add a test for this class which fetches everything in parallel and sequentially and assert that the result is equivalent?\r\nAnd preferably also a benchmark, like we have it for https://github.com/bitcoin/bitcoin/blob/master/src/bench/checkqueue.cpp.\r\nI would gladly help here, if needed.",
      "created_at": "2024-10-23T11:39:06Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812548418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812548418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812560601",
      "pull_request_review_id": 2388117544,
      "id": 1812560601,
      "node_id": "PRRC_kwDOABII585sCXrZ",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept",
      "path": "src/inputfetcher.h",
      "position": 145,
      "original_position": 145,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For consistency (see: `explicit CCheckQueue(unsigned int batch_size, int worker_threads_num)`) and simplicity (`m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)}`, and to follow modern C++ directions where sizes seem to be preferred as signed values, see: https://github.com/bitcoin/bitcoin/pull/30927#discussion_r1766881296), please consider making these int(s) instead.",
      "created_at": "2024-10-23T11:46:37Z",
      "updated_at": "2024-10-23T12:47:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812560601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812560601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812599960",
      "pull_request_review_id": 2388117544,
      "id": 1812599960,
      "node_id": "PRRC_kwDOABII585sChSY",
      "diff_hunk": "@@ -6243,6 +6248,7 @@ static ChainstateManager::Options&& Flatten(ChainstateManager::Options&& opts)\n \n ChainstateManager::ChainstateManager(const util::SignalInterrupt& interrupt, Options options, node::BlockManager::Options blockman_options)\n     : m_script_check_queue{/*batch_size=*/128, options.worker_threads_num},\n+      m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)},",
      "path": "src/validation.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unlike the script checks, these fetches aren't CPU bound, there is no reason to provide the number of CPUs as the number of parallels threads.\r\nI don't know if we care about HDD performance here or not, but we can likely find a multiplier that makes this better for both SSD and HDD.\r\n\r\nQuoting from https://pkolaczk.github.io/disk-parallelism:\r\n> It was surprising to me that even 64 threads, which are far more than the number of CPU cores (4 physical, 8 virtual), still improved the performance. I guess that with requests of such a small size to such a fast storage, you need to submit really many of them to keep the SSD busy.\r\n\r\nIf we can provide a benchmark for this usecase we can likely find an optimal multiplier here - I won't nack but this part is very important for me.",
      "created_at": "2024-10-23T12:07:45Z",
      "updated_at": "2024-10-23T12:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812599960",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812599960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6257,
      "original_line": 6257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812604307",
      "pull_request_review_id": 2388117544,
      "id": 1812604307,
      "node_id": "PRRC_kwDOABII585sCiWT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {",
      "path": "src/inputfetcher.h",
      "position": 188,
      "original_position": 188,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it be possible to create the batch sizes dynamically?\r\nSince the number of missing values differs for every block (and every dbcache size), it may not make more sense to calculate the optimal split instead of using the random value of 128.\r\nCoroutines might alleviate this problem.",
      "created_at": "2024-10-23T12:10:35Z",
      "updated_at": "2024-10-23T13:37:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812604307",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812604307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 188,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812606720",
      "pull_request_review_id": 2388117544,
      "id": 1812606720,
      "node_id": "PRRC_kwDOABII585sCi8A",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));\n+                    buffer.clear();\n+                    buffer.reserve(m_batch_size);\n+                }\n+            }\n+            txids.insert(tx->GetHash());\n+        }\n+\n+        Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 197,
      "original_position": 197,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we always have leftovers or will this process the last batch twice (or process an empty one) if the batch happens to be divisible by batch_size?",
      "created_at": "2024-10-23T12:11:58Z",
      "updated_at": "2024-10-23T13:37:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812606720",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812606720"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 197,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812659221",
      "pull_request_review_id": 2388117544,
      "id": 1812659221,
      "node_id": "PRRC_kwDOABII585sCvwV",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're basically mimicking RocksDB's `MultiGet` here - but prewarming the cache instead in separate get requests, since we can't really access LevelDB's internals.\r\n\r\nSince splitting into buckets isn't trivial and since `MultiGet` seems to rely on C++20 [coroutines](https://en.cppreference.com/w/cpp/language/coroutines) (which wasn't available in 2012 when `CCheckQueue` was written), I'm wondering how much simpler this fetching would be if we had lightweight suspendible threads instead: https://rocksdb.org/blog/2022/10/07/asynchronous-io-in-rocksdb.html#multiget",
      "created_at": "2024-10-23T12:35:29Z",
      "updated_at": "2024-10-23T13:37:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812659221",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812659221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812779405",
      "pull_request_review_id": 2388734949,
      "id": 1812779405,
      "node_id": "PRRC_kwDOABII585sDNGN",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);",
      "path": "src/inputfetcher.h",
      "position": 73,
      "original_position": 73,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812534028,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is blocking so we can access the queue of shared outpoints that we need to fetch from. It is not blocking for LevelDB, we access the db once we are out of the critical section.",
      "created_at": "2024-10-23T13:34:07Z",
      "updated_at": "2024-10-23T13:34:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812779405",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812779405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812781136",
      "pull_request_review_id": 2388740849,
      "id": 1812781136,
      "node_id": "PRRC_kwDOABII585sDNhQ",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher",
      "path": "src/inputfetcher.h",
      "position": 29,
      "original_position": 29,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812548418,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, I can add these but I am waiting for some more conceptual support.",
      "created_at": "2024-10-23T13:35:04Z",
      "updated_at": "2024-10-23T13:35:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812781136",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812781136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 29,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812785573",
      "pull_request_review_id": 2388754731,
      "id": 1812785573,
      "node_id": "PRRC_kwDOABII585sDOml",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));\n+                    buffer.clear();\n+                    buffer.reserve(m_batch_size);\n+                }\n+            }\n+            txids.insert(tx->GetHash());\n+        }\n+\n+        Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 197,
      "original_position": 197,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812606720,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It won't process twice, but it could pass in an empty vector, which is ignored if you look at `Add` implementation.",
      "created_at": "2024-10-23T13:37:19Z",
      "updated_at": "2024-10-23T13:37:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812785573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812785573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 197,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812794214",
      "pull_request_review_id": 2388768186,
      "id": 1812794214,
      "node_id": "PRRC_kwDOABII585sDQtm",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it would be similar in complexity, we would still need all the locking mechanisms to prevent multithreaded access.\r\n\r\nWhat would really be great is if we had a similar construction to Rust's `std::sync::mpsc`.",
      "created_at": "2024-10-23T13:40:49Z",
      "updated_at": "2024-10-23T13:40:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812794214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812794214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812797796",
      "pull_request_review_id": 2388773991,
      "id": 1812797796,
      "node_id": "PRRC_kwDOABII585sDRlk",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {",
      "path": "src/inputfetcher.h",
      "position": 188,
      "original_position": 188,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812604307,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure it would warrant the complexity I think this batch size is \"good enough\" for now. In a follow up we could maybe add ways to set this with configs to experiment if there really is more optimal settings.",
      "created_at": "2024-10-23T13:42:02Z",
      "updated_at": "2024-10-23T13:42:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812797796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812797796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 188,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812800076",
      "pull_request_review_id": 2388778745,
      "id": 1812800076,
      "node_id": "PRRC_kwDOABII585sDSJM",
      "diff_hunk": "@@ -6243,6 +6248,7 @@ static ChainstateManager::Options&& Flatten(ChainstateManager::Options&& opts)\n \n ChainstateManager::ChainstateManager(const util::SignalInterrupt& interrupt, Options options, node::BlockManager::Options blockman_options)\n     : m_script_check_queue{/*batch_size=*/128, options.worker_threads_num},\n+      m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)},",
      "path": "src/validation.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812599960,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Adding more threads will require more memory, which is one reason to not use many more.\r\n\r\nI did a benchmark using 64 threads on the same 16 vcore machine, and it was slightly slower :/",
      "created_at": "2024-10-23T13:43:08Z",
      "updated_at": "2024-10-23T13:43:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812800076",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812800076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6257,
      "original_line": 6257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812807883",
      "pull_request_review_id": 2388792724,
      "id": 1812807883,
      "node_id": "PRRC_kwDOABII585sDUDL",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 189,
      "original_position": 189,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812531761,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think there is any lock contention here if we are doing multithreaded reading?\r\n\r\nI also think what you're suggesting would add a lot more complexity to this PR, when this is \"good enough\".",
      "created_at": "2024-10-23T13:46:50Z",
      "updated_at": "2024-10-23T13:46:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812807883",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812807883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812815888",
      "pull_request_review_id": 2388804635,
      "id": 1812815888,
      "node_id": "PRRC_kwDOABII585sDWAQ",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812440117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unsure, copied from `CScriptCheck`. If the state of the art of thread naming has advanced since that was written, please let me know!",
      "created_at": "2024-10-23T13:49:23Z",
      "updated_at": "2024-10-23T13:49:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812815888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812815888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812826580",
      "pull_request_review_id": 2388824311,
      "id": 1812826580,
      "node_id": "PRRC_kwDOABII585sDYnU",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812440117,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The C++ standard library does as far as I know have no way of renaming threads at all. `src/util/threadnames.{h,cpp}` is our wrapper around the various platform-dependent ways of doing so on supported systems.",
      "created_at": "2024-10-23T13:54:03Z",
      "updated_at": "2024-10-23T13:54:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812826580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812826580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812838378",
      "pull_request_review_id": 2388842458,
      "id": 1812838378,
      "node_id": "PRRC_kwDOABII585sDbfq",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you tell me why we need to prevent multithreaded access exactly? We could collect the values to different vectors, each one accessed only by a single thread and merge them into the cache at the end on a single thread, right?\r\n \r\n How would `mpsc` solve this better? Do you think we need work stealing to make it perfectly parallel? Wouldn't coroutines already achieve the same?",
      "created_at": "2024-10-23T13:58:56Z",
      "updated_at": "2024-10-23T13:58:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812838378",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812838378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812842053",
      "pull_request_review_id": 2388848761,
      "id": 1812842053,
      "node_id": "PRRC_kwDOABII585sDcZF",
      "diff_hunk": "@@ -6243,6 +6248,7 @@ static ChainstateManager::Options&& Flatten(ChainstateManager::Options&& opts)\n \n ChainstateManager::ChainstateManager(const util::SignalInterrupt& interrupt, Options options, node::BlockManager::Options blockman_options)\n     : m_script_check_queue{/*batch_size=*/128, options.worker_threads_num},\n+      m_input_fetcher{/*batch_size=*/128, static_cast<size_t>(options.worker_threads_num)},",
      "path": "src/validation.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812599960,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4x may be too much to begin with, but 1.5-2x sounds plausible, I'll help with benchmarking this once my current batches finish.",
      "created_at": "2024-10-23T14:00:53Z",
      "updated_at": "2024-10-23T14:00:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812842053",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812842053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 6257,
      "original_line": 6257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812845859",
      "pull_request_review_id": 2388855957,
      "id": 1812845859,
      "node_id": "PRRC_kwDOABII585sDdUj",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 189,
      "original_position": 189,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812531761,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This might be as simple as sorting by tx before we create the buckets.",
      "created_at": "2024-10-23T14:02:34Z",
      "updated_at": "2024-10-23T14:02:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812845859",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812845859"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812849403",
      "pull_request_review_id": 2388859978,
      "id": 1812849403,
      "node_id": "PRRC_kwDOABII585sDeL7",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));",
      "path": "src/inputfetcher.h",
      "position": 151,
      "original_position": 151,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812440117,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thank you, please resolve the comment.",
      "created_at": "2024-10-23T14:03:52Z",
      "updated_at": "2024-10-23T14:03:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812849403",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812849403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812852143",
      "pull_request_review_id": 2388864249,
      "id": 1812852143,
      "node_id": "PRRC_kwDOABII585sDe2v",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);",
      "path": "src/inputfetcher.h",
      "position": 73,
      "original_position": 73,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812534028,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As mentioned before, why do we need shared outpoints here?",
      "created_at": "2024-10-23T14:04:56Z",
      "updated_at": "2024-10-23T14:04:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812852143",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812852143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812858116",
      "pull_request_review_id": 2388874771,
      "id": 1812858116,
      "node_id": "PRRC_kwDOABII585sDgUE",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I haven't yet experimented with them, but as far as I understand it, coroutines are just programming paradigm, not magic; they don't do anything of their own, besides making things that were already possible easier to write. In particular, you still need a thread pool or some mechanism for scheduling how to run them,",
      "created_at": "2024-10-23T14:07:08Z",
      "updated_at": "2024-10-23T14:07:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812858116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812858116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812862679",
      "pull_request_review_id": 2388882032,
      "id": 1812862679,
      "node_id": "PRRC_kwDOABII585sDhbX",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> We could collect the values to different vectors, each one accessed only by a single thread and merge them into the cache at the end on a single thread\r\n\r\nIf the vectors are thread local, then how can the main thread access them at the end to write them? We also want to be writing throughout while the workers are fetching, not just at the end.\r\n\r\n> How would mpsc solve this better?\r\n\r\nInstead of each worker thread having a local queue of results, which they then append to the global results queue, they could just push each result to the channel individually. The main thread could just pull results off the channel as they arrive, instead of waiting to be awoken by a worker thread that appended all its results to the global queue.\r\n\r\n> work stealing\r\n\r\nThat is a concept for async rust, or `std::async::mpsc`. We can do all this without introducing an async runtime. But, this is getting off topic.",
      "created_at": "2024-10-23T14:09:31Z",
      "updated_at": "2024-10-23T14:09:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812862679",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812862679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812869347",
      "pull_request_review_id": 2388892235,
      "id": 1812869347,
      "node_id": "PRRC_kwDOABII585sDjDj",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);\n+                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n+                // in_flight_fetches_count will only be truthy after first run.\n+                if (in_flight_fetches_count) {\n+                    if (m_pairs.empty()) {\n+                        m_pairs = std::move(pairs);\n+                    } else {\n+                        m_pairs.reserve(m_pairs.size() + pairs.size());\n+                        m_pairs.insert(m_pairs.end(), std::make_move_iterator(pairs.begin()),\n+                                       std::make_move_iterator(pairs.end()));\n+                    }\n+                    m_in_flight_fetches_count -= in_flight_fetches_count;\n+                    m_main_cv.notify_one();\n+                }\n+\n+                // logically, the do loop starts here\n+                while (m_outpoints.empty() && !m_request_stop) {\n+                    m_worker_cv.wait(lock);\n+                }\n+                if (m_request_stop) {\n+                    return;\n+                }\n+\n+                const auto even_bucket{m_in_flight_fetches_count / m_worker_threads.size()};\n+                in_flight_fetches_count = std::max(static_cast<size_t>(1),\n+                                                   std::min(std::min(m_outpoints.size(), m_batch_size), even_bucket));\n+                auto start_it = m_outpoints.end() - in_flight_fetches_count;\n+                outpoints.assign(std::make_move_iterator(start_it), std::make_move_iterator(m_outpoints.end()));\n+                m_outpoints.erase(start_it, m_outpoints.end());\n+            }\n+\n+            pairs.clear();\n+            pairs.reserve(outpoints.size());\n+            for (COutPoint& outpoint : outpoints) {\n+                Coin coin;\n+                if (!m_db->GetCoin(outpoint, coin)) {\n+                    // Missing an input, just break. This block will fail validation, so no point in continuing.\n+                    break;\n+                }\n+                pairs.emplace_back(std::move(outpoint), std::move(coin));\n+            }\n+        } while (true);\n+    }\n+\n+    //! Add a batch of outpoints to the queue\n+    void Add(std::vector<COutPoint>&& outpoints) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        if (outpoints.empty()) {\n+            return;\n+        }\n+\n+        const auto size{outpoints.size()};\n+        {\n+            LOCK(m_mutex);\n+            m_in_flight_fetches_count += outpoints.size();\n+            if (m_outpoints.empty()) {\n+                m_outpoints = std::move(outpoints);\n+            } else {\n+                m_outpoints.insert(m_outpoints.end(), std::make_move_iterator(outpoints.begin()), std::make_move_iterator(outpoints.end()));\n+            }\n+        }\n+\n+        if (size == 1) {\n+            m_worker_cv.notify_one();\n+        } else {\n+            m_worker_cv.notify_all();\n+        }\n+    }\n+\n+\n+public:\n+    //! Create a new input fetcher\n+    explicit InputFetcher(size_t batch_size, size_t worker_thread_count) noexcept\n+        : m_batch_size(batch_size)\n+    {\n+        m_worker_threads.reserve(worker_thread_count);\n+        for (size_t n = 0; n < worker_thread_count; ++n) {\n+            m_worker_threads.emplace_back([this, n]() {\n+                util::ThreadRename(strprintf(\"inputfetch.%i\", n));\n+                Loop();\n+            });\n+        }\n+    }\n+\n+    // Since this class manages its own resources, which is a thread\n+    // pool `m_worker_threads`, copy and move operations are not appropriate.\n+    InputFetcher(const InputFetcher&) = delete;\n+    InputFetcher& operator=(const InputFetcher&) = delete;\n+    InputFetcher(InputFetcher&&) = delete;\n+    InputFetcher& operator=(InputFetcher&&) = delete;\n+\n+\n+    //! Fetch all block inputs from db, and insert into cache.\n+    void FetchInputs(CCoinsViewCache& cache, const CCoinsViewDB& db, const CBlock& block) noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        m_db = &db;\n+\n+        std::vector<COutPoint> buffer{};\n+        buffer.reserve(m_batch_size);\n+        std::set<Txid> txids{};\n+        for (const auto& tx : block.vtx) {\n+            if (tx->IsCoinBase()) continue;\n+            for (const auto& in : tx->vin) {\n+                const auto& outpoint = in.prevout;\n+                // If an input references an outpoint from earlier in the\n+                // block, it won't be in the cache yet but it also won't be\n+                // in the db either.\n+                if (txids.contains(outpoint.hash)) {\n+                    continue;\n+                }\n+                if (cache.HaveCoinInCache(outpoint)) {\n+                    continue;\n+                }\n+\n+                buffer.emplace_back(outpoint);\n+                if (buffer.size() == m_batch_size) {\n+                    Add(std::move(buffer));",
      "path": "src/inputfetcher.h",
      "position": 189,
      "original_position": 189,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812531761,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If a benchmark shows that it is better, then great!",
      "created_at": "2024-10-23T14:12:37Z",
      "updated_at": "2024-10-23T14:17:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812869347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812869347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 189,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812874933",
      "pull_request_review_id": 2388902089,
      "id": 1812874933,
      "node_id": "PRRC_kwDOABII585sDka1",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        size_t in_flight_fetches_count{0};\n+        std::vector<std::pair<COutPoint, Coin>> pairs{};\n+        do {\n+            std::vector<COutPoint> outpoints{};\n+            outpoints.reserve(m_batch_size);\n+            {\n+                WAIT_LOCK(m_mutex, lock);",
      "path": "src/inputfetcher.h",
      "position": 73,
      "original_position": 73,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812534028,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The main thread adds all outpoints to a global vector, which all workers will fetch their work from.",
      "created_at": "2024-10-23T14:15:35Z",
      "updated_at": "2024-10-23T14:17:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1812874933",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1812874933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1813017536",
      "pull_request_review_id": 2389159040,
      "id": 1813017536,
      "node_id": "PRRC_kwDOABII585sEHPA",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> coroutines are just programming paradigm, not magic\r\n\r\nThat's also what I was counting on! :D\r\n\r\nIn RocksDB they have [high and low priority work](https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide#parallelism-options) (I assume that's just added to the front or the back of a background work deque) â€“ this could align well with @furszy's suggestion for mixing different kinds of background work units.\r\n\r\nI haven't used the C++ variant of coroutines either, but my thinking was that since they can theoretically yield execution when waiting for IO (and resume later), this would allow threads to focus on other tasks in the meantime. Combined with an appropriate scheduling mechanism (such as a thread pool), we could maximize both CPU and IO usage, if I'm not mistaken.\r\nInstead of each thread handling just one task, it could suspend a coroutine while waiting on IO (e.g., a database fetch) and resume it later, effectively maximizing CPU and IO work without needing to know the exact details of the work.\r\n\r\n> If the vectors are thread local\r\n\r\nThe vector would still be global, but each thread would only access a single bucket (i.e. global vector of vectors, with each thread from the pool writing only to `vector[thread_id]`, which contains a vector of fetched coins).\r\nWhen all the work is finished, we'd iterate over the global vector and merge the results into the cache on a single thread.\r\nAs mentioned, sorting the outpoints before fetching could help improve data locality and reduce lock contention, and the coroutines above would help with work stealing, ensuring that all threads finish roughly at the same time.\r\n\r\nIs there anything prohibiting us from doing something like this to minimize synchronization and lock contention during the fetch phase? I understand some synchronization would still be needed during the merge, but this could help reduce global locks and unnecessary synchronization throughout the process.\r\n",
      "created_at": "2024-10-23T15:15:39Z",
      "updated_at": "2024-10-23T15:18:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1813017536",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1813017536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1813041419",
      "pull_request_review_id": 2389202333,
      "id": 1813041419,
      "node_id": "PRRC_kwDOABII585sENEL",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INPUTFETCHER_H\n+#define BITCOIN_INPUTFETCHER_H\n+\n+#include <coins.h>\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <txdb.h>\n+#include <util/threadnames.h>\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <set>\n+#include <vector>\n+\n+/**\n+ * Input fetcher for fetching inputs from the CoinsDB and inserting\n+ * into the CoinsTip.\n+ *\n+ * The main thread pushes batches of outpoints\n+ * onto the queue, where they are fetched by N worker threads. The resulting\n+ * coins are pushed onto another queue after they are read from disk. When\n+ * the main is done adding outpoints, it starts writing the results of the read\n+ * queue to the cache.\n+ */\n+class InputFetcher\n+{\n+private:\n+    //! Mutex to protect the inner state\n+    Mutex m_mutex{};\n+\n+    //! Worker threads block on this when out of work\n+    std::condition_variable m_worker_cv{};\n+\n+    //! Main thread blocks on this when out of work\n+    std::condition_variable m_main_cv{};\n+\n+    //! The queue of outpoints to be fetched from disk.\n+    //! As the order of outpoints doesn't matter, it is used as a LIFO (stack)\n+    std::vector<COutPoint> m_outpoints GUARDED_BY(m_mutex){};\n+\n+    //! The queue of pairs to be written to the cache.\n+    std::vector<std::pair<COutPoint, Coin>> m_pairs GUARDED_BY(m_mutex){};\n+\n+    /**\n+     * Number of outpoint fetches that haven't completed yet.\n+     * This includes outpoints that are no longer queued, but still in the\n+     * worker's own batches.\n+     */\n+    size_t m_in_flight_fetches_count GUARDED_BY(m_mutex){0};\n+\n+    //! The maximum number of outpoints to be processed in one batch\n+    const size_t m_batch_size;\n+\n+    //! DB to fetch from.\n+    const CCoinsViewDB* m_db{nullptr};\n+\n+    std::vector<std::thread> m_worker_threads;\n+    bool m_request_stop GUARDED_BY(m_mutex){false};\n+\n+    /** Internal function that does the fetching from disk. */\n+    void Loop() noexcept EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/inputfetcher.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "942f3006fcc85be70fb174c99b73e7b9022cfcdb",
      "original_commit_id": "e9e23b59f8eedb8dfae75aa660328299fba92b50",
      "in_reply_to_id": 1812659221,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I haven't used the C++ variant of coroutines either, but my thinking was that since they can theoretically yield execution when waiting for IO (and resume later), this would allow threads to focus on other tasks in the meantime.\r\n\r\nThat needs async I/O, and is unrelated to coroutines, as far as I understand it. Coroutines just help with keeping track of what to do when the reads come back inside rocksdb.\r\n\r\nAs long as LevelDB (or whatever database engine we use) internally does not use async I/O, there will be one (waiting) thread per parallel outstanding read request from the database.",
      "created_at": "2024-10-23T15:28:19Z",
      "updated_at": "2024-10-23T15:28:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31132#discussion_r1813041419",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1813041419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31132"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    }
  ]
}