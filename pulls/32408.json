{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408",
    "id": 2496221599,
    "node_id": "PR_kwDOABII586UyVGf",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/32408",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/32408.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/32408.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/f16c8c67bf137e64fbeea1242431baaa915a5c53",
    "number": 32408,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "tests: Expand HTTP coverage to assert libevent behavior",
    "user": {
      "login": "pinheadmz",
      "id": 2084648,
      "node_id": "MDQ6VXNlcjIwODQ2NDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pinheadmz",
      "html_url": "https://github.com/pinheadmz",
      "followers_url": "https://api.github.com/users/pinheadmz/followers",
      "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
      "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
      "repos_url": "https://api.github.com/users/pinheadmz/repos",
      "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "These commits are cherry-picked from #32061  and part of a project to [remove libevent](https://github.com/bitcoin/bitcoin/issues/31194).\r\n\r\nThis PR only adds functional tests to `interface_http` to cover some HTTP server behaviors we inherit from libevent, in order to maintain those behaviors when we replace libevent with our own HTTP server.\r\n\r\n1. Pipelining: The server must respond to requests from a client in the order in which they were received [RFC 7230 6.3.2](https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2)\r\n2. `-rpcservertimeout` config option which sets the amount of time the server will keep an idle client connection alive\r\n3. \"Chunked\" Transfer-Encoding: Allows a client to send a request in pieces, without the `Content-Length` header [RFC 7230 4.1](https://www.rfc-editor.org/rfc/rfc7230#section-4.1) ",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2025-05-02T18:56:14Z",
    "updated_at": "2025-06-09T19:50:51Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "a035043155f4f941410f44cdb96783c010880036",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "pinheadmz:http-tests",
      "ref": "http-tests",
      "sha": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 61248407,
        "node_id": "MDEwOlJlcG9zaXRvcnk2MTI0ODQwNw==",
        "name": "bitcoin",
        "full_name": "pinheadmz/bitcoin",
        "owner": {
          "login": "pinheadmz",
          "id": 2084648,
          "node_id": "MDQ6VXNlcjIwODQ2NDg=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/pinheadmz",
          "html_url": "https://github.com/pinheadmz",
          "followers_url": "https://api.github.com/users/pinheadmz/followers",
          "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
          "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
          "repos_url": "https://api.github.com/users/pinheadmz/repos",
          "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/pinheadmz/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/pinheadmz/bitcoin",
        "archive_url": "https://api.github.com/repos/pinheadmz/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/pinheadmz/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/pinheadmz/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/pinheadmz/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/pinheadmz/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/pinheadmz/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/pinheadmz/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/pinheadmz/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/pinheadmz/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/pinheadmz/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/pinheadmz/bitcoin/events",
        "forks_url": "https://api.github.com/repos/pinheadmz/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/pinheadmz/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/pinheadmz/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/pinheadmz/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/pinheadmz/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/pinheadmz/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/pinheadmz/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/pinheadmz/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/pinheadmz/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/pinheadmz/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/pinheadmz/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:pinheadmz/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/pinheadmz/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/pinheadmz/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/pinheadmz/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/pinheadmz/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/pinheadmz/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/pinheadmz/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/pinheadmz/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/pinheadmz/bitcoin/hooks",
        "svn_url": "https://github.com/pinheadmz/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 272751,
        "default_branch": "master2",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-05-21T14:47:35Z",
        "created_at": "2016-06-15T23:48:20Z",
        "updated_at": "2025-03-15T13:15:10Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "87ec923d3a7af7b30613174b41c6fb11671df466",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37332,
        "stargazers_count": 84049,
        "watchers_count": 84049,
        "size": 283531,
        "default_branch": "master",
        "open_issues_count": 752,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-06-09T15:27:02Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-06-09T19:50:54Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 139,
    "deletions": 0,
    "changed_files": 3,
    "commits": 1,
    "review_comments": 35,
    "comments": 5
  },
  "events": [
    {
      "event": "commented",
      "id": 2847888981,
      "node_id": "IC_kwDOABII586pv1ZV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2847888981",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-02T18:56:17Z",
      "updated_at": "2025-06-09T19:50:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32408.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2860441380), [polespinasa](https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2893647989), [fjahr](https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2894320133), [achow101](https://github.com/bitcoin/bitcoin/pull/32408#issuecomment-2956842297) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#issuecomment-2847888981",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408"
    },
    {
      "event": "labeled",
      "id": 17503663874,
      "node_id": "LE_lADOABII5860_2wnzwAAAAQTTLcC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17503663874",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-02T18:56:29Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "labeled",
      "id": 17504512492,
      "node_id": "LE_lADOABII5860_2wnzwAAAAQTWans",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17504512492",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-02T20:23:56Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2813454772,
      "node_id": "PRR_kwDOABII586nsem0",
      "url": null,
      "actor": null,
      "commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2813454772",
      "submitted_at": "2025-05-04T12:33:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "reviewed",
      "id": 2822108438,
      "node_id": "PRR_kwDOABII586oNfUW",
      "url": null,
      "actor": null,
      "commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2822108438",
      "submitted_at": "2025-05-07T14:54:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17575259084,
      "node_id": "HRFPE_lADOABII5860_2wnzwAAAAQXkSvM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17575259084",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "abe94200fd71dbe64461437d1c9948ed135ebdfc",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/abe94200fd71dbe64461437d1c9948ed135ebdfc",
      "created_at": "2025-05-08T14:37:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17576534111,
      "node_id": "HRFPE_lADOABII5860_2wnzwAAAAQXpKBf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17576534111",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "840dd5b6eb0b2c1f35a91c36acac5d97933172dc",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/840dd5b6eb0b2c1f35a91c36acac5d97933172dc",
      "created_at": "2025-05-08T15:51:12Z"
    },
    {
      "event": "unlabeled",
      "id": 17578840883,
      "node_id": "UNLE_lADOABII5860_2wnzwAAAAQXx9Mz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17578840883",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-08T18:38:03Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2827256478,
      "node_id": "PRR_kwDOABII586ohIKe",
      "url": null,
      "actor": null,
      "commit_id": "840dd5b6eb0b2c1f35a91c36acac5d97933172dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2827256478",
      "submitted_at": "2025-05-09T07:16:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "reviewed",
      "id": 2827278739,
      "node_id": "PRR_kwDOABII586ohNmT",
      "url": null,
      "actor": null,
      "commit_id": "840dd5b6eb0b2c1f35a91c36acac5d97933172dc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "tACK 840dd5b6eb0b2c1f35a91c36acac5d97933172dc\r\n\r\nMaybe the three commits could be squashed?",
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2827278739",
      "submitted_at": "2025-05-09T07:22:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17590884499,
      "node_id": "HRFPE_lADOABII5860_2wnzwAAAAQYf5iT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17590884499",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/95d47449b2c069fca9859d76b2c3766868b5ec79",
      "created_at": "2025-05-09T13:09:46Z"
    },
    {
      "event": "commented",
      "id": 2866480355,
      "node_id": "IC_kwDOABII586q2wTj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2866480355",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-09T13:10:00Z",
      "updated_at": "2025-05-09T13:10:00Z",
      "author_association": "MEMBER",
      "body": "> Maybe the three commits could be squashed?\r\n\r\nDone! thanks for reviewing",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#issuecomment-2866480355",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408"
    },
    {
      "event": "commented",
      "id": 2890931358,
      "node_id": "IC_kwDOABII586sUBye",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2890931358",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-19T13:00:30Z",
      "updated_at": "2025-05-19T13:00:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#issuecomment-2890931358",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408"
    },
    {
      "event": "reviewed",
      "id": 2854214850,
      "node_id": "PRR_kwDOABII586qH9zC",
      "url": null,
      "actor": null,
      "commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK 95d47449b2c069fca9859d76b2c3766868b5ec79\r\n\r\nCopied my review comments from https://github.com/bitcoin/bitcoin/pull/32061",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2854214850",
      "submitted_at": "2025-05-20T13:39:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYxNmM4YzY3YmYxMzdlNjRmYmVlYTEyNDI0MzFiYWFhOTE1YTVjNTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "tree": {
        "sha": "9b82804fe907e46ebd381f0b23dabf8998f7f5c3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b82804fe907e46ebd381f0b23dabf8998f7f5c3"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9b82804fe907e46ebd381f0b23dabf8998f7f5c3\nparent 5b8046a6e893b7fad5a93631e6d1e70db31878af\nauthor Matthew Zipkin <pinheadmz@pm.me> 1743623206 -0400\ncommitter Matthew Zipkin <pinheadmz@pm.me> 1747838843 -0400\n\ntests: Expand HTTP coverage to assert libevent behavior\n\nCovers:\n- http pipelining\n- rpcservertimeout\n\n  Testing this requires adding an option to TestNode to force\n  the test framework to establish a new HTTP connection for\n  every RPC. Otherwise, attempting to reuse a persistent connection\n  would cause framework RPCs during startup and shutdown to fail.\n\n- \"chunked\" Transfer-Encoding\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmgt530ACgkQ5+KYS2KJ\nyTqHfBAAmHMqudme9gN4jr6i05X6dcVhZxcIuWDGIDEbJCVY5dVH6bTX33ksOoPU\nKSk8e2LV1vinxdzhVgRz3+k+XviDD1Lxuzjggy5QcW0UPurS2P1HOdggzFH2T0Su\n6YF6E4AhkskPMLCG3XL8X2yLVc/a3bHAffZD9WOcPPEb7eXdPEb3fsdOJCXUpxEZ\nPeCB6lrXV0wazDe/EFmFFMu+9JaHnhpFxQoKPZi+gnb3iuFbu4M3pr0PqqIoThzS\nWOrsGFoM63eC93ugqSh8Ke2LBEPr30zJjrzkn472TrdYDpkm5Yk+0lfkO6Ws12E0\nDXYey6eZhq0XIQQ7jIM/n8x0/K0GzN0PHAXQOOiisW5A++w/OagSxsNKe92M4oCe\nT9tCIuX3VjfSl2kG61Woq9FP7IrAAj67/BA2TxtagnfnV4JR5oLccMzQtRVo/pLP\nzAaFtFuxLFczOK/FfP8IgQDSf88BevFf7hgqj6D2bTKfPc47C9mC1Q2PY74GHN9O\nV9CbMViRTaNoyAVbv1uQQJrJCCqarJvG/aCs6SnmTymRSOhOhC9oSxBtfSJTvkYE\njBIORso3Wsh3p0R8eXRbNXNH3oxCaSRmGJYC5On41/+eXOj2SO2fUiOmcn5ol610\nFG6IDrdM9MDTC5A4gjnLixfk9cV5ov66FUbzKc1J65Utn45sgjU=\n=COBH\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5b8046a6e893b7fad5a93631e6d1e70db31878af",
          "sha": "5b8046a6e893b7fad5a93631e6d1e70db31878af",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5b8046a6e893b7fad5a93631e6d1e70db31878af"
        }
      ],
      "message": "tests: Expand HTTP coverage to assert libevent behavior\n\nCovers:\n- http pipelining\n- rpcservertimeout\n\n  Testing this requires adding an option to TestNode to force\n  the test framework to establish a new HTTP connection for\n  every RPC. Otherwise, attempting to reuse a persistent connection\n  would cause framework RPCs during startup and shutdown to fail.\n\n- \"chunked\" Transfer-Encoding",
      "committer": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-05-21T14:47:23Z"
      },
      "author": {
        "name": "Matthew Zipkin",
        "email": "pinheadmz@pm.me",
        "date": "2025-04-02T19:46:46Z"
      },
      "sha": "f16c8c67bf137e64fbeea1242431baaa915a5c53"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17755435720,
      "node_id": "HRFPE_lADOABII5860_2wnzwAAAAQiTnLI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17755435720",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "commit_url": "https://api.github.com/repos/pinheadmz/bitcoin/commits/f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "created_at": "2025-05-21T14:47:36Z"
    },
    {
      "event": "reviewed",
      "id": 2858010430,
      "node_id": "PRR_kwDOABII586qWcc-",
      "url": null,
      "actor": null,
      "commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "rebase to f16c8c67bf to address comments, not touching the `rpcservertimeout` test just yet, discussion still ongoing",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2858010430",
      "submitted_at": "2025-05-21T14:48:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "reviewed",
      "id": 2860441380,
      "node_id": "PRR_kwDOABII586qft8k",
      "url": null,
      "actor": null,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK f16c8c67bf137e64fbeea1242431baaa915a5c53\r\n\r\nMaybe the check for the timeout can be improved, ongoing discussion at https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2077834027 (non-blocker IMO)",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2860441380",
      "submitted_at": "2025-05-22T09:17:00Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "review_requested",
      "id": 17768339151,
      "node_id": "RRE_lADOABII5860_2wnzwAAAAQjE1bP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17768339151",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-22T09:17:04Z",
      "requested_reviewer": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 17768339311,
      "node_id": "RRE_lADOABII5860_2wnzwAAAAQjE1dv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17768339311",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-22T09:17:04Z",
      "requested_reviewer": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 2935446085,
      "node_id": "IC_kwDOABII586u91pF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2935446085",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-03T14:09:06Z",
      "updated_at": "2025-06-03T14:09:06Z",
      "author_association": "MEMBER",
      "body": "Friendly ping @fjahr  and @polespinasa for reviewing some HTTP tests ? <3",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#issuecomment-2935446085",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408"
    },
    {
      "event": "mentioned",
      "id": 17959416405,
      "node_id": "MEE_lADOABII5860_2wnzwAAAAQudvJV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17959416405",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-03T14:09:08Z"
    },
    {
      "event": "subscribed",
      "id": 17959416439,
      "node_id": "SE_lADOABII5860_2wnzwAAAAQudvJ3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17959416439",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-03T14:09:08Z"
    },
    {
      "event": "mentioned",
      "id": 17959416475,
      "node_id": "MEE_lADOABII5860_2wnzwAAAAQudvKb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17959416475",
      "actor": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-03T14:09:08Z"
    },
    {
      "event": "subscribed",
      "id": 17959416506,
      "node_id": "SE_lADOABII5860_2wnzwAAAAQudvK6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17959416506",
      "actor": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-03T14:09:08Z"
    },
    {
      "event": "reviewed",
      "id": 2893647989,
      "node_id": "PRR_kwDOABII586seZB1",
      "url": null,
      "actor": null,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "LGTM friendly acknowledging this PR :)\r\nACK f16c8c67bf137e64fbeea1242431baaa915a5c53\r\n\r\nAgree on the 5sec timeout change, we avoid weird errors if the CI is lazy.\r\n\r\nI locally rebased this on top of master (e872a566f251c73908de8b6d243c94a6679c2eac) to make sure there aren't silent merging conflicts that make the test fail. It works correctly :)",
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2893647989",
      "submitted_at": "2025-06-03T18:31:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "reviewed",
      "id": 2894320133,
      "node_id": "PRR_kwDOABII586sg9IF",
      "url": null,
      "actor": null,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "utACK f16c8c67bf137e64fbeea1242431baaa915a5c53\r\n\r\nLooks good to me, I would consider my comments non-blocking and could potentially be addressed in a follow-up.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#pullrequestreview-2894320133",
      "submitted_at": "2025-06-03T23:11:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
    },
    {
      "event": "commented",
      "id": 2956842297,
      "node_id": "IC_kwDOABII586wPdU5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2956842297",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-09T19:50:48Z",
      "updated_at": "2025-06-09T19:50:48Z",
      "author_association": "MEMBER",
      "body": "ACK f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#issuecomment-2956842297",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32408"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072606185",
      "pull_request_review_id": 2813454772,
      "id": 2072606185,
      "node_id": "PRRC_kwDOABII5857iXXp",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        assert res == b\"\"\n+        assert stop - start >= 1",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 113,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\r\nhttps://cirrus-ci.com/task/5276299050090496?logs=ci#L3261:\r\n\r\n```\r\n[15:13:21.244]  node2 2025-05-02T19:13:19.879966Z [httpworker.4] [rpc/request.cpp:241] [parse] [rpc] ThreadRPCServer method=getmempoolinfo user=__cookie__ \r\n[15:13:21.244]  test  2025-05-02T19:13:19.882000Z TestFramework.node2 (DEBUG): RPC successfully started \r\n[15:13:21.244]  test  2025-05-02T19:13:20.885000Z TestFramework (ERROR): Assertion failed \r\n[15:13:21.244]                                    Traceback (most recent call last):\r\n[15:13:21.244]                                      File \"/ci_container_base/test/functional/test_framework/test_framework.py\", line 183, in main\r\n[15:13:21.244]                                        self.run_test()\r\n[15:13:21.244]                                      File \"/ci_container_base/ci/scratch/build-x86_64-pc-linux-gnu/test/functional/interface_http.py\", line 210, in run_test\r\n[15:13:21.244]                                        assert stop - start >= 1\r\n[15:13:21.244]                                               ^^^^^^^^^^^^^^^^^\r\n[15:13:21.244]                                    AssertionError",
      "created_at": "2025-05-04T12:32:37Z",
      "updated_at": "2025-05-04T12:33:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2072606185",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072606185"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072612696",
      "pull_request_review_id": 2813461396,
      "id": 2072612696,
      "node_id": "PRRC_kwDOABII5857iY9Y",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        assert res == b\"\"\n+        assert stop - start >= 1",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 113,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2072606185,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yeah i see it -- gotta figure out why `sock.recv(1024)` is non blocking on the two failing platforms",
      "created_at": "2025-05-04T13:00:42Z",
      "updated_at": "2025-05-04T13:00:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2072612696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2072612696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2077834027",
      "pull_request_review_id": 2822108438,
      "id": 2077834027,
      "node_id": "PRRC_kwDOABII58572Tsr",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": null,
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "~~If you move the `start = time.time()` before sending the test passes correctly.~~\r\n\r\n~~CI was failing locally on my laptop. After changing this it does work.~~\r\n\r\nNote: it was just working on some executions",
      "created_at": "2025-05-07T14:54:35Z",
      "updated_at": "2025-05-07T15:09:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2077834027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2077834027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2080431221",
      "pull_request_review_id": 2826311134,
      "id": 2080431221,
      "node_id": "PRRC_kwDOABII5858ANx1",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I noticed in the libevent's test they don't actually check that server waited at all, just that the connection closed within a few seconds of the configured time out. So I went that route, but also added a tiny minimum check just to make sure the server isn't closing immediately. And this gives us better test reliability.\r\n\r\nSo the new test is: `-rpcservertimeout=2`, we send a request, we time how long it takes to close, and that duration is expected to be between 1 and 4 seconds.",
      "created_at": "2025-05-08T20:38:37Z",
      "updated_at": "2025-05-08T20:38:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2080431221",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2080431221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081079062",
      "pull_request_review_id": 2827256478,
      "id": 2081079062,
      "node_id": "PRRC_kwDOABII5858Cr8W",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:",
      "path": "test/functional/interface_http.py",
      "position": 44,
      "original_position": 44,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "840dd5b6eb0b2c1f35a91c36acac5d97933172dc",
      "in_reply_to_id": null,
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure about this but shouldn't this be `socket.timeout`? As we're using `sock.recv` and not `getresponse()`?",
      "created_at": "2025-05-09T07:16:44Z",
      "updated_at": "2025-05-09T07:16:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2081079062",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081079062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081097699",
      "pull_request_review_id": 2827292967,
      "id": 2081097699,
      "node_id": "PRRC_kwDOABII5858Cwfj",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If the timeout is set to 2 wouldn't make more sense to test between 2 and 4 seconds? Can it be less than 2 seconds?",
      "created_at": "2025-05-09T07:26:34Z",
      "updated_at": "2025-05-09T07:26:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2081097699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081097699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081584805",
      "pull_request_review_id": 2828157954,
      "id": 2081584805,
      "node_id": "PRRC_kwDOABII5858Enal",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It can be, and that was why the 1 second timeout check kept failing. I tried a few implementations of the test and it's just impossible to reliably start the test timer in sync with the HTTP server. So sometimes it starts late and you end up with `duration < expected`.\r\n\r\nThe point of the test is to ensure that the server disconnects idle clients, I think it does that even though the exact time is a little fudged.",
      "created_at": "2025-05-09T12:38:19Z",
      "updated_at": "2025-05-09T12:38:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2081584805",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081584805"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081628843",
      "pull_request_review_id": 2828234063,
      "id": 2081628843,
      "node_id": "PRRC_kwDOABII5858EyKr",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:",
      "path": "test/functional/interface_http.py",
      "position": 44,
      "original_position": 44,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "840dd5b6eb0b2c1f35a91c36acac5d97933172dc",
      "in_reply_to_id": 2081079062,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Great catch! I found [this:](https://docs.python.org/3/library/socket.html#socket.timeout)\r\n\r\n> `exception socket.timeout`\r\n> A deprecated alias of [TimeoutError](https://docs.python.org/3/library/exceptions.html#TimeoutError).\r\n> Changed in version 3.10: This class was made an alias of [TimeoutError](https://docs.python.org/3/library/exceptions.html#TimeoutError).\r\n\r\nSince Python 3.10 is minimum version required in dependencies.md (and the test passes!) I think it's ok to leave as-is",
      "created_at": "2025-05-09T13:06:25Z",
      "updated_at": "2025-05-09T13:06:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2081628843",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2081628843"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 141,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097988275",
      "pull_request_review_id": 2854214850,
      "id": 2097988275,
      "node_id": "PRRC_kwDOABII5859DMKz",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=2\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        # Server disconnected with EOF\n+        assert res == b\"\"\n+        # Server disconnected within an acceptable range of time:\n+        # not immediately, and not too far over the configured duration.\n+        # This allows for some jitter in the test between client and server.\n+        duration = stop - start\n+        assert duration <= 4, f\"Server disconnected too slow: {duration} > 4\"\n+        assert duration >= 1, f\"Server disconnected too fast: {duration} < 1\"",
      "path": "test/functional/interface_http.py",
      "position": 119,
      "original_position": 119,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That should be 2, I guess since the timeout is set to 2. E.g. disconnecting after 1.5 seconds is unexpected and should be treated as an error.\r\n\r\n```diff\r\ndiff --git i/test/functional/interface_http.py w/test/functional/interface_http.py\r\nindex 4f10b55afd..9c345c30b9 100755\r\n--- i/test/functional/interface_http.py\r\n+++ w/test/functional/interface_http.py\r\n@@ -185,13 +185,14 @@ class HTTPBasicsTest (BitcoinTestFramework):\r\n         # so low on this one node, its connection will quickly timeout and get dropped by\r\n         # the server. Negating this setting will force the AuthServiceProxy\r\n         # for this node to create a fresh new HTTP connection for every command\r\n         # called for the remainder of this test.\r\n         self.nodes[2].reuse_http_connections = False\r\n \r\n-        self.restart_node(2, extra_args=[\"-rpcservertimeout=2\"])\r\n+        rpcservertimeout = 2\r\n+        self.restart_node(2, extra_args=[f\"-rpcservertimeout={rpcservertimeout}\"])\r\n         # This is the amount of time the server will wait for a client to\r\n         # send a complete request. Test it by sending an incomplete but\r\n         # so-far otherwise well-formed HTTP request, and never finishing it.\r\n \r\n         # Copied from http_incomplete_test_() in regress_http.c in libevent.\r\n         # A complete request would have an additional \"\\r\\n\" at the end.\r\n@@ -199,24 +200,24 @@ class HTTPBasicsTest (BitcoinTestFramework):\r\n \r\n         # Get the underlying socket from HTTP connection so we can send something unusual\r\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\r\n         conn.connect()\r\n         sock = conn.sock\r\n         sock.sendall(http_request.encode(\"utf-8\"))\r\n-        # Wait for response, but expect a timeout disconnection after 1 second\r\n+        # Wait for response, but expect a timeout disconnection after `rpcservertimeout` seconds\r\n         start = time.time()\r\n         res = sock.recv(1024)\r\n         stop = time.time()\r\n         # Server disconnected with EOF\r\n         assert res == b\"\"\r\n         # Server disconnected within an acceptable range of time:\r\n         # not immediately, and not too far over the configured duration.\r\n         # This allows for some jitter in the test between client and server.\r\n         duration = stop - start\r\n         assert duration <= 4, f\"Server disconnected too slow: {duration} > 4\"\r\n-        assert duration >= 1, f\"Server disconnected too fast: {duration} < 1\"\r\n+        assert duration >= rpcservertimeout, f\"Server disconnected too fast: {duration} < {rpcservertimeout}\"\r\n         # The connection is definitely closed.\r\n         try:\r\n             conn.request('GET', '/')\r\n             conn.getresponse()\r\n         #       macos/linux           windows\r\n         except (ConnectionResetError, ConnectionAbortedError):\r\n```",
      "created_at": "2025-05-20T13:32:31Z",
      "updated_at": "2025-05-20T13:39:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2097988275",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097988275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 216,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097991881",
      "pull_request_review_id": 2854214850,
      "id": 2097991881,
      "node_id": "PRRC_kwDOABII5859DNDJ",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 35,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Repeat comment https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090504818 here:_\r\n\r\n1 second timeout to send or receive seems more than enough for local testing on a dev machine. However, CI virtual machines sometimes are surprisingly slow. To avoid unnecessary test failures maybe it would be better to have this be 5 or 10 seconds for the `sendall()` calls and then set to 1 for the `recv()` call which we expect to timeout.",
      "created_at": "2025-05-20T13:34:10Z",
      "updated_at": "2025-05-20T13:39:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2097991881",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097991881"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097995543",
      "pull_request_review_id": 2854214850,
      "id": 2097995543,
      "node_id": "PRRC_kwDOABII5859DN8X",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 43,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Repeat comment https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090527952 here:_\r\n\r\nShouldn't this be `assert False`? Here the expectation is that the `recv()` will throw an exception due to timeout.\r\n\r\nhttps://docs.python.org/3/library/socket.html#socket.socket.recv\r\n> A returned empty bytes object indicates that the client has disconnected.\r\n\r\nAn \"empty bytes object\" will not trigger the assert `assert not res` but if that happens (= disconnect) then the test should fail.\r\n\r\nsuggestion:\r\n```diff\r\n-            assert not res\r\n+            assert False\r\n```",
      "created_at": "2025-05-20T13:35:50Z",
      "updated_at": "2025-05-20T13:39:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2097995543",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097995543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097997782",
      "pull_request_review_id": 2854214850,
      "id": 2097997782,
      "node_id": "PRRC_kwDOABII5859DOfW",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=2\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        # Server disconnected with EOF\n+        assert res == b\"\"\n+        # Server disconnected within an acceptable range of time:\n+        # not immediately, and not too far over the configured duration.\n+        # This allows for some jitter in the test between client and server.\n+        duration = stop - start\n+        assert duration <= 4, f\"Server disconnected too slow: {duration} > 4\"\n+        assert duration >= 1, f\"Server disconnected too fast: {duration} < 1\"\n+        # The connection is definitely closed.\n+        try:\n+            conn.request('GET', '/')\n+            conn.getresponse()\n+        #       macos/linux           windows\n+        except (ConnectionResetError, ConnectionAbortedError):\n+            pass",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 126,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Repeat comment https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090840593 here:_\r\n\r\nThis will also pass if no exception is thrown. Either add `assert False` after line 214 or have a boolean variable to false before the `try` and set it to true inside `except` and assert that it is true afterwards.",
      "created_at": "2025-05-20T13:36:51Z",
      "updated_at": "2025-05-20T13:39:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2097997782",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2097997782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098000122",
      "pull_request_review_id": 2854214850,
      "id": 2098000122,
      "node_id": "PRRC_kwDOABII5859DPD6",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 72,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Repeat comment https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090912262 here:_\r\n\r\nIs the intention here to send 8MB of data?\r\n",
      "created_at": "2025-05-20T13:37:50Z",
      "updated_at": "2025-05-20T13:39:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2098000122",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098000122"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098002185",
      "pull_request_review_id": 2854214850,
      "id": 2098002185,
      "node_id": "PRRC_kwDOABII5859DPkJ",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 82,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Repeat comment https://github.com/bitcoin/bitcoin/pull/32061#discussion_r2090917556 here:_\r\n\r\nHere and elsewhere in the added tests, `assert_equal()` produces a better error message:\r\n\r\n`assert` (value of `out1` is not printed):\r\n```\r\n    assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nAssertionError\r\n```\r\n\r\nvs\r\n\r\n`assert_equal()`:\r\n```\r\nAssertionError: not(b'{\"result\":null,\"error\":{\"code\":-32700,\"message\":\"Parse error\"},\"id\":null}\\n' == b'{\"result\":\"high-hash\",\"error\":null}\\n')\r\n```",
      "created_at": "2025-05-20T13:38:45Z",
      "updated_at": "2025-05-20T13:39:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2098002185",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098002185"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098146539",
      "pull_request_review_id": 2854470053,
      "id": 2098146539,
      "node_id": "PRRC_kwDOABII5859Dyzr",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=2\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        # Server disconnected with EOF\n+        assert res == b\"\"\n+        # Server disconnected within an acceptable range of time:\n+        # not immediately, and not too far over the configured duration.\n+        # This allows for some jitter in the test between client and server.\n+        duration = stop - start\n+        assert duration <= 4, f\"Server disconnected too slow: {duration} > 4\"\n+        assert duration >= 1, f\"Server disconnected too fast: {duration} < 1\"",
      "path": "test/functional/interface_http.py",
      "position": 119,
      "original_position": 119,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2097988275,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The problem with this is the test becomes flakey because the timer may not start in sync with the server, so it may record less time than the server actually waited: https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2081584805\r\n\r\nnote also that libevent doesn't even try to test the lower bound: https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2080431221",
      "created_at": "2025-05-20T14:34:41Z",
      "updated_at": "2025-05-20T14:34:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2098146539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2098146539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 216,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2099675521",
      "pull_request_review_id": 2856778879,
      "id": 2099675521,
      "node_id": "PRRC_kwDOABII5859JoGB",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Did you try to start the timer before connecting? Like this:\r\n\r\n```diff\r\n         # Get the underlying socket from HTTP connection so we can send something unusual\r\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\r\n+        start = time.time()\r\n         conn.connect()\r\n         sock = conn.sock\r\n         sock.sendall(http_request.encode(\"utf-8\"))\r\n         # Wait for response, but expect a timeout disconnection after 1 second\r\n-        start = time.time()\r\n         res = sock.recv(1024)\r\n         stop = time.time()\r\n         # Server disconnected with EOF\r\n```\r\n\r\nIt must make it such that the timer in the test is then always >= than the server timeout of 2 seconds, no?",
      "created_at": "2025-05-21T08:22:25Z",
      "updated_at": "2025-05-21T08:22:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2099675521",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2099675521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2099677203",
      "pull_request_review_id": 2856781130,
      "id": 2099677203,
      "node_id": "PRRC_kwDOABII5859JogT",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=2\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        # Server disconnected with EOF\n+        assert res == b\"\"\n+        # Server disconnected within an acceptable range of time:\n+        # not immediately, and not too far over the configured duration.\n+        # This allows for some jitter in the test between client and server.\n+        duration = stop - start\n+        assert duration <= 4, f\"Server disconnected too slow: {duration} > 4\"\n+        assert duration >= 1, f\"Server disconnected too fast: {duration} < 1\"",
      "path": "test/functional/interface_http.py",
      "position": 119,
      "original_position": 119,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2097988275,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_continued the discussion in https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2081584805_",
      "created_at": "2025-05-21T08:23:05Z",
      "updated_at": "2025-05-21T08:23:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2099677203",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2099677203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 216,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100126887",
      "pull_request_review_id": 2857465920,
      "id": 2100126887,
      "node_id": "PRRC_kwDOABII5859LWSn",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah we tried that and still was not working.\r\nFor more context we got a discussion on the IRC channel: https://www.erisian.com.au/bitcoin-core-dev/log-2025-05-07.html",
      "created_at": "2025-05-21T12:09:45Z",
      "updated_at": "2025-05-21T12:11:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100126887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100126887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100197725",
      "pull_request_review_id": 2857578515,
      "id": 2100197725,
      "node_id": "PRRC_kwDOABII5859Lnld",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In that discussion @maflcko [suggested](https://www.erisian.com.au/bitcoin-core-dev/log-2025-05-07.html#l-102) to start the timer before connect and send and sliv3r__ said that [before connect it worked 15 times in a row](https://www.erisian.com.au/bitcoin-core-dev/log-2025-05-07.html#l-117). Do I miss something?",
      "created_at": "2025-05-21T12:44:01Z",
      "updated_at": "2025-05-21T12:44:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100197725",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100197725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100216282",
      "pull_request_review_id": 2857607072,
      "id": 2100216282,
      "node_id": "PRRC_kwDOABII5859LsHa",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It was \"randomly\" failing. The 15 times in a row was moving it before `http.clinet.HTTPConn...`.\r\nMoving it before `conn.connect` failed the 6th time https://www.erisian.com.au/bitcoin-core-dev/log-2025-05-07.html#l-115",
      "created_at": "2025-05-21T12:52:51Z",
      "updated_at": "2025-05-21T12:52:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100216282",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100216282"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100230504",
      "pull_request_review_id": 2857627837,
      "id": 2100230504,
      "node_id": "PRRC_kwDOABII5859Lvlo",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, then this should work:\r\n\r\n```diff\r\n         # Get the underlying socket from HTTP connection so we can send something unusual\r\n+        start = time.time()\r\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\r\n         conn.connect()\r\n         sock = conn.sock\r\n         sock.sendall(http_request.encode(\"utf-8\"))\r\n         # Wait for response, but expect a timeout disconnection after 1 second\r\n-        start = time.time()\r\n         res = sock.recv(1024)\r\n         stop = time.time()\r\n         # Server disconnected with EOF\r\n```\r\n",
      "created_at": "2025-05-21T12:57:50Z",
      "updated_at": "2025-05-21T12:57:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100230504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100230504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100440303",
      "pull_request_review_id": 2857955068,
      "id": 2100440303,
      "node_id": "PRRC_kwDOABII5859Mizv",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That should work but the reason I didn't leave like that is I don't feel like its effectively testing the right thing. We could start the timer at the top of the file and it would always pass, but it wouldn't necessarily catch any regressions. The server timeout should re-start every time it receives a packet from the client, and it's very hard to start the test timer at the right moment.\r\n\r\nAnother approach I tried was actually setting libevent debug logs and trying to track down messages like these:\r\n\r\n```\r\nevent_add: event: 0x10a004210 (fd 20), EV_READ   EV_TIMEOUT call 0x1053cf1bc \r\nevent_add: event 0x10a004210, timeout in 1 seconds 0 useconds, call 0x1053cf1bc \r\n```\r\n\r\nInterestingly, the original version of this test always passes after switching to Sockman",
      "created_at": "2025-05-21T14:25:16Z",
      "updated_at": "2025-05-21T14:25:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100440303",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100440303"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100443031",
      "pull_request_review_id": 2857959442,
      "id": 2100443031,
      "node_id": "PRRC_kwDOABII5859MjeX",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "All that being said, if you want me to use the patch you wrote that's fine by me too ;-)",
      "created_at": "2025-05-21T14:26:28Z",
      "updated_at": "2025-05-21T14:26:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100443031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100443031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100474952",
      "pull_request_review_id": 2858010430,
      "id": 2100474952,
      "node_id": "PRRC_kwDOABII5859MrRI",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 35,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2097991881,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok I'll change the value here to 5 -- meaning the `sock.recv()` on L139 will always take that much time. That will, however, protect us against false positives on a slow CI, if the server regressed and actually responded to the requests out of order, but took more than 1 second to do so.\r\n\r\nAfter we generate a block, the `sock.recv()` on L150 should execute very quickly, but will allow up to 5 seconds for a slow CI to respond to the two RPC requests. That applies to the `sendall()` as well.",
      "created_at": "2025-05-21T14:40:28Z",
      "updated_at": "2025-05-21T14:48:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100474952",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100474952"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100476656",
      "pull_request_review_id": 2858010430,
      "id": 2100476656,
      "node_id": "PRRC_kwDOABII5859Mrrw",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 43,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2097995543,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "thanks, done",
      "created_at": "2025-05-21T14:41:10Z",
      "updated_at": "2025-05-21T14:48:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100476656",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100476656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100477997",
      "pull_request_review_id": 2858010430,
      "id": 2100477997,
      "node_id": "PRRC_kwDOABII5859MsAt",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 72,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2098000122,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, 4MB! Great catch thanks, fixed.",
      "created_at": "2025-05-21T14:41:42Z",
      "updated_at": "2025-05-21T14:48:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100477997",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100477997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": 162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100481900",
      "pull_request_review_id": 2858010430,
      "id": 2100481900,
      "node_id": "PRRC_kwDOABII5859Ms9s",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 82,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2098002185,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "awesome yes, thanks, done",
      "created_at": "2025-05-21T14:43:18Z",
      "updated_at": "2025-05-21T14:48:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100481900",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100481900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100488438",
      "pull_request_review_id": 2858010430,
      "id": 2100488438,
      "node_id": "PRRC_kwDOABII5859Muj2",
      "diff_hunk": "@@ -105,5 +106,133 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=2\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()\n+        res = sock.recv(1024)\n+        stop = time.time()\n+        # Server disconnected with EOF\n+        assert res == b\"\"\n+        # Server disconnected within an acceptable range of time:\n+        # not immediately, and not too far over the configured duration.\n+        # This allows for some jitter in the test between client and server.\n+        duration = stop - start\n+        assert duration <= 4, f\"Server disconnected too slow: {duration} > 4\"\n+        assert duration >= 1, f\"Server disconnected too fast: {duration} < 1\"\n+        # The connection is definitely closed.\n+        try:\n+            conn.request('GET', '/')\n+            conn.getresponse()\n+        #       macos/linux           windows\n+        except (ConnectionResetError, ConnectionAbortedError):\n+            pass",
      "path": "test/functional/interface_http.py",
      "position": null,
      "original_position": 126,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "95d47449b2c069fca9859d76b2c3766868b5ec79",
      "in_reply_to_id": 2097997782,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yep thanks",
      "created_at": "2025-05-21T14:46:19Z",
      "updated_at": "2025-05-21T14:48:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2100488438",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2100488438"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101815542",
      "pull_request_review_id": 2860059754,
      "id": 2101815542,
      "node_id": "PRRC_kwDOABII5859Ryj2",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't see this discussion as a blocker.\r\n\r\nI just want to get to the bottom of it. Checked the source code of `http.client.HTTPConnection()` - it does not open any connections, just sets some internal member variables of the `HTTPConnection` class. So, starting the timer before or after `http.client.HTTPConnection()` shouldn't make a difference.\r\n\r\n`conn.connect()` is what makes the connection. And the timer should be started before it. Why would not the followng test the right thing?\r\n\r\n* start timer in the test (A)\r\n* connect, server timer starts here (B)\r\n* send\r\n* try to recv, connection will be closed by the server due to server timeout (C)\r\n* stop the timer (D)\r\n\r\nTime between B and C will (must!) always be less than the time between A and D. If it is not, then I would like to know why. Maybe we are doing something completely wrong.\r\n\r\nMy worry is that CI machines are sometimes veeery slow and any \"reasonable\" time we set turns out to be surprise and results in intermittent test failures. Now, if doing the above can result in the time between A and D being less than 2 sec (= server timeout, B to C) and we don't know why is that and we set to check only for >1 sec instead, then, because we do not know the cause, how can we be sure that the test timer (A to D) will not be sometimes e.g. 0.99 sec causing the test to fail?",
      "created_at": "2025-05-22T07:13:56Z",
      "updated_at": "2025-05-22T07:13:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2101815542",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101815542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103080376",
      "pull_request_review_id": 2862062147,
      "id": 2103080376,
      "node_id": "PRRC_kwDOABII5859WnW4",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The server timer *should* start after receiving the last packet from the client, because its an idle timer not a session timer. So its more correct to have:\r\n\r\n> send, server timer starts immediately after (B)\r\n\r\nI tried to to nail this in https://github.com/bitcoin/bitcoin/commit/ce9847e284a361fb050f366848cdf1a38b2b933b but that also failed.\r\n\r\nAnd then, if we start the timer too early, we will always get a duration > 1 no matter what the server actually does... maybe its the initial TCP connection attempt that takes 1 second and then the server doesn't connect, or responds immediately, etc.\r\n\r\nThere also could be something with libevent itself making this act funny? I haven't had any intermittency with the original test in #32061 -- so maybe as part of that PR we can tighten up the test ;-)\r\n",
      "created_at": "2025-05-22T17:32:33Z",
      "updated_at": "2025-05-22T17:32:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2103080376",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103080376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104068784",
      "pull_request_review_id": 2863603285,
      "id": 2104068784,
      "node_id": "PRRC_kwDOABII5859aYqw",
      "diff_hunk": "@@ -105,5 +106,127 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(1)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert not res\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0A' * 1000000,\n+            b'0B' * 1000000,\n+            b'0C' * 1000000,\n+            b'0D' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        conn.request(\n+            method='POST',\n+            url='/',\n+            body=iter(body_chunked),\n+            headers=headers_chunked,\n+            encode_chunked=True)\n+        out1 = conn.getresponse().read()\n+        assert out1 == b'{\"result\":\"high-hash\",\"error\":null}\\n'\n+\n+\n+        self.log.info(\"Check -rpcservertimeout\")\n+        # The test framework typically reuses a single persistent HTTP connection\n+        # for all RPCs to a TestNode. Because we are setting -rpcservertimeout\n+        # so low on this one node, its connection will quickly timeout and get dropped by\n+        # the server. Negating this setting will force the AuthServiceProxy\n+        # for this node to create a fresh new HTTP connection for every command\n+        # called for the remainder of this test.\n+        self.nodes[2].reuse_http_connections = False\n+\n+        self.restart_node(2, extra_args=[\"-rpcservertimeout=1\"])\n+        # This is the amount of time the server will wait for a client to\n+        # send a complete request. Test it by sending an incomplete but\n+        # so-far otherwise well-formed HTTP request, and never finishing it.\n+\n+        # Copied from http_incomplete_test_() in regress_http.c in libevent.\n+        # A complete request would have an additional \"\\r\\n\" at the end.\n+        http_request = \"GET /test1 HTTP/1.1\\r\\nHost: somehost\\r\\n\"\n+\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.sendall(http_request.encode(\"utf-8\"))\n+        # Wait for response, but expect a timeout disconnection after 1 second\n+        start = time.time()",
      "path": "test/functional/interface_http.py",
      "position": 109,
      "original_position": 109,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "39c04c7570ba18d296a0eb8ba20ba88b463c3a87",
      "in_reply_to_id": 2077834027,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, it could be that libevent behaves in an unexpected way. In https://github.com/bitcoin/bitcoin/pull/32061 we could tighten up the test to:\r\n\r\n* connect\r\n* start timer in the test (A)\r\n* send, server timer starts after last packet received from the client (B)\r\n* try to recv, connection will be closed by the server due to server timeout (C)\r\n* stop the timer in the test (D)\r\n",
      "created_at": "2025-05-23T08:15:38Z",
      "updated_at": "2025-05-23T08:15:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2104068784",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2104068784"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 206,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2125070216",
      "pull_request_review_id": 2894320133,
      "id": 2125070216,
      "node_id": "PRRC_kwDOABII585-qf-I",
      "diff_hunk": "@@ -105,5 +106,136 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(5)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert False\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0' * 1000000,\n+            b'1' * 1000000,\n+            b'2' * 1000000,\n+            b'3' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)",
      "path": "test/functional/interface_http.py",
      "position": 73,
      "original_position": 73,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Could use a helper function to get rid of some duplication here (and even beyond the changes here across the whole test file).\r\n\r\n```\r\ndef _get_http_connection(self, url_node):\r\n    conn = http.client.HTTPConnection(url_node.hostname, url_node.port) \r\n    conn.connect()\r\n    sock = conn.sock\r\n    return conn, sock\r\n```",
      "created_at": "2025-06-03T22:51:16Z",
      "updated_at": "2025-06-03T23:11:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2125070216",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2125070216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2125071947",
      "pull_request_review_id": 2894320133,
      "id": 2125071947,
      "node_id": "PRRC_kwDOABII585-qgZL",
      "diff_hunk": "@@ -105,5 +106,136 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(5)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert False\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)",
      "path": "test/functional/interface_http.py",
      "position": 53,
      "original_position": 53,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I haven't looked at the actual data but this seems a bit fragile, if the second \"result\" is at the very end of res, the test would continue here but then fail below. Not sure how real that threat is but it could also be easily mitigated by doing one more `recv` I guess.",
      "created_at": "2025-06-03T22:53:21Z",
      "updated_at": "2025-06-03T23:11:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2125071947",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2125071947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": 149,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": 150,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126939031",
      "pull_request_review_id": 2897289165,
      "id": 2126939031,
      "node_id": "PRRC_kwDOABII585-xoOX",
      "diff_hunk": "@@ -105,5 +106,136 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(5)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert False\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)",
      "path": "test/functional/interface_http.py",
      "position": 53,
      "original_position": 53,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "in_reply_to_id": 2125071947,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think that's possible, the two RPCs are `getblockcount` and `waitforblockheight`, those two responses together including their HTTP overhead only total about 500 bytes so I don't think `recv(1024)` would truncate anything. If the server is extremely slow the client may even have to call `recv()` twice in the while loop, reading only about 250 bytes each time.",
      "created_at": "2025-06-04T15:52:27Z",
      "updated_at": "2025-06-04T15:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2126939031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126939031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": 149,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": 150,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126941493",
      "pull_request_review_id": 2897293175,
      "id": 2126941493,
      "node_id": "PRRC_kwDOABII585-xo01",
      "diff_hunk": "@@ -105,5 +106,136 @@ def run_test(self):\n         assert_equal(out1.status, http.client.BAD_REQUEST)\n \n \n+        self.log.info(\"Check pipelining\")\n+        # Requests are responded to in order they were received\n+        # See https://www.rfc-editor.org/rfc/rfc7230#section-6.3.2\n+        tip_height = self.nodes[2].getblockcount()\n+\n+        req = \"POST / HTTP/1.1\\r\\n\"\n+        req += f'Authorization: Basic {str_to_b64str(authpair)}\\r\\n'\n+\n+        # First request will take a long time to process\n+        body1 = f'{{\"method\": \"waitforblockheight\", \"params\": [{tip_height + 1}]}}'\n+        req1 = req\n+        req1 += f'Content-Length: {len(body1)}\\r\\n\\r\\n'\n+        req1 += body1\n+\n+        # Second request will process very fast\n+        body2 = '{\"method\": \"getblockcount\"}'\n+        req2 = req\n+        req2 += f'Content-Length: {len(body2)}\\r\\n\\r\\n'\n+        req2 += body2\n+        # Get the underlying socket from HTTP connection so we can send something unusual\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)\n+        conn.connect()\n+        sock = conn.sock\n+        sock.settimeout(5)\n+        # Send two requests in a row. The first will block the second indefinitely\n+        sock.sendall(req1.encode(\"utf-8\"))\n+        sock.sendall(req2.encode(\"utf-8\"))\n+        try:\n+            # The server should not respond to the fast, second request\n+            # until the (very) slow first request has been handled:\n+            res = sock.recv(1024)\n+            assert False\n+        except TimeoutError:\n+            pass\n+\n+        # Use a separate http connection to generate a block\n+        self.generate(self.nodes[2], 1, sync_fun=self.no_op)\n+\n+        # Wait for two responses to be received\n+        res = b\"\"\n+        while res.count(b\"result\") != 2:\n+            res += sock.recv(1024)\n+\n+        # waitforblockheight was responded to first, and then getblockcount\n+        # which includes the block added after the request was made\n+        chunks = res.split(b'\"result\":')\n+        assert chunks[1].startswith(b'{\"hash\":')\n+        assert chunks[2].startswith(bytes(f'{tip_height + 1}', 'utf8'))\n+\n+\n+        self.log.info(\"Check HTTP request encoded with chunked transfer\")\n+        headers_chunked = headers.copy()\n+        headers_chunked.update({\"Transfer-encoding\": \"chunked\"})\n+        body_chunked = [\n+            b'{\"method\": \"submitblock\", \"params\": [\"',\n+            b'0' * 1000000,\n+            b'1' * 1000000,\n+            b'2' * 1000000,\n+            b'3' * 1000000,\n+            b'\"]}'\n+        ]\n+        conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)",
      "path": "test/functional/interface_http.py",
      "position": 73,
      "original_position": 73,
      "commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "original_commit_id": "f16c8c67bf137e64fbeea1242431baaa915a5c53",
      "in_reply_to_id": 2125070216,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good call thanks. I will do this if I retouch this PR, otherwise will add to #32061 on rebase",
      "created_at": "2025-06-04T15:53:49Z",
      "updated_at": "2025-06-04T15:53:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32408#discussion_r2126941493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2126941493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32408"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 170,
      "original_line": 170,
      "side": "RIGHT"
    }
  ]
}