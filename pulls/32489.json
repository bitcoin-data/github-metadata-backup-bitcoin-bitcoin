{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489",
    "id": 2517768893,
    "node_id": "PR_kwDOABII586WEhq9",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/32489",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/32489.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/32489.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/6fafa9dd48a814a929efb31b746dce343a3c96dc",
    "number": 32489,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "wallet: Add `exportwatchonlywallet` RPC to export a watchonly version of a wallet",
    "user": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Currently, if a user wants to use an airgapped setup, they need to manually create the watchonly wallet that will live on the online node by importing the public descriptors. This PR introduces `exportwatchonlywallet` which will create a wallet file with the public descriptors to avoid exposing the specific internals to the user. Additionally, this RPC will copy any existing labels, transactions, and wallet flags. This ensures that the exported watchonly wallet is almost entirely a copy of the original wallet but without private keys.",
    "labels": [
      {
        "id": 149424,
        "node_id": "MDU6TGFiZWwxNDk0MjQ=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
        "name": "Wallet",
        "color": "08a781",
        "default": false
      },
      {
        "id": 1648013533,
        "node_id": "MDU6TGFiZWwxNjQ4MDEzNTMz",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Review%20club",
        "name": "Review club",
        "description": "",
        "color": "0052cc",
        "default": false
      }
    ],
    "created_at": "2025-05-13T22:22:00Z",
    "updated_at": "2025-10-23T02:55:30Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "9b4c9a7dbcd8f4b103e230aa77f6b80458528507",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "shahsb",
        "id": 20738488,
        "node_id": "MDQ6VXNlcjIwNzM4NDg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/20738488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/shahsb",
        "html_url": "https://github.com/shahsb",
        "followers_url": "https://api.github.com/users/shahsb/followers",
        "following_url": "https://api.github.com/users/shahsb/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/shahsb/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/shahsb/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/shahsb/subscriptions",
        "organizations_url": "https://api.github.com/users/shahsb/orgs",
        "repos_url": "https://api.github.com/users/shahsb/repos",
        "events_url": "https://api.github.com/users/shahsb/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/shahsb/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "achow101:export-watchonly-wallet",
      "ref": "export-watchonly-wallet",
      "sha": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 45006379,
        "node_id": "MDEwOlJlcG9zaXRvcnk0NTAwNjM3OQ==",
        "name": "bitcoin",
        "full_name": "achow101/bitcoin",
        "owner": {
          "login": "achow101",
          "id": 3782274,
          "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/achow101",
          "html_url": "https://github.com/achow101",
          "followers_url": "https://api.github.com/users/achow101/followers",
          "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
          "organizations_url": "https://api.github.com/users/achow101/orgs",
          "repos_url": "https://api.github.com/users/achow101/repos",
          "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/achow101/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/achow101/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/achow101/bitcoin",
        "archive_url": "https://api.github.com/repos/achow101/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/achow101/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/achow101/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/achow101/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/achow101/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/achow101/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/achow101/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/achow101/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/achow101/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/achow101/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/achow101/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/achow101/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/achow101/bitcoin/events",
        "forks_url": "https://api.github.com/repos/achow101/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/achow101/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/achow101/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/achow101/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/achow101/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/achow101/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/achow101/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/achow101/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/achow101/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/achow101/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/achow101/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/achow101/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/achow101/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/achow101/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/achow101/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/achow101/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:achow101/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/achow101/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/achow101/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/achow101/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/achow101/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/achow101/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/achow101/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/achow101/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/achow101/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/achow101/bitcoin/hooks",
        "svn_url": "https://github.com/achow101/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 10,
        "stargazers_count": 41,
        "watchers_count": 41,
        "size": 310752,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-21T07:29:41Z",
        "created_at": "2015-10-27T00:20:28Z",
        "updated_at": "2025-09-06T09:25:53Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "d41b503ae128ac36ef27e652d2935c6fe7981a79",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38070,
        "stargazers_count": 86357,
        "watchers_count": 86357,
        "size": 295104,
        "default_branch": "master",
        "open_issues_count": 751,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-22T10:50:05Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-10-23T02:40:37Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 572,
    "deletions": 85,
    "changed_files": 11,
    "commits": 8,
    "review_comments": 89,
    "comments": 16
  },
  "events": [
    {
      "event": "commented",
      "id": 2878094400,
      "node_id": "IC_kwDOABII586rjDxA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2878094400",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-13T22:22:04Z",
      "updated_at": "2025-10-23T02:55:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32489.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [shahsb](https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-2843940627), [Sjors](https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2890893688), [vicjuma](https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2917340365), [Eunovo](https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2980159342), [stringintech](https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3103209012), [enirox001](https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3116692194) |\n| Stale ACK | [pablomartin4btc](https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3090320231), [ryanofsky](https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3094757593), [rkrux](https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3164472562), [polespinasa](https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3268580076) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#bitcoin-core/gui/872](https://github.com/bitcoin-core/gui/pull/872) (Menu action to export a watchonly wallet by achow101)\n* [#33135](https://github.com/bitcoin/bitcoin/pull/33135) (wallet: warn against accidental unsafe older() import by Sjors)\n* [#33034](https://github.com/bitcoin/bitcoin/pull/33034) (wallet: Store transactions in a separate sqlite table by achow101)\n* [#33008](https://github.com/bitcoin/bitcoin/pull/33008) (wallet: support bip388 policy with external signer by Sjors)\n* [#32895](https://github.com/bitcoin/bitcoin/pull/32895) (wallet: Prepare for future upgrades by recording versions of last client to open and decrypt by achow101)\n* [#32861](https://github.com/bitcoin/bitcoin/pull/32861) (Have createwalletdescriptor auto-detect an unused(KEY) by Sjors)\n* [#32471](https://github.com/bitcoin/bitcoin/pull/32471) (wallet/rpc: fix listdescriptors RPC fails to return descriptors with private key information when wallet contains descriptors missing any key by Eunovo)\n* [#29136](https://github.com/bitcoin/bitcoin/pull/29136) (wallet: `addhdkey` RPC to add just keys to wallets via new `unused(KEY)` descriptor by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2878094400",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "labeled",
      "id": 17643451597,
      "node_id": "LE_lADOABII5862eKb6zwAAAAQbobTN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17643451597",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-13T22:23:13Z",
      "label": {
        "name": "Wallet",
        "color": "08a781"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17643564759,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQbo27X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17643564759",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "30ebc9724a0ca15c17457c0bc6b8ba953383dc0d",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/30ebc9724a0ca15c17457c0bc6b8ba953383dc0d",
      "created_at": "2025-05-13T22:38:59Z"
    },
    {
      "event": "labeled",
      "id": 17643567414,
      "node_id": "LE_lADOABII5862eKb6zwAAAAQbo3k2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17643567414",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-13T22:39:21Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2878116938,
      "node_id": "IC_kwDOABII586rjJRK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2878116938",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-13T22:39:22Z",
      "updated_at": "2025-05-13T22:39:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/runs/42170822821</sub>\n<sub>LLM reason (✨ experimental): The CI failure is due to linting errors in Python and C++ code.\n</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2878116938",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17643755335,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQbpldH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17643755335",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "211dbe3119e4f18970f9034b06e20d6127b63382",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/211dbe3119e4f18970f9034b06e20d6127b63382",
      "created_at": "2025-05-13T23:04:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17643902859,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQbqJeL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17643902859",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9fd93da673d161480d7fa57548e41d652faeb650",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/9fd93da673d161480d7fa57548e41d652faeb650",
      "created_at": "2025-05-13T23:28:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17658378080,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQchXdg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17658378080",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4ef9315bb0202dc04dd08bc9b903b08305f87cd3",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/4ef9315bb0202dc04dd08bc9b903b08305f87cd3",
      "created_at": "2025-05-14T18:00:19Z"
    },
    {
      "event": "unlabeled",
      "id": 17660061186,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAAQcnyYC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17660061186",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-14T20:11:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2843940627,
      "node_id": "PRR_kwDOABII586pgxcT",
      "url": null,
      "actor": null,
      "commit_id": "4ef9315bb0202dc04dd08bc9b903b08305f87cd3",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-15T14:30:03Z",
      "author_association": "NONE",
      "body": "Concept ACK",
      "user": {
        "login": "shahsb",
        "id": 20738488,
        "node_id": "MDQ6VXNlcjIwNzM4NDg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/20738488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/shahsb",
        "html_url": "https://github.com/shahsb",
        "followers_url": "https://api.github.com/users/shahsb/followers",
        "following_url": "https://api.github.com/users/shahsb/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/shahsb/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/shahsb/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/shahsb/subscriptions",
        "organizations_url": "https://api.github.com/users/shahsb/orgs",
        "repos_url": "https://api.github.com/users/shahsb/repos",
        "events_url": "https://api.github.com/users/shahsb/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/shahsb/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-2843940627",
      "submitted_at": "2025-05-15T14:30:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "labeled",
      "id": 17694336603,
      "node_id": "LE_lADOABII5862eKb6zwAAAAQeqiZb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17694336603",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T20:48:30Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17694772046,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQesMtO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17694772046",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "def95949c5291fe8acfbfafd99e99e260e84ecae",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/def95949c5291fe8acfbfafd99e99e260e84ecae",
      "created_at": "2025-05-16T21:43:04Z"
    },
    {
      "event": "unlabeled",
      "id": 17695303275,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAAQeuOZr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17695303275",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-16T23:07:37Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2890893688,
      "node_id": "IC_kwDOABII586sT4l4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2890893688",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-19T12:50:11Z",
      "updated_at": "2025-05-19T12:58:07Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nThis might also be useful in a _multisig_ airgapped scenario (where two private keys never go near each other).\r\n\r\nE.g. create a 2-of-2 MuSig2 wallet on your offline machine, with one hot key held by Bitcoin Core and the other a hardware wallet. Export the watch-only wallet and put it on the online machine. You can then use the hardware wallet on either the online or offline machine to co-sign.\r\n\r\nThough for that to work, the `exportwatchonlywallet` should have an option to set the `external_signer` flag (the offline wallet might not have this flag, depending on how you set it up).",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2890893688",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "labeled",
      "id": 17721950666,
      "node_id": "LE_lADOABII5862eKb6zwAAAAQgT4HK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17721950666",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-19T20:49:33Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17723982426,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQgboJa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17723982426",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d41059b3f6e38a80e4b20effd6d64d147c261ae1",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/d41059b3f6e38a80e4b20effd6d64d147c261ae1",
      "created_at": "2025-05-20T00:55:03Z"
    },
    {
      "event": "unlabeled",
      "id": 17724133998,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAAQgcNJu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17724133998",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-20T01:13:41Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 17754727486,
      "node_id": "LE_lADOABII5862eKb6zwAAAAQiQ6Q-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17754727486",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-21T14:10:04Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17758529573,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQifagl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17758529573",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1ec0073636fd07740b855eea8ad928f3e875232e",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/1ec0073636fd07740b855eea8ad928f3e875232e",
      "created_at": "2025-05-21T17:52:54Z"
    },
    {
      "event": "ready_for_review",
      "id": 17758550578,
      "node_id": "RFRE_lADOABII5862eKb6zwAAAAQiffoy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17758550578",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-21T17:54:12Z"
    },
    {
      "event": "commented",
      "id": 2898781091,
      "node_id": "IC_kwDOABII586sx-Oj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2898781091",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-21T17:54:14Z",
      "updated_at": "2025-05-21T17:54:14Z",
      "author_association": "MEMBER",
      "body": "Rebased, ready for review",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2898781091",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "unlabeled",
      "id": 17759063456,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAAQihc2g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17759063456",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-21T18:33:17Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2860239353,
      "node_id": "PRR_kwDOABII586qe8n5",
      "url": null,
      "actor": null,
      "commit_id": "1ec0073636fd07740b855eea8ad928f3e875232e",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-05-22T08:31:43Z",
      "author_association": "MEMBER",
      "body": "Some initial observations on the early commits inline...\r\n\r\n> Those are primarily bug fixes for existing issues that came up during testing.\r\n\r\nIt's a bit hard to follow, so I would suggest splitting (some of) them out. Unless they're actual preparation like cb43639babdc961fda5b0b2e3426fe6dcd4b7cc6.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-2860239353",
      "submitted_at": "2025-05-22T08:30:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17779761555,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQjwaGT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17779761555",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c92caab80368cb72eae253d321a60fc15bab896c",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/c92caab80368cb72eae253d321a60fc15bab896c",
      "created_at": "2025-05-22T21:21:13Z"
    },
    {
      "event": "commented",
      "id": 2902602828,
      "node_id": "IC_kwDOABII586tAjRM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2902602828",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-22T21:21:56Z",
      "updated_at": "2025-06-04T23:53:52Z",
      "author_association": "MEMBER",
      "body": "Split the `LockCoin` commit into #32593, the `parent_descs` to #32594, the flag setting and retrieval stuff to #32597, and exception logging to #32598",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2902602828",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "convert_to_draft",
      "id": 17779770427,
      "node_id": "CTDE_lADOABII5862eKb6zwAAAAQjwcQ7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17779770427",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-22T21:22:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17779781487,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQjwe9v",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17779781487",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a9bbb4906c773d19088d54d4053ea0a10eda0f3f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/a9bbb4906c773d19088d54d4053ea0a10eda0f3f",
      "created_at": "2025-05-22T21:23:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17781437371,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQj2zO7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17781437371",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a7375a6ba1ed3c90dab9da21880bcaaf57ffb52b",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/a7375a6ba1ed3c90dab9da21880bcaaf57ffb52b",
      "created_at": "2025-05-23T00:40:48Z"
    },
    {
      "event": "commented",
      "id": 2903590736,
      "node_id": "IC_kwDOABII586tEUdQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2903590736",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-23T07:52:40Z",
      "updated_at": "2025-05-23T07:52:40Z",
      "author_association": "MEMBER",
      "body": "> Split the LockCoin commit into https://github.com/bitcoin/bitcoin/pull/3259,\r\n\r\n#32593",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2903590736",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "commented",
      "id": 2917340365,
      "node_id": "IC_kwDOABII586t4xTN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2917340365",
      "actor": {
        "login": "vicjuma",
        "id": 30392363,
        "node_id": "MDQ6VXNlcjMwMzkyMzYz",
        "avatar_url": "https://avatars.githubusercontent.com/u/30392363?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vicjuma",
        "html_url": "https://github.com/vicjuma",
        "followers_url": "https://api.github.com/users/vicjuma/followers",
        "following_url": "https://api.github.com/users/vicjuma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vicjuma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vicjuma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vicjuma/subscriptions",
        "organizations_url": "https://api.github.com/users/vicjuma/orgs",
        "repos_url": "https://api.github.com/users/vicjuma/repos",
        "events_url": "https://api.github.com/users/vicjuma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vicjuma/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-28T19:06:36Z",
      "updated_at": "2025-05-28T19:06:36Z",
      "author_association": "NONE",
      "body": "Concept ACK\r\n\r\nThis separates viewing and spending logic and will be efficient especially if **exporting** it to an _easily_ **importable** format ",
      "user": {
        "login": "vicjuma",
        "id": 30392363,
        "node_id": "MDQ6VXNlcjMwMzkyMzYz",
        "avatar_url": "https://avatars.githubusercontent.com/u/30392363?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vicjuma",
        "html_url": "https://github.com/vicjuma",
        "followers_url": "https://api.github.com/users/vicjuma/followers",
        "following_url": "https://api.github.com/users/vicjuma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vicjuma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vicjuma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vicjuma/subscriptions",
        "organizations_url": "https://api.github.com/users/vicjuma/orgs",
        "repos_url": "https://api.github.com/users/vicjuma/repos",
        "events_url": "https://api.github.com/users/vicjuma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vicjuma/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2917340365",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "referenced",
      "id": 17883249290,
      "node_id": "REFE_lADOABII5862eKb6zwAAAAQp7LqK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17883249290",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4b1d48a6866b24f0ed027334c6de642fc848d083",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b1d48a6866b24f0ed027334c6de642fc848d083",
      "created_at": "2025-05-30T10:33:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17941730270,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQtaRPe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17941730270",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "793dbc5518e30ee7d89a11f4a3aad5494da43798",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/793dbc5518e30ee7d89a11f4a3aad5494da43798",
      "created_at": "2025-06-02T19:38:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17990927140,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQwV8Mk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17990927140",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7e4d00bc81eae8275bcc3d66ea3acd8d47b6ceb0",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/7e4d00bc81eae8275bcc3d66ea3acd8d47b6ceb0",
      "created_at": "2025-06-04T23:55:53Z"
    },
    {
      "event": "referenced",
      "id": 18142460531,
      "node_id": "REFE_lADOABII5862eKb6zwAAAAQ5X_pz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18142460531",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "287cd04a32dfff769f5ef9bf4f5a65d40f9f9eea",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/287cd04a32dfff769f5ef9bf4f5a65d40f9f9eea",
      "created_at": "2025-06-13T22:28:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18143767361,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQ5c-tB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18143767361",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/ab7e1f248d2588472029514a4a643f043c853f9b",
      "created_at": "2025-06-14T01:01:16Z"
    },
    {
      "event": "commented",
      "id": 2976174896,
      "node_id": "IC_kwDOABII586xZNMw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2976174896",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-16T11:27:23Z",
      "updated_at": "2025-06-16T11:27:23Z",
      "author_association": "MEMBER",
      "body": "Can you update the description with the prerequisite PRs? Just #32593 and #32597 are left I believe.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2976174896",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "reviewed",
      "id": 2935366709,
      "node_id": "PRR_kwDOABII586u9iQ1",
      "url": null,
      "actor": null,
      "commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-17T11:59:47Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-2935366709",
      "submitted_at": "2025-06-17T11:59:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 2935426257,
      "node_id": "PRR_kwDOABII586u9wzR",
      "url": null,
      "actor": null,
      "commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-06-17T12:18:52Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-2935426257",
      "submitted_at": "2025-06-17T12:18:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "commented",
      "id": 2980159342,
      "node_id": "IC_kwDOABII586xoZ9u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2980159342",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-17T12:20:10Z",
      "updated_at": "2025-06-17T12:20:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nLeft some comments.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-2980159342",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18196092168,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAQ8klUI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18196092168",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3010b614acbe58d3378ded28e770fd3da62b300f",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/3010b614acbe58d3378ded28e770fd3da62b300f",
      "created_at": "2025-06-17T18:15:10Z"
    },
    {
      "event": "referenced",
      "id": 18323672986,
      "node_id": "REFE_lADOABII5862eKb6zwAAAARELQ-a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18323672986",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8578fabb95face25d9fa7dfaad38d0a2857c2481",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8578fabb95face25d9fa7dfaad38d0a2857c2481",
      "created_at": "2025-06-25T20:14:59Z"
    },
    {
      "event": "labeled",
      "id": 18412097787,
      "node_id": "LE_lADOABII5862eKb6zwAAAARJclD7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18412097787",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T14:03:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18417285464,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAARJwXlY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18417285464",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8cd66e16bac0c490f4df9f23ebfbc040734634ec",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/8cd66e16bac0c490f4df9f23ebfbc040734634ec",
      "created_at": "2025-07-01T18:47:14Z"
    },
    {
      "event": "unlabeled",
      "id": 18418745503,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAARJ18Cf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18418745503",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-01T20:37:35Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 18800205378,
      "node_id": "REFE_lADOABII5862eKb6zwAAAARglF5C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18800205378",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5ad79b203505fe7b867c05139d78e9aa6d662dcc",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5ad79b203505fe7b867c05139d78e9aa6d662dcc",
      "created_at": "2025-07-24T17:40:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18800469714,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAARgmGbS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18800469714",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "created_at": "2025-07-24T17:56:45Z"
    },
    {
      "event": "ready_for_review",
      "id": 18800899486,
      "node_id": "RFRE_lADOABII5862eKb6zwAAAARgnvWe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18800899486",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T18:21:56Z"
    },
    {
      "event": "commented",
      "id": 3114420072,
      "node_id": "IC_kwDOABII5865okdo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3114420072",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T18:22:12Z",
      "updated_at": "2025-07-24T18:22:12Z",
      "author_association": "MEMBER",
      "body": "All prerequisite PRs merged, ready for review.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3114420072",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "commented",
      "id": 3116306876,
      "node_id": "IC_kwDOABII5865vxG8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3116306876",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T03:59:24Z",
      "updated_at": "2025-07-25T03:59:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "Strong Concept ACK e6ac2015a852caa0f50e44becf9cd4b7592c48e7\r\nVery useful for the users, the GUI option (in the separate PR) makes creating a watch-only version even easier.\r\nI will review this PR soon.\r\n\r\nI believe the following is done now and can be removed from the PR description?\r\n> Some of the first several commits can be split into separate PRs if so desired. Those are primarily bug fixes for existing issues that came up during testing.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3116306876",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "commented",
      "id": 3116401175,
      "node_id": "IC_kwDOABII5865wIIX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3116401175",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T05:03:06Z",
      "updated_at": "2025-07-25T05:03:06Z",
      "author_association": "MEMBER",
      "body": "> I believe the following is done now and can be removed from the PR description?\r\n\r\nYes, removed.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3116401175",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "reviewed",
      "id": 3054267110,
      "node_id": "PRR_kwDOABII5862DGrm",
      "url": null,
      "actor": null,
      "commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-25T06:36:42Z",
      "author_association": "MEMBER",
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3054267110",
      "submitted_at": "2025-07-25T06:36:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3054273346,
      "node_id": "PRR_kwDOABII5862DINC",
      "url": null,
      "actor": null,
      "commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-25T06:40:01Z",
      "author_association": "MEMBER",
      "body": "light cr ACK e6ac2015a852caa0f50e44becf9cd4b7592c48e7\r\n\r\nI like the refactoring in moving the logic of extracting descriptors info out of `listdescriptors` RPC to `CWallet` itself. \r\n\r\nI'll continue reviewing and will test it soon.\r\n\r\nLeft a couple of comments.",
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3054273346",
      "submitted_at": "2025-07-25T06:40:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "review_requested",
      "id": 18808696621,
      "node_id": "RRE_lADOABII5862eKb6zwAAAARhFe8t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18808696621",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T06:40:05Z",
      "requested_reviewer": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18808696832,
      "node_id": "RRE_lADOABII5862eKb6zwAAAARhFfAA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18808696832",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T06:40:06Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18808697006,
      "node_id": "RRE_lADOABII5862eKb6zwAAAARhFfCu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18808697006",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T06:40:07Z",
      "requested_reviewer": {
        "login": "shahsb",
        "id": 20738488,
        "node_id": "MDQ6VXNlcjIwNzM4NDg4",
        "avatar_url": "https://avatars.githubusercontent.com/u/20738488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/shahsb",
        "html_url": "https://github.com/shahsb",
        "followers_url": "https://api.github.com/users/shahsb/followers",
        "following_url": "https://api.github.com/users/shahsb/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/shahsb/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/shahsb/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/shahsb/subscriptions",
        "organizations_url": "https://api.github.com/users/shahsb/orgs",
        "repos_url": "https://api.github.com/users/shahsb/repos",
        "events_url": "https://api.github.com/users/shahsb/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/shahsb/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18808697225,
      "node_id": "RRE_lADOABII5862eKb6zwAAAARhFfGJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18808697225",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T06:40:08Z",
      "requested_reviewer": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3054306625,
      "node_id": "PRR_kwDOABII5862DQVB",
      "url": null,
      "actor": null,
      "commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-25T06:54:21Z",
      "author_association": "MEMBER",
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3054306625",
      "submitted_at": "2025-07-25T06:54:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3076595915,
      "node_id": "PRR_kwDOABII5863YSDL",
      "url": null,
      "actor": null,
      "commit_id": "01b72fd4f5e5bcbbf851c217a895b09204a760a3",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-31T19:03:51Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3076595915",
      "submitted_at": "2025-07-31T19:03:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "labeled",
      "id": 18927927276,
      "node_id": "LE_lADOABII5862eKb6zwAAAARoMT_s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18927927276",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-31T22:44:15Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18928250536,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAARoNi6o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18928250536",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "183091c1da4d8d281d1ab89f13b5c98735bd5245",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/183091c1da4d8d281d1ab89f13b5c98735bd5245",
      "created_at": "2025-07-31T23:22:22Z"
    },
    {
      "event": "unlabeled",
      "id": 18929242766,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAARoRVKO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18929242766",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T01:07:50Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 18929424490,
      "node_id": "LE_lADOABII5862eKb6zwAAAARoSBhq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18929424490",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T01:24:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3141837682,
      "node_id": "IC_kwDOABII5867RKNy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3141837682",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-01T01:24:12Z",
      "updated_at": "2025-08-01T01:24:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Task `tidy`: https://github.com/bitcoin/bitcoin/runs/47161464649</sub>\n<sub>LLM reason (✨ experimental): Clang-tidy detected a recursive function call in descriptor.cpp, which caused the CI failure.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3141837682",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18930961568,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAARoX4yg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18930961568",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8b060b6c91440e0d4f539779408b061ce682cddf",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/8b060b6c91440e0d4f539779408b061ce682cddf",
      "created_at": "2025-08-01T03:53:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18948415706,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAARpaeDa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18948415706",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "created_at": "2025-08-02T00:24:58Z"
    },
    {
      "event": "unlabeled",
      "id": 18949224877,
      "node_id": "UNLE_lADOABII5862eKb6zwAAAARpdjmt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18949224877",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-02T03:52:07Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3151407154,
      "node_id": "IC_kwDOABII58671qgy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3151407154",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-04T16:13:52Z",
      "updated_at": "2025-08-04T16:13:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "For anyone who's interested, I'm hosting a review club meeting about this PR on Wednesday: https://bitcoincore.reviews/32489",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3151407154",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "commented",
      "id": 3152447889,
      "node_id": "IC_kwDOABII58675omR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3152447889",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-04T21:23:37Z",
      "updated_at": "2025-08-04T21:23:37Z",
      "author_association": "MEMBER",
      "body": "> For anyone who's interested, I'm hosting a review club meeting about this PR on Wednesday: [bitcoincore.reviews/32489](https://bitcoincore.reviews/32489)\r\n\r\nThere is `Review Club` label in this repo that can be added, too.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3152447889",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "labeled",
      "id": 18979339639,
      "node_id": "LE_lADOABII5862eKb6zwAAAARrQb13",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18979339639",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-04T22:16:01Z",
      "label": {
        "name": "Review club",
        "color": "0052cc"
      }
    },
    {
      "event": "reviewed",
      "id": 3090314166,
      "node_id": "PRR_kwDOABII5864MnO2",
      "url": null,
      "actor": null,
      "commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-06T03:34:13Z",
      "author_association": "MEMBER",
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3090314166",
      "submitted_at": "2025-08-06T03:34:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3090320231,
      "node_id": "PRR_kwDOABII5864Motn",
      "url": null,
      "actor": null,
      "commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-06T03:39:58Z",
      "author_association": "MEMBER",
      "body": "re-ACK 84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4\r\n\r\nSince my last review `CanSelfExpand()` has been refactored as @ryanofsky [suggested](https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2246172625).\r\n\r\nWe'd need release notes for this new RPC.",
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3090320231",
      "submitted_at": "2025-08-06T03:39:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3094757593,
      "node_id": "PRR_kwDOABII5864dkDZ",
      "url": null,
      "actor": null,
      "commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-07T15:55:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "Code review ACK 84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4. This is great. Nice feature cleanly implemented with very good test coverage. I left a bunch of comments but none are critical.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3094757593",
      "submitted_at": "2025-08-07T15:55:32Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3103209012,
      "node_id": "PRR_kwDOABII58649zY0",
      "url": null,
      "actor": null,
      "commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-09T18:51:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK. I did a light code review.",
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3103209012",
      "submitted_at": "2025-08-09T18:51:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3116692194,
      "node_id": "PRR_kwDOABII5865xPLi",
      "url": null,
      "actor": null,
      "commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-13T19:17:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK 84d3bc6\r\n\r\nLeft some nits, comments",
      "user": {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3116692194",
      "submitted_at": "2025-08-13T19:17:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19166101616,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAR2Y4Bw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19166101616",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7d63d0804320be63ae0c63c8aac052b4dbffce41",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/7d63d0804320be63ae0c63c8aac052b4dbffce41",
      "created_at": "2025-08-14T19:56:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19166112792,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAR2Y6wY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19166112792",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4cc7be4ed92de3d6323734107000666c3298ac96",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/4cc7be4ed92de3d6323734107000666c3298ac96",
      "created_at": "2025-08-14T19:56:58Z"
    },
    {
      "event": "reviewed",
      "id": 3138017810,
      "node_id": "PRR_kwDOABII5867CloS",
      "url": null,
      "actor": null,
      "commit_id": "4cc7be4ed92de3d6323734107000666c3298ac96",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-20T19:46:35Z",
      "author_association": "MEMBER",
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3138017810",
      "submitted_at": "2025-08-20T19:46:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEzYmUyZDg3NDUwM2RjMjRiNWQ1MmZlMDNkNGNmMmM3YjVmZjYwN2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a3be2d874503dc24b5d52fe03d4cf2c7b5ff607d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a3be2d874503dc24b5d52fe03d4cf2c7b5ff607d",
      "tree": {
        "sha": "f37914b64ad197769f26c06ea01be91b85bd19e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f37914b64ad197769f26c06ea01be91b85bd19e3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/04c115dfde369ae4c4458f140efec433d9e14e56",
          "sha": "04c115dfde369ae4c4458f140efec433d9e14e56",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/04c115dfde369ae4c4458f140efec433d9e14e56"
        }
      ],
      "message": "descriptor: Add CanSelfExpand()\n\nCanSelfExpand() reports whether a descriptor can be expanded without\nneeding any caches or private keys to be provided by the caller of\nExpand().",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-08-20T21:37:56Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-12T22:41:53Z"
      },
      "sha": "a3be2d874503dc24b5d52fe03d4cf2c7b5ff607d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkzMTdlYTBiMWNmYTJmMzFkZDc4YzNlYzU4YzZmNmVlZWRmOWJhMjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9317ea0b1cfa2f31dd78c3ec58c6f6eeedf9ba20",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9317ea0b1cfa2f31dd78c3ec58c6f6eeedf9ba20",
      "tree": {
        "sha": "180cde2fcbbe73b2ecbed0bb1d2669fc27492797",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/180cde2fcbbe73b2ecbed0bb1d2669fc27492797"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a3be2d874503dc24b5d52fe03d4cf2c7b5ff607d",
          "sha": "a3be2d874503dc24b5d52fe03d4cf2c7b5ff607d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a3be2d874503dc24b5d52fe03d4cf2c7b5ff607d"
        }
      ],
      "message": "wallet: Use Descriptor::CanSelfExpand() in CanGetAddresses()\n\nIf a descriptor does not need any caches or private keys in order to\nexpand, then CanGetAddresses() should return true for that descriptor.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-08-20T21:37:56Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-12T22:42:51Z"
      },
      "sha": "9317ea0b1cfa2f31dd78c3ec58c6f6eeedf9ba20"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRkN2FlYWIxNTAwMzQ0MWVmYjJiOGVlODliZGQxYWQ0ZTYwOGU2MWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d7aeab15003441efb2b8ee89bdd1ad4e608e61b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4d7aeab15003441efb2b8ee89bdd1ad4e608e61b",
      "tree": {
        "sha": "f2e02117a687696ba1d7fd03c30cd19dcbaf0121",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f2e02117a687696ba1d7fd03c30cd19dcbaf0121"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9317ea0b1cfa2f31dd78c3ec58c6f6eeedf9ba20",
          "sha": "9317ea0b1cfa2f31dd78c3ec58c6f6eeedf9ba20",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9317ea0b1cfa2f31dd78c3ec58c6f6eeedf9ba20"
        }
      ],
      "message": "wallet: Write new descriptor's cache in AddWalletDescriptor\n\nIf a new WalletDescriptor is provided to us with a cache, write the\ncache to disk as well.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-08-20T21:37:56Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-13T21:36:04Z"
      },
      "sha": "4d7aeab15003441efb2b8ee89bdd1ad4e608e61b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY3MjE2NzAwY2U4ZWM1ZTg0YmNhNWY4Mzg2MDA5MWY2YWM0ZjY3ZjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67216700ce8ec5e84bca5f83860091f6ac4f67f4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/67216700ce8ec5e84bca5f83860091f6ac4f67f4",
      "tree": {
        "sha": "ed6c1b40cdc6daacccaf98f7508dd48cfa4dfa2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ed6c1b40cdc6daacccaf98f7508dd48cfa4dfa2f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d7aeab15003441efb2b8ee89bdd1ad4e608e61b",
          "sha": "4d7aeab15003441efb2b8ee89bdd1ad4e608e61b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4d7aeab15003441efb2b8ee89bdd1ad4e608e61b"
        }
      ],
      "message": "wallet: Move listdescriptors retrieving from RPC to CWallet\n\nWhen listdescriptors retrieves the descriptors from the wallet, instead\nof having this logic in the RPC, move it into CWallet itself. This\nwill enable other functions to get the descriptors in an exportable\nform.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-08-20T21:37:57Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-12T19:35:53Z"
      },
      "sha": "67216700ce8ec5e84bca5f83860091f6ac4f67f4"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19254970205,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAAR7r4dd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19254970205",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "created_at": "2025-08-20T22:18:01Z"
    },
    {
      "event": "reviewed",
      "id": 3151519710,
      "node_id": "PRR_kwDOABII58672F_e",
      "url": null,
      "actor": null,
      "commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-25T14:58:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "Started reviewing.\r\n\r\nCode review cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3151519710",
      "submitted_at": "2025-08-25T14:58:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19330458218,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAASAL2Jq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19330458218",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "created_at": "2025-08-25T21:09:31Z"
    },
    {
      "event": "reviewed",
      "id": 3155276288,
      "node_id": "PRR_kwDOABII5868EbIA",
      "url": null,
      "actor": null,
      "commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-26T14:04:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "Code review c9eb6c853dbc96f47c89ab5ca26dde028cd5e108\r\n\r\nLooking good, mentioned few points.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3155276288",
      "submitted_at": "2025-08-26T14:04:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19353282937,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAASBi6l5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19353282937",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6e8cddbd30935907fd5e7654b15193e187f640c8",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/6e8cddbd30935907fd5e7654b15193e187f640c8",
      "created_at": "2025-08-26T18:26:07Z"
    },
    {
      "event": "reviewed",
      "id": 3164472562,
      "node_id": "PRR_kwDOABII5868ngTy",
      "url": null,
      "actor": null,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-28T11:31:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "lgtm ACK 0f547141487e3964a55102f6ae441233d7144aaf\r\n\r\nThanks for addressing the comments.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3164472562",
      "submitted_at": "2025-08-28T11:31:32Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "review_requested",
      "id": 19389744644,
      "node_id": "RRE_lADOABII5862eKb6zwAAAASDuAYE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19389744644",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-28T11:31:38Z",
      "requested_reviewer": {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 19389744858,
      "node_id": "RRE_lADOABII5862eKb6zwAAAASDuAba",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19389744858",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-28T11:31:39Z",
      "requested_reviewer": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 19389745148,
      "node_id": "RRE_lADOABII5862eKb6zwAAAASDuAf8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19389745148",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-28T11:31:40Z",
      "requested_reviewer": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 19389745509,
      "node_id": "RRE_lADOABII5862eKb6zwAAAASDuAll",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19389745509",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-28T11:31:42Z",
      "requested_reviewer": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 3268580076,
      "node_id": "IC_kwDOABII587C0pLs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3268580076",
      "actor": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-09-09T01:53:25Z",
      "updated_at": "2025-09-10T20:46:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "slightly code review tACK 0f547141487e3964a55102f6ae441233d7144aaf\r\n\r\nThe behaviour of this new RPC was tested to update the guide in commit 0f547141487e3964a55102f6ae441233d7144aaf and the behavior is the expected.",
      "user": {
        "login": "polespinasa",
        "id": 57642229,
        "node_id": "MDQ6VXNlcjU3NjQyMjI5",
        "avatar_url": "https://avatars.githubusercontent.com/u/57642229?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/polespinasa",
        "html_url": "https://github.com/polespinasa",
        "followers_url": "https://api.github.com/users/polespinasa/followers",
        "following_url": "https://api.github.com/users/polespinasa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/polespinasa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/polespinasa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/polespinasa/subscriptions",
        "organizations_url": "https://api.github.com/users/polespinasa/orgs",
        "repos_url": "https://api.github.com/users/polespinasa/repos",
        "events_url": "https://api.github.com/users/polespinasa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/polespinasa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#issuecomment-3268580076",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32489"
    },
    {
      "event": "reviewed",
      "id": 3264171057,
      "node_id": "PRR_kwDOABII587Cj0wx",
      "url": null,
      "actor": null,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-24T18:28:01Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3264171057",
      "submitted_at": "2025-09-24T18:28:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE0NTNlYTZmZjA2Nzk3MjI0YWRiYjFkZDgzOTI5OWZlM2Q4NjM2YWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a453ea6ff06797224adbb1dd839299fe3d8636ae",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a453ea6ff06797224adbb1dd839299fe3d8636ae",
      "tree": {
        "sha": "003bcae5ad4ecb1b2d86a97fc26aa73c69685240",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/003bcae5ad4ecb1b2d86a97fc26aa73c69685240"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67216700ce8ec5e84bca5f83860091f6ac4f67f4",
          "sha": "67216700ce8ec5e84bca5f83860091f6ac4f67f4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/67216700ce8ec5e84bca5f83860091f6ac4f67f4"
        }
      ],
      "message": "wallet: Add CWallet::ExportWatchOnly\n\nExportWatchOnly produces a watchonly wallet file from a CWallet. This\ncan be restored onto another instance of Bitcoin Core to allow that\ninstance to watch the same descriptors, and also have all of the same\ninitial address book and transactions.",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-09-24T18:41:45Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-12T20:39:26Z"
      },
      "sha": "a453ea6ff06797224adbb1dd839299fe3d8636ae"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFmOWY0OWVhODU1NjE4NTVkOTYxYzJlZTRhZmJiMjkxOTg0ZTEwNDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f9f49ea85561855d961c2ee4afbb291984e1045",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1f9f49ea85561855d961c2ee4afbb291984e1045",
      "tree": {
        "sha": "430409970579c71596f7f01e761482430f184f0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/430409970579c71596f7f01e761482430f184f0a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a453ea6ff06797224adbb1dd839299fe3d8636ae",
          "sha": "a453ea6ff06797224adbb1dd839299fe3d8636ae",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a453ea6ff06797224adbb1dd839299fe3d8636ae"
        }
      ],
      "message": "wallet, rpc: Add exportwatchonlywallet RPC",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-09-24T18:41:45Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-12T21:16:28Z"
      },
      "sha": "1f9f49ea85561855d961c2ee4afbb291984e1045"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNlYmYzZjdiNThhYWRlM2RhMjBiNTBiZjY5YzVlZjhmZTVhYzJmMGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ebf3f7b58aade3da20b50bf69c5ef8fe5ac2f0f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3ebf3f7b58aade3da20b50bf69c5ef8fe5ac2f0f",
      "tree": {
        "sha": "39f1928d0bf39cf07bd541faa5e1fd0b850a7dce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/39f1928d0bf39cf07bd541faa5e1fd0b850a7dce"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f9f49ea85561855d961c2ee4afbb291984e1045",
          "sha": "1f9f49ea85561855d961c2ee4afbb291984e1045",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1f9f49ea85561855d961c2ee4afbb291984e1045"
        }
      ],
      "message": "test: Test for exportwatchonlywallet",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-09-24T18:41:45Z"
      },
      "author": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-05-12T22:45:11Z"
      },
      "sha": "3ebf3f7b58aade3da20b50bf69c5ef8fe5ac2f0f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZmYWZhOWRkNDhhODE0YTkyOWVmYjMxYjc0NmRjZTM0M2EzYzk2ZGM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "tree": {
        "sha": "093198abcac451004df504f0b5952c479f0a96cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/093198abcac451004df504f0b5952c479f0a96cd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3ebf3f7b58aade3da20b50bf69c5ef8fe5ac2f0f",
          "sha": "3ebf3f7b58aade3da20b50bf69c5ef8fe5ac2f0f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3ebf3f7b58aade3da20b50bf69c5ef8fe5ac2f0f"
        }
      ],
      "message": "doc: update offline-signing-tutorial to use exportwatchonlywallet rpc",
      "committer": {
        "name": "Ava Chow",
        "email": "github@achow101.com",
        "date": "2025-09-24T18:41:45Z"
      },
      "author": {
        "name": "Pol Espinasa",
        "email": "pol.espinasa@uab.cat",
        "date": "2025-08-27T21:56:24Z"
      },
      "sha": "6fafa9dd48a814a929efb31b746dce343a3c96dc"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19899717238,
      "node_id": "HRFPE_lADOABII5862eKb6zwAAAASiHZZ2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19899717238",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "commit_url": "https://api.github.com/repos/achow101/bitcoin/commits/6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "created_at": "2025-09-24T18:41:53Z"
    },
    {
      "event": "reviewed",
      "id": 3264251914,
      "node_id": "PRR_kwDOABII587CkIgK",
      "url": null,
      "actor": null,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-24T18:52:40Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3264251914",
      "submitted_at": "2025-09-24T18:52:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    },
    {
      "event": "reviewed",
      "id": 3264827907,
      "node_id": "PRR_kwDOABII587CmVID",
      "url": null,
      "actor": null,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-09-24T21:43:21Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#pullrequestreview-3264827907",
      "submitted_at": "2025-09-24T21:43:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101930556",
      "pull_request_review_id": 2860239353,
      "id": 2101930556,
      "node_id": "PRRC_kwDOABII5859SOo8",
      "diff_hunk": "@@ -2622,10 +2622,16 @@ util::Result<void> CWallet::DisplayAddress(const CTxDestination& dest)\n     return util::Error{_(\"There is no ScriptPubKeyManager for this address\")};\n }\n \n+void CWallet::LoadLockedCoin(const COutPoint& coin, bool persistent)\n+{\n+    AssertLockHeld(cs_wallet);\n+    m_locked_coins.emplace(coin, persistent);\n+}\n+\n bool CWallet::LockCoin(const COutPoint& output, WalletBatch* batch)\n {\n     AssertLockHeld(cs_wallet);\n-    setLockedCoins.insert(output);\n+    LoadLockedCoin(output, batch != nullptr);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 14,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "129fdf7b9b7f52dc6e41f3562fd9d8601f75792c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 129fdf7b9b7f52dc6e41f3562fd9d8601f75792c \"wallet: Track whether a locked coin is persisted\": this seems a bit cryptic. At the interface level we have `lockCoin()` which has a `write_to_db` argument, which determines whether the function here is called with a `batch`. And then here we have to translate that again to the `persist` bool of `LoadLockedCoin`.\r\n\r\nMaybe LockCoin could have an explicit `persist` bool and batch as the third optional argument?",
      "created_at": "2025-05-22T08:14:39Z",
      "updated_at": "2025-05-22T08:30:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2101930556",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101930556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2634,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101947190",
      "pull_request_review_id": 2860239353,
      "id": 2101947190,
      "node_id": "PRRC_kwDOABII5859SSs2",
      "diff_hunk": "@@ -109,7 +109,10 @@ void PushParentDescriptors(const CWallet& wallet, const CScript& script_pubkey,\n {\n     UniValue parent_descs(UniValue::VARR);\n     for (const auto& desc: wallet.GetWalletDescriptors(script_pubkey)) {\n-        parent_descs.push_back(desc.descriptor->ToString());",
      "path": "src/wallet/rpc/util.cpp",
      "position": 1,
      "original_position": 4,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c61c87a453c1e5c1ad2f7d9c5b0e04c2d6df87ec",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In c61c87a453c1e5c1ad2f7d9c5b0e04c2d6df87ec \"wallet, rpc: Push the normalized parent descriptor\": typo in the commit message \"prividing\".\r\n\r\nI'm a bit surprised such a change doesn't break a test.\r\n\r\nWould also be good to explain why this needs to happen.",
      "created_at": "2025-05-22T08:23:18Z",
      "updated_at": "2025-05-22T08:30:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2101947190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101947190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 112,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101952111",
      "pull_request_review_id": 2860239353,
      "id": 2101952111,
      "node_id": "PRRC_kwDOABII5859ST5v",
      "diff_hunk": "@@ -1174,7 +1174,7 @@ bool DescriptorScriptPubKeyMan::CanGetAddresses(bool internal) const\n     LOCK(cs_desc_man);\n     return m_wallet_descriptor.descriptor->IsSingleType() &&\n            m_wallet_descriptor.descriptor->IsRange() &&\n-           (HavePrivateKeys() || m_wallet_descriptor.next_index < m_wallet_descriptor.range_end);\n+           (HavePrivateKeys() || m_wallet_descriptor.next_index < m_wallet_descriptor.range_end || m_wallet_descriptor.descriptor->CanSelfExpand());",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 108,
      "original_position": 5,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "52583d3269cc747ff58b6d0b8c213a1ac521aeb3",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 52583d3269cc747ff58b6d0b8c213a1ac521aeb3 \"wallet: Use Descriptor::CanSelfExpand() in CanGetAddresses()\": would be nice to have to test that illustrates a case where this matters",
      "created_at": "2025-05-22T08:25:48Z",
      "updated_at": "2025-05-22T08:30:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2101952111",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2101952111"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1179,
      "original_line": 1179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103345663",
      "pull_request_review_id": 2862486878,
      "id": 2103345663,
      "node_id": "PRRC_kwDOABII5859XoH_",
      "diff_hunk": "@@ -1174,7 +1174,7 @@ bool DescriptorScriptPubKeyMan::CanGetAddresses(bool internal) const\n     LOCK(cs_desc_man);\n     return m_wallet_descriptor.descriptor->IsSingleType() &&\n            m_wallet_descriptor.descriptor->IsRange() &&\n-           (HavePrivateKeys() || m_wallet_descriptor.next_index < m_wallet_descriptor.range_end);\n+           (HavePrivateKeys() || m_wallet_descriptor.next_index < m_wallet_descriptor.range_end || m_wallet_descriptor.descriptor->CanSelfExpand());",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 108,
      "original_position": 5,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "52583d3269cc747ff58b6d0b8c213a1ac521aeb3",
      "in_reply_to_id": 2101952111,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This PR does that.\r\n\r\nWithout this PR, that test would not be possible as it is inherently contradictory. We want to test that we are able to get addresses from something for which we are not able to get addresses for in a watchonly wallet. The only way a watchonly wallet could have those addresses are if it had private keys and derived the keys already. But a watchonly wallet cannot have private keys. This situation is literally impossible to test prior to this PR.\r\n\r\nThe only reason such a test works with this PR is because we can bring along the descriptor caches when making the watchonly wallet, so the pubkeys are already derived.",
      "created_at": "2025-05-22T20:26:35Z",
      "updated_at": "2025-05-22T20:26:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2103345663",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103345663"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1179,
      "original_line": 1179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103348928",
      "pull_request_review_id": 2862493508,
      "id": 2103348928,
      "node_id": "PRRC_kwDOABII5859Xo7A",
      "diff_hunk": "@@ -109,7 +109,10 @@ void PushParentDescriptors(const CWallet& wallet, const CScript& script_pubkey,\n {\n     UniValue parent_descs(UniValue::VARR);\n     for (const auto& desc: wallet.GetWalletDescriptors(script_pubkey)) {\n-        parent_descs.push_back(desc.descriptor->ToString());",
      "path": "src/wallet/rpc/util.cpp",
      "position": 1,
      "original_position": 4,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c61c87a453c1e5c1ad2f7d9c5b0e04c2d6df87ec",
      "in_reply_to_id": 2101947190,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We don't have tests that check that the resulting parent descriptors exactly match, just that they are valid parent descriptors.",
      "created_at": "2025-05-22T20:28:04Z",
      "updated_at": "2025-05-22T20:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2103348928",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103348928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 112,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103415625",
      "pull_request_review_id": 2862595654,
      "id": 2103415625,
      "node_id": "PRRC_kwDOABII5859X5NJ",
      "diff_hunk": "@@ -2622,10 +2622,16 @@ util::Result<void> CWallet::DisplayAddress(const CTxDestination& dest)\n     return util::Error{_(\"There is no ScriptPubKeyManager for this address\")};\n }\n \n+void CWallet::LoadLockedCoin(const COutPoint& coin, bool persistent)\n+{\n+    AssertLockHeld(cs_wallet);\n+    m_locked_coins.emplace(coin, persistent);\n+}\n+\n bool CWallet::LockCoin(const COutPoint& output, WalletBatch* batch)\n {\n     AssertLockHeld(cs_wallet);\n-    setLockedCoins.insert(output);\n+    LoadLockedCoin(output, batch != nullptr);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 14,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "129fdf7b9b7f52dc6e41f3562fd9d8601f75792c",
      "in_reply_to_id": 2101930556,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I removed the `batch` argument is having the caller provide that is entirely unnecessary. It's been replaced with `bool persist` in `LockCoin`, and no extra argument is needed for `UnlockCoin`.\r\n\r\nAlso split into #32593",
      "created_at": "2025-05-22T21:20:28Z",
      "updated_at": "2025-05-22T21:20:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2103415625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103415625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2634,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103415859",
      "pull_request_review_id": 2862595991,
      "id": 2103415859,
      "node_id": "PRRC_kwDOABII5859X5Qz",
      "diff_hunk": "@@ -109,7 +109,10 @@ void PushParentDescriptors(const CWallet& wallet, const CScript& script_pubkey,\n {\n     UniValue parent_descs(UniValue::VARR);\n     for (const auto& desc: wallet.GetWalletDescriptors(script_pubkey)) {\n-        parent_descs.push_back(desc.descriptor->ToString());",
      "path": "src/wallet/rpc/util.cpp",
      "position": 1,
      "original_position": 4,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c61c87a453c1e5c1ad2f7d9c5b0e04c2d6df87ec",
      "in_reply_to_id": 2101947190,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a test.",
      "created_at": "2025-05-22T21:20:40Z",
      "updated_at": "2025-05-22T21:20:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2103415859",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2103415859"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 112,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152084790",
      "pull_request_review_id": 2935366709,
      "id": 2152084790,
      "node_id": "PRRC_kwDOABII586ARjU2",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly2.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly2\", res[\"exported_file\"])\n+        online_wallet2 = self.online.get_wallet_rpc(\"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"addrbook_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"addrbook_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(0 ,1)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"txs_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"txs_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"imports_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"imports_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funds.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        addr = offline_wallet.getnewaddress()\n+        self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([offline_wallet.getnewaddress()])\n+        self.funds.sendtoaddress(addr, 1)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 226,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/32489/commits/ab7e1f248d2588472029514a4a643f043c853f9b:\r\nThis test does not fail when https://github.com/bitcoin/bitcoin/blob/ab7e1f248d2588472029514a4a643f043c853f9b/src/wallet/wallet.cpp#L4608 is commented out\r\n\r\nThe TX on line 225 will not be in node0's mempool before generate is called on line 227. The tx will remain in mempool when the `avoidreuse` wallet is exported. `avoidreuse_watchonly` on the online node will call `requestMempoolTransactions`, which will cause the 225's tx to be added to the wallet again and subsequently set `previously_spent`, whether **ExportWatchOnlyWallet correctly writes previously_spent data or not**\r\n\r\nAdding a `self.sync_mempools()` statement before generating the new block seems to fix this. ",
      "created_at": "2025-06-17T11:59:47Z",
      "updated_at": "2025-06-17T11:59:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2152084790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152084790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152120010",
      "pull_request_review_id": 2935426257,
      "id": 2152120010,
      "node_id": "PRRC_kwDOABII586ARr7K",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly2.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly2\", res[\"exported_file\"])\n+        online_wallet2 = self.online.get_wallet_rpc(\"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"addrbook_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"addrbook_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(0 ,1)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"txs_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"txs_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"imports_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"imports_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funds.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        addr = offline_wallet.getnewaddress()\n+        self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([offline_wallet.getnewaddress()])",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 225,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "conssider using `offline_wallet.sendall([self.funds.getnewaddress()])` instead\r\n\r\nUsing an `offline_wallet` address here causes this test to fail intermittently because it creates a new UTXO in `offline_wallet`, causing the UTXO of interest in this test to be at index `1` instead of `0`. This causes `offline_wallet.listunspent()[0]['reused']` to sometimes be `False` ",
      "created_at": "2025-06-17T12:18:52Z",
      "updated_at": "2025-06-17T12:18:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2152120010",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152120010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152883888",
      "pull_request_review_id": 2936641220,
      "id": 2152883888,
      "node_id": "PRRC_kwDOABII586AUmaw",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly2.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly2\", res[\"exported_file\"])\n+        online_wallet2 = self.online.get_wallet_rpc(\"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"addrbook_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"addrbook_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(0 ,1)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"txs_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"txs_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"imports_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"imports_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funds.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        addr = offline_wallet.getnewaddress()\n+        self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([offline_wallet.getnewaddress()])\n+        self.funds.sendtoaddress(addr, 1)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 226,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "in_reply_to_id": 2152084790,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-17T18:15:12Z",
      "updated_at": "2025-06-17T18:15:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2152883888",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152883888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152884065",
      "pull_request_review_id": 2936641466,
      "id": 2152884065,
      "node_id": "PRRC_kwDOABII586AUmdh",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly2.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly2\", res[\"exported_file\"])\n+        online_wallet2 = self.online.get_wallet_rpc(\"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"addrbook_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"addrbook_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(0 ,1)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"txs_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"txs_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"imports_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"imports_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funds.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        addr = offline_wallet.getnewaddress()\n+        self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([offline_wallet.getnewaddress()])",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 225,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "ab7e1f248d2588472029514a4a643f043c853f9b",
      "in_reply_to_id": 2152120010,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-06-17T18:15:16Z",
      "updated_at": "2025-06-17T18:15:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2152884065",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2152884065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2230275124",
      "pull_request_review_id": 3054267110,
      "id": 2230275124,
      "node_id": "PRRC_kwDOABII586E70w0",
      "diff_hunk": "@@ -3706,6 +3706,10 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        batch.WriteDescriptorCacheItems(id, desc.cache);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "in_reply_to_id": null,
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "out of curiosity... why do we need this here now? what's the issue if we don't (currently in `master`)? could we not use `UpgradeDescriptorCache()` from an upper level?",
      "created_at": "2025-07-25T06:36:42Z",
      "updated_at": "2025-07-25T06:36:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2230275124",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2230275124"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 3710,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3679,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2230304020",
      "pull_request_review_id": 3054306625,
      "id": 2230304020,
      "node_id": "PRRC_kwDOABII586E770U",
      "diff_hunk": "@@ -4475,4 +4479,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const",
      "path": "src/wallet/wallet.cpp",
      "position": 170,
      "original_position": 16,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "in_reply_to_id": null,
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: this could be just GetDescriptors? you can list them or export them later?",
      "created_at": "2025-07-25T06:54:21Z",
      "updated_at": "2025-07-25T06:54:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2230304020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2230304020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4485,
      "original_line": 4485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2240683030",
      "pull_request_review_id": 3068778951,
      "id": 2240683030,
      "node_id": "PRRC_kwDOABII586FjhwW",
      "diff_hunk": "@@ -3706,6 +3706,10 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        batch.WriteDescriptorCacheItems(id, desc.cache);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "in_reply_to_id": 2230275124,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The cache can only be generated if private keys are available, so we need this to write the cache to disk of the watchonly wallet.",
      "created_at": "2025-07-29T18:49:56Z",
      "updated_at": "2025-07-29T18:49:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2240683030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2240683030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 3710,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3679,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2240684156",
      "pull_request_review_id": 3068780406,
      "id": 2240684156,
      "node_id": "PRRC_kwDOABII586FjiB8",
      "diff_hunk": "@@ -4475,4 +4479,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const",
      "path": "src/wallet/wallet.cpp",
      "position": 170,
      "original_position": 16,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "in_reply_to_id": 2230304020,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think export is a reasonable name since listing them is also an export.",
      "created_at": "2025-07-29T18:50:33Z",
      "updated_at": "2025-07-29T18:50:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2240684156",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2240684156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4485,
      "original_line": 4485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2246172625",
      "pull_request_review_id": 3076595915,
      "id": 2246172625,
      "node_id": "PRRC_kwDOABII586F4d_R",
      "diff_hunk": "@@ -1368,6 +1410,7 @@ class RawTRDescriptor final : public DescriptorImpl\n     RawTRDescriptor(std::unique_ptr<PubkeyProvider> output_key) : DescriptorImpl(Vector(std::move(output_key)), \"rawtr\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32M; }\n     bool IsSingleType() const final { return true; }\n+    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }",
      "path": "src/script/descriptor.cpp",
      "position": 1,
      "original_position": 158,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "01b72fd4f5e5bcbbf851c217a895b09204a760a3",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"descriptor: Add CanSelfExpand()\" (01b72fd4f5e5bcbbf851c217a895b09204a760a3)\r\n\r\nI was wondering whether it's possible to provide a generic implementation of CanSelfExpand() to avoid needing all these specializations. Would the following work?\r\n\r\n<details><summary>diff</summary>\r\n<p>\r\n\r\n```diff\r\n--- a/src/script/descriptor.cpp\r\n+++ b/src/script/descriptor.cpp\r\n@@ -786,6 +786,16 @@ public:\r\n         }\r\n     }\r\n \r\n+    bool CanSelfExpand() const override {\r\n+        for (const auto& key : m_pubkey_args) {\r\n+            if (!key->CanSelfExpand()) return false;\r\n+        }\r\n+        for (const auto& sub : m_subdescriptor_args) {\r\n+            if (!sub->CanSelfExpand()) return false;\r\n+        }\r\n+        return true;\r\n+    }\r\n+\r\n     virtual std::unique_ptr<DescriptorImpl> Clone() const = 0;\r\n };\r\n \r\n@@ -806,7 +816,6 @@ public:\r\n     }\r\n     bool IsSingleType() const final { return true; }\r\n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const final { return false; }\r\n-    bool CanSelfExpand() const final { return true; }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return GetScriptForDestination(m_destination).size(); }\r\n     std::unique_ptr<DescriptorImpl> Clone() const override\r\n@@ -834,7 +843,6 @@ public:\r\n     }\r\n     bool IsSingleType() const final { return true; }\r\n     bool ToPrivateString(const SigningProvider& arg, std::string& out) const final { return false; }\r\n-    bool CanSelfExpand() const final { return true; }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return m_script.size(); }\r\n \r\n@@ -862,7 +870,6 @@ protected:\r\n public:\r\n     PKDescriptor(std::unique_ptr<PubkeyProvider> prov, bool xonly = false) : DescriptorImpl(Vector(std::move(prov)), \"pk\"), m_xonly(xonly) {}\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }\r\n \r\n     std::optional<int64_t> ScriptSize() const override {\r\n         return 1 + (m_xonly ? 32 : m_pubkey_args[0]->GetSize()) + 1;\r\n@@ -898,7 +905,6 @@ public:\r\n     PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"pkh\") {}\r\n     std::optional<OutputType> GetOutputType() const override { return OutputType::LEGACY; }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return 1 + 1 + 1 + 20 + 1 + 1; }\r\n \r\n@@ -932,7 +938,6 @@ public:\r\n     WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"wpkh\") {}\r\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return 1 + 1 + 20; }\r\n \r\n@@ -974,7 +979,6 @@ protected:\r\n public:\r\n     ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), \"combo\") {}\r\n     bool IsSingleType() const final { return false; }\r\n-    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }\r\n     std::unique_ptr<DescriptorImpl> Clone() const override\r\n     {\r\n         return std::make_unique<ComboDescriptor>(m_pubkey_args.at(0)->Clone());\r\n@@ -999,13 +1003,6 @@ protected:\r\n public:\r\n     MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers, bool sorted = false) : DescriptorImpl(std::move(providers), sorted ? \"sortedmulti\" : \"multi\"), m_threshold(threshold), m_sorted(sorted) {}\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override {\r\n-        bool can_expand = true;\r\n-        for (const auto& key : m_pubkey_args) {\r\n-            can_expand &= key->CanSelfExpand();\r\n-        }\r\n-        return can_expand;\r\n-    }\r\n \r\n     std::optional<int64_t> ScriptSize() const override {\r\n         const auto n_keys = m_pubkey_args.size();\r\n@@ -1057,13 +1054,6 @@ protected:\r\n public:\r\n     MultiADescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers, bool sorted = false) : DescriptorImpl(std::move(providers), sorted ? \"sortedmulti_a\" : \"multi_a\"), m_threshold(threshold), m_sorted(sorted) {}\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override {\r\n-        bool can_expand = true;\r\n-        for (const auto& key : m_pubkey_args) {\r\n-            can_expand &= key->CanSelfExpand();\r\n-        }\r\n-        return can_expand;\r\n-    }\r\n \r\n     std::optional<int64_t> ScriptSize() const override {\r\n         const auto n_keys = m_pubkey_args.size();\r\n@@ -1110,7 +1100,6 @@ public:\r\n         return OutputType::LEGACY;\r\n     }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override { return m_subdescriptor_args[0]->CanSelfExpand(); }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return 1 + 1 + 20 + 1; }\r\n \r\n@@ -1152,7 +1141,6 @@ public:\r\n     WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\r\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32; }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override { return m_subdescriptor_args[0]->CanSelfExpand(); }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return 1 + 1 + 32; }\r\n \r\n@@ -1230,13 +1218,6 @@ public:\r\n     }\r\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32M; }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override {\r\n-        bool can_expand = m_pubkey_args[0]->CanSelfExpand();\r\n-        for (const auto& sub : m_subdescriptor_args) {\r\n-            can_expand &= sub->CanSelfExpand();\r\n-        }\r\n-        return can_expand;\r\n-    }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return 1 + 1 + 32; }\r\n \r\n@@ -1364,13 +1345,6 @@ public:\r\n \r\n     bool IsSolvable() const override { return true; }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override {\r\n-        bool can_expand = true;\r\n-        for (const auto& key : m_pubkey_args) {\r\n-            can_expand &= key->CanSelfExpand();\r\n-        }\r\n-        return can_expand;\r\n-    }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return m_node->ScriptSize(); }\r\n \r\n@@ -1410,7 +1384,6 @@ public:\r\n     RawTRDescriptor(std::unique_ptr<PubkeyProvider> output_key) : DescriptorImpl(Vector(std::move(output_key)), \"rawtr\") {}\r\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32M; }\r\n     bool IsSingleType() const final { return true; }\r\n-    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }\r\n \r\n     std::optional<int64_t> ScriptSize() const override { return 1 + 1 + 32; }\r\n \r\n```\r\n</p>\r\n</details>\r\n",
      "created_at": "2025-07-31T19:03:50Z",
      "updated_at": "2025-07-31T19:03:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2246172625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2246172625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2246561816",
      "pull_request_review_id": 3077150358,
      "id": 2246561816,
      "node_id": "PRRC_kwDOABII586F59AY",
      "diff_hunk": "@@ -1368,6 +1410,7 @@ class RawTRDescriptor final : public DescriptorImpl\n     RawTRDescriptor(std::unique_ptr<PubkeyProvider> output_key) : DescriptorImpl(Vector(std::move(output_key)), \"rawtr\") {}\n     std::optional<OutputType> GetOutputType() const override { return OutputType::BECH32M; }\n     bool IsSingleType() const final { return true; }\n+    bool CanSelfExpand() const override { return m_pubkey_args[0]->CanSelfExpand(); }",
      "path": "src/script/descriptor.cpp",
      "position": 1,
      "original_position": 158,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "01b72fd4f5e5bcbbf851c217a895b09204a760a3",
      "in_reply_to_id": 2246172625,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-07-31T23:23:14Z",
      "updated_at": "2025-07-31T23:23:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2246561816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2246561816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1413,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2255780830",
      "pull_request_review_id": 3090314166,
      "id": 2255780830,
      "node_id": "PRRC_kwDOABII586GdHve",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified path and name containing a watchonly version \"\n+        \"of the wallet. This watchonly wallet contains the wallet's public descriptors, \"\n+        \"its transactions, and address book data. The watchonly wallet can be imported to \"\n+        \"another node using 'restorewallet'.\",",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 1,
      "original_position": 10,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n        \"Creates a wallet file at the specified destination containing a watchonly version \"\r\n        \"of the current wallet. This watchonly wallet contains the wallet's public descriptors, \"\r\n        \"its transactions, and address book data. The watchonly wallet can be imported into \"\r\n        \"another node using 'restorewallet'.\",\r\n```",
      "created_at": "2025-08-06T03:34:13Z",
      "updated_at": "2025-08-06T03:34:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2255780830",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2255780830"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 852,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 855,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2258638700",
      "pull_request_review_id": 3094757593,
      "id": 2258638700,
      "node_id": "PRRC_kwDOABII586GoBds",
      "diff_hunk": "@@ -4447,4 +4447,32 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 12,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3c5cdae7a15cb046010d753b918b313423861582",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"wallet: Move listdescriptors retrieving from RPC to CWallet\" (3c5cdae7a15cb046010d753b918b313423861582)\r\n\r\nSince these are errors are pretty technical and obscure, seems like it probably makes sense to use `Untranslated` instead of `_` to avoid these becoming translated strings.",
      "created_at": "2025-08-07T01:16:15Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2258638700",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2258638700"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4458,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2258660270",
      "pull_request_review_id": 3094757593,
      "id": 2258660270,
      "node_id": "PRRC_kwDOABII586GoGuu",
      "diff_hunk": "@@ -1174,7 +1174,7 @@ bool DescriptorScriptPubKeyMan::CanGetAddresses(bool internal) const\n     LOCK(cs_desc_man);\n     return m_wallet_descriptor.descriptor->IsSingleType() &&\n            m_wallet_descriptor.descriptor->IsRange() &&\n-           (HavePrivateKeys() || m_wallet_descriptor.next_index < m_wallet_descriptor.range_end);\n+           (HavePrivateKeys() || m_wallet_descriptor.next_index < m_wallet_descriptor.range_end || m_wallet_descriptor.descriptor->CanSelfExpand());",
      "path": "src/wallet/scriptpubkeyman.cpp",
      "position": 108,
      "original_position": 5,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "52583d3269cc747ff58b6d0b8c213a1ac521aeb3",
      "in_reply_to_id": 2101952111,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2101952111\r\n\r\nIn commit \"wallet: Use Descriptor::CanSelfExpand() in CanGetAddresses()\" (1170ade3a6d1fbb50ee2a83b906bb83560b0484d)\r\n\r\nCan confirm without this change the test fails as expected with `self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)` throwing \"No addresses available\"\r\n",
      "created_at": "2025-08-07T01:29:03Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2258660270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2258660270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1179,
      "original_line": 1179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2258663429",
      "pull_request_review_id": 3094757593,
      "id": 2258663429,
      "node_id": "PRRC_kwDOABII586GoHgF",
      "diff_hunk": "@@ -3706,6 +3706,10 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        batch.WriteDescriptorCacheItems(id, desc.cache);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "e6ac2015a852caa0f50e44becf9cd4b7592c48e7",
      "in_reply_to_id": 2230275124,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2230275124\r\n\r\nIn commit \"wallet: Write new descriptor's cache in AddWalletDescriptor\" (fcf7dfe08519aefd193d12958070bfc5ea52f090)\r\n\r\nCan confirm if I revert this change I see a `Wallet corrupted (-4)\r\n` error from `self.online.restorewallet(\"imports_watchonly\", res[\"exported_file\"])` running the test with `Error: Unable to expand wallet descriptor from cache` in the logs",
      "created_at": "2025-08-07T01:32:10Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2258663429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2258663429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 3710,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3679,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260598786",
      "pull_request_review_id": 3094757593,
      "id": 2260598786,
      "node_id": "PRRC_kwDOABII586GvgAC",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 15,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"wallet: Add CWallet::ExportWatchOnly\" (236970d25cc45b02678e410cfdc7e064da22cf11)\r\n\r\nCalling `fs::canonical` on the destination parent path seems like a nice way of making sure the parent path exists and throwing an error early if it doesn't. But it doesn't handle other problems like the destination path not being writable. Also I'm wary of code that manipulates paths unnecessarily instead of passing them directly to the OS.\r\n\r\nNot critical, but I'd suggest a change like the following to improve behavior and also simplify the function by eliminating the `canonical_dest` variable:\r\n\r\n<details><summary>diff</summary>\r\n<p>\r\n\r\n```diff\r\n--- a/src/wallet/wallet.cpp\r\n+++ b/src/wallet/wallet.cpp\r\n@@ -19,6 +19,7 @@\r\n #include <consensus/consensus.h>\r\n #include <consensus/validation.h>\r\n #include <external_signer.h>\r\n+#include <fstream>\r\n #include <interfaces/chain.h>\r\n #include <interfaces/handler.h>\r\n #include <interfaces/wallet.h>\r\n@@ -4486,8 +4487,10 @@ util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destina\r\n     if (fs::exists(destination)) {\r\n         return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\r\n     }\r\n-    fs::path canonical_dest = fs::canonical(destination.parent_path());\r\n-    canonical_dest /= destination.filename();\r\n+    if (!std::ofstream{destination}) {\r\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\r\n+    }\r\n+    fs::remove(destination);\r\n \r\n     // Get the descriptors from this wallet\r\n     util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\r\n@@ -4630,7 +4633,7 @@ util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destina\r\n         }\r\n \r\n         // Make a backup of this wallet at the specified destination directory\r\n-        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));\r\n+        watchonly_wallet->BackupWallet(fs::PathToString(destination));\r\n     }\r\n \r\n     // Delete the watchonly wallet now that it has been exported to the desired location\r\n@@ -4638,6 +4641,6 @@ util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destina\r\n     watchonly_wallet.reset();\r\n     fs::remove_all(watchonly_path);\r\n \r\n-    return fs::PathToString(canonical_dest);\r\n+    return fs::PathToString(destination);\r\n }\r\n } // namespace wallet\r\n```\r\n</p>\r\n</details>",
      "created_at": "2025-08-07T14:59:17Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2260598786",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260598786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4489,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260608137",
      "pull_request_review_id": 3094757593,
      "id": 2260608137,
      "node_id": "PRRC_kwDOABII586GviSJ",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);\n+\n+            // Write the best block locator to avoid rescanning on reload\n+            CBlockLocator best_block_locator;\n+            {\n+                WalletBatch local_wallet_batch(GetDatabase());\n+                if (!local_wallet_batch.ReadBestBlock(best_block_locator)) {\n+                    return util::Error{_(\"Error: Unable to read wallet's best block locator record\")};\n+                }\n+            }\n+            if (!watchonly_batch.WriteBestBlock(best_block_locator)) {\n+                return util::Error{_(\"Error: Unable to write watchonly wallet best block locator record\")};\n+            }\n+\n+            // Copy the transactions\n+            for (const auto& [txid, wtx] : mapWallet) {\n+                const CWalletTx& to_copy_wtx = wtx;\n+                if (!watchonly_wallet->LoadToWallet(txid, [&](CWalletTx& ins_wtx, bool new_tx) EXCLUSIVE_LOCKS_REQUIRED(watchonly_wallet->cs_wallet) {\n+                    if (!new_tx) return false;\n+                    ins_wtx.SetTx(to_copy_wtx.tx);\n+                    ins_wtx.CopyFrom(to_copy_wtx);\n+                    return true;\n+                })) {\n+                    return util::Error{strprintf(_(\"Error: Could not add tx %s to watchonly wallet\"), txid.GetHex())};\n+                }\n+                watchonly_batch.WriteTx(watchonly_wallet->mapWallet.at(txid));\n+            }\n+\n+            // Copy address book\n+            for (const auto& [dest, entry] : m_address_book) {\n+                auto address{EncodeDestination(dest)};\n+                if (entry.purpose) watchonly_batch.WritePurpose(address, PurposeToString(*entry.purpose));\n+                if (entry.label) watchonly_batch.WriteName(address, *entry.label);\n+                for (const auto& [id, request] : entry.receive_requests) {\n+                    watchonly_batch.WriteAddressReceiveRequest(dest, id, request);\n+                }\n+                if (entry.previously_spent) watchonly_batch.WriteAddressPreviouslySpent(dest, true);\n+            }\n+\n+            if (!watchonly_batch.TxnCommit()) {\n+                return util::Error{_(\"Error: cannot commit db transaction for watchonly wallet export\")};\n+            }\n+        }\n+\n+        // Make a backup of this wallet at the specified destination directory\n+        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 159,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"wallet: Add CWallet::ExportWatchOnly\" (236970d25cc45b02678e410cfdc7e064da22cf11)\r\n\r\nNo error is returned here if this fails. If I test with an unwritable path like `bitcoin-cli exportwatchonlywallet /foo` I see the RPC return success, but no backup file is created and `SQLite Error. Code: 14. Message: os_unix.c:44906: (2) open(/foo) - No such file or directory` is in the debug log.\r\n\r\nWould be good to fix, and may also want to add `[[nodiscard]]` to the BackupWallet method to prevent problems like this.",
      "created_at": "2025-08-07T15:02:51Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2260608137",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260608137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4633,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260646957",
      "pull_request_review_id": 3094757593,
      "id": 2260646957,
      "node_id": "PRRC_kwDOABII586Gvrwt",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);\n+\n+            // Write the best block locator to avoid rescanning on reload\n+            CBlockLocator best_block_locator;\n+            {\n+                WalletBatch local_wallet_batch(GetDatabase());\n+                if (!local_wallet_batch.ReadBestBlock(best_block_locator)) {\n+                    return util::Error{_(\"Error: Unable to read wallet's best block locator record\")};\n+                }\n+            }\n+            if (!watchonly_batch.WriteBestBlock(best_block_locator)) {\n+                return util::Error{_(\"Error: Unable to write watchonly wallet best block locator record\")};\n+            }\n+\n+            // Copy the transactions\n+            for (const auto& [txid, wtx] : mapWallet) {\n+                const CWalletTx& to_copy_wtx = wtx;\n+                if (!watchonly_wallet->LoadToWallet(txid, [&](CWalletTx& ins_wtx, bool new_tx) EXCLUSIVE_LOCKS_REQUIRED(watchonly_wallet->cs_wallet) {\n+                    if (!new_tx) return false;\n+                    ins_wtx.SetTx(to_copy_wtx.tx);\n+                    ins_wtx.CopyFrom(to_copy_wtx);\n+                    return true;\n+                })) {\n+                    return util::Error{strprintf(_(\"Error: Could not add tx %s to watchonly wallet\"), txid.GetHex())};\n+                }\n+                watchonly_batch.WriteTx(watchonly_wallet->mapWallet.at(txid));\n+            }\n+\n+            // Copy address book\n+            for (const auto& [dest, entry] : m_address_book) {\n+                auto address{EncodeDestination(dest)};\n+                if (entry.purpose) watchonly_batch.WritePurpose(address, PurposeToString(*entry.purpose));\n+                if (entry.label) watchonly_batch.WriteName(address, *entry.label);\n+                for (const auto& [id, request] : entry.receive_requests) {\n+                    watchonly_batch.WriteAddressReceiveRequest(dest, id, request);\n+                }\n+                if (entry.previously_spent) watchonly_batch.WriteAddressPreviouslySpent(dest, true);\n+            }\n+\n+            if (!watchonly_batch.TxnCommit()) {\n+                return util::Error{_(\"Error: cannot commit db transaction for watchonly wallet export\")};\n+            }\n+        }\n+\n+        // Make a backup of this wallet at the specified destination directory\n+        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));\n+    }\n+\n+    // Delete the watchonly wallet now that it has been exported to the desired location\n+    fs::path watchonly_path = fs::PathFromString(watchonly_wallet->GetDatabase().Filename()).parent_path();\n+    watchonly_wallet.reset();\n+    fs::remove_all(watchonly_path);",
      "path": "src/wallet/wallet.cpp",
      "position": 357,
      "original_position": 165,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"wallet: Add CWallet::ExportWatchOnly\" (236970d25cc45b02678e410cfdc7e064da22cf11)\r\n\r\nI don’t think fs::remove_all is appropriate here or elsewhere in wallet code. We should have a wallet delete function that explicitly removes known database and log files, then removes the directory, rather than recursively deleting everything. remove_all is fine in the happy case, but if there’s a bug (e.g. an extra parent_path call) or if users mistakenly store other data or bind mounts in the wallet directory, the results could be catastrophic. Seems fine to keep for now since there are other instances, but this would be good to address eventually.",
      "created_at": "2025-08-07T15:16:41Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2260646957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260646957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4672,
      "original_line": 4672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260690524",
      "pull_request_review_id": 3094757593,
      "id": 2260690524,
      "node_id": "PRRC_kwDOABII586Gv2Zc",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified path and name containing a watchonly version \"\n+        \"of the wallet. This watchonly wallet contains the wallet's public descriptors, \"\n+        \"its transactions, and address book data. The watchonly wallet can be imported to \"\n+        \"another node using 'restorewallet'.\",\n+        {\n+            {\"destination\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The path to the filename the exported watchonly wallet will be saved to\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::STR, \"exported_file\", \"The full path that the file has been exported to\"},\n+            },\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\\\\"\")\n+            + HelpExampleRpc(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\\\\"\")",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 1,
      "original_position": 22,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "71e25ee9ad52d8b9a763782b795690a196f218ef",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"wallet, rpc: Add exportwatchonlywallet RPC\" (71e25ee9ad52d8b9a763782b795690a196f218ef)\r\n\r\nSeems like a mistake here, did you mean to write `\"\\\"home\\\\user\\\\backup.dat\\\"\"`?",
      "created_at": "2025-08-07T15:30:11Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2260690524",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260690524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 866,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 867,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260733624",
      "pull_request_review_id": 3094757593,
      "id": 2260733624,
      "node_id": "PRRC_kwDOABII586GwA64",
      "diff_hunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 45,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"test: Test for exportwatchonlywallet\" (84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4)\r\n\r\nThis chunk of code is repeated many times. Maybe factor out into an export_and_restore help method",
      "created_at": "2025-08-07T15:45:07Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2260733624",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260733624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260742888",
      "pull_request_review_id": 3094757593,
      "id": 2260742888,
      "node_id": "PRRC_kwDOABII586GwDLo",
      "diff_hunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly2.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly2\", res[\"exported_file\"])\n+        online_wallet2 = self.online.get_wallet_rpc(\"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"addrbook_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"addrbook_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(0 ,1)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 126,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"test: Test for exportwatchonlywallet\" (84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4)\r\n\r\nDoes this need a sync_mempools like the other case below to make sure offline wallet receives the funds?\r\n\r\nAlso would be nice here and other places to replace 0, 1 with self.online.index and self.offline.index",
      "created_at": "2025-08-07T15:48:27Z",
      "updated_at": "2025-08-07T15:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2260742888",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2260742888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2264922251",
      "pull_request_review_id": 3103209012,
      "id": 2264922251,
      "node_id": "PRRC_kwDOABII586G__iL",
      "diff_hunk": "@@ -4443,4 +4447,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{_(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));",
      "path": "src/wallet/wallet.cpp",
      "position": 269,
      "original_position": 112,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "stringintech",
        "id": 157148846,
        "node_id": "U_kgDOCV3mrg",
        "avatar_url": "https://avatars.githubusercontent.com/u/157148846?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stringintech",
        "html_url": "https://github.com/stringintech",
        "followers_url": "https://api.github.com/users/stringintech/followers",
        "following_url": "https://api.github.com/users/stringintech/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stringintech/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stringintech/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stringintech/subscriptions",
        "organizations_url": "https://api.github.com/users/stringintech/orgs",
        "repos_url": "https://api.github.com/users/stringintech/repos",
        "events_url": "https://api.github.com/users/stringintech/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stringintech/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Perhaps `dynamic_cast` could be wrapped by `CHECK_NONFATAL`?",
      "created_at": "2025-08-09T18:51:37Z",
      "updated_at": "2025-08-09T18:51:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2264922251",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2264922251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4584,
      "original_line": 4584,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2273932347",
      "pull_request_review_id": 3116692194,
      "id": 2273932347,
      "node_id": "PRRC_kwDOABII586HiXQ7",
      "diff_hunk": "@@ -3673,6 +3673,10 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        batch.WriteDescriptorCacheItems(id, desc.cache);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Small question: WalletBatch::WriteDescriptorCacheItems(...) returns a bool and can fail on DB errors — should we check the return and surface/propagate the error instead of ignoring it? That would avoid silently losing the cache on disk",
      "created_at": "2025-08-13T16:09:01Z",
      "updated_at": "2025-08-13T19:17:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2273932347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2273932347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3679,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2274115610",
      "pull_request_review_id": 3116692194,
      "id": 2274115610,
      "node_id": "PRRC_kwDOABII586HjEAa",
      "diff_hunk": "@@ -4443,4 +4447,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{_(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));",
      "path": "src/wallet/wallet.cpp",
      "position": 269,
      "original_position": 112,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Here GetScriptPubKeyMan(desc_id) we dynamic_cast to DescriptorScriptPubKeyMan* and use it directly. Would it be worth adding a null-check here to handle the case where desc_id is missing or the type is unexpected, to avoid a possible crash?",
      "created_at": "2025-08-13T17:07:18Z",
      "updated_at": "2025-08-13T19:17:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2274115610",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2274115610"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4584,
      "original_line": 4584,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2274142446",
      "pull_request_review_id": 3116692194,
      "id": 2274142446,
      "node_id": "PRRC_kwDOABII586HjKju",
      "diff_hunk": "@@ -4443,4 +4447,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{_(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+",
      "path": "src/wallet/wallet.cpp",
      "position": 243,
      "original_position": 87,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can we add a runtime sanity check here to ensure the newly created watch-only wallet does not have private keys enabled (i.e. !watchonly_wallet->HavePrivateKeys())? If the flag didn’t take effect we should fail early with a clear error rather than continuing.",
      "created_at": "2025-08-13T17:17:35Z",
      "updated_at": "2025-08-13T19:17:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2274142446",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2274142446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4558,
      "original_line": 4558,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2274171707",
      "pull_request_review_id": 3116692194,
      "id": 2274171707,
      "node_id": "PRRC_kwDOABII586HjRs7",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified path and name containing a watchonly version \"",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": null,
      "user": {
        "login": "enirox001",
        "id": 66912335,
        "node_id": "MDQ6VXNlcjY2OTEyMzM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/66912335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/enirox001",
        "html_url": "https://github.com/enirox001",
        "followers_url": "https://api.github.com/users/enirox001/followers",
        "following_url": "https://api.github.com/users/enirox001/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/enirox001/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/enirox001/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/enirox001/subscriptions",
        "organizations_url": "https://api.github.com/users/enirox001/orgs",
        "repos_url": "https://api.github.com/users/enirox001/repos",
        "events_url": "https://api.github.com/users/enirox001/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/enirox001/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Small nit: could we reword the help text to be clearer and use “watch-only” (hyphenated) consistently? \r\n\r\nSuggest: “Creates a wallet file at the specified destination containing a watch-only version of the current wallet.”",
      "created_at": "2025-08-13T17:31:00Z",
      "updated_at": "2025-08-13T19:17:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2274171707",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2274171707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 852,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277494973",
      "pull_request_review_id": 3121811672,
      "id": 2277494973,
      "node_id": "PRRC_kwDOABII586Hv9C9",
      "diff_hunk": "@@ -4443,4 +4447,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{_(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));",
      "path": "src/wallet/wallet.cpp",
      "position": 269,
      "original_position": 112,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2264922251,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think it's really useful to have a check on that since earlier functions already enforce that the retrieved `ScriptPubKeyMan` must be a `DescriptorScriptPubKeyMan`.",
      "created_at": "2025-08-14T19:03:18Z",
      "updated_at": "2025-08-14T19:03:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277494973",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277494973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4584,
      "original_line": 4584,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277498396",
      "pull_request_review_id": 3121816519,
      "id": 2277498396,
      "node_id": "PRRC_kwDOABII586Hv94c",
      "diff_hunk": "@@ -4443,4 +4447,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{_(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));",
      "path": "src/wallet/wallet.cpp",
      "position": 269,
      "original_position": 112,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2274115610,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277494973",
      "created_at": "2025-08-14T19:05:16Z",
      "updated_at": "2025-08-14T19:05:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277498396",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277498396"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4584,
      "original_line": 4584,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277567966",
      "pull_request_review_id": 3121910420,
      "id": 2277567966,
      "node_id": "PRRC_kwDOABII586HwO3e",
      "diff_hunk": "@@ -4443,4 +4447,197 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{_(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+",
      "path": "src/wallet/wallet.cpp",
      "position": 243,
      "original_position": 87,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2274142446,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think that's necessary. It uses code that is well tested to behave correctly.",
      "created_at": "2025-08-14T19:43:01Z",
      "updated_at": "2025-08-14T19:43:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277567966",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277567966"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4558,
      "original_line": 4558,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277594348",
      "pull_request_review_id": 3121943799,
      "id": 2277594348,
      "node_id": "PRRC_kwDOABII586HwVTs",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified path and name containing a watchonly version \"\n+        \"of the wallet. This watchonly wallet contains the wallet's public descriptors, \"\n+        \"its transactions, and address book data. The watchonly wallet can be imported to \"\n+        \"another node using 'restorewallet'.\",",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 1,
      "original_position": 10,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2255780830,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:01Z",
      "updated_at": "2025-08-14T19:57:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277594348",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277594348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 852,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 855,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277594517",
      "pull_request_review_id": 3121944014,
      "id": 2277594517,
      "node_id": "PRRC_kwDOABII586HwVWV",
      "diff_hunk": "@@ -4447,4 +4447,32 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{_(\"Unexpected ScriptPubKey manager type.\")};",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 12,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3c5cdae7a15cb046010d753b918b313423861582",
      "in_reply_to_id": 2258638700,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:07Z",
      "updated_at": "2025-08-14T19:57:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277594517",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277594517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4458,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277594740",
      "pull_request_review_id": 3121944359,
      "id": 2277594740,
      "node_id": "PRRC_kwDOABII586HwVZ0",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 15,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": 2260598786,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done as suggested",
      "created_at": "2025-08-14T19:57:15Z",
      "updated_at": "2025-08-14T19:57:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277594740",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277594740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4489,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595029",
      "pull_request_review_id": 3121944801,
      "id": 2277595029,
      "node_id": "PRRC_kwDOABII586HwVeV",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);\n+\n+            // Write the best block locator to avoid rescanning on reload\n+            CBlockLocator best_block_locator;\n+            {\n+                WalletBatch local_wallet_batch(GetDatabase());\n+                if (!local_wallet_batch.ReadBestBlock(best_block_locator)) {\n+                    return util::Error{_(\"Error: Unable to read wallet's best block locator record\")};\n+                }\n+            }\n+            if (!watchonly_batch.WriteBestBlock(best_block_locator)) {\n+                return util::Error{_(\"Error: Unable to write watchonly wallet best block locator record\")};\n+            }\n+\n+            // Copy the transactions\n+            for (const auto& [txid, wtx] : mapWallet) {\n+                const CWalletTx& to_copy_wtx = wtx;\n+                if (!watchonly_wallet->LoadToWallet(txid, [&](CWalletTx& ins_wtx, bool new_tx) EXCLUSIVE_LOCKS_REQUIRED(watchonly_wallet->cs_wallet) {\n+                    if (!new_tx) return false;\n+                    ins_wtx.SetTx(to_copy_wtx.tx);\n+                    ins_wtx.CopyFrom(to_copy_wtx);\n+                    return true;\n+                })) {\n+                    return util::Error{strprintf(_(\"Error: Could not add tx %s to watchonly wallet\"), txid.GetHex())};\n+                }\n+                watchonly_batch.WriteTx(watchonly_wallet->mapWallet.at(txid));\n+            }\n+\n+            // Copy address book\n+            for (const auto& [dest, entry] : m_address_book) {\n+                auto address{EncodeDestination(dest)};\n+                if (entry.purpose) watchonly_batch.WritePurpose(address, PurposeToString(*entry.purpose));\n+                if (entry.label) watchonly_batch.WriteName(address, *entry.label);\n+                for (const auto& [id, request] : entry.receive_requests) {\n+                    watchonly_batch.WriteAddressReceiveRequest(dest, id, request);\n+                }\n+                if (entry.previously_spent) watchonly_batch.WriteAddressPreviouslySpent(dest, true);\n+            }\n+\n+            if (!watchonly_batch.TxnCommit()) {\n+                return util::Error{_(\"Error: cannot commit db transaction for watchonly wallet export\")};\n+            }\n+        }\n+\n+        // Make a backup of this wallet at the specified destination directory\n+        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 159,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": 2260608137,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:24Z",
      "updated_at": "2025-08-14T19:57:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277595029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4633,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595390",
      "pull_request_review_id": 3121945225,
      "id": 2277595390,
      "node_id": "PRRC_kwDOABII586HwVj-",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);\n+\n+            // Write the best block locator to avoid rescanning on reload\n+            CBlockLocator best_block_locator;\n+            {\n+                WalletBatch local_wallet_batch(GetDatabase());\n+                if (!local_wallet_batch.ReadBestBlock(best_block_locator)) {\n+                    return util::Error{_(\"Error: Unable to read wallet's best block locator record\")};\n+                }\n+            }\n+            if (!watchonly_batch.WriteBestBlock(best_block_locator)) {\n+                return util::Error{_(\"Error: Unable to write watchonly wallet best block locator record\")};\n+            }\n+\n+            // Copy the transactions\n+            for (const auto& [txid, wtx] : mapWallet) {\n+                const CWalletTx& to_copy_wtx = wtx;\n+                if (!watchonly_wallet->LoadToWallet(txid, [&](CWalletTx& ins_wtx, bool new_tx) EXCLUSIVE_LOCKS_REQUIRED(watchonly_wallet->cs_wallet) {\n+                    if (!new_tx) return false;\n+                    ins_wtx.SetTx(to_copy_wtx.tx);\n+                    ins_wtx.CopyFrom(to_copy_wtx);\n+                    return true;\n+                })) {\n+                    return util::Error{strprintf(_(\"Error: Could not add tx %s to watchonly wallet\"), txid.GetHex())};\n+                }\n+                watchonly_batch.WriteTx(watchonly_wallet->mapWallet.at(txid));\n+            }\n+\n+            // Copy address book\n+            for (const auto& [dest, entry] : m_address_book) {\n+                auto address{EncodeDestination(dest)};\n+                if (entry.purpose) watchonly_batch.WritePurpose(address, PurposeToString(*entry.purpose));\n+                if (entry.label) watchonly_batch.WriteName(address, *entry.label);\n+                for (const auto& [id, request] : entry.receive_requests) {\n+                    watchonly_batch.WriteAddressReceiveRequest(dest, id, request);\n+                }\n+                if (entry.previously_spent) watchonly_batch.WriteAddressPreviouslySpent(dest, true);\n+            }\n+\n+            if (!watchonly_batch.TxnCommit()) {\n+                return util::Error{_(\"Error: cannot commit db transaction for watchonly wallet export\")};\n+            }\n+        }\n+\n+        // Make a backup of this wallet at the specified destination directory\n+        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));\n+    }\n+\n+    // Delete the watchonly wallet now that it has been exported to the desired location\n+    fs::path watchonly_path = fs::PathFromString(watchonly_wallet->GetDatabase().Filename()).parent_path();\n+    watchonly_wallet.reset();\n+    fs::remove_all(watchonly_path);",
      "path": "src/wallet/wallet.cpp",
      "position": 357,
      "original_position": 165,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": 2260646957,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll leave that for a followup",
      "created_at": "2025-08-14T19:57:35Z",
      "updated_at": "2025-08-14T19:57:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277595390",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595390"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4672,
      "original_line": 4672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595557",
      "pull_request_review_id": 3121945421,
      "id": 2277595557,
      "node_id": "PRRC_kwDOABII586HwVml",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified path and name containing a watchonly version \"\n+        \"of the wallet. This watchonly wallet contains the wallet's public descriptors, \"\n+        \"its transactions, and address book data. The watchonly wallet can be imported to \"\n+        \"another node using 'restorewallet'.\",\n+        {\n+            {\"destination\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The path to the filename the exported watchonly wallet will be saved to\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::STR, \"exported_file\", \"The full path that the file has been exported to\"},\n+            },\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\\\\"\")\n+            + HelpExampleRpc(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\\\\"\")",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 1,
      "original_position": 22,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "71e25ee9ad52d8b9a763782b795690a196f218ef",
      "in_reply_to_id": 2260690524,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:40Z",
      "updated_at": "2025-08-14T19:57:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277595557",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 866,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 867,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595694",
      "pull_request_review_id": 3121945631,
      "id": 2277595694,
      "node_id": "PRRC_kwDOABII586HwVou",
      "diff_hunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 45,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2260733624,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:46Z",
      "updated_at": "2025-08-14T19:57:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277595694",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 40,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595809",
      "pull_request_review_id": 3121945780,
      "id": 2277595809,
      "node_id": "PRRC_kwDOABII586HwVqh",
      "diff_hunk": "@@ -0,0 +1,288 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        watchonly_export = os.path.join(self.export_path, \"basic_watchonly2.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"basic_watchonly2\", res[\"exported_file\"])\n+        online_wallet2 = self.online.get_wallet_rpc(\"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        watchonly_export = os.path.join(self.export_path, \"addrbook_watchonly.dat\")\n+        res = offline_wallet.exportwatchonlywallet(watchonly_export)\n+        assert_equal(res[\"exported_file\"], watchonly_export)\n+        self.online.restorewallet(\"addrbook_watchonly\", res[\"exported_file\"])\n+        online_wallet = self.online.get_wallet_rpc(\"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(0, 1)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(0 ,1)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 126,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2260742888,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:50Z",
      "updated_at": "2025-08-14T19:57:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277595809",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595809"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595978",
      "pull_request_review_id": 3121945980,
      "id": 2277595978,
      "node_id": "PRRC_kwDOABII586HwVtK",
      "diff_hunk": "@@ -3673,6 +3673,10 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        batch.WriteDescriptorCacheItems(id, desc.cache);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2273932347,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:57:55Z",
      "updated_at": "2025-08-14T19:57:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277595978",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277595978"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3679,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277596191",
      "pull_request_review_id": 3121946266,
      "id": 2277596191,
      "node_id": "PRRC_kwDOABII586HwVwf",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified path and name containing a watchonly version \"",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 1,
      "original_position": 7,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "84d3bc68cc4d23ab9f7a91a955cd0e26ffb1b6e4",
      "in_reply_to_id": 2274171707,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-14T19:58:01Z",
      "updated_at": "2025-08-14T19:58:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2277596191",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2277596191"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 852,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289136538",
      "pull_request_review_id": 3138017810,
      "id": 2289136538,
      "node_id": "PRRC_kwDOABII586IcXOa",
      "diff_hunk": "@@ -4443,4 +4450,201 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{Untranslated(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{Untranslated(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 162,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "4cc7be4ed92de3d6323734107000666c3298ac96",
      "in_reply_to_id": null,
      "user": {
        "login": "pablomartin4btc",
        "id": 110166421,
        "node_id": "U_kgDOBpEBlQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/110166421?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pablomartin4btc",
        "html_url": "https://github.com/pablomartin4btc",
        "followers_url": "https://api.github.com/users/pablomartin4btc/followers",
        "following_url": "https://api.github.com/users/pablomartin4btc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pablomartin4btc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pablomartin4btc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pablomartin4btc/subscriptions",
        "organizations_url": "https://api.github.com/users/pablomartin4btc/orgs",
        "repos_url": "https://api.github.com/users/pablomartin4btc/repos",
        "events_url": "https://api.github.com/users/pablomartin4btc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pablomartin4btc/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "These were all removed in #32977.",
      "created_at": "2025-08-20T19:46:34Z",
      "updated_at": "2025-08-20T19:46:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2289136538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289136538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 4589,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4590,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289424563",
      "pull_request_review_id": 3138432762,
      "id": 2289424563,
      "node_id": "PRRC_kwDOABII586Iddiz",
      "diff_hunk": "@@ -4443,4 +4450,201 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{Untranslated(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{Untranslated(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 162,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "4cc7be4ed92de3d6323734107000666c3298ac96",
      "in_reply_to_id": 2289136538,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed",
      "created_at": "2025-08-20T22:18:04Z",
      "updated_at": "2025-08-20T22:18:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2289424563",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2289424563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": 4589,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 4590,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298140555",
      "pull_request_review_id": 3151519710,
      "id": 2298140555,
      "node_id": "PRRC_kwDOABII586I-teL",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 165,
      "original_position": 168,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In cf588607fa36964597a6d6acc853eeb26e51b0ea \"test: Test for exportwatchonlywallet\"\r\n\r\nIn this particular subtest, there are 5 inactive and 8 active descriptors in the `listdescriptors` RPC response after importing few descriptors. This subtest can also check that the active and inactive descriptors remain the same after export.",
      "created_at": "2025-08-25T13:39:12Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298140555",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298140555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 165,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298155422",
      "pull_request_review_id": 3151519710,
      "id": 2298155422,
      "node_id": "PRRC_kwDOABII586I-xGe",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 185,
      "original_position": 185,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In cf588607fa36964597a6d6acc853eeb26e51b0ea \"test: Test for exportwatchonlywallet\"\r\n\r\nThis `getnewaddress` fails as expected because 10 pre-generated keys were there in the offline before export. I understand this seems to be a caveat for the hardened ranged descriptors that few pre-generated keys must be there before export otherwise the online wallet can't create new addresses - I feel this should be mentioned in the RPC Help section wrt the usability of the online wallet where the user might face this error straightaway if the keys were not pre-generated for export (though a little less likely with the default keypool size of 1000)",
      "created_at": "2025-08-25T13:45:21Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298155422",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298155422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 185,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298283741",
      "pull_request_review_id": 3151519710,
      "id": 2298283741,
      "node_id": "PRRC_kwDOABII586I_Qbd",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funds.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        addr = offline_wallet.getnewaddress()\n+        self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([self.funds.getnewaddress()])\n+        self.funds.sendtoaddress(addr, 1)\n+        self.sync_mempools()\n+        self.generate(self.online, 1)\n+        assert_equal(offline_wallet.listunspent()[0][\"reused\"], True)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"avoidreuse_watchonly\")\n+\n+        # check avoid_reuse is still set\n+        assert_equal(online_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+        assert_equal(online_wallet.listunspent()[0][\"reused\"], True)\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_encrypted_wallet(self):\n+        self.log.info(\"Test that a watchonly wallet can be exported from a locked wallet\")\n+        self.offline.createwallet(wallet_name=\"encrypted\", passphrase=\"pass\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"encrypted\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"unlocked_until\"], 0)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"encrypted_watchonly\")\n+\n+        # watchonly wallet does not have encryption because it doesn't have private keys\n+        assert \"unlocked_until\" not in online_wallet.getwalletinfo()\n+        # But it still has all of the public descriptors\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def run_test(self):\n+        self.online = self.nodes[0]\n+        self.offline = self.nodes[1]\n+        self.funds = self.online.get_wallet_rpc(self.default_wallet_name)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 249,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In cf588607fa36964597a6d6acc853eeb26e51b0ea \"test: Test for exportwatchonlywallet\"\r\n\r\nNit for clarity in the subtests. Otherwise it takes a while to figure out that these funds are not part of the wallet(s) under consideration.\r\n\r\n```diff\r\n- self.funds = self.online.get_wallet_rpc(self.default_wallet_name)\r\n+ self.outside_wallet_funds = self.online.get_wallet_rpc(self.default_wallet_name) \r\n```",
      "created_at": "2025-08-25T14:32:24Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298283741",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298283741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298304988",
      "pull_request_review_id": 3151519710,
      "id": 2298304988,
      "node_id": "PRRC_kwDOABII586I_Vnc",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 67,
      "original_position": 67,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/cf588607fa36964597a6d6acc853eeb26e51b0ea \"test: Test for exportwatchonlywallet\"\r\n\r\nIn this subtest, can also assert for few `getwalletinfo` RPC response values being equal as well such as `txcount, keypoolsize, keypoolsize_hd_internal, birthtime, lastprocessedblock`. For the `flags` RPC response key, it can be asserted that for the watch-only one, the value is the union of the original flags and `disable_private_keys`.\r\n\r\nMight as well put all these assertions in a `assert_common_values` function that can be called in all the subtests.  ",
      "created_at": "2025-08-25T14:40:17Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298304988",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298304988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": 66,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298309162",
      "pull_request_review_id": 3151519710,
      "id": 2298309162,
      "node_id": "PRRC_kwDOABII586I_Woq",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 165,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/cf588607fa36964597a6d6acc853eeb26e51b0ea \"test: Test for exportwatchonlywallet\"\r\n\r\nWhile calling this RPC here is fine, maybe add 10 as the default value for keypool in the node extra_args argument? That would represent a scenario that's more likely to happen in the real world.",
      "created_at": "2025-08-25T14:42:08Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298309162",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298309162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298311703",
      "pull_request_review_id": 3151519710,
      "id": 2298311703,
      "node_id": "PRRC_kwDOABII586I_XQX",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 183,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/cf588607fa36964597a6d6acc853eeb26e51b0ea \"test: Test for exportwatchonlywallet\"\r\n\r\nNit: would be nice to tie this `9` to the `10` above in the `keypoolrefill` RPC - `KEYPOOL_SIZE - 1`",
      "created_at": "2025-08-25T14:43:10Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298311703",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298311703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298327208",
      "pull_request_review_id": 3151519710,
      "id": 2298327208,
      "node_id": "PRRC_kwDOABII586I_bCo",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 31,
      "original_position": 4,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cdaed2bab95870f77efb3cbca1dc98e5d4f5695c",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In cdaed2bab95870f77efb3cbca1dc98e5d4f5695c \"wallet, rpc: Add exportwatchonlywallet RPC\"\r\n\r\nBased on some threshold value of remaining unused keys available, should this RPC also pre-generate keys before exporting the watch-only wallet so that the user doesn't end up with not being able to generate new addresses quickly after exporting and has to export again?",
      "created_at": "2025-08-25T14:49:55Z",
      "updated_at": "2025-08-25T14:58:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2298327208",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2298327208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 849,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299137075",
      "pull_request_review_id": 3153028977,
      "id": 2299137075,
      "node_id": "PRRC_kwDOABII586JCgwz",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 67,
      "original_position": 67,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298304988,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think any of those are actually useful things to assert. The point of the offline wallet is that it doesn't have access to the blockchain, so actually `txcount`, and `lastprocessedblock` should be different. The keypool sizes may be different depending on the node startup options, and birthtime may be different if something was used before being imported to the offline wallet.",
      "created_at": "2025-08-25T21:06:03Z",
      "updated_at": "2025-08-25T21:06:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299137075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299137075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": 66,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299144047",
      "pull_request_review_id": 3153040649,
      "id": 2299144047,
      "node_id": "PRRC_kwDOABII586JCidv",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 165,
      "original_position": 168,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298140555,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-25T21:09:40Z",
      "updated_at": "2025-08-25T21:09:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299144047",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299144047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 165,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299144625",
      "pull_request_review_id": 3153041438,
      "id": 2299144625,
      "node_id": "PRRC_kwDOABII586JCimx",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 185,
      "original_position": 185,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298155422,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added extra text to the help.",
      "created_at": "2025-08-25T21:09:53Z",
      "updated_at": "2025-08-25T21:09:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299144625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299144625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 185,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299145052",
      "pull_request_review_id": 3153041884,
      "id": 2299145052,
      "node_id": "PRRC_kwDOABII586JCitc",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funds.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        addr = offline_wallet.getnewaddress()\n+        self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([self.funds.getnewaddress()])\n+        self.funds.sendtoaddress(addr, 1)\n+        self.sync_mempools()\n+        self.generate(self.online, 1)\n+        assert_equal(offline_wallet.listunspent()[0][\"reused\"], True)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"avoidreuse_watchonly\")\n+\n+        # check avoid_reuse is still set\n+        assert_equal(online_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+        assert_equal(online_wallet.listunspent()[0][\"reused\"], True)\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_encrypted_wallet(self):\n+        self.log.info(\"Test that a watchonly wallet can be exported from a locked wallet\")\n+        self.offline.createwallet(wallet_name=\"encrypted\", passphrase=\"pass\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"encrypted\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"unlocked_until\"], 0)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"encrypted_watchonly\")\n+\n+        # watchonly wallet does not have encryption because it doesn't have private keys\n+        assert \"unlocked_until\" not in online_wallet.getwalletinfo()\n+        # But it still has all of the public descriptors\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def run_test(self):\n+        self.online = self.nodes[0]\n+        self.offline = self.nodes[1]\n+        self.funds = self.online.get_wallet_rpc(self.default_wallet_name)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 249,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298283741,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Renamed to `funder`.",
      "created_at": "2025-08-25T21:10:01Z",
      "updated_at": "2025-08-25T21:10:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299145052",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299145052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299145315",
      "pull_request_review_id": 3153042226,
      "id": 2299145315,
      "node_id": "PRRC_kwDOABII586JCixj",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 165,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298309162,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-25T21:10:08Z",
      "updated_at": "2025-08-25T21:10:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299145315",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299145315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299145463",
      "pull_request_review_id": 3153042444,
      "id": 2299145463,
      "node_id": "PRRC_kwDOABII586JCiz3",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funds.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funds.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funds.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Make sure that the hardened derivation has some pregenerated keys\n+        offline_wallet.keypoolrefill(10)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funds.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have 9 remaining addresses\n+        for _ in range(9):",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 183,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298311703,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-25T21:10:14Z",
      "updated_at": "2025-08-25T21:10:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299145463",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299145463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299146384",
      "pull_request_review_id": 3153043521,
      "id": 2299146384,
      "node_id": "PRRC_kwDOABII586JCjCQ",
      "diff_hunk": "@@ -846,6 +846,46 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 31,
      "original_position": 4,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cdaed2bab95870f77efb3cbca1dc98e5d4f5695c",
      "in_reply_to_id": 2298327208,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, however there should not be an expectation that the topup will always work as it does not work for wallets that are encrypted but not unlocked.",
      "created_at": "2025-08-25T21:10:41Z",
      "updated_at": "2025-08-25T21:10:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2299146384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299146384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 849,
      "original_line": 849,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300740989",
      "pull_request_review_id": 3155276288,
      "id": 2300740989,
      "node_id": "PRRC_kwDOABII586JIoV9",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 68,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 3a30ce4cecfb25c353ec4e5f178f47668214bb4a \"wallet: Add CWallet::ExportWatchOnly\"\r\n\r\nBecause there is no actual use of keys and error here in this flow.\r\n\r\n```diff\r\ndiff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp\r\nindex 4bfa11c0bf..95061559c7 100644\r\n--- a/src/wallet/wallet.cpp\r\n+++ b/src/wallet/wallet.cpp\r\n@@ -4562,10 +4562,11 @@ util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destina\r\n         // Parse the descriptors and add them to the new wallet\r\n         for (const WalletDescInfo& desc_info : *exported) {\r\n             // Parse the descriptor\r\n-            FlatSigningProvider keys;\r\n-            std::string parse_err;\r\n-            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\r\n+            FlatSigningProvider dummy_keys;\r\n+            std::string dummy_err;\r\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, dummy_keys, dummy_err, /*require_checksum=*/true);\r\n-            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\r\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath as they are made 'singlepath' during import\r\n+            assert(dummy_keys.keys.size() == 0); // No private keys should be present in case of public descriptors\r\n \r\n             // Get the range if there is one\r\n             int32_t range_start = 0;\r\n@@ -4585,7 +4586,7 @@ util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destina\r\n             }\r\n \r\n             // Add to the watchonly wallet\r\n-            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\r\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, dummy_keys, \"\", false); !spkm_res) {\r\n                 return util::Error{util::ErrorString(spkm_res)};\r\n             }\r\n```",
      "created_at": "2025-08-26T11:47:40Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300740989",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300740989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": 4564,
      "original_start_line": 4564,
      "start_side": "RIGHT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300744906",
      "pull_request_review_id": 3155276288,
      "id": 2300744906,
      "node_id": "PRRC_kwDOABII586JIpTK",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 3a30ce4cecfb25c353ec4e5f178f47668214bb4a \"wallet: Add CWallet::ExportWatchOnly\"\r\n\r\nNit:\r\ns/watchonly_wallet/watchonly wallet\r\n",
      "created_at": "2025-08-26T11:49:05Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300744906",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300744906"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300812988",
      "pull_request_review_id": 3155276288,
      "id": 2300812988,
      "node_id": "PRRC_kwDOABII586JI568",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 3a30ce4cecfb25c353ec4e5f178f47668214bb4a \"wallet: Add CWallet::ExportWatchOnly\"\r\n\r\nNit: \r\n```diff\r\n             // Add to the watchonly wallet\r\n-            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\r\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, dummy_keys, /*label*/ \"\", /*internal*/ false); !spkm_res) {\r\n```",
      "created_at": "2025-08-26T12:18:09Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300812988",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300812988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4588,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300814679",
      "pull_request_review_id": 3155276288,
      "id": 2300814679,
      "node_id": "PRRC_kwDOABII586JI6VX",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/3a30ce4cecfb25c353ec4e5f178f47668214bb4a \"wallet: Add CWallet::ExportWatchOnly\"\r\n\r\nAll the inactive descriptors are hardcoded to not being internal, is this correct? I can't seem to come up with a test case that fails this assumption.",
      "created_at": "2025-08-26T12:18:54Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300814679",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300814679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4588,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300852509",
      "pull_request_review_id": 3155276288,
      "id": 2300852509,
      "node_id": "PRRC_kwDOABII586JJDkd",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funder.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funder.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funder.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 107,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In c9eb6c853dbc96f47c89ab5ca26dde028cd5e108 \"test: Test for exportwatchonlywallet\"\r\n\r\nOtherwise assertion for online wallet is missed.\r\n```diff\r\n--- a/test/functional/wallet_exported_watchonly.py\r\n+++ b/test/functional/wallet_exported_watchonly.py\r\n@@ -104,7 +104,7 @@ class WalletExportedWatchOnly(BitcoinTestFramework):\r\n                 label = f\"addrbook_{purpose}\"\r\n                 assert_equal(wallet.listlabels(purpose), [label])\r\n                 addr = send_addr if purpose == \"send\" else receive_addr\r\n-                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\r\n+                assert_equal(wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\r\n```",
      "created_at": "2025-08-26T12:34:44Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300852509",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300852509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300928844",
      "pull_request_review_id": 3155276288,
      "id": 2300928844,
      "node_id": "PRRC_kwDOABII586JJWNM",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funder.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funder.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funder.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funder.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify public descriptors are the same\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have KEYPOOL_SIZE - 1 remaining addresses\n+        for _ in range(KEYPOOL_SIZE - 1):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funder.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        addr = offline_wallet.getnewaddress()\n+        self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([self.funder.getnewaddress()])\n+        self.funder.sendtoaddress(addr, 1)\n+        self.sync_mempools()",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 214,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/c9eb6c853dbc96f47c89ab5ca26dde028cd5e108 \"test: Test for exportwatchonlywallet\"\r\n\r\nNit: don't think this call is necessary here.\r\n\r\n```diff\r\n@@ -211,7 +215,6 @@ class WalletExportedWatchOnly(BitcoinTestFramework):\r\n         # Spend funds in order to mark addr as previously spent\r\n         offline_wallet.sendall([self.funder.getnewaddress()])\r\n         self.funder.sendtoaddress(addr, 1)\r\n-        self.sync_mempools()\r\n         self.generate(self.online, 1)\r\n```",
      "created_at": "2025-08-26T13:04:15Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300928844",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300928844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300951675",
      "pull_request_review_id": 3155276288,
      "id": 2300951675,
      "node_id": "PRRC_kwDOABII586JJbx7",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funder.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funder.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funder.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funder.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify public descriptors are the same\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have KEYPOOL_SIZE - 1 remaining addresses\n+        for _ in range(KEYPOOL_SIZE - 1):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funder.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        addr = offline_wallet.getnewaddress()\n+        self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([self.funder.getnewaddress()])\n+        self.funder.sendtoaddress(addr, 1)\n+        self.sync_mempools()\n+        self.generate(self.online, 1)\n+        assert_equal(offline_wallet.listunspent()[0][\"reused\"], True)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 216,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/c9eb6c853dbc96f47c89ab5ca26dde028cd5e108 \"test: Test for exportwatchonlywallet\"\r\n\r\nNit to make it explicit that why the unspent is marked as reused.\r\n```diff\r\n-        assert_equal(offline_wallet.listunspent()[0][\"reused\"], True)\r\n+        assert_equal(offline_wallet.listunspent(addresses=[addr])[0][\"reused\"], True)\r\n         self.disconnect_nodes(self.offline.index ,self.online.index)\r\n \r\n         # Export the watchonly wallet file and load onto online node\r\n@@ -221,7 +224,7 @@ class WalletExportedWatchOnly(BitcoinTestFramework):\r\n \r\n         # check avoid_reuse is still set\r\n         assert_equal(online_wallet.getwalletinfo()[\"avoid_reuse\"], True)\r\n-        assert_equal(online_wallet.listunspent()[0][\"reused\"], True)\r\n+        assert_equal(online_wallet.listunspent(addresses=[addr])[0][\"reused\"], True)\r\n```",
      "created_at": "2025-08-26T13:12:17Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2300951675",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2300951675"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301080188",
      "pull_request_review_id": 3155276288,
      "id": 2301080188,
      "node_id": "PRRC_kwDOABII586JJ7J8",
      "diff_hunk": "@@ -846,6 +846,49 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified destination containing a watchonly version \"\n+        \"of the current wallet. This watchonly wallet contains the wallet's public descriptors, \"\n+        \"its transactions, and address book data. Descriptors that use hardened derivation will \"\n+        \"only have a limited number of derived keys included in the export due to hardened \"\n+        \"derivation requiring private keys. Descriptors with unhardened derivation do not have \"\n+        \"this limitation. The watchonly wallet can be imported into another node using 'restorewallet'.\",\n+        {\n+            {\"destination\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The path to the filename the exported watchonly wallet will be saved to\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::STR, \"exported_file\", \"The full path that the file has been exported to\"},\n+            },\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\export.dat\\\"\")\n+            + HelpExampleRpc(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\export.dat\\\"\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return UniValue::VNULL;\n+            WalletContext& context = EnsureWalletContext(request.context);\n+\n+            std::string dest = request.params[0].get_str();\n+\n+            LOCK(pwallet->cs_wallet);\n+            pwallet->TopUpKeyPool();\n+            util::Result<std::string> exported = pwallet->ExportWatchOnlyWallet(fs::PathFromString(dest), context);",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 63,
      "original_position": 36,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "34137b327085b8e1d18f4dbf30f773fb507505dc",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 34137b327085b8e1d18f4dbf30f773fb507505dc \"wallet, rpc: Add exportwatchonlywallet RPC\"\r\n\r\nAny particular reason to convert from string to path before passing it to `ExportWatchOnlyWallet`? Asking because I noticed 4 `fs::PathToString(destination)` calls inside `ExportWatchOnlyWallet` that could be avoided if the string is accepted and this conversion is done over there.",
      "created_at": "2025-08-26T13:53:17Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301080188",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301080188"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 881,
      "original_line": 881,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301113117",
      "pull_request_review_id": 3155276288,
      "id": 2301113117,
      "node_id": "PRRC_kwDOABII586JKDMd",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 46,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/3a30ce4cecfb25c353ec4e5f178f47668214bb4a \"wallet: Add CWallet::ExportWatchOnly\"\r\n\r\nLogs while exporting:\r\n```bash\r\n2025-08-26T13:55:18Z [test_watchonly] Setting spkMan to active: id = c21a5fab36193920bcc2f13558b436ac4b1866c56a97bf03bb4c128610279a21, type = bech32m, internal = true\r\n```\r\n\r\nPerhaps we can also add a `temp` in the name to emphasise in the logs that this is a temporary wallet.\r\nMaybe `<name>_watchonly_temp`?",
      "created_at": "2025-08-26T14:03:35Z",
      "updated_at": "2025-08-26T14:04:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301113117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301113117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4546,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301117939",
      "pull_request_review_id": 3155812317,
      "id": 2301117939,
      "node_id": "PRRC_kwDOABII586JKEXz",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Expand offline's keypool so that it will recognize the scriptPubKeys it can sign\n+        offline_wallet.keypoolrefill(100)\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funds.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 67,
      "original_position": 67,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "cf588607fa36964597a6d6acc853eeb26e51b0ea",
      "in_reply_to_id": 2298304988,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fair point. \r\nI can imagine one of the use cases being that the user creates a offline wallet and immediately exports the watchonly version that's to be imported on a connected node.",
      "created_at": "2025-08-26T14:05:11Z",
      "updated_at": "2025-08-26T14:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301117939",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301117939"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": 66,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301769238",
      "pull_request_review_id": 3156790883,
      "id": 2301769238,
      "node_id": "PRRC_kwDOABII586JMjYW",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": 2300814679,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`internal` is only used for setting the labels in the address book within `AddWalletDescriptor`, and only if the descriptor is not ranged and that there is a label provided. Since we copy the labels from the address book right after this, there's no need for us to provide `label` or `internal` to this call.",
      "created_at": "2025-08-26T18:15:29Z",
      "updated_at": "2025-08-26T18:15:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301769238",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301769238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4588,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301789533",
      "pull_request_review_id": 3156818600,
      "id": 2301789533,
      "node_id": "PRRC_kwDOABII586JMoVd",
      "diff_hunk": "@@ -846,6 +846,49 @@ static RPCHelpMan createwalletdescriptor()\n     };\n }\n \n+static RPCHelpMan exportwatchonlywallet()\n+{\n+    return RPCHelpMan{\"exportwatchonlywallet\",\n+        \"Creates a wallet file at the specified destination containing a watchonly version \"\n+        \"of the current wallet. This watchonly wallet contains the wallet's public descriptors, \"\n+        \"its transactions, and address book data. Descriptors that use hardened derivation will \"\n+        \"only have a limited number of derived keys included in the export due to hardened \"\n+        \"derivation requiring private keys. Descriptors with unhardened derivation do not have \"\n+        \"this limitation. The watchonly wallet can be imported into another node using 'restorewallet'.\",\n+        {\n+            {\"destination\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The path to the filename the exported watchonly wallet will be saved to\"},\n+        },\n+        RPCResult{\n+            RPCResult::Type::OBJ, \"\", \"\",\n+            {\n+                {RPCResult::Type::STR, \"exported_file\", \"The full path that the file has been exported to\"},\n+            },\n+        },\n+        RPCExamples{\n+            HelpExampleCli(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\export.dat\\\"\")\n+            + HelpExampleRpc(\"exportwatchonlywallet\", \"\\\"home\\\\user\\\\export.dat\\\"\")\n+        },\n+        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n+        {\n+            std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);\n+            if (!pwallet) return UniValue::VNULL;\n+            WalletContext& context = EnsureWalletContext(request.context);\n+\n+            std::string dest = request.params[0].get_str();\n+\n+            LOCK(pwallet->cs_wallet);\n+            pwallet->TopUpKeyPool();\n+            util::Result<std::string> exported = pwallet->ExportWatchOnlyWallet(fs::PathFromString(dest), context);",
      "path": "src/wallet/rpc/wallet.cpp",
      "position": 63,
      "original_position": 36,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "34137b327085b8e1d18f4dbf30f773fb507505dc",
      "in_reply_to_id": 2301080188,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it conceptually makes more sense to be passing paths as ` fs::Path`, rather than strings. Ideally, `BackupWallet` should be taking a `fs::Path` instead of a string, and the other conversions are only necessary for logging.",
      "created_at": "2025-08-26T18:25:28Z",
      "updated_at": "2025-08-26T18:25:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301789533",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301789533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 881,
      "original_line": 881,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301791098",
      "pull_request_review_id": 3156820839,
      "id": 2301791098,
      "node_id": "PRRC_kwDOABII586JMot6",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 68,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": 2300740989,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:15Z",
      "updated_at": "2025-08-26T18:26:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301791098",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301791098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": 4564,
      "original_start_line": 4564,
      "start_side": "RIGHT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301791322",
      "pull_request_review_id": 3156821117,
      "id": 2301791322,
      "node_id": "PRRC_kwDOABII586JMoxa",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": 2300744906,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:19Z",
      "updated_at": "2025-08-26T18:26:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301791322",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301791322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301791661",
      "pull_request_review_id": 3156821430,
      "id": 2301791661,
      "node_id": "PRRC_kwDOABII586JMo2t",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 88,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": 2300812988,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:24Z",
      "updated_at": "2025-08-26T18:26:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301791661",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301791661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4588,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792083",
      "pull_request_review_id": 3156821905,
      "id": 2301792083,
      "node_id": "PRRC_kwDOABII586JMo9T",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funder.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funder.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funder.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 107,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "in_reply_to_id": 2300852509,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:30Z",
      "updated_at": "2025-08-26T18:26:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301792083",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792083"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 107,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792295",
      "pull_request_review_id": 3156822164,
      "id": 2301792295,
      "node_id": "PRRC_kwDOABII586JMpAn",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funder.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funder.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funder.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funder.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify public descriptors are the same\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have KEYPOOL_SIZE - 1 remaining addresses\n+        for _ in range(KEYPOOL_SIZE - 1):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funder.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        addr = offline_wallet.getnewaddress()\n+        self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([self.funder.getnewaddress()])\n+        self.funder.sendtoaddress(addr, 1)\n+        self.sync_mempools()",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 214,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "in_reply_to_id": 2300928844,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:35Z",
      "updated_at": "2025-08-26T18:26:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301792295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792510",
      "pull_request_review_id": 3156822447,
      "id": 2301792510,
      "node_id": "PRRC_kwDOABII586JMpD-",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])\n+        return self.online.get_wallet_rpc(export_name)\n+\n+    def test_basic_export(self):\n+        self.log.info(\"Test basic watchonly wallet export\")\n+        self.offline.createwallet(\"basic\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"basic\")\n+\n+        # Bad RPC args\n+        assert_raises_rpc_error(-4, \"Error: Export \", offline_wallet.exportwatchonlywallet, \"\")\n+        assert_raises_rpc_error(-4, \"Error: Export destination '.' already exists\", offline_wallet.exportwatchonlywallet, \".\")\n+        assert_raises_rpc_error(-4, f\"Error: Export destination '{self.export_path}' already exists\", offline_wallet.exportwatchonlywallet, self.export_path)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"basic_watchonly\")\n+\n+        # Exporting watchonly from a watchonly also works\n+        online_wallet2 = self.export_and_restore(online_wallet, \"basic_watchonly2\")\n+\n+        # Verify that the wallets have the same descriptors\n+        addr = offline_wallet.getnewaddress()\n+        assert_equal(addr, online_wallet.getnewaddress())\n+        assert_equal(addr, online_wallet2.getnewaddress())\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet2.listdescriptors()[\"descriptors\"])\n+\n+        # Verify that online wallet cannot spend, but offline can\n+        self.funder.sendtoaddress(online_wallet.getnewaddress(), 10)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        assert_equal(online_wallet.getbalances()[\"mine\"][\"trusted\"], 10)\n+        assert_equal(offline_wallet.getbalances()[\"mine\"][\"trusted\"], 0)\n+        funds_addr = self.funder.getnewaddress()\n+        send_res = online_wallet.send([{funds_addr: 5}])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        # Verify that the change address is known to both wallets\n+        dec_tx = self.online.decoderawtransaction(finalized)\n+        for txout in dec_tx[\"vout\"]:\n+            if txout[\"scriptPubKey\"][\"address\"] == funds_addr:\n+                continue\n+            assert_equal(online_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+            assert_equal(offline_wallet.getaddressinfo(txout[\"scriptPubKey\"][\"address\"])[\"ismine\"], True)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_address_book(self):\n+        self.log.info(\"Test all address book entries appear in the exported wallet\")\n+        self.offline.createwallet(\"addrbook\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"addrbook\")\n+\n+        # Create some address book entries\n+        receive_addr = offline_wallet.getnewaddress(label=\"addrbook_receive\")\n+        send_addr = self.funder.getnewaddress()\n+        offline_wallet.setlabel(send_addr, \"addrbook_send\") # Sets purpose \"send\"\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"addrbook_watchonly\")\n+\n+        # Verify the labels are in both wallets\n+        for wallet in [online_wallet, offline_wallet]:\n+            for purpose in [\"receive\", \"send\"]:\n+                label = f\"addrbook_{purpose}\"\n+                assert_equal(wallet.listlabels(purpose), [label])\n+                addr = send_addr if purpose == \"send\" else receive_addr\n+                assert_equal(offline_wallet.getaddressesbylabel(label), {addr: {\"purpose\": purpose}})\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_with_txs_and_locked_coins(self):\n+        self.log.info(\"Test all transactions and locked coins appear in the exported wallet\")\n+        self.offline.createwallet(\"txs\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"txs\")\n+\n+        # In order to make transactions in the offline wallet, briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        txids = [self.funder.sendtoaddress(offline_wallet.getnewaddress(\"funds\"), i) for i in range(1, 4)]\n+        self.generate(self.online, 1)\n+        self.disconnect_nodes(self.offline.index ,self.online.index)\n+\n+        # lock some coins\n+        persistent_lock = [{\"txid\": txids[0], \"vout\": 0}]\n+        temp_lock = [{\"txid\": txids[1], \"vout\": 0}]\n+        offline_wallet.lockunspent(unlock=False, transactions=persistent_lock, persistent=True)\n+        offline_wallet.lockunspent(unlock=False, transactions=temp_lock, persistent=False)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"txs_watchonly\")\n+\n+        # Verify the transactions are in both wallets\n+        for txid in txids:\n+            assert_equal(online_wallet.gettransaction(txid), offline_wallet.gettransaction(txid))\n+\n+        # Verify that the persistent locked coin is locked in both wallets\n+        assert_equal(online_wallet.listlockunspent(), persistent_lock)\n+        assert_equal(sorted(offline_wallet.listlockunspent(), key=lambda x: x[\"txid\"]), sorted(persistent_lock + temp_lock, key=lambda x: x[\"txid\"]))\n+\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_export_imported_descriptors(self):\n+        self.log.info(\"Test imported descriptors are exported to the watchonly wallet\")\n+        self.offline.createwallet(\"imports\")\n+        offline_wallet = self.offline.get_wallet_rpc(\"imports\")\n+\n+        import_res = offline_wallet.importdescriptors(\n+            [\n+                # A single key, non-ranged\n+                {\"desc\": descsum_create(f\"pkh({generate_keypair(wif=True)[0]})\"), \"timestamp\": \"now\"},\n+                # hardened derivation\n+                {\"desc\": descsum_create(\"sh(wpkh(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0'/*'))\"), \"timestamp\": \"now\", \"active\": True},\n+                # multisig\n+                {\"desc\": descsum_create(\"wsh(multi(1,tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*,tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/*))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+                # taproot multi scripts\n+                {\"desc\": descsum_create(f\"tr({H_POINT},{{pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/*),pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/0h/*)}})\"), \"timestamp\": \"now\", \"active\": True},\n+                # miniscript\n+                {\"desc\": descsum_create(f\"tr({H_POINT},or_b(pk(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/2/*),s:pk(tprv8ZgxMBicQKsPeuVhWwi6wuMQGfPKi9Li5GtX35jVNknACgqe3CY4g5xgkfDDJcmtF7o1QnxWDRYw4H5P26PXq7sbcUkEqeR4fg3Kxp2tigg/1h/2/*)))\"), \"timestamp\": \"now\", \"active\": True, \"internal\": True},\n+            ]\n+        )\n+        assert_equal(all([r[\"success\"] for r in import_res]), True)\n+\n+        # Export the watchonly wallet file and load onto online node\n+        online_wallet = self.export_and_restore(offline_wallet, \"imports_watchonly\")\n+\n+        # Verify public descriptors are the same\n+        assert_equal(offline_wallet.listdescriptors()[\"descriptors\"], online_wallet.listdescriptors()[\"descriptors\"])\n+\n+        # Verify all the addresses are the same\n+        for address_type in [\"legacy\", \"p2sh-segwit\", \"bech32\", \"bech32m\"]:\n+            for internal in [False, True]:\n+                if internal:\n+                    addr = offline_wallet.getrawchangeaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getrawchangeaddress(address_type=address_type))\n+                else:\n+                    addr = offline_wallet.getnewaddress(address_type=address_type)\n+                    assert_equal(addr, online_wallet.getnewaddress(address_type=address_type))\n+                self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+\n+        # The hardened derivation should have KEYPOOL_SIZE - 1 remaining addresses\n+        for _ in range(KEYPOOL_SIZE - 1):\n+            online_wallet.getnewaddress(address_type=\"p2sh-segwit\")\n+        assert_raises_rpc_error(-12, \"No addresses available\", online_wallet.getnewaddress, address_type=\"p2sh-segwit\")\n+\n+        # Verify that the offline wallet can sign and send\n+        send_res = online_wallet.sendall([self.funder.getnewaddress()])\n+        assert_equal(send_res[\"complete\"], False)\n+        assert \"psbt\" in send_res\n+        signed_psbt = offline_wallet.walletprocesspsbt(send_res[\"psbt\"])[\"psbt\"]\n+        finalized = self.online.finalizepsbt(signed_psbt)[\"hex\"]\n+        self.online.sendrawtransaction(finalized)\n+\n+        self.generate(self.online, 1, sync_fun=self.no_op)\n+        offline_wallet.unloadwallet()\n+        online_wallet.unloadwallet()\n+\n+    def test_avoid_reuse(self):\n+        self.log.info(\"Test that the avoid reuse flag appears in the exported wallet\")\n+        self.offline.createwallet(wallet_name=\"avoidreuse\", avoid_reuse=True)\n+        offline_wallet = self.offline.get_wallet_rpc(\"avoidreuse\")\n+        assert_equal(offline_wallet.getwalletinfo()[\"avoid_reuse\"], True)\n+\n+        # The avoid_reuse flag also sets some specific address book entries to track reused addresses\n+        # In order for these to be set, a few transactions need to be made, so briefly connect offline to online\n+        self.connect_nodes(self.offline.index, self.online.index)\n+        addr = offline_wallet.getnewaddress()\n+        self.funder.sendtoaddress(addr, 1)\n+        self.generate(self.online, 1)\n+        # Spend funds in order to mark addr as previously spent\n+        offline_wallet.sendall([self.funder.getnewaddress()])\n+        self.funder.sendtoaddress(addr, 1)\n+        self.sync_mempools()\n+        self.generate(self.online, 1)\n+        assert_equal(offline_wallet.listunspent()[0][\"reused\"], True)",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 1,
      "original_position": 216,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "c9eb6c853dbc96f47c89ab5ca26dde028cd5e108",
      "in_reply_to_id": 2300951675,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:40Z",
      "updated_at": "2025-08-26T18:26:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301792510",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792510"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792754",
      "pull_request_review_id": 3156822737,
      "id": 2301792754,
      "node_id": "PRRC_kwDOABII586JMpHy",
      "diff_hunk": "@@ -4508,4 +4509,167 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 46,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "3a30ce4cecfb25c353ec4e5f178f47668214bb4a",
      "in_reply_to_id": 2301113117,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2025-08-26T18:26:45Z",
      "updated_at": "2025-08-26T18:26:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2301792754",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2301792754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4546,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376702343",
      "pull_request_review_id": 3264171057,
      "id": 2376702343,
      "node_id": "PRRC_kwDOABII586NqZmH",
      "diff_hunk": "@@ -4474,4 +4481,196 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{Untranslated(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{Untranslated(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly_temp\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider dummy_keys;\n+            std::string dummy_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, dummy_keys, dummy_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+            assert(dummy_keys.keys.size() == 0); // No private keys should be present in our exported descriptors\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, dummy_keys, /*label=*/\"\", /*internal=*/false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 160,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is this copying `nOrderPosNext` from source wallet to the `watchonly` one ?\r\n```suggestion\r\n            watchonly_batch.WriteOrderPosNext(this->nOrderPosNext);\r\n```",
      "created_at": "2025-09-24T18:27:57Z",
      "updated_at": "2025-09-24T18:28:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2376702343",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376702343"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4619,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376728821",
      "pull_request_review_id": 3264210812,
      "id": 2376728821,
      "node_id": "PRRC_kwDOABII586NqgD1",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);\n+\n+            // Write the best block locator to avoid rescanning on reload\n+            CBlockLocator best_block_locator;\n+            {\n+                WalletBatch local_wallet_batch(GetDatabase());\n+                if (!local_wallet_batch.ReadBestBlock(best_block_locator)) {\n+                    return util::Error{_(\"Error: Unable to read wallet's best block locator record\")};\n+                }\n+            }\n+            if (!watchonly_batch.WriteBestBlock(best_block_locator)) {\n+                return util::Error{_(\"Error: Unable to write watchonly wallet best block locator record\")};\n+            }\n+\n+            // Copy the transactions\n+            for (const auto& [txid, wtx] : mapWallet) {\n+                const CWalletTx& to_copy_wtx = wtx;\n+                if (!watchonly_wallet->LoadToWallet(txid, [&](CWalletTx& ins_wtx, bool new_tx) EXCLUSIVE_LOCKS_REQUIRED(watchonly_wallet->cs_wallet) {\n+                    if (!new_tx) return false;\n+                    ins_wtx.SetTx(to_copy_wtx.tx);\n+                    ins_wtx.CopyFrom(to_copy_wtx);\n+                    return true;\n+                })) {\n+                    return util::Error{strprintf(_(\"Error: Could not add tx %s to watchonly wallet\"), txid.GetHex())};\n+                }\n+                watchonly_batch.WriteTx(watchonly_wallet->mapWallet.at(txid));\n+            }\n+\n+            // Copy address book\n+            for (const auto& [dest, entry] : m_address_book) {\n+                auto address{EncodeDestination(dest)};\n+                if (entry.purpose) watchonly_batch.WritePurpose(address, PurposeToString(*entry.purpose));\n+                if (entry.label) watchonly_batch.WriteName(address, *entry.label);\n+                for (const auto& [id, request] : entry.receive_requests) {\n+                    watchonly_batch.WriteAddressReceiveRequest(dest, id, request);\n+                }\n+                if (entry.previously_spent) watchonly_batch.WriteAddressPreviouslySpent(dest, true);\n+            }\n+\n+            if (!watchonly_batch.TxnCommit()) {\n+                return util::Error{_(\"Error: cannot commit db transaction for watchonly wallet export\")};\n+            }\n+        }\n+\n+        // Make a backup of this wallet at the specified destination directory\n+        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));\n+    }\n+\n+    // Delete the watchonly wallet now that it has been exported to the desired location\n+    fs::path watchonly_path = fs::PathFromString(watchonly_wallet->GetDatabase().Filename()).parent_path();\n+    watchonly_wallet.reset();\n+    fs::remove_all(watchonly_path);",
      "path": "src/wallet/wallet.cpp",
      "position": 357,
      "original_position": 165,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": 2260646957,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wouldn't it be safe to delete only the watchonly wallet file ?",
      "created_at": "2025-09-24T18:39:30Z",
      "updated_at": "2025-09-24T18:39:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2376728821",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376728821"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4672,
      "original_line": 4672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376734029",
      "pull_request_review_id": 3264217732,
      "id": 2376734029,
      "node_id": "PRRC_kwDOABII586NqhVN",
      "diff_hunk": "@@ -4474,4 +4481,196 @@ std::optional<WalletTXO> CWallet::GetTXO(const COutPoint& outpoint) const\n     }\n     return it->second;\n }\n+\n+util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export_private) const\n+{\n+    AssertLockHeld(cs_wallet);\n+    std::vector<WalletDescInfo> wallet_descriptors;\n+    for (const auto& spk_man : GetAllScriptPubKeyMans()) {\n+        const auto desc_spk_man = dynamic_cast<DescriptorScriptPubKeyMan*>(spk_man);\n+        if (!desc_spk_man) {\n+            return util::Error{Untranslated(\"Unexpected ScriptPubKey manager type.\")};\n+        }\n+        LOCK(desc_spk_man->cs_desc_man);\n+        const auto& wallet_descriptor = desc_spk_man->GetWalletDescriptor();\n+        std::string descriptor;\n+        if (!desc_spk_man->GetDescriptorString(descriptor, export_private)) {\n+            return util::Error{Untranslated(\"Can't get descriptor string.\")};\n+        }\n+        const bool is_range = wallet_descriptor.descriptor->IsRange();\n+        wallet_descriptors.push_back({\n+            descriptor,\n+            wallet_descriptor.creation_time,\n+            IsActiveScriptPubKeyMan(*desc_spk_man),\n+            IsInternalScriptPubKeyMan(desc_spk_man),\n+            is_range ? std::optional(std::make_pair(wallet_descriptor.range_start, wallet_descriptor.range_end)) : std::nullopt,\n+            wallet_descriptor.next_index\n+        });\n+    }\n+    return wallet_descriptors;\n+}\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    if (!std::ofstream{destination}) {\n+        return util::Error{strprintf(_(\"Error: Could not create file '%s'\"), fs::PathToString(destination))};\n+    }\n+    fs::remove(destination);\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly_temp\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider dummy_keys;\n+            std::string dummy_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, dummy_keys, dummy_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+            assert(dummy_keys.keys.size() == 0); // No private keys should be present in our exported descriptors\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, dummy_keys, /*label=*/\"\", /*internal=*/false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);",
      "path": "src/wallet/wallet.cpp",
      "position": 1,
      "original_position": 160,
      "commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "original_commit_id": "0f547141487e3964a55102f6ae441233d7144aaf",
      "in_reply_to_id": 2376702343,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oops fixed",
      "created_at": "2025-09-24T18:41:56Z",
      "updated_at": "2025-09-24T18:41:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2376734029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376734029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4619,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376736505",
      "pull_request_review_id": 3264221027,
      "id": 2376736505,
      "node_id": "PRRC_kwDOABII586Nqh75",
      "diff_hunk": "@@ -4475,4 +4475,169 @@ util::Result<std::vector<WalletDescInfo>> CWallet::ExportDescriptors(bool export\n     }\n     return wallet_descriptors;\n }\n+\n+util::Result<std::string> CWallet::ExportWatchOnlyWallet(const fs::path& destination, WalletContext& context) const\n+{\n+    AssertLockHeld(cs_wallet);\n+\n+    if (destination.empty()) {\n+        return util::Error{_(\"Error: Export destination cannot be empty\")};\n+    }\n+    if (fs::exists(destination)) {\n+        return util::Error{strprintf(_(\"Error: Export destination '%s' already exists\"), fs::PathToString(destination))};\n+    }\n+    fs::path canonical_dest = fs::canonical(destination.parent_path());\n+    canonical_dest /= destination.filename();\n+\n+    // Get the descriptors from this wallet\n+    util::Result<std::vector<WalletDescInfo>> exported = ExportDescriptors(/*export_private=*/false);\n+    if (!exported) {\n+        return util::Error{util::ErrorString(exported)};\n+    }\n+\n+    // Setup DatabaseOptions to create a new sqlite database\n+    DatabaseOptions options;\n+    options.require_existing = false;\n+    options.require_create = true;\n+    options.require_format = DatabaseFormat::SQLITE;\n+\n+    // Make the wallet with the same flags as this wallet, but without private keys\n+    options.create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS;\n+\n+    // Make the watchonly wallet\n+    DatabaseStatus status;\n+    std::vector<bilingual_str> warnings;\n+    std::string wallet_name = GetName() + \"_watchonly\";\n+    bilingual_str error;\n+    std::unique_ptr<WalletDatabase> database = MakeWalletDatabase(wallet_name, options, status, error);\n+    if (!database) {\n+        return util::Error{strprintf(_(\"Wallet file creation failed: %s\"), error)};\n+    }\n+    WalletContext empty_context;\n+    empty_context.args = context.args;\n+    std::shared_ptr<CWallet> watchonly_wallet = CWallet::Create(empty_context, wallet_name, std::move(database), options.create_flags, error, warnings);\n+    if (!watchonly_wallet) {\n+        return util::Error{_(\"Error: Failed to create new watchonly wallet\")};\n+    }\n+\n+    {\n+        LOCK(watchonly_wallet->cs_wallet);\n+\n+        // Parse the descriptors and add them to the new wallet\n+        for (const WalletDescInfo& desc_info : *exported) {\n+            // Parse the descriptor\n+            FlatSigningProvider keys;\n+            std::string parse_err;\n+            std::vector<std::unique_ptr<Descriptor>> descs = Parse(desc_info.descriptor, keys, parse_err, /*require_checksum=*/true);\n+            assert(descs.size() == 1); // All of our descriptors should be valid, and not multipath\n+\n+            // Get the range if there is one\n+            int32_t range_start = 0;\n+            int32_t range_end = 0;\n+            if (desc_info.range) {\n+                range_start = desc_info.range->first;\n+                range_end = desc_info.range->second;\n+            }\n+\n+            WalletDescriptor w_desc(std::move(descs.at(0)), desc_info.creation_time, range_start, range_end, desc_info.next_index);\n+\n+            // For descriptors that cannot self expand (i.e. needs private keys or cache), retrieve the cache\n+            uint256 desc_id = w_desc.id;\n+            if (!w_desc.descriptor->CanSelfExpand()) {\n+                DescriptorScriptPubKeyMan* desc_spkm = dynamic_cast<DescriptorScriptPubKeyMan*>(GetScriptPubKeyMan(desc_id));\n+                w_desc.cache = WITH_LOCK(desc_spkm->cs_desc_man, return desc_spkm->GetWalletDescriptor().cache);\n+            }\n+\n+            // Add to the watchonly wallet\n+            if (auto spkm_res = watchonly_wallet->AddWalletDescriptor(w_desc, keys, \"\", false); !spkm_res) {\n+                return util::Error{util::ErrorString(spkm_res)};\n+            }\n+\n+            // Set active spkms as active\n+            if (desc_info.active) {\n+                // Determine whether this descriptor is internal\n+                // This is only set for active spkms\n+                bool internal = false;\n+                if (desc_info.internal) {\n+                    internal = *desc_info.internal;\n+                }\n+                watchonly_wallet->AddActiveScriptPubKeyMan(desc_id, *w_desc.descriptor->GetOutputType(), internal);\n+            }\n+        }\n+\n+        // Copy locked coins that are persisted\n+        for (const auto& [coin, persisted] : m_locked_coins) {\n+            if (!persisted) continue;\n+            watchonly_wallet->LockCoin(coin, persisted);\n+        }\n+\n+        {\n+            // Make a WalletBatch for the watchonly_wallet so that everything else can be written atomically\n+            WalletBatch watchonly_batch(watchonly_wallet->GetDatabase());\n+            if (!watchonly_batch.TxnBegin()) {\n+                return util::Error{strprintf(_(\"Error: database transaction cannot be executed for new watchonly wallet %s\"), watchonly_wallet->GetName())};\n+            }\n+\n+            // Copy minversion\n+            // Don't use SetMinVersion to account for the newly created wallet having FEATURE_LATEST\n+            // while the source wallet doesn't.\n+            watchonly_wallet->LoadMinVersion(GetVersion());\n+            watchonly_batch.WriteMinVersion(watchonly_wallet->GetVersion());\n+\n+            // Copy orderPosNext\n+            watchonly_batch.WriteOrderPosNext(watchonly_wallet->nOrderPosNext);\n+\n+            // Write the best block locator to avoid rescanning on reload\n+            CBlockLocator best_block_locator;\n+            {\n+                WalletBatch local_wallet_batch(GetDatabase());\n+                if (!local_wallet_batch.ReadBestBlock(best_block_locator)) {\n+                    return util::Error{_(\"Error: Unable to read wallet's best block locator record\")};\n+                }\n+            }\n+            if (!watchonly_batch.WriteBestBlock(best_block_locator)) {\n+                return util::Error{_(\"Error: Unable to write watchonly wallet best block locator record\")};\n+            }\n+\n+            // Copy the transactions\n+            for (const auto& [txid, wtx] : mapWallet) {\n+                const CWalletTx& to_copy_wtx = wtx;\n+                if (!watchonly_wallet->LoadToWallet(txid, [&](CWalletTx& ins_wtx, bool new_tx) EXCLUSIVE_LOCKS_REQUIRED(watchonly_wallet->cs_wallet) {\n+                    if (!new_tx) return false;\n+                    ins_wtx.SetTx(to_copy_wtx.tx);\n+                    ins_wtx.CopyFrom(to_copy_wtx);\n+                    return true;\n+                })) {\n+                    return util::Error{strprintf(_(\"Error: Could not add tx %s to watchonly wallet\"), txid.GetHex())};\n+                }\n+                watchonly_batch.WriteTx(watchonly_wallet->mapWallet.at(txid));\n+            }\n+\n+            // Copy address book\n+            for (const auto& [dest, entry] : m_address_book) {\n+                auto address{EncodeDestination(dest)};\n+                if (entry.purpose) watchonly_batch.WritePurpose(address, PurposeToString(*entry.purpose));\n+                if (entry.label) watchonly_batch.WriteName(address, *entry.label);\n+                for (const auto& [id, request] : entry.receive_requests) {\n+                    watchonly_batch.WriteAddressReceiveRequest(dest, id, request);\n+                }\n+                if (entry.previously_spent) watchonly_batch.WriteAddressPreviouslySpent(dest, true);\n+            }\n+\n+            if (!watchonly_batch.TxnCommit()) {\n+                return util::Error{_(\"Error: cannot commit db transaction for watchonly wallet export\")};\n+            }\n+        }\n+\n+        // Make a backup of this wallet at the specified destination directory\n+        watchonly_wallet->BackupWallet(fs::PathToString(canonical_dest));\n+    }\n+\n+    // Delete the watchonly wallet now that it has been exported to the desired location\n+    fs::path watchonly_path = fs::PathFromString(watchonly_wallet->GetDatabase().Filename()).parent_path();\n+    watchonly_wallet.reset();\n+    fs::remove_all(watchonly_path);",
      "path": "src/wallet/wallet.cpp",
      "position": 357,
      "original_position": 165,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "236970d25cc45b02678e410cfdc7e064da22cf11",
      "in_reply_to_id": 2260646957,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Wouldn't it be safe to delete only the watchonly wallet file ?\r\n\r\nI don't think we should be leaving behind the wallet directory, and possibly the `-journal` file either.",
      "created_at": "2025-09-24T18:43:11Z",
      "updated_at": "2025-09-24T18:43:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2376736505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376736505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4672,
      "original_line": 4672,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376758113",
      "pull_request_review_id": 3264251914,
      "id": 2376758113,
      "node_id": "PRRC_kwDOABII586NqnNh",
      "diff_hunk": "@@ -3704,6 +3704,12 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        if (!batch.WriteDescriptorCacheItems(id, desc.cache)) {",
      "path": "src/wallet/wallet.cpp",
      "position": 15,
      "original_position": 7,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "4d7aeab15003441efb2b8ee89bdd1ad4e608e61b",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can `desc.cache` be empty here ?",
      "created_at": "2025-09-24T18:52:32Z",
      "updated_at": "2025-09-24T18:52:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2376758113",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2376758113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3711,
      "original_line": 3710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2377142018",
      "pull_request_review_id": 3264827907,
      "id": 2377142018,
      "node_id": "PRRC_kwDOABII586NsE8C",
      "diff_hunk": "@@ -0,0 +1,266 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 37,
      "original_position": 37,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "in_reply_to_id": null,
      "user": {
        "login": "w0xlt",
        "id": 94266259,
        "node_id": "U_kgDOBZ5jkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/94266259?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/w0xlt",
        "html_url": "https://github.com/w0xlt",
        "followers_url": "https://api.github.com/users/w0xlt/followers",
        "following_url": "https://api.github.com/users/w0xlt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/w0xlt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/w0xlt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/w0xlt/subscriptions",
        "organizations_url": "https://api.github.com/users/w0xlt/orgs",
        "repos_url": "https://api.github.com/users/w0xlt/repos",
        "events_url": "https://api.github.com/users/w0xlt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/w0xlt/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The assertion below (same as found in `wallet_migration.py`) fails.\r\nIs this expected ?\r\n\r\n```suggestion\r\n        # Assert no rescan occurs when restoring the exported watch-only wallet.\r\n        with self.online.assert_debug_log(unexpected_msgs=[\"Rescanning\"]):\r\n            self.online.restorewallet(export_name, res[\"exported_file\"])\r\n```",
      "created_at": "2025-09-24T21:41:37Z",
      "updated_at": "2025-09-24T21:43:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2377142018",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2377142018"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2379892167",
      "pull_request_review_id": 3268851640,
      "id": 2379892167,
      "node_id": "PRRC_kwDOABII586N2kXH",
      "diff_hunk": "@@ -3704,6 +3704,12 @@ util::Result<std::reference_wrapper<DescriptorScriptPubKeyMan>> CWallet::AddWall\n         // Save the descriptor to memory\n         uint256 id = new_spk_man->GetID();\n         AddScriptPubKeyMan(id, std::move(new_spk_man));\n+\n+        // Write the existing cache to disk\n+        WalletBatch batch(GetDatabase());\n+        if (!batch.WriteDescriptorCacheItems(id, desc.cache)) {",
      "path": "src/wallet/wallet.cpp",
      "position": 15,
      "original_position": 7,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "4d7aeab15003441efb2b8ee89bdd1ad4e608e61b",
      "in_reply_to_id": 2376758113,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, but that's not an issue.",
      "created_at": "2025-09-25T17:49:33Z",
      "updated_at": "2025-09-25T17:49:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2379892167",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2379892167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3711,
      "original_line": 3710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2379903393",
      "pull_request_review_id": 3268865959,
      "id": 2379903393,
      "node_id": "PRRC_kwDOABII586N2nGh",
      "diff_hunk": "@@ -0,0 +1,266 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+import os\n+\n+from test_framework.descriptors import descsum_create\n+from test_framework.key import H_POINT\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_not_equal,\n+    assert_raises_rpc_error,\n+)\n+from test_framework.wallet_util import generate_keypair\n+\n+KEYPOOL_SIZE = 10\n+\n+class WalletExportedWatchOnly(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[], [f\"-keypool={KEYPOOL_SIZE}\"]]\n+\n+    def setup_network(self):\n+        # Setup the nodes but don't connect them to each other\n+        self.setup_nodes()\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def export_and_restore(self, wallet, export_name):\n+        export_path = os.path.join(self.export_path, f\"{export_name}.dat\")\n+        res = wallet.exportwatchonlywallet(export_path)\n+        assert_equal(res[\"exported_file\"], export_path)\n+        self.online.restorewallet(export_name, res[\"exported_file\"])",
      "path": "test/functional/wallet_exported_watchonly.py",
      "position": 37,
      "original_position": 37,
      "commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "original_commit_id": "6fafa9dd48a814a929efb31b746dce343a3c96dc",
      "in_reply_to_id": 2377142018,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes. The nodes in this test are not always in sync with each other.",
      "created_at": "2025-09-25T17:53:00Z",
      "updated_at": "2025-09-25T17:53:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/32489#discussion_r2379903393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2379903393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/32489"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    }
  ]
}